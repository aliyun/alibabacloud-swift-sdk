import Foundation
import Tea
import TeaUtils
import AlibabaCloudOssSdk
import AlibabacloudOpenPlatform20191219
import AlibabaCloudOSSUtil
import TeaFileForm
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ConfigureDtsJobRequest : Tea.TeaModel {
    public var checkpoint: String?

    public var dataCheckConfigure: String?

    public var dataInitialization: Bool?

    public var dataSynchronization: Bool?

    public var dbList: String?

    public var dedicatedClusterId: String?

    public var delayNotice: Bool?

    public var delayPhone: String?

    public var delayRuleTime: Int64?

    public var destCaCertificateOssUrl: String?

    public var destCaCertificatePassword: String?

    public var destClientCertOssUrl: String?

    public var destClientKeyOssUrl: String?

    public var destClientPassword: String?

    public var destPrimaryVswId: String?

    public var destSecondaryVswId: String?

    public var destinationEndpointDataBaseName: String?

    public var destinationEndpointEngineName: String?

    public var destinationEndpointIP: String?

    public var destinationEndpointInstanceID: String?

    public var destinationEndpointInstanceType: String?

    public var destinationEndpointOracleSID: String?

    public var destinationEndpointOwnerID: String?

    public var destinationEndpointPassword: String?

    public var destinationEndpointPort: String?

    public var destinationEndpointRegion: String?

    public var destinationEndpointRole: String?

    public var destinationEndpointUserName: String?

    public var disasterRecoveryJob: Bool?

    public var dtsBisLabel: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var dtsJobName: String?

    public var errorNotice: Bool?

    public var errorPhone: String?

    public var fileOssUrl: String?

    public var jobType: String?

    public var maxDu: Double?

    public var minDu: Double?

    public var ownerId: String?

    public var regionId: String?

    public var reserve: String?

    public var resourceGroupId: String?

    public var sourceEndpointDatabaseName: String?

    public var sourceEndpointEngineName: String?

    public var sourceEndpointIP: String?

    public var sourceEndpointInstanceID: String?

    public var sourceEndpointInstanceType: String?

    public var sourceEndpointOracleSID: String?

    public var sourceEndpointOwnerID: String?

    public var sourceEndpointPassword: String?

    public var sourceEndpointPort: String?

    public var sourceEndpointRegion: String?

    public var sourceEndpointRole: String?

    public var sourceEndpointUserName: String?

    public var sourceEndpointVSwitchID: String?

    public var srcCaCertificateOssUrl: String?

    public var srcCaCertificatePassword: String?

    public var srcClientCertOssUrl: String?

    public var srcClientKeyOssUrl: String?

    public var srcClientPassword: String?

    public var srcPrimaryVswId: String?

    public var srcSecondaryVswId: String?

    public var structureInitialization: Bool?

    public var synchronizationDirection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkpoint != nil {
            map["Checkpoint"] = self.checkpoint!
        }
        if self.dataCheckConfigure != nil {
            map["DataCheckConfigure"] = self.dataCheckConfigure!
        }
        if self.dataInitialization != nil {
            map["DataInitialization"] = self.dataInitialization!
        }
        if self.dataSynchronization != nil {
            map["DataSynchronization"] = self.dataSynchronization!
        }
        if self.dbList != nil {
            map["DbList"] = self.dbList!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.delayNotice != nil {
            map["DelayNotice"] = self.delayNotice!
        }
        if self.delayPhone != nil {
            map["DelayPhone"] = self.delayPhone!
        }
        if self.delayRuleTime != nil {
            map["DelayRuleTime"] = self.delayRuleTime!
        }
        if self.destCaCertificateOssUrl != nil {
            map["DestCaCertificateOssUrl"] = self.destCaCertificateOssUrl!
        }
        if self.destCaCertificatePassword != nil {
            map["DestCaCertificatePassword"] = self.destCaCertificatePassword!
        }
        if self.destClientCertOssUrl != nil {
            map["DestClientCertOssUrl"] = self.destClientCertOssUrl!
        }
        if self.destClientKeyOssUrl != nil {
            map["DestClientKeyOssUrl"] = self.destClientKeyOssUrl!
        }
        if self.destClientPassword != nil {
            map["DestClientPassword"] = self.destClientPassword!
        }
        if self.destPrimaryVswId != nil {
            map["DestPrimaryVswId"] = self.destPrimaryVswId!
        }
        if self.destSecondaryVswId != nil {
            map["DestSecondaryVswId"] = self.destSecondaryVswId!
        }
        if self.destinationEndpointDataBaseName != nil {
            map["DestinationEndpointDataBaseName"] = self.destinationEndpointDataBaseName!
        }
        if self.destinationEndpointEngineName != nil {
            map["DestinationEndpointEngineName"] = self.destinationEndpointEngineName!
        }
        if self.destinationEndpointIP != nil {
            map["DestinationEndpointIP"] = self.destinationEndpointIP!
        }
        if self.destinationEndpointInstanceID != nil {
            map["DestinationEndpointInstanceID"] = self.destinationEndpointInstanceID!
        }
        if self.destinationEndpointInstanceType != nil {
            map["DestinationEndpointInstanceType"] = self.destinationEndpointInstanceType!
        }
        if self.destinationEndpointOracleSID != nil {
            map["DestinationEndpointOracleSID"] = self.destinationEndpointOracleSID!
        }
        if self.destinationEndpointOwnerID != nil {
            map["DestinationEndpointOwnerID"] = self.destinationEndpointOwnerID!
        }
        if self.destinationEndpointPassword != nil {
            map["DestinationEndpointPassword"] = self.destinationEndpointPassword!
        }
        if self.destinationEndpointPort != nil {
            map["DestinationEndpointPort"] = self.destinationEndpointPort!
        }
        if self.destinationEndpointRegion != nil {
            map["DestinationEndpointRegion"] = self.destinationEndpointRegion!
        }
        if self.destinationEndpointRole != nil {
            map["DestinationEndpointRole"] = self.destinationEndpointRole!
        }
        if self.destinationEndpointUserName != nil {
            map["DestinationEndpointUserName"] = self.destinationEndpointUserName!
        }
        if self.disasterRecoveryJob != nil {
            map["DisasterRecoveryJob"] = self.disasterRecoveryJob!
        }
        if self.dtsBisLabel != nil {
            map["DtsBisLabel"] = self.dtsBisLabel!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dtsJobName != nil {
            map["DtsJobName"] = self.dtsJobName!
        }
        if self.errorNotice != nil {
            map["ErrorNotice"] = self.errorNotice!
        }
        if self.errorPhone != nil {
            map["ErrorPhone"] = self.errorPhone!
        }
        if self.fileOssUrl != nil {
            map["FileOssUrl"] = self.fileOssUrl!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.maxDu != nil {
            map["MaxDu"] = self.maxDu!
        }
        if self.minDu != nil {
            map["MinDu"] = self.minDu!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reserve != nil {
            map["Reserve"] = self.reserve!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sourceEndpointDatabaseName != nil {
            map["SourceEndpointDatabaseName"] = self.sourceEndpointDatabaseName!
        }
        if self.sourceEndpointEngineName != nil {
            map["SourceEndpointEngineName"] = self.sourceEndpointEngineName!
        }
        if self.sourceEndpointIP != nil {
            map["SourceEndpointIP"] = self.sourceEndpointIP!
        }
        if self.sourceEndpointInstanceID != nil {
            map["SourceEndpointInstanceID"] = self.sourceEndpointInstanceID!
        }
        if self.sourceEndpointInstanceType != nil {
            map["SourceEndpointInstanceType"] = self.sourceEndpointInstanceType!
        }
        if self.sourceEndpointOracleSID != nil {
            map["SourceEndpointOracleSID"] = self.sourceEndpointOracleSID!
        }
        if self.sourceEndpointOwnerID != nil {
            map["SourceEndpointOwnerID"] = self.sourceEndpointOwnerID!
        }
        if self.sourceEndpointPassword != nil {
            map["SourceEndpointPassword"] = self.sourceEndpointPassword!
        }
        if self.sourceEndpointPort != nil {
            map["SourceEndpointPort"] = self.sourceEndpointPort!
        }
        if self.sourceEndpointRegion != nil {
            map["SourceEndpointRegion"] = self.sourceEndpointRegion!
        }
        if self.sourceEndpointRole != nil {
            map["SourceEndpointRole"] = self.sourceEndpointRole!
        }
        if self.sourceEndpointUserName != nil {
            map["SourceEndpointUserName"] = self.sourceEndpointUserName!
        }
        if self.sourceEndpointVSwitchID != nil {
            map["SourceEndpointVSwitchID"] = self.sourceEndpointVSwitchID!
        }
        if self.srcCaCertificateOssUrl != nil {
            map["SrcCaCertificateOssUrl"] = self.srcCaCertificateOssUrl!
        }
        if self.srcCaCertificatePassword != nil {
            map["SrcCaCertificatePassword"] = self.srcCaCertificatePassword!
        }
        if self.srcClientCertOssUrl != nil {
            map["SrcClientCertOssUrl"] = self.srcClientCertOssUrl!
        }
        if self.srcClientKeyOssUrl != nil {
            map["SrcClientKeyOssUrl"] = self.srcClientKeyOssUrl!
        }
        if self.srcClientPassword != nil {
            map["SrcClientPassword"] = self.srcClientPassword!
        }
        if self.srcPrimaryVswId != nil {
            map["SrcPrimaryVswId"] = self.srcPrimaryVswId!
        }
        if self.srcSecondaryVswId != nil {
            map["SrcSecondaryVswId"] = self.srcSecondaryVswId!
        }
        if self.structureInitialization != nil {
            map["StructureInitialization"] = self.structureInitialization!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Checkpoint") {
            self.checkpoint = dict["Checkpoint"] as! String
        }
        if dict.keys.contains("DataCheckConfigure") {
            self.dataCheckConfigure = dict["DataCheckConfigure"] as! String
        }
        if dict.keys.contains("DataInitialization") {
            self.dataInitialization = dict["DataInitialization"] as! Bool
        }
        if dict.keys.contains("DataSynchronization") {
            self.dataSynchronization = dict["DataSynchronization"] as! Bool
        }
        if dict.keys.contains("DbList") {
            self.dbList = dict["DbList"] as! String
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DelayNotice") {
            self.delayNotice = dict["DelayNotice"] as! Bool
        }
        if dict.keys.contains("DelayPhone") {
            self.delayPhone = dict["DelayPhone"] as! String
        }
        if dict.keys.contains("DelayRuleTime") {
            self.delayRuleTime = dict["DelayRuleTime"] as! Int64
        }
        if dict.keys.contains("DestCaCertificateOssUrl") {
            self.destCaCertificateOssUrl = dict["DestCaCertificateOssUrl"] as! String
        }
        if dict.keys.contains("DestCaCertificatePassword") {
            self.destCaCertificatePassword = dict["DestCaCertificatePassword"] as! String
        }
        if dict.keys.contains("DestClientCertOssUrl") {
            self.destClientCertOssUrl = dict["DestClientCertOssUrl"] as! String
        }
        if dict.keys.contains("DestClientKeyOssUrl") {
            self.destClientKeyOssUrl = dict["DestClientKeyOssUrl"] as! String
        }
        if dict.keys.contains("DestClientPassword") {
            self.destClientPassword = dict["DestClientPassword"] as! String
        }
        if dict.keys.contains("DestPrimaryVswId") {
            self.destPrimaryVswId = dict["DestPrimaryVswId"] as! String
        }
        if dict.keys.contains("DestSecondaryVswId") {
            self.destSecondaryVswId = dict["DestSecondaryVswId"] as! String
        }
        if dict.keys.contains("DestinationEndpointDataBaseName") {
            self.destinationEndpointDataBaseName = dict["DestinationEndpointDataBaseName"] as! String
        }
        if dict.keys.contains("DestinationEndpointEngineName") {
            self.destinationEndpointEngineName = dict["DestinationEndpointEngineName"] as! String
        }
        if dict.keys.contains("DestinationEndpointIP") {
            self.destinationEndpointIP = dict["DestinationEndpointIP"] as! String
        }
        if dict.keys.contains("DestinationEndpointInstanceID") {
            self.destinationEndpointInstanceID = dict["DestinationEndpointInstanceID"] as! String
        }
        if dict.keys.contains("DestinationEndpointInstanceType") {
            self.destinationEndpointInstanceType = dict["DestinationEndpointInstanceType"] as! String
        }
        if dict.keys.contains("DestinationEndpointOracleSID") {
            self.destinationEndpointOracleSID = dict["DestinationEndpointOracleSID"] as! String
        }
        if dict.keys.contains("DestinationEndpointOwnerID") {
            self.destinationEndpointOwnerID = dict["DestinationEndpointOwnerID"] as! String
        }
        if dict.keys.contains("DestinationEndpointPassword") {
            self.destinationEndpointPassword = dict["DestinationEndpointPassword"] as! String
        }
        if dict.keys.contains("DestinationEndpointPort") {
            self.destinationEndpointPort = dict["DestinationEndpointPort"] as! String
        }
        if dict.keys.contains("DestinationEndpointRegion") {
            self.destinationEndpointRegion = dict["DestinationEndpointRegion"] as! String
        }
        if dict.keys.contains("DestinationEndpointRole") {
            self.destinationEndpointRole = dict["DestinationEndpointRole"] as! String
        }
        if dict.keys.contains("DestinationEndpointUserName") {
            self.destinationEndpointUserName = dict["DestinationEndpointUserName"] as! String
        }
        if dict.keys.contains("DisasterRecoveryJob") {
            self.disasterRecoveryJob = dict["DisasterRecoveryJob"] as! Bool
        }
        if dict.keys.contains("DtsBisLabel") {
            self.dtsBisLabel = dict["DtsBisLabel"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DtsJobName") {
            self.dtsJobName = dict["DtsJobName"] as! String
        }
        if dict.keys.contains("ErrorNotice") {
            self.errorNotice = dict["ErrorNotice"] as! Bool
        }
        if dict.keys.contains("ErrorPhone") {
            self.errorPhone = dict["ErrorPhone"] as! String
        }
        if dict.keys.contains("FileOssUrl") {
            self.fileOssUrl = dict["FileOssUrl"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("MaxDu") {
            self.maxDu = dict["MaxDu"] as! Double
        }
        if dict.keys.contains("MinDu") {
            self.minDu = dict["MinDu"] as! Double
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reserve") {
            self.reserve = dict["Reserve"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SourceEndpointDatabaseName") {
            self.sourceEndpointDatabaseName = dict["SourceEndpointDatabaseName"] as! String
        }
        if dict.keys.contains("SourceEndpointEngineName") {
            self.sourceEndpointEngineName = dict["SourceEndpointEngineName"] as! String
        }
        if dict.keys.contains("SourceEndpointIP") {
            self.sourceEndpointIP = dict["SourceEndpointIP"] as! String
        }
        if dict.keys.contains("SourceEndpointInstanceID") {
            self.sourceEndpointInstanceID = dict["SourceEndpointInstanceID"] as! String
        }
        if dict.keys.contains("SourceEndpointInstanceType") {
            self.sourceEndpointInstanceType = dict["SourceEndpointInstanceType"] as! String
        }
        if dict.keys.contains("SourceEndpointOracleSID") {
            self.sourceEndpointOracleSID = dict["SourceEndpointOracleSID"] as! String
        }
        if dict.keys.contains("SourceEndpointOwnerID") {
            self.sourceEndpointOwnerID = dict["SourceEndpointOwnerID"] as! String
        }
        if dict.keys.contains("SourceEndpointPassword") {
            self.sourceEndpointPassword = dict["SourceEndpointPassword"] as! String
        }
        if dict.keys.contains("SourceEndpointPort") {
            self.sourceEndpointPort = dict["SourceEndpointPort"] as! String
        }
        if dict.keys.contains("SourceEndpointRegion") {
            self.sourceEndpointRegion = dict["SourceEndpointRegion"] as! String
        }
        if dict.keys.contains("SourceEndpointRole") {
            self.sourceEndpointRole = dict["SourceEndpointRole"] as! String
        }
        if dict.keys.contains("SourceEndpointUserName") {
            self.sourceEndpointUserName = dict["SourceEndpointUserName"] as! String
        }
        if dict.keys.contains("SourceEndpointVSwitchID") {
            self.sourceEndpointVSwitchID = dict["SourceEndpointVSwitchID"] as! String
        }
        if dict.keys.contains("SrcCaCertificateOssUrl") {
            self.srcCaCertificateOssUrl = dict["SrcCaCertificateOssUrl"] as! String
        }
        if dict.keys.contains("SrcCaCertificatePassword") {
            self.srcCaCertificatePassword = dict["SrcCaCertificatePassword"] as! String
        }
        if dict.keys.contains("SrcClientCertOssUrl") {
            self.srcClientCertOssUrl = dict["SrcClientCertOssUrl"] as! String
        }
        if dict.keys.contains("SrcClientKeyOssUrl") {
            self.srcClientKeyOssUrl = dict["SrcClientKeyOssUrl"] as! String
        }
        if dict.keys.contains("SrcClientPassword") {
            self.srcClientPassword = dict["SrcClientPassword"] as! String
        }
        if dict.keys.contains("SrcPrimaryVswId") {
            self.srcPrimaryVswId = dict["SrcPrimaryVswId"] as! String
        }
        if dict.keys.contains("SrcSecondaryVswId") {
            self.srcSecondaryVswId = dict["SrcSecondaryVswId"] as! String
        }
        if dict.keys.contains("StructureInitialization") {
            self.structureInitialization = dict["StructureInitialization"] as! Bool
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
    }
}

public class ConfigureDtsJobAdvanceRequest : Tea.TeaModel {
    public var checkpoint: String?

    public var dataCheckConfigure: String?

    public var dataInitialization: Bool?

    public var dataSynchronization: Bool?

    public var dbList: String?

    public var dedicatedClusterId: String?

    public var delayNotice: Bool?

    public var delayPhone: String?

    public var delayRuleTime: Int64?

    public var destCaCertificateOssUrl: String?

    public var destCaCertificatePassword: String?

    public var destClientCertOssUrl: String?

    public var destClientKeyOssUrl: String?

    public var destClientPassword: String?

    public var destPrimaryVswId: String?

    public var destSecondaryVswId: String?

    public var destinationEndpointDataBaseName: String?

    public var destinationEndpointEngineName: String?

    public var destinationEndpointIP: String?

    public var destinationEndpointInstanceID: String?

    public var destinationEndpointInstanceType: String?

    public var destinationEndpointOracleSID: String?

    public var destinationEndpointOwnerID: String?

    public var destinationEndpointPassword: String?

    public var destinationEndpointPort: String?

    public var destinationEndpointRegion: String?

    public var destinationEndpointRole: String?

    public var destinationEndpointUserName: String?

    public var disasterRecoveryJob: Bool?

    public var dtsBisLabel: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var dtsJobName: String?

    public var errorNotice: Bool?

    public var errorPhone: String?

    public var fileOssUrlObject: InputStream?

    public var jobType: String?

    public var maxDu: Double?

    public var minDu: Double?

    public var ownerId: String?

    public var regionId: String?

    public var reserve: String?

    public var resourceGroupId: String?

    public var sourceEndpointDatabaseName: String?

    public var sourceEndpointEngineName: String?

    public var sourceEndpointIP: String?

    public var sourceEndpointInstanceID: String?

    public var sourceEndpointInstanceType: String?

    public var sourceEndpointOracleSID: String?

    public var sourceEndpointOwnerID: String?

    public var sourceEndpointPassword: String?

    public var sourceEndpointPort: String?

    public var sourceEndpointRegion: String?

    public var sourceEndpointRole: String?

    public var sourceEndpointUserName: String?

    public var sourceEndpointVSwitchID: String?

    public var srcCaCertificateOssUrl: String?

    public var srcCaCertificatePassword: String?

    public var srcClientCertOssUrl: String?

    public var srcClientKeyOssUrl: String?

    public var srcClientPassword: String?

    public var srcPrimaryVswId: String?

    public var srcSecondaryVswId: String?

    public var structureInitialization: Bool?

    public var synchronizationDirection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkpoint != nil {
            map["Checkpoint"] = self.checkpoint!
        }
        if self.dataCheckConfigure != nil {
            map["DataCheckConfigure"] = self.dataCheckConfigure!
        }
        if self.dataInitialization != nil {
            map["DataInitialization"] = self.dataInitialization!
        }
        if self.dataSynchronization != nil {
            map["DataSynchronization"] = self.dataSynchronization!
        }
        if self.dbList != nil {
            map["DbList"] = self.dbList!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.delayNotice != nil {
            map["DelayNotice"] = self.delayNotice!
        }
        if self.delayPhone != nil {
            map["DelayPhone"] = self.delayPhone!
        }
        if self.delayRuleTime != nil {
            map["DelayRuleTime"] = self.delayRuleTime!
        }
        if self.destCaCertificateOssUrl != nil {
            map["DestCaCertificateOssUrl"] = self.destCaCertificateOssUrl!
        }
        if self.destCaCertificatePassword != nil {
            map["DestCaCertificatePassword"] = self.destCaCertificatePassword!
        }
        if self.destClientCertOssUrl != nil {
            map["DestClientCertOssUrl"] = self.destClientCertOssUrl!
        }
        if self.destClientKeyOssUrl != nil {
            map["DestClientKeyOssUrl"] = self.destClientKeyOssUrl!
        }
        if self.destClientPassword != nil {
            map["DestClientPassword"] = self.destClientPassword!
        }
        if self.destPrimaryVswId != nil {
            map["DestPrimaryVswId"] = self.destPrimaryVswId!
        }
        if self.destSecondaryVswId != nil {
            map["DestSecondaryVswId"] = self.destSecondaryVswId!
        }
        if self.destinationEndpointDataBaseName != nil {
            map["DestinationEndpointDataBaseName"] = self.destinationEndpointDataBaseName!
        }
        if self.destinationEndpointEngineName != nil {
            map["DestinationEndpointEngineName"] = self.destinationEndpointEngineName!
        }
        if self.destinationEndpointIP != nil {
            map["DestinationEndpointIP"] = self.destinationEndpointIP!
        }
        if self.destinationEndpointInstanceID != nil {
            map["DestinationEndpointInstanceID"] = self.destinationEndpointInstanceID!
        }
        if self.destinationEndpointInstanceType != nil {
            map["DestinationEndpointInstanceType"] = self.destinationEndpointInstanceType!
        }
        if self.destinationEndpointOracleSID != nil {
            map["DestinationEndpointOracleSID"] = self.destinationEndpointOracleSID!
        }
        if self.destinationEndpointOwnerID != nil {
            map["DestinationEndpointOwnerID"] = self.destinationEndpointOwnerID!
        }
        if self.destinationEndpointPassword != nil {
            map["DestinationEndpointPassword"] = self.destinationEndpointPassword!
        }
        if self.destinationEndpointPort != nil {
            map["DestinationEndpointPort"] = self.destinationEndpointPort!
        }
        if self.destinationEndpointRegion != nil {
            map["DestinationEndpointRegion"] = self.destinationEndpointRegion!
        }
        if self.destinationEndpointRole != nil {
            map["DestinationEndpointRole"] = self.destinationEndpointRole!
        }
        if self.destinationEndpointUserName != nil {
            map["DestinationEndpointUserName"] = self.destinationEndpointUserName!
        }
        if self.disasterRecoveryJob != nil {
            map["DisasterRecoveryJob"] = self.disasterRecoveryJob!
        }
        if self.dtsBisLabel != nil {
            map["DtsBisLabel"] = self.dtsBisLabel!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dtsJobName != nil {
            map["DtsJobName"] = self.dtsJobName!
        }
        if self.errorNotice != nil {
            map["ErrorNotice"] = self.errorNotice!
        }
        if self.errorPhone != nil {
            map["ErrorPhone"] = self.errorPhone!
        }
        if self.fileOssUrlObject != nil {
            map["FileOssUrl"] = self.fileOssUrlObject!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.maxDu != nil {
            map["MaxDu"] = self.maxDu!
        }
        if self.minDu != nil {
            map["MinDu"] = self.minDu!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reserve != nil {
            map["Reserve"] = self.reserve!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sourceEndpointDatabaseName != nil {
            map["SourceEndpointDatabaseName"] = self.sourceEndpointDatabaseName!
        }
        if self.sourceEndpointEngineName != nil {
            map["SourceEndpointEngineName"] = self.sourceEndpointEngineName!
        }
        if self.sourceEndpointIP != nil {
            map["SourceEndpointIP"] = self.sourceEndpointIP!
        }
        if self.sourceEndpointInstanceID != nil {
            map["SourceEndpointInstanceID"] = self.sourceEndpointInstanceID!
        }
        if self.sourceEndpointInstanceType != nil {
            map["SourceEndpointInstanceType"] = self.sourceEndpointInstanceType!
        }
        if self.sourceEndpointOracleSID != nil {
            map["SourceEndpointOracleSID"] = self.sourceEndpointOracleSID!
        }
        if self.sourceEndpointOwnerID != nil {
            map["SourceEndpointOwnerID"] = self.sourceEndpointOwnerID!
        }
        if self.sourceEndpointPassword != nil {
            map["SourceEndpointPassword"] = self.sourceEndpointPassword!
        }
        if self.sourceEndpointPort != nil {
            map["SourceEndpointPort"] = self.sourceEndpointPort!
        }
        if self.sourceEndpointRegion != nil {
            map["SourceEndpointRegion"] = self.sourceEndpointRegion!
        }
        if self.sourceEndpointRole != nil {
            map["SourceEndpointRole"] = self.sourceEndpointRole!
        }
        if self.sourceEndpointUserName != nil {
            map["SourceEndpointUserName"] = self.sourceEndpointUserName!
        }
        if self.sourceEndpointVSwitchID != nil {
            map["SourceEndpointVSwitchID"] = self.sourceEndpointVSwitchID!
        }
        if self.srcCaCertificateOssUrl != nil {
            map["SrcCaCertificateOssUrl"] = self.srcCaCertificateOssUrl!
        }
        if self.srcCaCertificatePassword != nil {
            map["SrcCaCertificatePassword"] = self.srcCaCertificatePassword!
        }
        if self.srcClientCertOssUrl != nil {
            map["SrcClientCertOssUrl"] = self.srcClientCertOssUrl!
        }
        if self.srcClientKeyOssUrl != nil {
            map["SrcClientKeyOssUrl"] = self.srcClientKeyOssUrl!
        }
        if self.srcClientPassword != nil {
            map["SrcClientPassword"] = self.srcClientPassword!
        }
        if self.srcPrimaryVswId != nil {
            map["SrcPrimaryVswId"] = self.srcPrimaryVswId!
        }
        if self.srcSecondaryVswId != nil {
            map["SrcSecondaryVswId"] = self.srcSecondaryVswId!
        }
        if self.structureInitialization != nil {
            map["StructureInitialization"] = self.structureInitialization!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Checkpoint") {
            self.checkpoint = dict["Checkpoint"] as! String
        }
        if dict.keys.contains("DataCheckConfigure") {
            self.dataCheckConfigure = dict["DataCheckConfigure"] as! String
        }
        if dict.keys.contains("DataInitialization") {
            self.dataInitialization = dict["DataInitialization"] as! Bool
        }
        if dict.keys.contains("DataSynchronization") {
            self.dataSynchronization = dict["DataSynchronization"] as! Bool
        }
        if dict.keys.contains("DbList") {
            self.dbList = dict["DbList"] as! String
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DelayNotice") {
            self.delayNotice = dict["DelayNotice"] as! Bool
        }
        if dict.keys.contains("DelayPhone") {
            self.delayPhone = dict["DelayPhone"] as! String
        }
        if dict.keys.contains("DelayRuleTime") {
            self.delayRuleTime = dict["DelayRuleTime"] as! Int64
        }
        if dict.keys.contains("DestCaCertificateOssUrl") {
            self.destCaCertificateOssUrl = dict["DestCaCertificateOssUrl"] as! String
        }
        if dict.keys.contains("DestCaCertificatePassword") {
            self.destCaCertificatePassword = dict["DestCaCertificatePassword"] as! String
        }
        if dict.keys.contains("DestClientCertOssUrl") {
            self.destClientCertOssUrl = dict["DestClientCertOssUrl"] as! String
        }
        if dict.keys.contains("DestClientKeyOssUrl") {
            self.destClientKeyOssUrl = dict["DestClientKeyOssUrl"] as! String
        }
        if dict.keys.contains("DestClientPassword") {
            self.destClientPassword = dict["DestClientPassword"] as! String
        }
        if dict.keys.contains("DestPrimaryVswId") {
            self.destPrimaryVswId = dict["DestPrimaryVswId"] as! String
        }
        if dict.keys.contains("DestSecondaryVswId") {
            self.destSecondaryVswId = dict["DestSecondaryVswId"] as! String
        }
        if dict.keys.contains("DestinationEndpointDataBaseName") {
            self.destinationEndpointDataBaseName = dict["DestinationEndpointDataBaseName"] as! String
        }
        if dict.keys.contains("DestinationEndpointEngineName") {
            self.destinationEndpointEngineName = dict["DestinationEndpointEngineName"] as! String
        }
        if dict.keys.contains("DestinationEndpointIP") {
            self.destinationEndpointIP = dict["DestinationEndpointIP"] as! String
        }
        if dict.keys.contains("DestinationEndpointInstanceID") {
            self.destinationEndpointInstanceID = dict["DestinationEndpointInstanceID"] as! String
        }
        if dict.keys.contains("DestinationEndpointInstanceType") {
            self.destinationEndpointInstanceType = dict["DestinationEndpointInstanceType"] as! String
        }
        if dict.keys.contains("DestinationEndpointOracleSID") {
            self.destinationEndpointOracleSID = dict["DestinationEndpointOracleSID"] as! String
        }
        if dict.keys.contains("DestinationEndpointOwnerID") {
            self.destinationEndpointOwnerID = dict["DestinationEndpointOwnerID"] as! String
        }
        if dict.keys.contains("DestinationEndpointPassword") {
            self.destinationEndpointPassword = dict["DestinationEndpointPassword"] as! String
        }
        if dict.keys.contains("DestinationEndpointPort") {
            self.destinationEndpointPort = dict["DestinationEndpointPort"] as! String
        }
        if dict.keys.contains("DestinationEndpointRegion") {
            self.destinationEndpointRegion = dict["DestinationEndpointRegion"] as! String
        }
        if dict.keys.contains("DestinationEndpointRole") {
            self.destinationEndpointRole = dict["DestinationEndpointRole"] as! String
        }
        if dict.keys.contains("DestinationEndpointUserName") {
            self.destinationEndpointUserName = dict["DestinationEndpointUserName"] as! String
        }
        if dict.keys.contains("DisasterRecoveryJob") {
            self.disasterRecoveryJob = dict["DisasterRecoveryJob"] as! Bool
        }
        if dict.keys.contains("DtsBisLabel") {
            self.dtsBisLabel = dict["DtsBisLabel"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DtsJobName") {
            self.dtsJobName = dict["DtsJobName"] as! String
        }
        if dict.keys.contains("ErrorNotice") {
            self.errorNotice = dict["ErrorNotice"] as! Bool
        }
        if dict.keys.contains("ErrorPhone") {
            self.errorPhone = dict["ErrorPhone"] as! String
        }
        if dict.keys.contains("FileOssUrl") {
            self.fileOssUrlObject = dict["FileOssUrl"] as! InputStream
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("MaxDu") {
            self.maxDu = dict["MaxDu"] as! Double
        }
        if dict.keys.contains("MinDu") {
            self.minDu = dict["MinDu"] as! Double
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reserve") {
            self.reserve = dict["Reserve"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SourceEndpointDatabaseName") {
            self.sourceEndpointDatabaseName = dict["SourceEndpointDatabaseName"] as! String
        }
        if dict.keys.contains("SourceEndpointEngineName") {
            self.sourceEndpointEngineName = dict["SourceEndpointEngineName"] as! String
        }
        if dict.keys.contains("SourceEndpointIP") {
            self.sourceEndpointIP = dict["SourceEndpointIP"] as! String
        }
        if dict.keys.contains("SourceEndpointInstanceID") {
            self.sourceEndpointInstanceID = dict["SourceEndpointInstanceID"] as! String
        }
        if dict.keys.contains("SourceEndpointInstanceType") {
            self.sourceEndpointInstanceType = dict["SourceEndpointInstanceType"] as! String
        }
        if dict.keys.contains("SourceEndpointOracleSID") {
            self.sourceEndpointOracleSID = dict["SourceEndpointOracleSID"] as! String
        }
        if dict.keys.contains("SourceEndpointOwnerID") {
            self.sourceEndpointOwnerID = dict["SourceEndpointOwnerID"] as! String
        }
        if dict.keys.contains("SourceEndpointPassword") {
            self.sourceEndpointPassword = dict["SourceEndpointPassword"] as! String
        }
        if dict.keys.contains("SourceEndpointPort") {
            self.sourceEndpointPort = dict["SourceEndpointPort"] as! String
        }
        if dict.keys.contains("SourceEndpointRegion") {
            self.sourceEndpointRegion = dict["SourceEndpointRegion"] as! String
        }
        if dict.keys.contains("SourceEndpointRole") {
            self.sourceEndpointRole = dict["SourceEndpointRole"] as! String
        }
        if dict.keys.contains("SourceEndpointUserName") {
            self.sourceEndpointUserName = dict["SourceEndpointUserName"] as! String
        }
        if dict.keys.contains("SourceEndpointVSwitchID") {
            self.sourceEndpointVSwitchID = dict["SourceEndpointVSwitchID"] as! String
        }
        if dict.keys.contains("SrcCaCertificateOssUrl") {
            self.srcCaCertificateOssUrl = dict["SrcCaCertificateOssUrl"] as! String
        }
        if dict.keys.contains("SrcCaCertificatePassword") {
            self.srcCaCertificatePassword = dict["SrcCaCertificatePassword"] as! String
        }
        if dict.keys.contains("SrcClientCertOssUrl") {
            self.srcClientCertOssUrl = dict["SrcClientCertOssUrl"] as! String
        }
        if dict.keys.contains("SrcClientKeyOssUrl") {
            self.srcClientKeyOssUrl = dict["SrcClientKeyOssUrl"] as! String
        }
        if dict.keys.contains("SrcClientPassword") {
            self.srcClientPassword = dict["SrcClientPassword"] as! String
        }
        if dict.keys.contains("SrcPrimaryVswId") {
            self.srcPrimaryVswId = dict["SrcPrimaryVswId"] as! String
        }
        if dict.keys.contains("SrcSecondaryVswId") {
            self.srcSecondaryVswId = dict["SrcSecondaryVswId"] as! String
        }
        if dict.keys.contains("StructureInitialization") {
            self.structureInitialization = dict["StructureInitialization"] as! Bool
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
    }
}

public class ConfigureDtsJobResponseBody : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ConfigureDtsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureDtsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureDtsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigureMigrationJobRequest : Tea.TeaModel {
    public class DestinationEndpoint : Tea.TeaModel {
        public var dataBaseName: String?

        public var engineName: String?

        public var IP: String?

        public var instanceID: String?

        public var instanceType: String?

        public var oracleSID: String?

        public var password: String?

        public var port: String?

        public var region: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataBaseName != nil {
                map["DataBaseName"] = self.dataBaseName!
            }
            if self.engineName != nil {
                map["EngineName"] = self.engineName!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceID != nil {
                map["InstanceID"] = self.instanceID!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.oracleSID != nil {
                map["OracleSID"] = self.oracleSID!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataBaseName") {
                self.dataBaseName = dict["DataBaseName"] as! String
            }
            if dict.keys.contains("EngineName") {
                self.engineName = dict["EngineName"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceID") {
                self.instanceID = dict["InstanceID"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("OracleSID") {
                self.oracleSID = dict["OracleSID"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class MigrationMode : Tea.TeaModel {
        public var dataIntialization: Bool?

        public var dataSynchronization: Bool?

        public var structureIntialization: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataIntialization != nil {
                map["DataIntialization"] = self.dataIntialization!
            }
            if self.dataSynchronization != nil {
                map["DataSynchronization"] = self.dataSynchronization!
            }
            if self.structureIntialization != nil {
                map["StructureIntialization"] = self.structureIntialization!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataIntialization") {
                self.dataIntialization = dict["DataIntialization"] as! Bool
            }
            if dict.keys.contains("DataSynchronization") {
                self.dataSynchronization = dict["DataSynchronization"] as! Bool
            }
            if dict.keys.contains("StructureIntialization") {
                self.structureIntialization = dict["StructureIntialization"] as! Bool
            }
        }
    }
    public class SourceEndpoint : Tea.TeaModel {
        public var databaseName: String?

        public var engineName: String?

        public var IP: String?

        public var instanceID: String?

        public var instanceType: String?

        public var oracleSID: String?

        public var ownerID: String?

        public var password: String?

        public var port: String?

        public var region: String?

        public var role: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.engineName != nil {
                map["EngineName"] = self.engineName!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceID != nil {
                map["InstanceID"] = self.instanceID!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.oracleSID != nil {
                map["OracleSID"] = self.oracleSID!
            }
            if self.ownerID != nil {
                map["OwnerID"] = self.ownerID!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("EngineName") {
                self.engineName = dict["EngineName"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceID") {
                self.instanceID = dict["InstanceID"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("OracleSID") {
                self.oracleSID = dict["OracleSID"] as! String
            }
            if dict.keys.contains("OwnerID") {
                self.ownerID = dict["OwnerID"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var destinationEndpoint: ConfigureMigrationJobRequest.DestinationEndpoint?

    public var migrationMode: ConfigureMigrationJobRequest.MigrationMode?

    public var sourceEndpoint: ConfigureMigrationJobRequest.SourceEndpoint?

    public var accountId: String?

    public var checkpoint: String?

    public var migrationJobId: String?

    public var migrationJobName: String?

    public var migrationObject: String?

    public var migrationReserved: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.destinationEndpoint?.validate()
        try self.migrationMode?.validate()
        try self.sourceEndpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationEndpoint != nil {
            map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
        }
        if self.migrationMode != nil {
            map["MigrationMode"] = self.migrationMode?.toMap()
        }
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.checkpoint != nil {
            map["Checkpoint"] = self.checkpoint!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.migrationJobName != nil {
            map["MigrationJobName"] = self.migrationJobName!
        }
        if self.migrationObject != nil {
            map["MigrationObject"] = self.migrationObject!
        }
        if self.migrationReserved != nil {
            map["MigrationReserved"] = self.migrationReserved!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationEndpoint") {
            var model = ConfigureMigrationJobRequest.DestinationEndpoint()
            model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
            self.destinationEndpoint = model
        }
        if dict.keys.contains("MigrationMode") {
            var model = ConfigureMigrationJobRequest.MigrationMode()
            model.fromMap(dict["MigrationMode"] as! [String: Any])
            self.migrationMode = model
        }
        if dict.keys.contains("SourceEndpoint") {
            var model = ConfigureMigrationJobRequest.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("Checkpoint") {
            self.checkpoint = dict["Checkpoint"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("MigrationJobName") {
            self.migrationJobName = dict["MigrationJobName"] as! String
        }
        if dict.keys.contains("MigrationObject") {
            self.migrationObject = dict["MigrationObject"] as! String
        }
        if dict.keys.contains("MigrationReserved") {
            self.migrationReserved = dict["MigrationReserved"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ConfigureMigrationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ConfigureMigrationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureMigrationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureMigrationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigureMigrationJobAlertRequest : Tea.TeaModel {
    public var accountId: String?

    public var delayAlertPhone: String?

    public var delayAlertStatus: String?

    public var delayOverSeconds: String?

    public var errorAlertPhone: String?

    public var errorAlertStatus: String?

    public var migrationJobId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.delayAlertPhone != nil {
            map["DelayAlertPhone"] = self.delayAlertPhone!
        }
        if self.delayAlertStatus != nil {
            map["DelayAlertStatus"] = self.delayAlertStatus!
        }
        if self.delayOverSeconds != nil {
            map["DelayOverSeconds"] = self.delayOverSeconds!
        }
        if self.errorAlertPhone != nil {
            map["ErrorAlertPhone"] = self.errorAlertPhone!
        }
        if self.errorAlertStatus != nil {
            map["ErrorAlertStatus"] = self.errorAlertStatus!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("DelayAlertPhone") {
            self.delayAlertPhone = dict["DelayAlertPhone"] as! String
        }
        if dict.keys.contains("DelayAlertStatus") {
            self.delayAlertStatus = dict["DelayAlertStatus"] as! String
        }
        if dict.keys.contains("DelayOverSeconds") {
            self.delayOverSeconds = dict["DelayOverSeconds"] as! String
        }
        if dict.keys.contains("ErrorAlertPhone") {
            self.errorAlertPhone = dict["ErrorAlertPhone"] as! String
        }
        if dict.keys.contains("ErrorAlertStatus") {
            self.errorAlertStatus = dict["ErrorAlertStatus"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ConfigureMigrationJobAlertResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ConfigureMigrationJobAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureMigrationJobAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureMigrationJobAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigureSubscriptionRequest : Tea.TeaModel {
    public var checkpoint: String?

    public var dbList: String?

    public var dedicatedClusterId: String?

    public var delayNotice: Bool?

    public var delayPhone: String?

    public var delayRuleTime: Int64?

    public var dtsBisLabel: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var dtsJobName: String?

    public var errorNotice: Bool?

    public var errorPhone: String?

    public var maxDu: Double?

    public var minDu: Double?

    public var regionId: String?

    public var reserve: String?

    public var resourceGroupId: String?

    public var sourceEndpointDatabaseName: String?

    public var sourceEndpointEngineName: String?

    public var sourceEndpointIP: String?

    public var sourceEndpointInstanceID: String?

    public var sourceEndpointInstanceType: String?

    public var sourceEndpointOracleSID: String?

    public var sourceEndpointOwnerID: String?

    public var sourceEndpointPassword: String?

    public var sourceEndpointPort: String?

    public var sourceEndpointRegion: String?

    public var sourceEndpointRole: String?

    public var sourceEndpointUserName: String?

    public var srcCaCertificateOssUrl: String?

    public var srcCaCertificatePassword: String?

    public var srcClientCertOssUrl: String?

    public var srcClientKeyOssUrl: String?

    public var srcClientPassword: String?

    public var subscriptionDataTypeDDL: Bool?

    public var subscriptionDataTypeDML: Bool?

    public var subscriptionInstanceNetworkType: String?

    public var subscriptionInstanceVPCId: String?

    public var subscriptionInstanceVSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkpoint != nil {
            map["Checkpoint"] = self.checkpoint!
        }
        if self.dbList != nil {
            map["DbList"] = self.dbList!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.delayNotice != nil {
            map["DelayNotice"] = self.delayNotice!
        }
        if self.delayPhone != nil {
            map["DelayPhone"] = self.delayPhone!
        }
        if self.delayRuleTime != nil {
            map["DelayRuleTime"] = self.delayRuleTime!
        }
        if self.dtsBisLabel != nil {
            map["DtsBisLabel"] = self.dtsBisLabel!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dtsJobName != nil {
            map["DtsJobName"] = self.dtsJobName!
        }
        if self.errorNotice != nil {
            map["ErrorNotice"] = self.errorNotice!
        }
        if self.errorPhone != nil {
            map["ErrorPhone"] = self.errorPhone!
        }
        if self.maxDu != nil {
            map["MaxDu"] = self.maxDu!
        }
        if self.minDu != nil {
            map["MinDu"] = self.minDu!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reserve != nil {
            map["Reserve"] = self.reserve!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sourceEndpointDatabaseName != nil {
            map["SourceEndpointDatabaseName"] = self.sourceEndpointDatabaseName!
        }
        if self.sourceEndpointEngineName != nil {
            map["SourceEndpointEngineName"] = self.sourceEndpointEngineName!
        }
        if self.sourceEndpointIP != nil {
            map["SourceEndpointIP"] = self.sourceEndpointIP!
        }
        if self.sourceEndpointInstanceID != nil {
            map["SourceEndpointInstanceID"] = self.sourceEndpointInstanceID!
        }
        if self.sourceEndpointInstanceType != nil {
            map["SourceEndpointInstanceType"] = self.sourceEndpointInstanceType!
        }
        if self.sourceEndpointOracleSID != nil {
            map["SourceEndpointOracleSID"] = self.sourceEndpointOracleSID!
        }
        if self.sourceEndpointOwnerID != nil {
            map["SourceEndpointOwnerID"] = self.sourceEndpointOwnerID!
        }
        if self.sourceEndpointPassword != nil {
            map["SourceEndpointPassword"] = self.sourceEndpointPassword!
        }
        if self.sourceEndpointPort != nil {
            map["SourceEndpointPort"] = self.sourceEndpointPort!
        }
        if self.sourceEndpointRegion != nil {
            map["SourceEndpointRegion"] = self.sourceEndpointRegion!
        }
        if self.sourceEndpointRole != nil {
            map["SourceEndpointRole"] = self.sourceEndpointRole!
        }
        if self.sourceEndpointUserName != nil {
            map["SourceEndpointUserName"] = self.sourceEndpointUserName!
        }
        if self.srcCaCertificateOssUrl != nil {
            map["SrcCaCertificateOssUrl"] = self.srcCaCertificateOssUrl!
        }
        if self.srcCaCertificatePassword != nil {
            map["SrcCaCertificatePassword"] = self.srcCaCertificatePassword!
        }
        if self.srcClientCertOssUrl != nil {
            map["SrcClientCertOssUrl"] = self.srcClientCertOssUrl!
        }
        if self.srcClientKeyOssUrl != nil {
            map["SrcClientKeyOssUrl"] = self.srcClientKeyOssUrl!
        }
        if self.srcClientPassword != nil {
            map["SrcClientPassword"] = self.srcClientPassword!
        }
        if self.subscriptionDataTypeDDL != nil {
            map["SubscriptionDataTypeDDL"] = self.subscriptionDataTypeDDL!
        }
        if self.subscriptionDataTypeDML != nil {
            map["SubscriptionDataTypeDML"] = self.subscriptionDataTypeDML!
        }
        if self.subscriptionInstanceNetworkType != nil {
            map["SubscriptionInstanceNetworkType"] = self.subscriptionInstanceNetworkType!
        }
        if self.subscriptionInstanceVPCId != nil {
            map["SubscriptionInstanceVPCId"] = self.subscriptionInstanceVPCId!
        }
        if self.subscriptionInstanceVSwitchId != nil {
            map["SubscriptionInstanceVSwitchId"] = self.subscriptionInstanceVSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Checkpoint") {
            self.checkpoint = dict["Checkpoint"] as! String
        }
        if dict.keys.contains("DbList") {
            self.dbList = dict["DbList"] as! String
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DelayNotice") {
            self.delayNotice = dict["DelayNotice"] as! Bool
        }
        if dict.keys.contains("DelayPhone") {
            self.delayPhone = dict["DelayPhone"] as! String
        }
        if dict.keys.contains("DelayRuleTime") {
            self.delayRuleTime = dict["DelayRuleTime"] as! Int64
        }
        if dict.keys.contains("DtsBisLabel") {
            self.dtsBisLabel = dict["DtsBisLabel"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DtsJobName") {
            self.dtsJobName = dict["DtsJobName"] as! String
        }
        if dict.keys.contains("ErrorNotice") {
            self.errorNotice = dict["ErrorNotice"] as! Bool
        }
        if dict.keys.contains("ErrorPhone") {
            self.errorPhone = dict["ErrorPhone"] as! String
        }
        if dict.keys.contains("MaxDu") {
            self.maxDu = dict["MaxDu"] as! Double
        }
        if dict.keys.contains("MinDu") {
            self.minDu = dict["MinDu"] as! Double
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reserve") {
            self.reserve = dict["Reserve"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SourceEndpointDatabaseName") {
            self.sourceEndpointDatabaseName = dict["SourceEndpointDatabaseName"] as! String
        }
        if dict.keys.contains("SourceEndpointEngineName") {
            self.sourceEndpointEngineName = dict["SourceEndpointEngineName"] as! String
        }
        if dict.keys.contains("SourceEndpointIP") {
            self.sourceEndpointIP = dict["SourceEndpointIP"] as! String
        }
        if dict.keys.contains("SourceEndpointInstanceID") {
            self.sourceEndpointInstanceID = dict["SourceEndpointInstanceID"] as! String
        }
        if dict.keys.contains("SourceEndpointInstanceType") {
            self.sourceEndpointInstanceType = dict["SourceEndpointInstanceType"] as! String
        }
        if dict.keys.contains("SourceEndpointOracleSID") {
            self.sourceEndpointOracleSID = dict["SourceEndpointOracleSID"] as! String
        }
        if dict.keys.contains("SourceEndpointOwnerID") {
            self.sourceEndpointOwnerID = dict["SourceEndpointOwnerID"] as! String
        }
        if dict.keys.contains("SourceEndpointPassword") {
            self.sourceEndpointPassword = dict["SourceEndpointPassword"] as! String
        }
        if dict.keys.contains("SourceEndpointPort") {
            self.sourceEndpointPort = dict["SourceEndpointPort"] as! String
        }
        if dict.keys.contains("SourceEndpointRegion") {
            self.sourceEndpointRegion = dict["SourceEndpointRegion"] as! String
        }
        if dict.keys.contains("SourceEndpointRole") {
            self.sourceEndpointRole = dict["SourceEndpointRole"] as! String
        }
        if dict.keys.contains("SourceEndpointUserName") {
            self.sourceEndpointUserName = dict["SourceEndpointUserName"] as! String
        }
        if dict.keys.contains("SrcCaCertificateOssUrl") {
            self.srcCaCertificateOssUrl = dict["SrcCaCertificateOssUrl"] as! String
        }
        if dict.keys.contains("SrcCaCertificatePassword") {
            self.srcCaCertificatePassword = dict["SrcCaCertificatePassword"] as! String
        }
        if dict.keys.contains("SrcClientCertOssUrl") {
            self.srcClientCertOssUrl = dict["SrcClientCertOssUrl"] as! String
        }
        if dict.keys.contains("SrcClientKeyOssUrl") {
            self.srcClientKeyOssUrl = dict["SrcClientKeyOssUrl"] as! String
        }
        if dict.keys.contains("SrcClientPassword") {
            self.srcClientPassword = dict["SrcClientPassword"] as! String
        }
        if dict.keys.contains("SubscriptionDataTypeDDL") {
            self.subscriptionDataTypeDDL = dict["SubscriptionDataTypeDDL"] as! Bool
        }
        if dict.keys.contains("SubscriptionDataTypeDML") {
            self.subscriptionDataTypeDML = dict["SubscriptionDataTypeDML"] as! Bool
        }
        if dict.keys.contains("SubscriptionInstanceNetworkType") {
            self.subscriptionInstanceNetworkType = dict["SubscriptionInstanceNetworkType"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceVPCId") {
            self.subscriptionInstanceVPCId = dict["SubscriptionInstanceVPCId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceVSwitchId") {
            self.subscriptionInstanceVSwitchId = dict["SubscriptionInstanceVSwitchId"] as! String
        }
    }
}

public class ConfigureSubscriptionResponseBody : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ConfigureSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureSubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigureSubscriptionInstanceRequest : Tea.TeaModel {
    public class SourceEndpoint : Tea.TeaModel {
        public var databaseName: String?

        public var IP: String?

        public var instanceID: String?

        public var instanceType: String?

        public var oracleSID: String?

        public var ownerID: String?

        public var password: String?

        public var port: String?

        public var role: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceID != nil {
                map["InstanceID"] = self.instanceID!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.oracleSID != nil {
                map["OracleSID"] = self.oracleSID!
            }
            if self.ownerID != nil {
                map["OwnerID"] = self.ownerID!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceID") {
                self.instanceID = dict["InstanceID"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("OracleSID") {
                self.oracleSID = dict["OracleSID"] as! String
            }
            if dict.keys.contains("OwnerID") {
                self.ownerID = dict["OwnerID"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class SubscriptionDataType : Tea.TeaModel {
        public var DDL: Bool?

        public var DML: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DDL != nil {
                map["DDL"] = self.DDL!
            }
            if self.DML != nil {
                map["DML"] = self.DML!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DDL") {
                self.DDL = dict["DDL"] as! Bool
            }
            if dict.keys.contains("DML") {
                self.DML = dict["DML"] as! Bool
            }
        }
    }
    public class SubscriptionInstance : Tea.TeaModel {
        public var VPCId: String?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.VPCId != nil {
                map["VPCId"] = self.VPCId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VPCId") {
                self.VPCId = dict["VPCId"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public var sourceEndpoint: ConfigureSubscriptionInstanceRequest.SourceEndpoint?

    public var subscriptionDataType: ConfigureSubscriptionInstanceRequest.SubscriptionDataType?

    public var subscriptionInstance: ConfigureSubscriptionInstanceRequest.SubscriptionInstance?

    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public var subscriptionInstanceName: String?

    public var subscriptionInstanceNetworkType: String?

    public var subscriptionObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceEndpoint?.validate()
        try self.subscriptionDataType?.validate()
        try self.subscriptionInstance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.subscriptionDataType != nil {
            map["SubscriptionDataType"] = self.subscriptionDataType?.toMap()
        }
        if self.subscriptionInstance != nil {
            map["SubscriptionInstance"] = self.subscriptionInstance?.toMap()
        }
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        if self.subscriptionInstanceName != nil {
            map["SubscriptionInstanceName"] = self.subscriptionInstanceName!
        }
        if self.subscriptionInstanceNetworkType != nil {
            map["SubscriptionInstanceNetworkType"] = self.subscriptionInstanceNetworkType!
        }
        if self.subscriptionObject != nil {
            map["SubscriptionObject"] = self.subscriptionObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceEndpoint") {
            var model = ConfigureSubscriptionInstanceRequest.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("SubscriptionDataType") {
            var model = ConfigureSubscriptionInstanceRequest.SubscriptionDataType()
            model.fromMap(dict["SubscriptionDataType"] as! [String: Any])
            self.subscriptionDataType = model
        }
        if dict.keys.contains("SubscriptionInstance") {
            var model = ConfigureSubscriptionInstanceRequest.SubscriptionInstance()
            model.fromMap(dict["SubscriptionInstance"] as! [String: Any])
            self.subscriptionInstance = model
        }
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceName") {
            self.subscriptionInstanceName = dict["SubscriptionInstanceName"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceNetworkType") {
            self.subscriptionInstanceNetworkType = dict["SubscriptionInstanceNetworkType"] as! String
        }
        if dict.keys.contains("SubscriptionObject") {
            self.subscriptionObject = dict["SubscriptionObject"] as! String
        }
    }
}

public class ConfigureSubscriptionInstanceResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ConfigureSubscriptionInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureSubscriptionInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureSubscriptionInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigureSubscriptionInstanceAlertRequest : Tea.TeaModel {
    public var accountId: String?

    public var delayAlertPhone: String?

    public var delayAlertStatus: String?

    public var delayOverSeconds: String?

    public var errorAlertPhone: String?

    public var errorAlertStatus: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.delayAlertPhone != nil {
            map["DelayAlertPhone"] = self.delayAlertPhone!
        }
        if self.delayAlertStatus != nil {
            map["DelayAlertStatus"] = self.delayAlertStatus!
        }
        if self.delayOverSeconds != nil {
            map["DelayOverSeconds"] = self.delayOverSeconds!
        }
        if self.errorAlertPhone != nil {
            map["ErrorAlertPhone"] = self.errorAlertPhone!
        }
        if self.errorAlertStatus != nil {
            map["ErrorAlertStatus"] = self.errorAlertStatus!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("DelayAlertPhone") {
            self.delayAlertPhone = dict["DelayAlertPhone"] as! String
        }
        if dict.keys.contains("DelayAlertStatus") {
            self.delayAlertStatus = dict["DelayAlertStatus"] as! String
        }
        if dict.keys.contains("DelayOverSeconds") {
            self.delayOverSeconds = dict["DelayOverSeconds"] as! String
        }
        if dict.keys.contains("ErrorAlertPhone") {
            self.errorAlertPhone = dict["ErrorAlertPhone"] as! String
        }
        if dict.keys.contains("ErrorAlertStatus") {
            self.errorAlertStatus = dict["ErrorAlertStatus"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
    }
}

public class ConfigureSubscriptionInstanceAlertResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ConfigureSubscriptionInstanceAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureSubscriptionInstanceAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureSubscriptionInstanceAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigureSynchronizationJobRequest : Tea.TeaModel {
    public class DestinationEndpoint : Tea.TeaModel {
        public var dataBaseName: String?

        public var IP: String?

        public var instanceId: String?

        public var instanceType: String?

        public var password: String?

        public var port: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataBaseName != nil {
                map["DataBaseName"] = self.dataBaseName!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataBaseName") {
                self.dataBaseName = dict["DataBaseName"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class PartitionKey : Tea.TeaModel {
        public var modifyTimeDay: Bool?

        public var modifyTimeHour: Bool?

        public var modifyTimeMinute: Bool?

        public var modifyTimeMonth: Bool?

        public var modifyTimeYear: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modifyTimeDay != nil {
                map["ModifyTime_Day"] = self.modifyTimeDay!
            }
            if self.modifyTimeHour != nil {
                map["ModifyTime_Hour"] = self.modifyTimeHour!
            }
            if self.modifyTimeMinute != nil {
                map["ModifyTime_Minute"] = self.modifyTimeMinute!
            }
            if self.modifyTimeMonth != nil {
                map["ModifyTime_Month"] = self.modifyTimeMonth!
            }
            if self.modifyTimeYear != nil {
                map["ModifyTime_Year"] = self.modifyTimeYear!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModifyTime_Day") {
                self.modifyTimeDay = dict["ModifyTime_Day"] as! Bool
            }
            if dict.keys.contains("ModifyTime_Hour") {
                self.modifyTimeHour = dict["ModifyTime_Hour"] as! Bool
            }
            if dict.keys.contains("ModifyTime_Minute") {
                self.modifyTimeMinute = dict["ModifyTime_Minute"] as! Bool
            }
            if dict.keys.contains("ModifyTime_Month") {
                self.modifyTimeMonth = dict["ModifyTime_Month"] as! Bool
            }
            if dict.keys.contains("ModifyTime_Year") {
                self.modifyTimeYear = dict["ModifyTime_Year"] as! Bool
            }
        }
    }
    public class SourceEndpoint : Tea.TeaModel {
        public var databaseName: String?

        public var IP: String?

        public var instanceId: String?

        public var instanceType: String?

        public var ownerID: String?

        public var password: String?

        public var port: String?

        public var role: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ownerID != nil {
                map["OwnerID"] = self.ownerID!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("OwnerID") {
                self.ownerID = dict["OwnerID"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var destinationEndpoint: ConfigureSynchronizationJobRequest.DestinationEndpoint?

    public var partitionKey: ConfigureSynchronizationJobRequest.PartitionKey?

    public var sourceEndpoint: ConfigureSynchronizationJobRequest.SourceEndpoint?

    public var accountId: String?

    public var checkpoint: String?

    public var dataInitialization: Bool?

    public var migrationReserved: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var structureInitialization: Bool?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public var synchronizationJobName: String?

    public var synchronizationObjects: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.destinationEndpoint?.validate()
        try self.partitionKey?.validate()
        try self.sourceEndpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationEndpoint != nil {
            map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
        }
        if self.partitionKey != nil {
            map["PartitionKey"] = self.partitionKey?.toMap()
        }
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.checkpoint != nil {
            map["Checkpoint"] = self.checkpoint!
        }
        if self.dataInitialization != nil {
            map["DataInitialization"] = self.dataInitialization!
        }
        if self.migrationReserved != nil {
            map["MigrationReserved"] = self.migrationReserved!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.structureInitialization != nil {
            map["StructureInitialization"] = self.structureInitialization!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        if self.synchronizationJobName != nil {
            map["SynchronizationJobName"] = self.synchronizationJobName!
        }
        if self.synchronizationObjects != nil {
            map["SynchronizationObjects"] = self.synchronizationObjects!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationEndpoint") {
            var model = ConfigureSynchronizationJobRequest.DestinationEndpoint()
            model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
            self.destinationEndpoint = model
        }
        if dict.keys.contains("PartitionKey") {
            var model = ConfigureSynchronizationJobRequest.PartitionKey()
            model.fromMap(dict["PartitionKey"] as! [String: Any])
            self.partitionKey = model
        }
        if dict.keys.contains("SourceEndpoint") {
            var model = ConfigureSynchronizationJobRequest.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("Checkpoint") {
            self.checkpoint = dict["Checkpoint"] as! String
        }
        if dict.keys.contains("DataInitialization") {
            self.dataInitialization = dict["DataInitialization"] as! Bool
        }
        if dict.keys.contains("MigrationReserved") {
            self.migrationReserved = dict["MigrationReserved"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StructureInitialization") {
            self.structureInitialization = dict["StructureInitialization"] as! Bool
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
        if dict.keys.contains("SynchronizationJobName") {
            self.synchronizationJobName = dict["SynchronizationJobName"] as! String
        }
        if dict.keys.contains("SynchronizationObjects") {
            self.synchronizationObjects = dict["SynchronizationObjects"] as! String
        }
    }
}

public class ConfigureSynchronizationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ConfigureSynchronizationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureSynchronizationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureSynchronizationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigureSynchronizationJobAlertRequest : Tea.TeaModel {
    public var accountId: String?

    public var delayAlertPhone: String?

    public var delayAlertStatus: String?

    public var delayOverSeconds: String?

    public var errorAlertPhone: String?

    public var errorAlertStatus: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.delayAlertPhone != nil {
            map["DelayAlertPhone"] = self.delayAlertPhone!
        }
        if self.delayAlertStatus != nil {
            map["DelayAlertStatus"] = self.delayAlertStatus!
        }
        if self.delayOverSeconds != nil {
            map["DelayOverSeconds"] = self.delayOverSeconds!
        }
        if self.errorAlertPhone != nil {
            map["ErrorAlertPhone"] = self.errorAlertPhone!
        }
        if self.errorAlertStatus != nil {
            map["ErrorAlertStatus"] = self.errorAlertStatus!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("DelayAlertPhone") {
            self.delayAlertPhone = dict["DelayAlertPhone"] as! String
        }
        if dict.keys.contains("DelayAlertStatus") {
            self.delayAlertStatus = dict["DelayAlertStatus"] as! String
        }
        if dict.keys.contains("DelayOverSeconds") {
            self.delayOverSeconds = dict["DelayOverSeconds"] as! String
        }
        if dict.keys.contains("ErrorAlertPhone") {
            self.errorAlertPhone = dict["ErrorAlertPhone"] as! String
        }
        if dict.keys.contains("ErrorAlertStatus") {
            self.errorAlertStatus = dict["ErrorAlertStatus"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class ConfigureSynchronizationJobAlertResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ConfigureSynchronizationJobAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureSynchronizationJobAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureSynchronizationJobAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigureSynchronizationJobReplicatorCompareRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public var synchronizationReplicatorCompareEnable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        if self.synchronizationReplicatorCompareEnable != nil {
            map["SynchronizationReplicatorCompareEnable"] = self.synchronizationReplicatorCompareEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
        if dict.keys.contains("SynchronizationReplicatorCompareEnable") {
            self.synchronizationReplicatorCompareEnable = dict["SynchronizationReplicatorCompareEnable"] as! Bool
        }
    }
}

public class ConfigureSynchronizationJobReplicatorCompareResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ConfigureSynchronizationJobReplicatorCompareResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureSynchronizationJobReplicatorCompareResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureSynchronizationJobReplicatorCompareResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConvertInstanceResourceGroupRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var newResourceGroupId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class ConvertInstanceResourceGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ConvertInstanceResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConvertInstanceResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConvertInstanceResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CountJobByConditionRequest : Tea.TeaModel {
    public var destDbType: String?

    public var groupId: String?

    public var jobType: String?

    public var params: String?

    public var region: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var srcDbType: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destDbType != nil {
            map["DestDbType"] = self.destDbType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.srcDbType != nil {
            map["SrcDbType"] = self.srcDbType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestDbType") {
            self.destDbType = dict["DestDbType"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SrcDbType") {
            self.srcDbType = dict["SrcDbType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CountJobByConditionResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class CountJobByConditionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CountJobByConditionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CountJobByConditionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateConsumerChannelRequest : Tea.TeaModel {
    public var consumerGroupName: String?

    public var consumerGroupPassword: String?

    public var consumerGroupUserName: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consumerGroupName != nil {
            map["ConsumerGroupName"] = self.consumerGroupName!
        }
        if self.consumerGroupPassword != nil {
            map["ConsumerGroupPassword"] = self.consumerGroupPassword!
        }
        if self.consumerGroupUserName != nil {
            map["ConsumerGroupUserName"] = self.consumerGroupUserName!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsumerGroupName") {
            self.consumerGroupName = dict["ConsumerGroupName"] as! String
        }
        if dict.keys.contains("ConsumerGroupPassword") {
            self.consumerGroupPassword = dict["ConsumerGroupPassword"] as! String
        }
        if dict.keys.contains("ConsumerGroupUserName") {
            self.consumerGroupUserName = dict["ConsumerGroupUserName"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateConsumerChannelResponseBody : Tea.TeaModel {
    public var consumerGroupID: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consumerGroupID != nil {
            map["ConsumerGroupID"] = self.consumerGroupID!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsumerGroupID") {
            self.consumerGroupID = dict["ConsumerGroupID"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateConsumerChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConsumerChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateConsumerChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateConsumerGroupRequest : Tea.TeaModel {
    public var accountId: String?

    public var consumerGroupName: String?

    public var consumerGroupPassword: String?

    public var consumerGroupUserName: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.consumerGroupName != nil {
            map["ConsumerGroupName"] = self.consumerGroupName!
        }
        if self.consumerGroupPassword != nil {
            map["ConsumerGroupPassword"] = self.consumerGroupPassword!
        }
        if self.consumerGroupUserName != nil {
            map["ConsumerGroupUserName"] = self.consumerGroupUserName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ConsumerGroupName") {
            self.consumerGroupName = dict["ConsumerGroupName"] as! String
        }
        if dict.keys.contains("ConsumerGroupPassword") {
            self.consumerGroupPassword = dict["ConsumerGroupPassword"] as! String
        }
        if dict.keys.contains("ConsumerGroupUserName") {
            self.consumerGroupUserName = dict["ConsumerGroupUserName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
    }
}

public class CreateConsumerGroupResponseBody : Tea.TeaModel {
    public var consumerGroupID: String?

    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consumerGroupID != nil {
            map["ConsumerGroupID"] = self.consumerGroupID!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsumerGroupID") {
            self.consumerGroupID = dict["ConsumerGroupID"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateConsumerGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConsumerGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateConsumerGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDedicatedClusterMonitorRuleRequest : Tea.TeaModel {
    public var cpuAlarmThreshold: Int64?

    public var dedicatedClusterId: String?

    public var diskAlarmThreshold: Int64?

    public var duAlarmThreshold: Int64?

    public var instanceId: String?

    public var memAlarmThreshold: Int64?

    public var noticeSwitch: Int64?

    public var ownerId: String?

    public var phones: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuAlarmThreshold != nil {
            map["CpuAlarmThreshold"] = self.cpuAlarmThreshold!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.diskAlarmThreshold != nil {
            map["DiskAlarmThreshold"] = self.diskAlarmThreshold!
        }
        if self.duAlarmThreshold != nil {
            map["DuAlarmThreshold"] = self.duAlarmThreshold!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.memAlarmThreshold != nil {
            map["MemAlarmThreshold"] = self.memAlarmThreshold!
        }
        if self.noticeSwitch != nil {
            map["NoticeSwitch"] = self.noticeSwitch!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.phones != nil {
            map["Phones"] = self.phones!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuAlarmThreshold") {
            self.cpuAlarmThreshold = dict["CpuAlarmThreshold"] as! Int64
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DiskAlarmThreshold") {
            self.diskAlarmThreshold = dict["DiskAlarmThreshold"] as! Int64
        }
        if dict.keys.contains("DuAlarmThreshold") {
            self.duAlarmThreshold = dict["DuAlarmThreshold"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MemAlarmThreshold") {
            self.memAlarmThreshold = dict["MemAlarmThreshold"] as! Int64
        }
        if dict.keys.contains("NoticeSwitch") {
            self.noticeSwitch = dict["NoticeSwitch"] as! Int64
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("Phones") {
            self.phones = dict["Phones"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateDedicatedClusterMonitorRuleResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateDedicatedClusterMonitorRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDedicatedClusterMonitorRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDedicatedClusterMonitorRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDtsInstanceRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoStart: Bool?

    public var computeUnit: Int32?

    public var databaseCount: Int32?

    public var destinationEndpointEngineName: String?

    public var destinationRegion: String?

    public var dtsRegion: String?

    public var du: Int32?

    public var feeType: String?

    public var instanceClass: String?

    public var jobId: String?

    public var maxDu: Double?

    public var minDu: Double?

    public var payType: String?

    public var period: String?

    public var quantity: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var sourceEndpointEngineName: String?

    public var sourceRegion: String?

    public var syncArchitecture: String?

    public var type: String?

    public var usedTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoStart != nil {
            map["AutoStart"] = self.autoStart!
        }
        if self.computeUnit != nil {
            map["ComputeUnit"] = self.computeUnit!
        }
        if self.databaseCount != nil {
            map["DatabaseCount"] = self.databaseCount!
        }
        if self.destinationEndpointEngineName != nil {
            map["DestinationEndpointEngineName"] = self.destinationEndpointEngineName!
        }
        if self.destinationRegion != nil {
            map["DestinationRegion"] = self.destinationRegion!
        }
        if self.dtsRegion != nil {
            map["DtsRegion"] = self.dtsRegion!
        }
        if self.du != nil {
            map["Du"] = self.du!
        }
        if self.feeType != nil {
            map["FeeType"] = self.feeType!
        }
        if self.instanceClass != nil {
            map["InstanceClass"] = self.instanceClass!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.maxDu != nil {
            map["MaxDu"] = self.maxDu!
        }
        if self.minDu != nil {
            map["MinDu"] = self.minDu!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sourceEndpointEngineName != nil {
            map["SourceEndpointEngineName"] = self.sourceEndpointEngineName!
        }
        if self.sourceRegion != nil {
            map["SourceRegion"] = self.sourceRegion!
        }
        if self.syncArchitecture != nil {
            map["SyncArchitecture"] = self.syncArchitecture!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoStart") {
            self.autoStart = dict["AutoStart"] as! Bool
        }
        if dict.keys.contains("ComputeUnit") {
            self.computeUnit = dict["ComputeUnit"] as! Int32
        }
        if dict.keys.contains("DatabaseCount") {
            self.databaseCount = dict["DatabaseCount"] as! Int32
        }
        if dict.keys.contains("DestinationEndpointEngineName") {
            self.destinationEndpointEngineName = dict["DestinationEndpointEngineName"] as! String
        }
        if dict.keys.contains("DestinationRegion") {
            self.destinationRegion = dict["DestinationRegion"] as! String
        }
        if dict.keys.contains("DtsRegion") {
            self.dtsRegion = dict["DtsRegion"] as! String
        }
        if dict.keys.contains("Du") {
            self.du = dict["Du"] as! Int32
        }
        if dict.keys.contains("FeeType") {
            self.feeType = dict["FeeType"] as! String
        }
        if dict.keys.contains("InstanceClass") {
            self.instanceClass = dict["InstanceClass"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MaxDu") {
            self.maxDu = dict["MaxDu"] as! Double
        }
        if dict.keys.contains("MinDu") {
            self.minDu = dict["MinDu"] as! Double
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("Quantity") {
            self.quantity = dict["Quantity"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SourceEndpointEngineName") {
            self.sourceEndpointEngineName = dict["SourceEndpointEngineName"] as! String
        }
        if dict.keys.contains("SourceRegion") {
            self.sourceRegion = dict["SourceRegion"] as! String
        }
        if dict.keys.contains("SyncArchitecture") {
            self.syncArchitecture = dict["SyncArchitecture"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UsedTime") {
            self.usedTime = dict["UsedTime"] as! Int32
        }
    }
}

public class CreateDtsInstanceResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var instanceId: String?

    public var jobId: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateDtsInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDtsInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDtsInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateJobMonitorRuleRequest : Tea.TeaModel {
    public var delayRuleTime: Int64?

    public var dtsJobId: String?

    public var noticeValue: Int32?

    public var period: Int32?

    public var phone: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var state: String?

    public var times: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.delayRuleTime != nil {
            map["DelayRuleTime"] = self.delayRuleTime!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.noticeValue != nil {
            map["NoticeValue"] = self.noticeValue!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.times != nil {
            map["Times"] = self.times!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DelayRuleTime") {
            self.delayRuleTime = dict["DelayRuleTime"] as! Int64
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("NoticeValue") {
            self.noticeValue = dict["NoticeValue"] as! Int32
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("Phone") {
            self.phone = dict["Phone"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Times") {
            self.times = dict["Times"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateJobMonitorRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var dtsJobId: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateJobMonitorRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateJobMonitorRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateJobMonitorRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMigrationJobRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var migrationJobClass: String?

    public var ownerId: String?

    public var region: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.migrationJobClass != nil {
            map["MigrationJobClass"] = self.migrationJobClass!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MigrationJobClass") {
            self.migrationJobClass = dict["MigrationJobClass"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateMigrationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var migrationJobId: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateMigrationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMigrationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMigrationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateReverseDtsJobRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var resourceGroupId: String?

    public var shardPassword: String?

    public var shardUsername: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.shardPassword != nil {
            map["ShardPassword"] = self.shardPassword!
        }
        if self.shardUsername != nil {
            map["ShardUsername"] = self.shardUsername!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ShardPassword") {
            self.shardPassword = dict["ShardPassword"] as! String
        }
        if dict.keys.contains("ShardUsername") {
            self.shardUsername = dict["ShardUsername"] as! String
        }
    }
}

public class CreateReverseDtsJobResponseBody : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateReverseDtsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateReverseDtsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateReverseDtsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSubscriptionInstanceRequest : Tea.TeaModel {
    public class SourceEndpoint : Tea.TeaModel {
        public var instanceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
        }
    }
    public var sourceEndpoint: CreateSubscriptionInstanceRequest.SourceEndpoint?

    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var payType: String?

    public var period: String?

    public var region: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var usedTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceEndpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceEndpoint") {
            var model = CreateSubscriptionInstanceRequest.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("UsedTime") {
            self.usedTime = dict["UsedTime"] as! Int32
        }
    }
}

public class CreateSubscriptionInstanceResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var subscriptionInstanceId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateSubscriptionInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSubscriptionInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSubscriptionInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSynchronizationJobRequest : Tea.TeaModel {
    public class DestinationEndpoint : Tea.TeaModel {
        public var instanceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
        }
    }
    public class SourceEndpoint : Tea.TeaModel {
        public var instanceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
        }
    }
    public var destinationEndpoint: CreateSynchronizationJobRequest.DestinationEndpoint?

    public var sourceEndpoint: CreateSynchronizationJobRequest.SourceEndpoint?

    public var accountId: String?

    public var clientToken: String?

    public var DBInstanceCount: Int32?

    public var destRegion: String?

    public var ownerId: String?

    public var payType: String?

    public var period: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var sourceRegion: String?

    public var synchronizationJobClass: String?

    public var topology: String?

    public var usedTime: Int32?

    public var networkType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.destinationEndpoint?.validate()
        try self.sourceEndpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationEndpoint != nil {
            map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
        }
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBInstanceCount != nil {
            map["DBInstanceCount"] = self.DBInstanceCount!
        }
        if self.destRegion != nil {
            map["DestRegion"] = self.destRegion!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sourceRegion != nil {
            map["SourceRegion"] = self.sourceRegion!
        }
        if self.synchronizationJobClass != nil {
            map["SynchronizationJobClass"] = self.synchronizationJobClass!
        }
        if self.topology != nil {
            map["Topology"] = self.topology!
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.networkType != nil {
            map["networkType"] = self.networkType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationEndpoint") {
            var model = CreateSynchronizationJobRequest.DestinationEndpoint()
            model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
            self.destinationEndpoint = model
        }
        if dict.keys.contains("SourceEndpoint") {
            var model = CreateSynchronizationJobRequest.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DBInstanceCount") {
            self.DBInstanceCount = dict["DBInstanceCount"] as! Int32
        }
        if dict.keys.contains("DestRegion") {
            self.destRegion = dict["DestRegion"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SourceRegion") {
            self.sourceRegion = dict["SourceRegion"] as! String
        }
        if dict.keys.contains("SynchronizationJobClass") {
            self.synchronizationJobClass = dict["SynchronizationJobClass"] as! String
        }
        if dict.keys.contains("Topology") {
            self.topology = dict["Topology"] as! String
        }
        if dict.keys.contains("UsedTime") {
            self.usedTime = dict["UsedTime"] as! Int32
        }
        if dict.keys.contains("networkType") {
            self.networkType = dict["networkType"] as! String
        }
    }
}

public class CreateSynchronizationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class CreateSynchronizationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSynchronizationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSynchronizationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteConsumerChannelRequest : Tea.TeaModel {
    public var consumerGroupId: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consumerGroupId != nil {
            map["ConsumerGroupId"] = self.consumerGroupId!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsumerGroupId") {
            self.consumerGroupId = dict["ConsumerGroupId"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DeleteConsumerChannelResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteConsumerChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConsumerChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteConsumerChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteConsumerGroupRequest : Tea.TeaModel {
    public var accountId: String?

    public var consumerGroupID: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.consumerGroupID != nil {
            map["ConsumerGroupID"] = self.consumerGroupID!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ConsumerGroupID") {
            self.consumerGroupID = dict["ConsumerGroupID"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
    }
}

public class DeleteConsumerGroupResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteConsumerGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConsumerGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteConsumerGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDtsJobRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var jobType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class DeleteDtsJobResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDtsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDtsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDtsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDtsJobsRequest : Tea.TeaModel {
    public var dtsJobIds: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobIds != nil {
            map["DtsJobIds"] = self.dtsJobIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobIds") {
            self.dtsJobIds = dict["DtsJobIds"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class DeleteDtsJobsResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDtsJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDtsJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDtsJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMigrationJobRequest : Tea.TeaModel {
    public var accountId: String?

    public var migrationJobId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DeleteMigrationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteMigrationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMigrationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMigrationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSubscriptionInstanceRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
    }
}

public class DeleteSubscriptionInstanceResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteSubscriptionInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSubscriptionInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSubscriptionInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSynchronizationJobRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class DeleteSynchronizationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteSynchronizationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSynchronizationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSynchronizationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeChannelAccountRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var ownerId: String?

    public var region: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tags: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeChannelAccountResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var password: String?

    public var requestId: String?

    public var success: Bool?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class DescribeChannelAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChannelAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeChannelAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCheckJobsRequest : Tea.TeaModel {
    public var checkJobId: String?

    public var checkType: Int32?

    public var instanceId: String?

    public var jobName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkJobId != nil {
            map["CheckJobId"] = self.checkJobId!
        }
        if self.checkType != nil {
            map["CheckType"] = self.checkType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckJobId") {
            self.checkJobId = dict["CheckJobId"] as! String
        }
        if dict.keys.contains("CheckType") {
            self.checkType = dict["CheckType"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeCheckJobsResponseBody : Tea.TeaModel {
    public class CheckJobs : Tea.TeaModel {
        public var chargeType: String?

        public var checkPoint: Int64?

        public var checkType: Int32?

        public var diffCount: Int64?

        public var diffSum: Int64?

        public var dtsInstanceID: String?

        public var dtsJobId: String?

        public var finishCount: Int64?

        public var groupId: String?

        public var instanceClass: String?

        public var jobName: String?

        public var jobStepId: String?

        public var parentJobType: String?

        public var regionId: String?

        public var status: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.checkPoint != nil {
                map["CheckPoint"] = self.checkPoint!
            }
            if self.checkType != nil {
                map["CheckType"] = self.checkType!
            }
            if self.diffCount != nil {
                map["DiffCount"] = self.diffCount!
            }
            if self.diffSum != nil {
                map["DiffSum"] = self.diffSum!
            }
            if self.dtsInstanceID != nil {
                map["DtsInstanceID"] = self.dtsInstanceID!
            }
            if self.dtsJobId != nil {
                map["DtsJobId"] = self.dtsJobId!
            }
            if self.finishCount != nil {
                map["FinishCount"] = self.finishCount!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.instanceClass != nil {
                map["InstanceClass"] = self.instanceClass!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.jobStepId != nil {
                map["JobStepId"] = self.jobStepId!
            }
            if self.parentJobType != nil {
                map["ParentJobType"] = self.parentJobType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("CheckPoint") {
                self.checkPoint = dict["CheckPoint"] as! Int64
            }
            if dict.keys.contains("CheckType") {
                self.checkType = dict["CheckType"] as! Int32
            }
            if dict.keys.contains("DiffCount") {
                self.diffCount = dict["DiffCount"] as! Int64
            }
            if dict.keys.contains("DiffSum") {
                self.diffSum = dict["DiffSum"] as! Int64
            }
            if dict.keys.contains("DtsInstanceID") {
                self.dtsInstanceID = dict["DtsInstanceID"] as! String
            }
            if dict.keys.contains("DtsJobId") {
                self.dtsJobId = dict["DtsJobId"] as! String
            }
            if dict.keys.contains("FinishCount") {
                self.finishCount = dict["FinishCount"] as! Int64
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("InstanceClass") {
                self.instanceClass = dict["InstanceClass"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("JobStepId") {
                self.jobStepId = dict["JobStepId"] as! String
            }
            if dict.keys.contains("ParentJobType") {
                self.parentJobType = dict["ParentJobType"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var checkJobs: [DescribeCheckJobsResponseBody.CheckJobs]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var pageNumber: Int32?

    public var pageRecordCount: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkJobs != nil {
            var tmp : [Any] = []
            for k in self.checkJobs! {
                tmp.append(k.toMap())
            }
            map["CheckJobs"] = tmp
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckJobs") {
            var tmp : [DescribeCheckJobsResponseBody.CheckJobs] = []
            for v in dict["CheckJobs"] as! [Any] {
                var model = DescribeCheckJobsResponseBody.CheckJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.checkJobs = tmp
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribeCheckJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCheckJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCheckJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterOperateLogsRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var dedicatedClusterId: String?

    public var dtsJobId: String?

    public var endTime: Int64?

    public var ownerID: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerID != nil {
            map["OwnerID"] = self.ownerID!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("OwnerID") {
            self.ownerID = dict["OwnerID"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeClusterOperateLogsResponseBody : Tea.TeaModel {
    public class DataPoints : Tea.TeaModel {
        public var content: String?

        public var id: String?

        public var logDatetime: Int64?

        public var newValue: String?

        public var oldValue: String?

        public var operationName: String?

        public var operationUser: String?

        public var success: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.logDatetime != nil {
                map["LogDatetime"] = self.logDatetime!
            }
            if self.newValue != nil {
                map["NewValue"] = self.newValue!
            }
            if self.oldValue != nil {
                map["OldValue"] = self.oldValue!
            }
            if self.operationName != nil {
                map["OperationName"] = self.operationName!
            }
            if self.operationUser != nil {
                map["OperationUser"] = self.operationUser!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("LogDatetime") {
                self.logDatetime = dict["LogDatetime"] as! Int64
            }
            if dict.keys.contains("NewValue") {
                self.newValue = dict["NewValue"] as! String
            }
            if dict.keys.contains("OldValue") {
                self.oldValue = dict["OldValue"] as! String
            }
            if dict.keys.contains("OperationName") {
                self.operationName = dict["OperationName"] as! String
            }
            if dict.keys.contains("OperationUser") {
                self.operationUser = dict["OperationUser"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Int32
            }
        }
    }
    public var code: String?

    public var dataPoints: [DescribeClusterOperateLogsResponseBody.DataPoints]?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dataPoints != nil {
            var tmp : [Any] = []
            for k in self.dataPoints! {
                tmp.append(k.toMap())
            }
            map["DataPoints"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DataPoints") {
            var tmp : [DescribeClusterOperateLogsResponseBody.DataPoints] = []
            for v in dict["DataPoints"] as! [Any] {
                var model = DescribeClusterOperateLogsResponseBody.DataPoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataPoints = tmp
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribeClusterOperateLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterOperateLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeClusterOperateLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterUsedUtilizationRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var dedicatedClusterId: String?

    public var dtsJobId: String?

    public var env: String?

    public var metricType: String?

    public var ownerID: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.env != nil {
            map["Env"] = self.env!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.ownerID != nil {
            map["OwnerID"] = self.ownerID!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("Env") {
            self.env = dict["Env"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("OwnerID") {
            self.ownerID = dict["OwnerID"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeClusterUsedUtilizationResponseBody : Tea.TeaModel {
    public var code: String?

    public var cpuTotal: Double?

    public var dedicatedClusterId: String?

    public var diskTotal: Double?

    public var diskUsed: Double?

    public var duTotal: Int32?

    public var duUsed: Int32?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var memoryTotal: Double?

    public var memoryUsed: Double?

    public var memoryUsedPercentage: Double?

    public var requestId: String?

    public var success: Bool?

    public var taskRunning: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.cpuTotal != nil {
            map["CpuTotal"] = self.cpuTotal!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.diskTotal != nil {
            map["DiskTotal"] = self.diskTotal!
        }
        if self.diskUsed != nil {
            map["DiskUsed"] = self.diskUsed!
        }
        if self.duTotal != nil {
            map["DuTotal"] = self.duTotal!
        }
        if self.duUsed != nil {
            map["DuUsed"] = self.duUsed!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.memoryTotal != nil {
            map["MemoryTotal"] = self.memoryTotal!
        }
        if self.memoryUsed != nil {
            map["MemoryUsed"] = self.memoryUsed!
        }
        if self.memoryUsedPercentage != nil {
            map["MemoryUsedPercentage"] = self.memoryUsedPercentage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskRunning != nil {
            map["TaskRunning"] = self.taskRunning!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CpuTotal") {
            self.cpuTotal = dict["CpuTotal"] as! Double
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DiskTotal") {
            self.diskTotal = dict["DiskTotal"] as! Double
        }
        if dict.keys.contains("DiskUsed") {
            self.diskUsed = dict["DiskUsed"] as! Double
        }
        if dict.keys.contains("DuTotal") {
            self.duTotal = dict["DuTotal"] as! Int32
        }
        if dict.keys.contains("DuUsed") {
            self.duUsed = dict["DuUsed"] as! Int32
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("MemoryTotal") {
            self.memoryTotal = dict["MemoryTotal"] as! Double
        }
        if dict.keys.contains("MemoryUsed") {
            self.memoryUsed = dict["MemoryUsed"] as! Double
        }
        if dict.keys.contains("MemoryUsedPercentage") {
            self.memoryUsedPercentage = dict["MemoryUsedPercentage"] as! Double
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskRunning") {
            self.taskRunning = dict["TaskRunning"] as! Int32
        }
    }
}

public class DescribeClusterUsedUtilizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterUsedUtilizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeClusterUsedUtilizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConnectionStatusRequest : Tea.TeaModel {
    public var destinationEndpointArchitecture: String?

    public var destinationEndpointDatabaseName: String?

    public var destinationEndpointEngineName: String?

    public var destinationEndpointIP: String?

    public var destinationEndpointInstanceID: String?

    public var destinationEndpointInstanceType: String?

    public var destinationEndpointOracleSID: String?

    public var destinationEndpointPassword: String?

    public var destinationEndpointPort: String?

    public var destinationEndpointRegion: String?

    public var destinationEndpointUserName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var sourceEndpointArchitecture: String?

    public var sourceEndpointDatabaseName: String?

    public var sourceEndpointEngineName: String?

    public var sourceEndpointIP: String?

    public var sourceEndpointInstanceID: String?

    public var sourceEndpointInstanceType: String?

    public var sourceEndpointOracleSID: String?

    public var sourceEndpointPassword: String?

    public var sourceEndpointPort: String?

    public var sourceEndpointRegion: String?

    public var sourceEndpointUserName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationEndpointArchitecture != nil {
            map["DestinationEndpointArchitecture"] = self.destinationEndpointArchitecture!
        }
        if self.destinationEndpointDatabaseName != nil {
            map["DestinationEndpointDatabaseName"] = self.destinationEndpointDatabaseName!
        }
        if self.destinationEndpointEngineName != nil {
            map["DestinationEndpointEngineName"] = self.destinationEndpointEngineName!
        }
        if self.destinationEndpointIP != nil {
            map["DestinationEndpointIP"] = self.destinationEndpointIP!
        }
        if self.destinationEndpointInstanceID != nil {
            map["DestinationEndpointInstanceID"] = self.destinationEndpointInstanceID!
        }
        if self.destinationEndpointInstanceType != nil {
            map["DestinationEndpointInstanceType"] = self.destinationEndpointInstanceType!
        }
        if self.destinationEndpointOracleSID != nil {
            map["DestinationEndpointOracleSID"] = self.destinationEndpointOracleSID!
        }
        if self.destinationEndpointPassword != nil {
            map["DestinationEndpointPassword"] = self.destinationEndpointPassword!
        }
        if self.destinationEndpointPort != nil {
            map["DestinationEndpointPort"] = self.destinationEndpointPort!
        }
        if self.destinationEndpointRegion != nil {
            map["DestinationEndpointRegion"] = self.destinationEndpointRegion!
        }
        if self.destinationEndpointUserName != nil {
            map["DestinationEndpointUserName"] = self.destinationEndpointUserName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sourceEndpointArchitecture != nil {
            map["SourceEndpointArchitecture"] = self.sourceEndpointArchitecture!
        }
        if self.sourceEndpointDatabaseName != nil {
            map["SourceEndpointDatabaseName"] = self.sourceEndpointDatabaseName!
        }
        if self.sourceEndpointEngineName != nil {
            map["SourceEndpointEngineName"] = self.sourceEndpointEngineName!
        }
        if self.sourceEndpointIP != nil {
            map["SourceEndpointIP"] = self.sourceEndpointIP!
        }
        if self.sourceEndpointInstanceID != nil {
            map["SourceEndpointInstanceID"] = self.sourceEndpointInstanceID!
        }
        if self.sourceEndpointInstanceType != nil {
            map["SourceEndpointInstanceType"] = self.sourceEndpointInstanceType!
        }
        if self.sourceEndpointOracleSID != nil {
            map["SourceEndpointOracleSID"] = self.sourceEndpointOracleSID!
        }
        if self.sourceEndpointPassword != nil {
            map["SourceEndpointPassword"] = self.sourceEndpointPassword!
        }
        if self.sourceEndpointPort != nil {
            map["SourceEndpointPort"] = self.sourceEndpointPort!
        }
        if self.sourceEndpointRegion != nil {
            map["SourceEndpointRegion"] = self.sourceEndpointRegion!
        }
        if self.sourceEndpointUserName != nil {
            map["SourceEndpointUserName"] = self.sourceEndpointUserName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationEndpointArchitecture") {
            self.destinationEndpointArchitecture = dict["DestinationEndpointArchitecture"] as! String
        }
        if dict.keys.contains("DestinationEndpointDatabaseName") {
            self.destinationEndpointDatabaseName = dict["DestinationEndpointDatabaseName"] as! String
        }
        if dict.keys.contains("DestinationEndpointEngineName") {
            self.destinationEndpointEngineName = dict["DestinationEndpointEngineName"] as! String
        }
        if dict.keys.contains("DestinationEndpointIP") {
            self.destinationEndpointIP = dict["DestinationEndpointIP"] as! String
        }
        if dict.keys.contains("DestinationEndpointInstanceID") {
            self.destinationEndpointInstanceID = dict["DestinationEndpointInstanceID"] as! String
        }
        if dict.keys.contains("DestinationEndpointInstanceType") {
            self.destinationEndpointInstanceType = dict["DestinationEndpointInstanceType"] as! String
        }
        if dict.keys.contains("DestinationEndpointOracleSID") {
            self.destinationEndpointOracleSID = dict["DestinationEndpointOracleSID"] as! String
        }
        if dict.keys.contains("DestinationEndpointPassword") {
            self.destinationEndpointPassword = dict["DestinationEndpointPassword"] as! String
        }
        if dict.keys.contains("DestinationEndpointPort") {
            self.destinationEndpointPort = dict["DestinationEndpointPort"] as! String
        }
        if dict.keys.contains("DestinationEndpointRegion") {
            self.destinationEndpointRegion = dict["DestinationEndpointRegion"] as! String
        }
        if dict.keys.contains("DestinationEndpointUserName") {
            self.destinationEndpointUserName = dict["DestinationEndpointUserName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SourceEndpointArchitecture") {
            self.sourceEndpointArchitecture = dict["SourceEndpointArchitecture"] as! String
        }
        if dict.keys.contains("SourceEndpointDatabaseName") {
            self.sourceEndpointDatabaseName = dict["SourceEndpointDatabaseName"] as! String
        }
        if dict.keys.contains("SourceEndpointEngineName") {
            self.sourceEndpointEngineName = dict["SourceEndpointEngineName"] as! String
        }
        if dict.keys.contains("SourceEndpointIP") {
            self.sourceEndpointIP = dict["SourceEndpointIP"] as! String
        }
        if dict.keys.contains("SourceEndpointInstanceID") {
            self.sourceEndpointInstanceID = dict["SourceEndpointInstanceID"] as! String
        }
        if dict.keys.contains("SourceEndpointInstanceType") {
            self.sourceEndpointInstanceType = dict["SourceEndpointInstanceType"] as! String
        }
        if dict.keys.contains("SourceEndpointOracleSID") {
            self.sourceEndpointOracleSID = dict["SourceEndpointOracleSID"] as! String
        }
        if dict.keys.contains("SourceEndpointPassword") {
            self.sourceEndpointPassword = dict["SourceEndpointPassword"] as! String
        }
        if dict.keys.contains("SourceEndpointPort") {
            self.sourceEndpointPort = dict["SourceEndpointPort"] as! String
        }
        if dict.keys.contains("SourceEndpointRegion") {
            self.sourceEndpointRegion = dict["SourceEndpointRegion"] as! String
        }
        if dict.keys.contains("SourceEndpointUserName") {
            self.sourceEndpointUserName = dict["SourceEndpointUserName"] as! String
        }
    }
}

public class DescribeConnectionStatusResponseBody : Tea.TeaModel {
    public var destinationConnectionStatus: [String: Any]?

    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var sourceConnectionStatus: [String: Any]?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationConnectionStatus != nil {
            map["DestinationConnectionStatus"] = self.destinationConnectionStatus!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceConnectionStatus != nil {
            map["SourceConnectionStatus"] = self.sourceConnectionStatus!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationConnectionStatus") {
            self.destinationConnectionStatus = dict["DestinationConnectionStatus"] as! [String: Any]
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceConnectionStatus") {
            self.sourceConnectionStatus = dict["SourceConnectionStatus"] as! [String: Any]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeConnectionStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConnectionStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConnectionStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsumerChannelRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentChannelId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentChannelId != nil {
            map["ParentChannelId"] = self.parentChannelId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ParentChannelId") {
            self.parentChannelId = dict["ParentChannelId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeConsumerChannelResponseBody : Tea.TeaModel {
    public class ConsumerChannels : Tea.TeaModel {
        public var consumerGroupId: String?

        public var consumerGroupName: String?

        public var consumerGroupUserName: String?

        public var consumptionCheckpoint: String?

        public var messageDelay: Int64?

        public var unconsumedData: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consumerGroupId != nil {
                map["ConsumerGroupId"] = self.consumerGroupId!
            }
            if self.consumerGroupName != nil {
                map["ConsumerGroupName"] = self.consumerGroupName!
            }
            if self.consumerGroupUserName != nil {
                map["ConsumerGroupUserName"] = self.consumerGroupUserName!
            }
            if self.consumptionCheckpoint != nil {
                map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
            }
            if self.messageDelay != nil {
                map["MessageDelay"] = self.messageDelay!
            }
            if self.unconsumedData != nil {
                map["UnconsumedData"] = self.unconsumedData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsumerGroupId") {
                self.consumerGroupId = dict["ConsumerGroupId"] as! String
            }
            if dict.keys.contains("ConsumerGroupName") {
                self.consumerGroupName = dict["ConsumerGroupName"] as! String
            }
            if dict.keys.contains("ConsumerGroupUserName") {
                self.consumerGroupUserName = dict["ConsumerGroupUserName"] as! String
            }
            if dict.keys.contains("ConsumptionCheckpoint") {
                self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
            }
            if dict.keys.contains("MessageDelay") {
                self.messageDelay = dict["MessageDelay"] as! Int64
            }
            if dict.keys.contains("UnconsumedData") {
                self.unconsumedData = dict["UnconsumedData"] as! Int64
            }
        }
    }
    public var consumerChannels: [DescribeConsumerChannelResponseBody.ConsumerChannels]?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var success: String?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consumerChannels != nil {
            var tmp : [Any] = []
            for k in self.consumerChannels! {
                tmp.append(k.toMap())
            }
            map["ConsumerChannels"] = tmp
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsumerChannels") {
            var tmp : [DescribeConsumerChannelResponseBody.ConsumerChannels] = []
            for v in dict["ConsumerChannels"] as! [Any] {
                var model = DescribeConsumerChannelResponseBody.ConsumerChannels()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.consumerChannels = tmp
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribeConsumerChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsumerChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsumerChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsumerGroupRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
    }
}

public class DescribeConsumerGroupResponseBody : Tea.TeaModel {
    public class ConsumerChannels : Tea.TeaModel {
        public class DescribeConsumerChannel : Tea.TeaModel {
            public var consumerGroupID: String?

            public var consumerGroupName: String?

            public var consumerGroupUserName: String?

            public var consumptionCheckpoint: String?

            public var messageDelay: Int64?

            public var unconsumedData: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consumerGroupID != nil {
                    map["ConsumerGroupID"] = self.consumerGroupID!
                }
                if self.consumerGroupName != nil {
                    map["ConsumerGroupName"] = self.consumerGroupName!
                }
                if self.consumerGroupUserName != nil {
                    map["ConsumerGroupUserName"] = self.consumerGroupUserName!
                }
                if self.consumptionCheckpoint != nil {
                    map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
                }
                if self.messageDelay != nil {
                    map["MessageDelay"] = self.messageDelay!
                }
                if self.unconsumedData != nil {
                    map["UnconsumedData"] = self.unconsumedData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsumerGroupID") {
                    self.consumerGroupID = dict["ConsumerGroupID"] as! String
                }
                if dict.keys.contains("ConsumerGroupName") {
                    self.consumerGroupName = dict["ConsumerGroupName"] as! String
                }
                if dict.keys.contains("ConsumerGroupUserName") {
                    self.consumerGroupUserName = dict["ConsumerGroupUserName"] as! String
                }
                if dict.keys.contains("ConsumptionCheckpoint") {
                    self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
                }
                if dict.keys.contains("MessageDelay") {
                    self.messageDelay = dict["MessageDelay"] as! Int64
                }
                if dict.keys.contains("UnconsumedData") {
                    self.unconsumedData = dict["UnconsumedData"] as! Int64
                }
            }
        }
        public var describeConsumerChannel: [DescribeConsumerGroupResponseBody.ConsumerChannels.DescribeConsumerChannel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.describeConsumerChannel != nil {
                var tmp : [Any] = []
                for k in self.describeConsumerChannel! {
                    tmp.append(k.toMap())
                }
                map["DescribeConsumerChannel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DescribeConsumerChannel") {
                var tmp : [DescribeConsumerGroupResponseBody.ConsumerChannels.DescribeConsumerChannel] = []
                for v in dict["DescribeConsumerChannel"] as! [Any] {
                    var model = DescribeConsumerGroupResponseBody.ConsumerChannels.DescribeConsumerChannel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.describeConsumerChannel = tmp
            }
        }
    }
    public var consumerChannels: DescribeConsumerGroupResponseBody.ConsumerChannels?

    public var errCode: String?

    public var errMessage: String?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var success: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.consumerChannels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consumerChannels != nil {
            map["ConsumerChannels"] = self.consumerChannels?.toMap()
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsumerChannels") {
            var model = DescribeConsumerGroupResponseBody.ConsumerChannels()
            model.fromMap(dict["ConsumerChannels"] as! [String: Any])
            self.consumerChannels = model
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int32
        }
    }
}

public class DescribeConsumerGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsumerGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsumerGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDTSIPRequest : Tea.TeaModel {
    public var destinationEndpointRegion: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var sourceEndpointRegion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationEndpointRegion != nil {
            map["DestinationEndpointRegion"] = self.destinationEndpointRegion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sourceEndpointRegion != nil {
            map["SourceEndpointRegion"] = self.sourceEndpointRegion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationEndpointRegion") {
            self.destinationEndpointRegion = dict["DestinationEndpointRegion"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SourceEndpointRegion") {
            self.sourceEndpointRegion = dict["SourceEndpointRegion"] as! String
        }
    }
}

public class DescribeDTSIPResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeDTSIPResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDTSIPResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDTSIPResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataCheckReportUrlRequest : Tea.TeaModel {
    public var checkType: Int32?

    public var dbName: String?

    public var dtsJobId: String?

    public var resourceGroupId: String?

    public var tbName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkType != nil {
            map["CheckType"] = self.checkType!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tbName != nil {
            map["TbName"] = self.tbName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckType") {
            self.checkType = dict["CheckType"] as! Int32
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TbName") {
            self.tbName = dict["TbName"] as! String
        }
    }
}

public class DescribeDataCheckReportUrlResponseBody : Tea.TeaModel {
    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeDataCheckReportUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataCheckReportUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataCheckReportUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataCheckTableDetailsRequest : Tea.TeaModel {
    public var checkType: Int32?

    public var dtsJobId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public var schemaName: String?

    public var status: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkType != nil {
            map["CheckType"] = self.checkType!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckType") {
            self.checkType = dict["CheckType"] as! Int32
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class DescribeDataCheckTableDetailsResponseBody : Tea.TeaModel {
    public class TableDetails : Tea.TeaModel {
        public var bootTime: String?

        public var diffCount: Int64?

        public var errorCode: Int32?

        public var finishCount: Int64?

        public var id: Int64?

        public var sourceDbName: String?

        public var sourceTbName: String?

        public var status: String?

        public var targetDbName: String?

        public var targetTbName: String?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bootTime != nil {
                map["BootTime"] = self.bootTime!
            }
            if self.diffCount != nil {
                map["DiffCount"] = self.diffCount!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.finishCount != nil {
                map["FinishCount"] = self.finishCount!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.sourceDbName != nil {
                map["SourceDbName"] = self.sourceDbName!
            }
            if self.sourceTbName != nil {
                map["SourceTbName"] = self.sourceTbName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.targetDbName != nil {
                map["TargetDbName"] = self.targetDbName!
            }
            if self.targetTbName != nil {
                map["TargetTbName"] = self.targetTbName!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BootTime") {
                self.bootTime = dict["BootTime"] as! String
            }
            if dict.keys.contains("DiffCount") {
                self.diffCount = dict["DiffCount"] as! Int64
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! Int32
            }
            if dict.keys.contains("FinishCount") {
                self.finishCount = dict["FinishCount"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("SourceDbName") {
                self.sourceDbName = dict["SourceDbName"] as! String
            }
            if dict.keys.contains("SourceTbName") {
                self.sourceTbName = dict["SourceTbName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TargetDbName") {
                self.targetDbName = dict["TargetDbName"] as! String
            }
            if dict.keys.contains("TargetTbName") {
                self.targetTbName = dict["TargetTbName"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var diffTableCount: Int64?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var failedTableCount: Int64?

    public var finishedCount: Int64?

    public var httpStatusCode: Int32?

    public var pageNumber: Int32?

    public var requestId: String?

    public var success: Bool?

    public var tableDetails: [DescribeDataCheckTableDetailsResponseBody.TableDetails]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diffTableCount != nil {
            map["DiffTableCount"] = self.diffTableCount!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.failedTableCount != nil {
            map["FailedTableCount"] = self.failedTableCount!
        }
        if self.finishedCount != nil {
            map["FinishedCount"] = self.finishedCount!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableDetails != nil {
            var tmp : [Any] = []
            for k in self.tableDetails! {
                tmp.append(k.toMap())
            }
            map["TableDetails"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiffTableCount") {
            self.diffTableCount = dict["DiffTableCount"] as! Int64
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("FailedTableCount") {
            self.failedTableCount = dict["FailedTableCount"] as! Int64
        }
        if dict.keys.contains("FinishedCount") {
            self.finishedCount = dict["FinishedCount"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TableDetails") {
            var tmp : [DescribeDataCheckTableDetailsResponseBody.TableDetails] = []
            for v in dict["TableDetails"] as! [Any] {
                var model = DescribeDataCheckTableDetailsResponseBody.TableDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tableDetails = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeDataCheckTableDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataCheckTableDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataCheckTableDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataCheckTableDiffDetailsRequest : Tea.TeaModel {
    public var checkType: Int32?

    public var dbName: String?

    public var dtsJobId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceGroupId: String?

    public var tbName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkType != nil {
            map["CheckType"] = self.checkType!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tbName != nil {
            map["TbName"] = self.tbName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckType") {
            self.checkType = dict["CheckType"] as! Int32
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TbName") {
            self.tbName = dict["TbName"] as! String
        }
    }
}

public class DescribeDataCheckTableDiffDetailsResponseBody : Tea.TeaModel {
    public class DiffDetails : Tea.TeaModel {
        public var diff: String?

        public var gmtCreated: String?

        public var id: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diff != nil {
                map["Diff"] = self.diff!
            }
            if self.gmtCreated != nil {
                map["GmtCreated"] = self.gmtCreated!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Diff") {
                self.diff = dict["Diff"] as! String
            }
            if dict.keys.contains("GmtCreated") {
                self.gmtCreated = dict["GmtCreated"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
        }
    }
    public var dbName: String?

    public var diffCount: Int64?

    public var diffDetails: [DescribeDataCheckTableDiffDetailsResponseBody.DiffDetails]?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var instanceId: String?

    public var requestId: String?

    public var success: Bool?

    public var tbName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.diffCount != nil {
            map["DiffCount"] = self.diffCount!
        }
        if self.diffDetails != nil {
            var tmp : [Any] = []
            for k in self.diffDetails! {
                tmp.append(k.toMap())
            }
            map["DiffDetails"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tbName != nil {
            map["TbName"] = self.tbName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("DiffCount") {
            self.diffCount = dict["DiffCount"] as! Int64
        }
        if dict.keys.contains("DiffDetails") {
            var tmp : [DescribeDataCheckTableDiffDetailsResponseBody.DiffDetails] = []
            for v in dict["DiffDetails"] as! [Any] {
                var model = DescribeDataCheckTableDiffDetailsResponseBody.DiffDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.diffDetails = tmp
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TbName") {
            self.tbName = dict["TbName"] as! String
        }
    }
}

public class DescribeDataCheckTableDiffDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataCheckTableDiffDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataCheckTableDiffDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedClusterRequest : Tea.TeaModel {
    public var dedicatedClusterId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeDedicatedClusterResponseBody : Tea.TeaModel {
    public var cpuUtilization: Int64?

    public var dedicatedClusterId: String?

    public var dedicatedClusterName: String?

    public var diskUtilization: Int64?

    public var dtsInstanceID: String?

    public var du: Int64?

    public var duUtilization: Int64?

    public var errCode: String?

    public var errMessage: String?

    public var gmtCreated: Int64?

    public var gmtFinished: Int64?

    public var httpStatusCode: String?

    public var memUtilization: Int64?

    public var nodeCount: Int64?

    public var oversoldDu: Int64?

    public var regionId: String?

    public var requestId: String?

    public var state: String?

    public var success: String?

    public var totalCpuCore: Int64?

    public var totalDiskGBSize: Int64?

    public var totalMemGBSize: Int64?

    public var usedCpuCore: Int64?

    public var usedDiskGBSize: Int64?

    public var usedDu: Int64?

    public var usedMemGBSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuUtilization != nil {
            map["CpuUtilization"] = self.cpuUtilization!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.dedicatedClusterName != nil {
            map["DedicatedClusterName"] = self.dedicatedClusterName!
        }
        if self.diskUtilization != nil {
            map["DiskUtilization"] = self.diskUtilization!
        }
        if self.dtsInstanceID != nil {
            map["DtsInstanceID"] = self.dtsInstanceID!
        }
        if self.du != nil {
            map["Du"] = self.du!
        }
        if self.duUtilization != nil {
            map["DuUtilization"] = self.duUtilization!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.gmtCreated != nil {
            map["GmtCreated"] = self.gmtCreated!
        }
        if self.gmtFinished != nil {
            map["GmtFinished"] = self.gmtFinished!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.memUtilization != nil {
            map["MemUtilization"] = self.memUtilization!
        }
        if self.nodeCount != nil {
            map["NodeCount"] = self.nodeCount!
        }
        if self.oversoldDu != nil {
            map["OversoldDu"] = self.oversoldDu!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCpuCore != nil {
            map["TotalCpuCore"] = self.totalCpuCore!
        }
        if self.totalDiskGBSize != nil {
            map["TotalDiskGBSize"] = self.totalDiskGBSize!
        }
        if self.totalMemGBSize != nil {
            map["TotalMemGBSize"] = self.totalMemGBSize!
        }
        if self.usedCpuCore != nil {
            map["UsedCpuCore"] = self.usedCpuCore!
        }
        if self.usedDiskGBSize != nil {
            map["UsedDiskGBSize"] = self.usedDiskGBSize!
        }
        if self.usedDu != nil {
            map["UsedDu"] = self.usedDu!
        }
        if self.usedMemGBSize != nil {
            map["UsedMemGBSize"] = self.usedMemGBSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuUtilization") {
            self.cpuUtilization = dict["CpuUtilization"] as! Int64
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DedicatedClusterName") {
            self.dedicatedClusterName = dict["DedicatedClusterName"] as! String
        }
        if dict.keys.contains("DiskUtilization") {
            self.diskUtilization = dict["DiskUtilization"] as! Int64
        }
        if dict.keys.contains("DtsInstanceID") {
            self.dtsInstanceID = dict["DtsInstanceID"] as! String
        }
        if dict.keys.contains("Du") {
            self.du = dict["Du"] as! Int64
        }
        if dict.keys.contains("DuUtilization") {
            self.duUtilization = dict["DuUtilization"] as! Int64
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("GmtCreated") {
            self.gmtCreated = dict["GmtCreated"] as! Int64
        }
        if dict.keys.contains("GmtFinished") {
            self.gmtFinished = dict["GmtFinished"] as! Int64
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("MemUtilization") {
            self.memUtilization = dict["MemUtilization"] as! Int64
        }
        if dict.keys.contains("NodeCount") {
            self.nodeCount = dict["NodeCount"] as! Int64
        }
        if dict.keys.contains("OversoldDu") {
            self.oversoldDu = dict["OversoldDu"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalCpuCore") {
            self.totalCpuCore = dict["TotalCpuCore"] as! Int64
        }
        if dict.keys.contains("TotalDiskGBSize") {
            self.totalDiskGBSize = dict["TotalDiskGBSize"] as! Int64
        }
        if dict.keys.contains("TotalMemGBSize") {
            self.totalMemGBSize = dict["TotalMemGBSize"] as! Int64
        }
        if dict.keys.contains("UsedCpuCore") {
            self.usedCpuCore = dict["UsedCpuCore"] as! Int64
        }
        if dict.keys.contains("UsedDiskGBSize") {
            self.usedDiskGBSize = dict["UsedDiskGBSize"] as! Int64
        }
        if dict.keys.contains("UsedDu") {
            self.usedDu = dict["UsedDu"] as! Int64
        }
        if dict.keys.contains("UsedMemGBSize") {
            self.usedMemGBSize = dict["UsedMemGBSize"] as! Int64
        }
    }
}

public class DescribeDedicatedClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedClusterMonitorRuleRequest : Tea.TeaModel {
    public var dedicatedClusterId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeDedicatedClusterMonitorRuleResponseBody : Tea.TeaModel {
    public var cpuAlarmThreshold: String?

    public var dedicatedClusterId: String?

    public var diskAlarmThreshold: String?

    public var duAlarmThreshold: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var memAlarmThreshold: String?

    public var noticeSwitch: String?

    public var phones: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuAlarmThreshold != nil {
            map["CpuAlarmThreshold"] = self.cpuAlarmThreshold!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.diskAlarmThreshold != nil {
            map["DiskAlarmThreshold"] = self.diskAlarmThreshold!
        }
        if self.duAlarmThreshold != nil {
            map["DuAlarmThreshold"] = self.duAlarmThreshold!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.memAlarmThreshold != nil {
            map["MemAlarmThreshold"] = self.memAlarmThreshold!
        }
        if self.noticeSwitch != nil {
            map["NoticeSwitch"] = self.noticeSwitch!
        }
        if self.phones != nil {
            map["Phones"] = self.phones!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuAlarmThreshold") {
            self.cpuAlarmThreshold = dict["CpuAlarmThreshold"] as! String
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DiskAlarmThreshold") {
            self.diskAlarmThreshold = dict["DiskAlarmThreshold"] as! String
        }
        if dict.keys.contains("DuAlarmThreshold") {
            self.duAlarmThreshold = dict["DuAlarmThreshold"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("MemAlarmThreshold") {
            self.memAlarmThreshold = dict["MemAlarmThreshold"] as! String
        }
        if dict.keys.contains("NoticeSwitch") {
            self.noticeSwitch = dict["NoticeSwitch"] as! String
        }
        if dict.keys.contains("Phones") {
            self.phones = dict["Phones"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeDedicatedClusterMonitorRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedClusterMonitorRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedClusterMonitorRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDtsEtlJobVersionInfoRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeDtsEtlJobVersionInfoResponseBody : Tea.TeaModel {
    public class DtsEtlJobVersionInfos : Tea.TeaModel {
        public var createTime: String?

        public var creator: String?

        public var creatorName: String?

        public var dtsInstanceId: String?

        public var dtsJobId: String?

        public var dtsJobName: String?

        public var modifyTime: String?

        public var safeCheckpoint: String?

        public var status: String?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.dtsInstanceId != nil {
                map["DtsInstanceId"] = self.dtsInstanceId!
            }
            if self.dtsJobId != nil {
                map["DtsJobId"] = self.dtsJobId!
            }
            if self.dtsJobName != nil {
                map["DtsJobName"] = self.dtsJobName!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.safeCheckpoint != nil {
                map["SafeCheckpoint"] = self.safeCheckpoint!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("DtsInstanceId") {
                self.dtsInstanceId = dict["DtsInstanceId"] as! String
            }
            if dict.keys.contains("DtsJobId") {
                self.dtsJobId = dict["DtsJobId"] as! String
            }
            if dict.keys.contains("DtsJobName") {
                self.dtsJobName = dict["DtsJobName"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("SafeCheckpoint") {
                self.safeCheckpoint = dict["SafeCheckpoint"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int32
            }
        }
    }
    public var dtsEtlJobVersionInfos: [DescribeDtsEtlJobVersionInfoResponseBody.DtsEtlJobVersionInfos]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsEtlJobVersionInfos != nil {
            var tmp : [Any] = []
            for k in self.dtsEtlJobVersionInfos! {
                tmp.append(k.toMap())
            }
            map["DtsEtlJobVersionInfos"] = tmp
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsEtlJobVersionInfos") {
            var tmp : [DescribeDtsEtlJobVersionInfoResponseBody.DtsEtlJobVersionInfos] = []
            for v in dict["DtsEtlJobVersionInfos"] as! [Any] {
                var model = DescribeDtsEtlJobVersionInfoResponseBody.DtsEtlJobVersionInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dtsEtlJobVersionInfos = tmp
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int32
        }
    }
}

public class DescribeDtsEtlJobVersionInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDtsEtlJobVersionInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDtsEtlJobVersionInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDtsJobConfigRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var forAcceleration: String?

    public var module: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.forAcceleration != nil {
            map["ForAcceleration"] = self.forAcceleration!
        }
        if self.module != nil {
            map["Module"] = self.module!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("ForAcceleration") {
            self.forAcceleration = dict["ForAcceleration"] as! String
        }
        if dict.keys.contains("Module") {
            self.module = dict["Module"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeDtsJobConfigResponseBody : Tea.TeaModel {
    public class Parameters : Tea.TeaModel {
        public var checkingCode: String?

        public var defaultValue: String?

        public var description_: String?

        public var forceRestart: String?

        public var modifiable: String?

        public var module: String?

        public var name: String?

        public var recommendValue: String?

        public var runningValue: String?

        public var valueType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingCode != nil {
                map["CheckingCode"] = self.checkingCode!
            }
            if self.defaultValue != nil {
                map["DefaultValue"] = self.defaultValue!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.forceRestart != nil {
                map["ForceRestart"] = self.forceRestart!
            }
            if self.modifiable != nil {
                map["Modifiable"] = self.modifiable!
            }
            if self.module != nil {
                map["Module"] = self.module!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.recommendValue != nil {
                map["RecommendValue"] = self.recommendValue!
            }
            if self.runningValue != nil {
                map["RunningValue"] = self.runningValue!
            }
            if self.valueType != nil {
                map["ValueType"] = self.valueType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckingCode") {
                self.checkingCode = dict["CheckingCode"] as! String
            }
            if dict.keys.contains("DefaultValue") {
                self.defaultValue = dict["DefaultValue"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ForceRestart") {
                self.forceRestart = dict["ForceRestart"] as! String
            }
            if dict.keys.contains("Modifiable") {
                self.modifiable = dict["Modifiable"] as! String
            }
            if dict.keys.contains("Module") {
                self.module = dict["Module"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RecommendValue") {
                self.recommendValue = dict["RecommendValue"] as! String
            }
            if dict.keys.contains("RunningValue") {
                self.runningValue = dict["RunningValue"] as! String
            }
            if dict.keys.contains("ValueType") {
                self.valueType = dict["ValueType"] as! Int32
            }
        }
    }
    public var parameters: [DescribeDtsJobConfigResponseBody.Parameters]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parameters != nil {
            var tmp : [Any] = []
            for k in self.parameters! {
                tmp.append(k.toMap())
            }
            map["Parameters"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Parameters") {
            var tmp : [DescribeDtsJobConfigResponseBody.Parameters] = []
            for v in dict["Parameters"] as! [Any] {
                var model = DescribeDtsJobConfigResponseBody.Parameters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.parameters = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDtsJobConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDtsJobConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDtsJobConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDtsJobDetailRequest : Tea.TeaModel {
    public var dtsInstanceID: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var syncSubJobHistory: Bool?

    public var synchronizationDirection: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceID != nil {
            map["DtsInstanceID"] = self.dtsInstanceID!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.syncSubJobHistory != nil {
            map["SyncSubJobHistory"] = self.syncSubJobHistory!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceID") {
            self.dtsInstanceID = dict["DtsInstanceID"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SyncSubJobHistory") {
            self.syncSubJobHistory = dict["SyncSubJobHistory"] as! Bool
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class DescribeDtsJobDetailResponseBody : Tea.TeaModel {
    public class DataDeliveryChannelInfo : Tea.TeaModel {
        public var partitionNum: Int32?

        public var publicDproxyUrl: String?

        public var region: String?

        public var topic: String?

        public var vpcDproxyUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.partitionNum != nil {
                map["PartitionNum"] = self.partitionNum!
            }
            if self.publicDproxyUrl != nil {
                map["PublicDproxyUrl"] = self.publicDproxyUrl!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            if self.vpcDproxyUrl != nil {
                map["VpcDproxyUrl"] = self.vpcDproxyUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PartitionNum") {
                self.partitionNum = dict["PartitionNum"] as! Int32
            }
            if dict.keys.contains("PublicDproxyUrl") {
                self.publicDproxyUrl = dict["PublicDproxyUrl"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Topic") {
                self.topic = dict["Topic"] as! String
            }
            if dict.keys.contains("VpcDproxyUrl") {
                self.vpcDproxyUrl = dict["VpcDproxyUrl"] as! String
            }
        }
    }
    public class DataSynchronizationStatus : Tea.TeaModel {
        public var errorMessage: String?

        public var needUpgrade: Bool?

        public var percent: String?

        public var progress: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.needUpgrade != nil {
                map["NeedUpgrade"] = self.needUpgrade!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("NeedUpgrade") {
                self.needUpgrade = dict["NeedUpgrade"] as! Bool
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DestinationEndpoint : Tea.TeaModel {
        public var canModifyPassword: Bool?

        public var databaseName: String?

        public var engineName: String?

        public var instanceID: String?

        public var instanceType: String?

        public var ip: String?

        public var oracleSID: String?

        public var port: String?

        public var region: String?

        public var sslSolutionEnum: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canModifyPassword != nil {
                map["CanModifyPassword"] = self.canModifyPassword!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.engineName != nil {
                map["EngineName"] = self.engineName!
            }
            if self.instanceID != nil {
                map["InstanceID"] = self.instanceID!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.oracleSID != nil {
                map["OracleSID"] = self.oracleSID!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.sslSolutionEnum != nil {
                map["SslSolutionEnum"] = self.sslSolutionEnum!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanModifyPassword") {
                self.canModifyPassword = dict["CanModifyPassword"] as! Bool
            }
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("EngineName") {
                self.engineName = dict["EngineName"] as! String
            }
            if dict.keys.contains("InstanceID") {
                self.instanceID = dict["InstanceID"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("OracleSID") {
                self.oracleSID = dict["OracleSID"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("SslSolutionEnum") {
                self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class MigrationMode : Tea.TeaModel {
        public var dataExtractTransformLoad: Bool?

        public var dataInitialization: Bool?

        public var dataSynchronization: Bool?

        public var structureInitialization: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataExtractTransformLoad != nil {
                map["DataExtractTransformLoad"] = self.dataExtractTransformLoad!
            }
            if self.dataInitialization != nil {
                map["DataInitialization"] = self.dataInitialization!
            }
            if self.dataSynchronization != nil {
                map["DataSynchronization"] = self.dataSynchronization!
            }
            if self.structureInitialization != nil {
                map["StructureInitialization"] = self.structureInitialization!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataExtractTransformLoad") {
                self.dataExtractTransformLoad = dict["DataExtractTransformLoad"] as! Bool
            }
            if dict.keys.contains("DataInitialization") {
                self.dataInitialization = dict["DataInitialization"] as! Bool
            }
            if dict.keys.contains("DataSynchronization") {
                self.dataSynchronization = dict["DataSynchronization"] as! Bool
            }
            if dict.keys.contains("StructureInitialization") {
                self.structureInitialization = dict["StructureInitialization"] as! Bool
            }
        }
    }
    public class RetryState : Tea.TeaModel {
        public var errMessage: String?

        public var jobId: String?

        public var maxRetryTime: Int32?

        public var module: String?

        public var retryCount: Int32?

        public var retryTarget: String?

        public var retryTime: Int32?

        public var retrying: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errMessage != nil {
                map["ErrMessage"] = self.errMessage!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.maxRetryTime != nil {
                map["MaxRetryTime"] = self.maxRetryTime!
            }
            if self.module != nil {
                map["Module"] = self.module!
            }
            if self.retryCount != nil {
                map["RetryCount"] = self.retryCount!
            }
            if self.retryTarget != nil {
                map["RetryTarget"] = self.retryTarget!
            }
            if self.retryTime != nil {
                map["RetryTime"] = self.retryTime!
            }
            if self.retrying != nil {
                map["Retrying"] = self.retrying!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrMessage") {
                self.errMessage = dict["ErrMessage"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MaxRetryTime") {
                self.maxRetryTime = dict["MaxRetryTime"] as! Int32
            }
            if dict.keys.contains("Module") {
                self.module = dict["Module"] as! String
            }
            if dict.keys.contains("RetryCount") {
                self.retryCount = dict["RetryCount"] as! Int32
            }
            if dict.keys.contains("RetryTarget") {
                self.retryTarget = dict["RetryTarget"] as! String
            }
            if dict.keys.contains("RetryTime") {
                self.retryTime = dict["RetryTime"] as! Int32
            }
            if dict.keys.contains("Retrying") {
                self.retrying = dict["Retrying"] as! Bool
            }
        }
    }
    public class SourceEndpoint : Tea.TeaModel {
        public var aliyunUid: String?

        public var canModifyPassword: Bool?

        public var databaseName: String?

        public var engineName: String?

        public var instanceID: String?

        public var instanceType: String?

        public var ip: String?

        public var oracleSID: String?

        public var port: String?

        public var region: String?

        public var roleName: String?

        public var sslSolutionEnum: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunUid != nil {
                map["AliyunUid"] = self.aliyunUid!
            }
            if self.canModifyPassword != nil {
                map["CanModifyPassword"] = self.canModifyPassword!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.engineName != nil {
                map["EngineName"] = self.engineName!
            }
            if self.instanceID != nil {
                map["InstanceID"] = self.instanceID!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.oracleSID != nil {
                map["OracleSID"] = self.oracleSID!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.roleName != nil {
                map["RoleName"] = self.roleName!
            }
            if self.sslSolutionEnum != nil {
                map["SslSolutionEnum"] = self.sslSolutionEnum!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliyunUid") {
                self.aliyunUid = dict["AliyunUid"] as! String
            }
            if dict.keys.contains("CanModifyPassword") {
                self.canModifyPassword = dict["CanModifyPassword"] as! Bool
            }
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("EngineName") {
                self.engineName = dict["EngineName"] as! String
            }
            if dict.keys.contains("InstanceID") {
                self.instanceID = dict["InstanceID"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("OracleSID") {
                self.oracleSID = dict["OracleSID"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("RoleName") {
                self.roleName = dict["RoleName"] as! String
            }
            if dict.keys.contains("SslSolutionEnum") {
                self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class SubDistributedJob : Tea.TeaModel {
        public class DataEtlStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataSynchronizationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DestinationEndpoint : Tea.TeaModel {
            public var aliyunUid: String?

            public var databaseName: String?

            public var engineName: String?

            public var instanceID: String?

            public var instanceType: String?

            public var ip: String?

            public var oracleSID: String?

            public var port: String?

            public var region: String?

            public var roleName: String?

            public var sslSolutionEnum: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.instanceID != nil {
                    map["InstanceID"] = self.instanceID!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.oracleSID != nil {
                    map["OracleSID"] = self.oracleSID!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.sslSolutionEnum != nil {
                    map["SslSolutionEnum"] = self.sslSolutionEnum!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunUid") {
                    self.aliyunUid = dict["AliyunUid"] as! String
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("InstanceID") {
                    self.instanceID = dict["InstanceID"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("OracleSID") {
                    self.oracleSID = dict["OracleSID"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("RoleName") {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("SslSolutionEnum") {
                    self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class MigrationMode : Tea.TeaModel {
            public var dataExtractTransformLoad: Bool?

            public var dataInitialization: Bool?

            public var dataSynchronization: Bool?

            public var structureInitialization: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataExtractTransformLoad != nil {
                    map["DataExtractTransformLoad"] = self.dataExtractTransformLoad!
                }
                if self.dataInitialization != nil {
                    map["DataInitialization"] = self.dataInitialization!
                }
                if self.dataSynchronization != nil {
                    map["DataSynchronization"] = self.dataSynchronization!
                }
                if self.structureInitialization != nil {
                    map["StructureInitialization"] = self.structureInitialization!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataExtractTransformLoad") {
                    self.dataExtractTransformLoad = dict["DataExtractTransformLoad"] as! Bool
                }
                if dict.keys.contains("DataInitialization") {
                    self.dataInitialization = dict["DataInitialization"] as! Bool
                }
                if dict.keys.contains("DataSynchronization") {
                    self.dataSynchronization = dict["DataSynchronization"] as! Bool
                }
                if dict.keys.contains("StructureInitialization") {
                    self.structureInitialization = dict["StructureInitialization"] as! Bool
                }
            }
        }
        public class Performance : Tea.TeaModel {
            public var flow: String?

            public var rps: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flow != nil {
                    map["Flow"] = self.flow!
                }
                if self.rps != nil {
                    map["Rps"] = self.rps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Flow") {
                    self.flow = dict["Flow"] as! String
                }
                if dict.keys.contains("Rps") {
                    self.rps = dict["Rps"] as! String
                }
            }
        }
        public class PrecheckStatus : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var checkItem: String?

                public var checkItemDescription: String?

                public var checkResult: String?

                public var failedReason: String?

                public var repairMethod: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItem != nil {
                        map["CheckItem"] = self.checkItem!
                    }
                    if self.checkItemDescription != nil {
                        map["CheckItemDescription"] = self.checkItemDescription!
                    }
                    if self.checkResult != nil {
                        map["CheckResult"] = self.checkResult!
                    }
                    if self.failedReason != nil {
                        map["FailedReason"] = self.failedReason!
                    }
                    if self.repairMethod != nil {
                        map["RepairMethod"] = self.repairMethod!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckItem") {
                        self.checkItem = dict["CheckItem"] as! String
                    }
                    if dict.keys.contains("CheckItemDescription") {
                        self.checkItemDescription = dict["CheckItemDescription"] as! String
                    }
                    if dict.keys.contains("CheckResult") {
                        self.checkResult = dict["CheckResult"] as! String
                    }
                    if dict.keys.contains("FailedReason") {
                        self.failedReason = dict["FailedReason"] as! String
                    }
                    if dict.keys.contains("RepairMethod") {
                        self.repairMethod = dict["RepairMethod"] as! String
                    }
                }
            }
            public var detail: [DescribeDtsJobDetailResponseBody.SubDistributedJob.PrecheckStatus.Detail]?

            public var errorMessage: String?

            public var percent: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    var tmp : [Any] = []
                    for k in self.detail! {
                        tmp.append(k.toMap())
                    }
                    map["Detail"] = tmp
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Detail") {
                    var tmp : [DescribeDtsJobDetailResponseBody.SubDistributedJob.PrecheckStatus.Detail] = []
                    for v in dict["Detail"] as! [Any] {
                        var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.PrecheckStatus.Detail()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.detail = tmp
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RetryState : Tea.TeaModel {
            public var errMsg: String?

            public var jobId: String?

            public var maxRetryTime: Int32?

            public var module: String?

            public var retryCount: Int32?

            public var retryTarget: String?

            public var retryTime: Int32?

            public var retrying: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errMsg != nil {
                    map["ErrMsg"] = self.errMsg!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.maxRetryTime != nil {
                    map["MaxRetryTime"] = self.maxRetryTime!
                }
                if self.module != nil {
                    map["Module"] = self.module!
                }
                if self.retryCount != nil {
                    map["RetryCount"] = self.retryCount!
                }
                if self.retryTarget != nil {
                    map["RetryTarget"] = self.retryTarget!
                }
                if self.retryTime != nil {
                    map["RetryTime"] = self.retryTime!
                }
                if self.retrying != nil {
                    map["Retrying"] = self.retrying!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrMsg") {
                    self.errMsg = dict["ErrMsg"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MaxRetryTime") {
                    self.maxRetryTime = dict["MaxRetryTime"] as! Int32
                }
                if dict.keys.contains("Module") {
                    self.module = dict["Module"] as! String
                }
                if dict.keys.contains("RetryCount") {
                    self.retryCount = dict["RetryCount"] as! Int32
                }
                if dict.keys.contains("RetryTarget") {
                    self.retryTarget = dict["RetryTarget"] as! String
                }
                if dict.keys.contains("RetryTime") {
                    self.retryTime = dict["RetryTime"] as! Int32
                }
                if dict.keys.contains("Retrying") {
                    self.retrying = dict["Retrying"] as! Bool
                }
            }
        }
        public class ReverseJob : Tea.TeaModel {
            public class DataEtlStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DataInitializationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DataSynchronizationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DestinationEndpoint : Tea.TeaModel {
                public var aliyunUid: String?

                public var databaseName: String?

                public var engineName: String?

                public var instanceID: String?

                public var instanceType: String?

                public var ip: String?

                public var oracleSID: String?

                public var port: String?

                public var region: String?

                public var roleName: String?

                public var sslSolutionEnum: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliyunUid != nil {
                        map["AliyunUid"] = self.aliyunUid!
                    }
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    if self.sslSolutionEnum != nil {
                        map["SslSolutionEnum"] = self.sslSolutionEnum!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AliyunUid") {
                        self.aliyunUid = dict["AliyunUid"] as! String
                    }
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("RoleName") {
                        self.roleName = dict["RoleName"] as! String
                    }
                    if dict.keys.contains("SslSolutionEnum") {
                        self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class MigrationMode : Tea.TeaModel {
                public var dataExtractTransformLoad: Bool?

                public var dataInitialization: Bool?

                public var dataSynchronization: Bool?

                public var structureInitialization: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataExtractTransformLoad != nil {
                        map["DataExtractTransformLoad"] = self.dataExtractTransformLoad!
                    }
                    if self.dataInitialization != nil {
                        map["DataInitialization"] = self.dataInitialization!
                    }
                    if self.dataSynchronization != nil {
                        map["DataSynchronization"] = self.dataSynchronization!
                    }
                    if self.structureInitialization != nil {
                        map["StructureInitialization"] = self.structureInitialization!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataExtractTransformLoad") {
                        self.dataExtractTransformLoad = dict["DataExtractTransformLoad"] as! Bool
                    }
                    if dict.keys.contains("DataInitialization") {
                        self.dataInitialization = dict["DataInitialization"] as! Bool
                    }
                    if dict.keys.contains("DataSynchronization") {
                        self.dataSynchronization = dict["DataSynchronization"] as! Bool
                    }
                    if dict.keys.contains("StructureInitialization") {
                        self.structureInitialization = dict["StructureInitialization"] as! Bool
                    }
                }
            }
            public class Performance : Tea.TeaModel {
                public var flow: String?

                public var rps: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.flow != nil {
                        map["Flow"] = self.flow!
                    }
                    if self.rps != nil {
                        map["Rps"] = self.rps!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Flow") {
                        self.flow = dict["Flow"] as! String
                    }
                    if dict.keys.contains("Rps") {
                        self.rps = dict["Rps"] as! String
                    }
                }
            }
            public class PrecheckStatus : Tea.TeaModel {
                public class Detail : Tea.TeaModel {
                    public var checkItem: String?

                    public var checkItemDescription: String?

                    public var checkResult: String?

                    public var failedReason: String?

                    public var repairMethod: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.checkItem != nil {
                            map["CheckItem"] = self.checkItem!
                        }
                        if self.checkItemDescription != nil {
                            map["CheckItemDescription"] = self.checkItemDescription!
                        }
                        if self.checkResult != nil {
                            map["CheckResult"] = self.checkResult!
                        }
                        if self.failedReason != nil {
                            map["FailedReason"] = self.failedReason!
                        }
                        if self.repairMethod != nil {
                            map["RepairMethod"] = self.repairMethod!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CheckItem") {
                            self.checkItem = dict["CheckItem"] as! String
                        }
                        if dict.keys.contains("CheckItemDescription") {
                            self.checkItemDescription = dict["CheckItemDescription"] as! String
                        }
                        if dict.keys.contains("CheckResult") {
                            self.checkResult = dict["CheckResult"] as! String
                        }
                        if dict.keys.contains("FailedReason") {
                            self.failedReason = dict["FailedReason"] as! String
                        }
                        if dict.keys.contains("RepairMethod") {
                            self.repairMethod = dict["RepairMethod"] as! String
                        }
                    }
                }
                public var detail: [DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.PrecheckStatus.Detail]?

                public var errorMessage: String?

                public var percent: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detail != nil {
                        var tmp : [Any] = []
                        for k in self.detail! {
                            tmp.append(k.toMap())
                        }
                        map["Detail"] = tmp
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Detail") {
                        var tmp : [DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.PrecheckStatus.Detail] = []
                        for v in dict["Detail"] as! [Any] {
                            var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.PrecheckStatus.Detail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.detail = tmp
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class RetryState : Tea.TeaModel {
                public var errMsg: String?

                public var jobId: String?

                public var maxRetryTime: Int32?

                public var module: String?

                public var retryCount: Int32?

                public var retryTarget: String?

                public var retryTime: Int32?

                public var retrying: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMsg != nil {
                        map["ErrMsg"] = self.errMsg!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.maxRetryTime != nil {
                        map["MaxRetryTime"] = self.maxRetryTime!
                    }
                    if self.module != nil {
                        map["Module"] = self.module!
                    }
                    if self.retryCount != nil {
                        map["RetryCount"] = self.retryCount!
                    }
                    if self.retryTarget != nil {
                        map["RetryTarget"] = self.retryTarget!
                    }
                    if self.retryTime != nil {
                        map["RetryTime"] = self.retryTime!
                    }
                    if self.retrying != nil {
                        map["Retrying"] = self.retrying!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMsg") {
                        self.errMsg = dict["ErrMsg"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("MaxRetryTime") {
                        self.maxRetryTime = dict["MaxRetryTime"] as! Int32
                    }
                    if dict.keys.contains("Module") {
                        self.module = dict["Module"] as! String
                    }
                    if dict.keys.contains("RetryCount") {
                        self.retryCount = dict["RetryCount"] as! Int32
                    }
                    if dict.keys.contains("RetryTarget") {
                        self.retryTarget = dict["RetryTarget"] as! String
                    }
                    if dict.keys.contains("RetryTime") {
                        self.retryTime = dict["RetryTime"] as! Int32
                    }
                    if dict.keys.contains("Retrying") {
                        self.retrying = dict["Retrying"] as! Bool
                    }
                }
            }
            public class SourceEndpoint : Tea.TeaModel {
                public var aliyunUid: String?

                public var databaseName: String?

                public var engineName: String?

                public var instanceID: String?

                public var instanceType: String?

                public var ip: String?

                public var oracleSID: String?

                public var port: String?

                public var region: String?

                public var roleName: String?

                public var sslSolutionEnum: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliyunUid != nil {
                        map["AliyunUid"] = self.aliyunUid!
                    }
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    if self.sslSolutionEnum != nil {
                        map["SslSolutionEnum"] = self.sslSolutionEnum!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AliyunUid") {
                        self.aliyunUid = dict["AliyunUid"] as! String
                    }
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("RoleName") {
                        self.roleName = dict["RoleName"] as! String
                    }
                    if dict.keys.contains("SslSolutionEnum") {
                        self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class StructureInitializationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class SubscriptionDataType : Tea.TeaModel {
                public var ddl: Bool?

                public var dml: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ddl != nil {
                        map["Ddl"] = self.ddl!
                    }
                    if self.dml != nil {
                        map["Dml"] = self.dml!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ddl") {
                        self.ddl = dict["Ddl"] as! Bool
                    }
                    if dict.keys.contains("Dml") {
                        self.dml = dict["Dml"] as! Bool
                    }
                }
            }
            public class SubscriptionHost : Tea.TeaModel {
                public var privateHost: String?

                public var publicHost: String?

                public var vpcHost: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateHost != nil {
                        map["PrivateHost"] = self.privateHost!
                    }
                    if self.publicHost != nil {
                        map["PublicHost"] = self.publicHost!
                    }
                    if self.vpcHost != nil {
                        map["VpcHost"] = self.vpcHost!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateHost") {
                        self.privateHost = dict["PrivateHost"] as! String
                    }
                    if dict.keys.contains("PublicHost") {
                        self.publicHost = dict["PublicHost"] as! String
                    }
                    if dict.keys.contains("VpcHost") {
                        self.vpcHost = dict["VpcHost"] as! String
                    }
                }
            }
            public class TagList : Tea.TeaModel {
                public var aliUid: Int64?

                public var creator: Int64?

                public var gmtCreate: String?

                public var gmtModified: String?

                public var id: Int64?

                public var regionId: String?

                public var resourceId: String?

                public var resourceType: String?

                public var scope: String?

                public var srcRegion: String?

                public var tagCategory: String?

                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliUid != nil {
                        map["AliUid"] = self.aliUid!
                    }
                    if self.creator != nil {
                        map["Creator"] = self.creator!
                    }
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.gmtModified != nil {
                        map["GmtModified"] = self.gmtModified!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.resourceId != nil {
                        map["ResourceId"] = self.resourceId!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.scope != nil {
                        map["Scope"] = self.scope!
                    }
                    if self.srcRegion != nil {
                        map["SrcRegion"] = self.srcRegion!
                    }
                    if self.tagCategory != nil {
                        map["TagCategory"] = self.tagCategory!
                    }
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AliUid") {
                        self.aliUid = dict["AliUid"] as! Int64
                    }
                    if dict.keys.contains("Creator") {
                        self.creator = dict["Creator"] as! Int64
                    }
                    if dict.keys.contains("GmtCreate") {
                        self.gmtCreate = dict["GmtCreate"] as! String
                    }
                    if dict.keys.contains("GmtModified") {
                        self.gmtModified = dict["GmtModified"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("ResourceId") {
                        self.resourceId = dict["ResourceId"] as! String
                    }
                    if dict.keys.contains("ResourceType") {
                        self.resourceType = dict["ResourceType"] as! String
                    }
                    if dict.keys.contains("Scope") {
                        self.scope = dict["Scope"] as! String
                    }
                    if dict.keys.contains("SrcRegion") {
                        self.srcRegion = dict["SrcRegion"] as! String
                    }
                    if dict.keys.contains("TagCategory") {
                        self.tagCategory = dict["TagCategory"] as! String
                    }
                    if dict.keys.contains("TagKey") {
                        self.tagKey = dict["TagKey"] as! String
                    }
                    if dict.keys.contains("TagValue") {
                        self.tagValue = dict["TagValue"] as! String
                    }
                }
            }
            public var appName: String?

            public var beginTimestamp: String?

            public var checkpoint: String?

            public var consumptionCheckpoint: String?

            public var consumptionClient: String?

            public var createTime: String?

            public var dataEtlStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.DataEtlStatus?

            public var dataInitializationStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.DataInitializationStatus?

            public var dataSynchronizationStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.DataSynchronizationStatus?

            public var databaseCount: Int32?

            public var dbObject: String?

            public var delay: Int64?

            public var destNetType: String?

            public var destinationEndpoint: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.DestinationEndpoint?

            public var dtsInstanceID: String?

            public var dtsJobClass: String?

            public var dtsJobDirection: String?

            public var dtsJobId: String?

            public var dtsJobName: String?

            public var endTimestamp: String?

            public var errorMessage: String?

            public var etlCalculator: String?

            public var expireTime: String?

            public var finishTime: String?

            public var groupId: String?

            public var isDemoJob: Bool?

            public var jobType: String?

            public var maxDu: Double?

            public var migrationMode: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.MigrationMode?

            public var minDu: Double?

            public var originType: String?

            public var payType: String?

            public var performance: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.Performance?

            public var precheckStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.PrecheckStatus?

            public var reserved: String?

            public var retryState: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.RetryState?

            public var reverseJob: Any?

            public var sourceEndpoint: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.SourceEndpoint?

            public var status: String?

            public var structureInitializationStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.StructureInitializationStatus?

            public var subscribeTopic: String?

            public var subscriptionDataType: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.SubscriptionDataType?

            public var subscriptionHost: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.SubscriptionHost?

            public var synchronizationDirection: String?

            public var tagList: [DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.TagList]?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataEtlStatus?.validate()
                try self.dataInitializationStatus?.validate()
                try self.dataSynchronizationStatus?.validate()
                try self.destinationEndpoint?.validate()
                try self.migrationMode?.validate()
                try self.performance?.validate()
                try self.precheckStatus?.validate()
                try self.retryState?.validate()
                try self.sourceEndpoint?.validate()
                try self.structureInitializationStatus?.validate()
                try self.subscriptionDataType?.validate()
                try self.subscriptionHost?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.beginTimestamp != nil {
                    map["BeginTimestamp"] = self.beginTimestamp!
                }
                if self.checkpoint != nil {
                    map["Checkpoint"] = self.checkpoint!
                }
                if self.consumptionCheckpoint != nil {
                    map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
                }
                if self.consumptionClient != nil {
                    map["ConsumptionClient"] = self.consumptionClient!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataEtlStatus != nil {
                    map["DataEtlStatus"] = self.dataEtlStatus?.toMap()
                }
                if self.dataInitializationStatus != nil {
                    map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
                }
                if self.dataSynchronizationStatus != nil {
                    map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
                }
                if self.databaseCount != nil {
                    map["DatabaseCount"] = self.databaseCount!
                }
                if self.dbObject != nil {
                    map["DbObject"] = self.dbObject!
                }
                if self.delay != nil {
                    map["Delay"] = self.delay!
                }
                if self.destNetType != nil {
                    map["DestNetType"] = self.destNetType!
                }
                if self.destinationEndpoint != nil {
                    map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
                }
                if self.dtsInstanceID != nil {
                    map["DtsInstanceID"] = self.dtsInstanceID!
                }
                if self.dtsJobClass != nil {
                    map["DtsJobClass"] = self.dtsJobClass!
                }
                if self.dtsJobDirection != nil {
                    map["DtsJobDirection"] = self.dtsJobDirection!
                }
                if self.dtsJobId != nil {
                    map["DtsJobId"] = self.dtsJobId!
                }
                if self.dtsJobName != nil {
                    map["DtsJobName"] = self.dtsJobName!
                }
                if self.endTimestamp != nil {
                    map["EndTimestamp"] = self.endTimestamp!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.etlCalculator != nil {
                    map["EtlCalculator"] = self.etlCalculator!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.isDemoJob != nil {
                    map["IsDemoJob"] = self.isDemoJob!
                }
                if self.jobType != nil {
                    map["JobType"] = self.jobType!
                }
                if self.maxDu != nil {
                    map["MaxDu"] = self.maxDu!
                }
                if self.migrationMode != nil {
                    map["MigrationMode"] = self.migrationMode?.toMap()
                }
                if self.minDu != nil {
                    map["MinDu"] = self.minDu!
                }
                if self.originType != nil {
                    map["OriginType"] = self.originType!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.performance != nil {
                    map["Performance"] = self.performance?.toMap()
                }
                if self.precheckStatus != nil {
                    map["PrecheckStatus"] = self.precheckStatus?.toMap()
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.retryState != nil {
                    map["RetryState"] = self.retryState?.toMap()
                }
                if self.reverseJob != nil {
                    map["ReverseJob"] = self.reverseJob!
                }
                if self.sourceEndpoint != nil {
                    map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.structureInitializationStatus != nil {
                    map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
                }
                if self.subscribeTopic != nil {
                    map["SubscribeTopic"] = self.subscribeTopic!
                }
                if self.subscriptionDataType != nil {
                    map["SubscriptionDataType"] = self.subscriptionDataType?.toMap()
                }
                if self.subscriptionHost != nil {
                    map["SubscriptionHost"] = self.subscriptionHost?.toMap()
                }
                if self.synchronizationDirection != nil {
                    map["SynchronizationDirection"] = self.synchronizationDirection!
                }
                if self.tagList != nil {
                    var tmp : [Any] = []
                    for k in self.tagList! {
                        tmp.append(k.toMap())
                    }
                    map["TagList"] = tmp
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("BeginTimestamp") {
                    self.beginTimestamp = dict["BeginTimestamp"] as! String
                }
                if dict.keys.contains("Checkpoint") {
                    self.checkpoint = dict["Checkpoint"] as! String
                }
                if dict.keys.contains("ConsumptionCheckpoint") {
                    self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
                }
                if dict.keys.contains("ConsumptionClient") {
                    self.consumptionClient = dict["ConsumptionClient"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DataEtlStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.DataEtlStatus()
                    model.fromMap(dict["DataEtlStatus"] as! [String: Any])
                    self.dataEtlStatus = model
                }
                if dict.keys.contains("DataInitializationStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.DataInitializationStatus()
                    model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
                    self.dataInitializationStatus = model
                }
                if dict.keys.contains("DataSynchronizationStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.DataSynchronizationStatus()
                    model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
                    self.dataSynchronizationStatus = model
                }
                if dict.keys.contains("DatabaseCount") {
                    self.databaseCount = dict["DatabaseCount"] as! Int32
                }
                if dict.keys.contains("DbObject") {
                    self.dbObject = dict["DbObject"] as! String
                }
                if dict.keys.contains("Delay") {
                    self.delay = dict["Delay"] as! Int64
                }
                if dict.keys.contains("DestNetType") {
                    self.destNetType = dict["DestNetType"] as! String
                }
                if dict.keys.contains("DestinationEndpoint") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.DestinationEndpoint()
                    model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                    self.destinationEndpoint = model
                }
                if dict.keys.contains("DtsInstanceID") {
                    self.dtsInstanceID = dict["DtsInstanceID"] as! String
                }
                if dict.keys.contains("DtsJobClass") {
                    self.dtsJobClass = dict["DtsJobClass"] as! String
                }
                if dict.keys.contains("DtsJobDirection") {
                    self.dtsJobDirection = dict["DtsJobDirection"] as! String
                }
                if dict.keys.contains("DtsJobId") {
                    self.dtsJobId = dict["DtsJobId"] as! String
                }
                if dict.keys.contains("DtsJobName") {
                    self.dtsJobName = dict["DtsJobName"] as! String
                }
                if dict.keys.contains("EndTimestamp") {
                    self.endTimestamp = dict["EndTimestamp"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("EtlCalculator") {
                    self.etlCalculator = dict["EtlCalculator"] as! String
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("IsDemoJob") {
                    self.isDemoJob = dict["IsDemoJob"] as! Bool
                }
                if dict.keys.contains("JobType") {
                    self.jobType = dict["JobType"] as! String
                }
                if dict.keys.contains("MaxDu") {
                    self.maxDu = dict["MaxDu"] as! Double
                }
                if dict.keys.contains("MigrationMode") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.MigrationMode()
                    model.fromMap(dict["MigrationMode"] as! [String: Any])
                    self.migrationMode = model
                }
                if dict.keys.contains("MinDu") {
                    self.minDu = dict["MinDu"] as! Double
                }
                if dict.keys.contains("OriginType") {
                    self.originType = dict["OriginType"] as! String
                }
                if dict.keys.contains("PayType") {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("Performance") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.Performance()
                    model.fromMap(dict["Performance"] as! [String: Any])
                    self.performance = model
                }
                if dict.keys.contains("PrecheckStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.PrecheckStatus()
                    model.fromMap(dict["PrecheckStatus"] as! [String: Any])
                    self.precheckStatus = model
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! String
                }
                if dict.keys.contains("RetryState") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.RetryState()
                    model.fromMap(dict["RetryState"] as! [String: Any])
                    self.retryState = model
                }
                if dict.keys.contains("ReverseJob") {
                    self.reverseJob = dict["ReverseJob"] as! Any
                }
                if dict.keys.contains("SourceEndpoint") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.SourceEndpoint()
                    model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                    self.sourceEndpoint = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StructureInitializationStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.StructureInitializationStatus()
                    model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
                    self.structureInitializationStatus = model
                }
                if dict.keys.contains("SubscribeTopic") {
                    self.subscribeTopic = dict["SubscribeTopic"] as! String
                }
                if dict.keys.contains("SubscriptionDataType") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.SubscriptionDataType()
                    model.fromMap(dict["SubscriptionDataType"] as! [String: Any])
                    self.subscriptionDataType = model
                }
                if dict.keys.contains("SubscriptionHost") {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.SubscriptionHost()
                    model.fromMap(dict["SubscriptionHost"] as! [String: Any])
                    self.subscriptionHost = model
                }
                if dict.keys.contains("SynchronizationDirection") {
                    self.synchronizationDirection = dict["SynchronizationDirection"] as! String
                }
                if dict.keys.contains("TagList") {
                    var tmp : [DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.TagList] = []
                    for v in dict["TagList"] as! [Any] {
                        var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob.TagList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tagList = tmp
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! String
                }
            }
        }
        public class SourceEndpoint : Tea.TeaModel {
            public var aliyunUid: String?

            public var databaseName: String?

            public var engineName: String?

            public var instanceID: String?

            public var instanceType: String?

            public var ip: String?

            public var oracleSID: String?

            public var port: String?

            public var region: String?

            public var roleName: String?

            public var sslSolutionEnum: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.instanceID != nil {
                    map["InstanceID"] = self.instanceID!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.oracleSID != nil {
                    map["OracleSID"] = self.oracleSID!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.sslSolutionEnum != nil {
                    map["SslSolutionEnum"] = self.sslSolutionEnum!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunUid") {
                    self.aliyunUid = dict["AliyunUid"] as! String
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("InstanceID") {
                    self.instanceID = dict["InstanceID"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("OracleSID") {
                    self.oracleSID = dict["OracleSID"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("RoleName") {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("SslSolutionEnum") {
                    self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class StructureInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class SubscriptionDataType : Tea.TeaModel {
            public var ddl: Bool?

            public var dml: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ddl != nil {
                    map["Ddl"] = self.ddl!
                }
                if self.dml != nil {
                    map["Dml"] = self.dml!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ddl") {
                    self.ddl = dict["Ddl"] as! Bool
                }
                if dict.keys.contains("Dml") {
                    self.dml = dict["Dml"] as! Bool
                }
            }
        }
        public class SubscriptionHost : Tea.TeaModel {
            public var privateHost: String?

            public var publicHost: String?

            public var vpcHost: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.privateHost != nil {
                    map["PrivateHost"] = self.privateHost!
                }
                if self.publicHost != nil {
                    map["PublicHost"] = self.publicHost!
                }
                if self.vpcHost != nil {
                    map["VpcHost"] = self.vpcHost!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PrivateHost") {
                    self.privateHost = dict["PrivateHost"] as! String
                }
                if dict.keys.contains("PublicHost") {
                    self.publicHost = dict["PublicHost"] as! String
                }
                if dict.keys.contains("VpcHost") {
                    self.vpcHost = dict["VpcHost"] as! String
                }
            }
        }
        public class TagList : Tea.TeaModel {
            public var aliUid: Int64?

            public var creator: Int64?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var regionId: String?

            public var resourceId: String?

            public var resourceType: String?

            public var scope: String?

            public var srcRegion: String?

            public var tagCategory: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliUid != nil {
                    map["AliUid"] = self.aliUid!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                if self.srcRegion != nil {
                    map["SrcRegion"] = self.srcRegion!
                }
                if self.tagCategory != nil {
                    map["TagCategory"] = self.tagCategory!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliUid") {
                    self.aliUid = dict["AliUid"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! Int64
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("Scope") {
                    self.scope = dict["Scope"] as! String
                }
                if dict.keys.contains("SrcRegion") {
                    self.srcRegion = dict["SrcRegion"] as! String
                }
                if dict.keys.contains("TagCategory") {
                    self.tagCategory = dict["TagCategory"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var appName: String?

        public var beginTimestamp: String?

        public var checkpoint: String?

        public var consumptionCheckpoint: String?

        public var consumptionClient: String?

        public var createTime: String?

        public var dataEtlStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.DataEtlStatus?

        public var dataInitializationStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.DataInitializationStatus?

        public var dataSynchronizationStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.DataSynchronizationStatus?

        public var databaseCount: Int32?

        public var dbObject: String?

        public var delay: Int64?

        public var destNetType: String?

        public var destinationEndpoint: DescribeDtsJobDetailResponseBody.SubDistributedJob.DestinationEndpoint?

        public var dtsInstanceID: String?

        public var dtsJobClass: String?

        public var dtsJobDirection: String?

        public var dtsJobId: String?

        public var dtsJobName: String?

        public var endTimestamp: String?

        public var errorMessage: String?

        public var etlCalculator: String?

        public var expireTime: String?

        public var finishTime: String?

        public var groupId: String?

        public var isDemoJob: Bool?

        public var jobType: String?

        public var maxDu: Double?

        public var migrationMode: DescribeDtsJobDetailResponseBody.SubDistributedJob.MigrationMode?

        public var minDu: Double?

        public var originType: String?

        public var payType: String?

        public var performance: DescribeDtsJobDetailResponseBody.SubDistributedJob.Performance?

        public var precheckStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.PrecheckStatus?

        public var reserved: String?

        public var retryState: DescribeDtsJobDetailResponseBody.SubDistributedJob.RetryState?

        public var reverseJob: DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob?

        public var sourceEndpoint: DescribeDtsJobDetailResponseBody.SubDistributedJob.SourceEndpoint?

        public var status: String?

        public var structureInitializationStatus: DescribeDtsJobDetailResponseBody.SubDistributedJob.StructureInitializationStatus?

        public var subSyncJob: [Any]?

        public var subscribeTopic: String?

        public var subscriptionDataType: DescribeDtsJobDetailResponseBody.SubDistributedJob.SubscriptionDataType?

        public var subscriptionHost: DescribeDtsJobDetailResponseBody.SubDistributedJob.SubscriptionHost?

        public var synchronizationDirection: String?

        public var tagList: [DescribeDtsJobDetailResponseBody.SubDistributedJob.TagList]?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataEtlStatus?.validate()
            try self.dataInitializationStatus?.validate()
            try self.dataSynchronizationStatus?.validate()
            try self.destinationEndpoint?.validate()
            try self.migrationMode?.validate()
            try self.performance?.validate()
            try self.precheckStatus?.validate()
            try self.retryState?.validate()
            try self.reverseJob?.validate()
            try self.sourceEndpoint?.validate()
            try self.structureInitializationStatus?.validate()
            try self.subscriptionDataType?.validate()
            try self.subscriptionHost?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.beginTimestamp != nil {
                map["BeginTimestamp"] = self.beginTimestamp!
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint!
            }
            if self.consumptionCheckpoint != nil {
                map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
            }
            if self.consumptionClient != nil {
                map["ConsumptionClient"] = self.consumptionClient!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataEtlStatus != nil {
                map["DataEtlStatus"] = self.dataEtlStatus?.toMap()
            }
            if self.dataInitializationStatus != nil {
                map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
            }
            if self.dataSynchronizationStatus != nil {
                map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
            }
            if self.databaseCount != nil {
                map["DatabaseCount"] = self.databaseCount!
            }
            if self.dbObject != nil {
                map["DbObject"] = self.dbObject!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.destNetType != nil {
                map["DestNetType"] = self.destNetType!
            }
            if self.destinationEndpoint != nil {
                map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
            }
            if self.dtsInstanceID != nil {
                map["DtsInstanceID"] = self.dtsInstanceID!
            }
            if self.dtsJobClass != nil {
                map["DtsJobClass"] = self.dtsJobClass!
            }
            if self.dtsJobDirection != nil {
                map["DtsJobDirection"] = self.dtsJobDirection!
            }
            if self.dtsJobId != nil {
                map["DtsJobId"] = self.dtsJobId!
            }
            if self.dtsJobName != nil {
                map["DtsJobName"] = self.dtsJobName!
            }
            if self.endTimestamp != nil {
                map["EndTimestamp"] = self.endTimestamp!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.etlCalculator != nil {
                map["EtlCalculator"] = self.etlCalculator!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.isDemoJob != nil {
                map["IsDemoJob"] = self.isDemoJob!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.maxDu != nil {
                map["MaxDu"] = self.maxDu!
            }
            if self.migrationMode != nil {
                map["MigrationMode"] = self.migrationMode?.toMap()
            }
            if self.minDu != nil {
                map["MinDu"] = self.minDu!
            }
            if self.originType != nil {
                map["OriginType"] = self.originType!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.performance != nil {
                map["Performance"] = self.performance?.toMap()
            }
            if self.precheckStatus != nil {
                map["PrecheckStatus"] = self.precheckStatus?.toMap()
            }
            if self.reserved != nil {
                map["Reserved"] = self.reserved!
            }
            if self.retryState != nil {
                map["RetryState"] = self.retryState?.toMap()
            }
            if self.reverseJob != nil {
                map["ReverseJob"] = self.reverseJob?.toMap()
            }
            if self.sourceEndpoint != nil {
                map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.structureInitializationStatus != nil {
                map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
            }
            if self.subSyncJob != nil {
                map["SubSyncJob"] = self.subSyncJob!
            }
            if self.subscribeTopic != nil {
                map["SubscribeTopic"] = self.subscribeTopic!
            }
            if self.subscriptionDataType != nil {
                map["SubscriptionDataType"] = self.subscriptionDataType?.toMap()
            }
            if self.subscriptionHost != nil {
                map["SubscriptionHost"] = self.subscriptionHost?.toMap()
            }
            if self.synchronizationDirection != nil {
                map["SynchronizationDirection"] = self.synchronizationDirection!
            }
            if self.tagList != nil {
                var tmp : [Any] = []
                for k in self.tagList! {
                    tmp.append(k.toMap())
                }
                map["TagList"] = tmp
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("BeginTimestamp") {
                self.beginTimestamp = dict["BeginTimestamp"] as! String
            }
            if dict.keys.contains("Checkpoint") {
                self.checkpoint = dict["Checkpoint"] as! String
            }
            if dict.keys.contains("ConsumptionCheckpoint") {
                self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
            }
            if dict.keys.contains("ConsumptionClient") {
                self.consumptionClient = dict["ConsumptionClient"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DataEtlStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.DataEtlStatus()
                model.fromMap(dict["DataEtlStatus"] as! [String: Any])
                self.dataEtlStatus = model
            }
            if dict.keys.contains("DataInitializationStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.DataInitializationStatus()
                model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
                self.dataInitializationStatus = model
            }
            if dict.keys.contains("DataSynchronizationStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.DataSynchronizationStatus()
                model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
                self.dataSynchronizationStatus = model
            }
            if dict.keys.contains("DatabaseCount") {
                self.databaseCount = dict["DatabaseCount"] as! Int32
            }
            if dict.keys.contains("DbObject") {
                self.dbObject = dict["DbObject"] as! String
            }
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! Int64
            }
            if dict.keys.contains("DestNetType") {
                self.destNetType = dict["DestNetType"] as! String
            }
            if dict.keys.contains("DestinationEndpoint") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.DestinationEndpoint()
                model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                self.destinationEndpoint = model
            }
            if dict.keys.contains("DtsInstanceID") {
                self.dtsInstanceID = dict["DtsInstanceID"] as! String
            }
            if dict.keys.contains("DtsJobClass") {
                self.dtsJobClass = dict["DtsJobClass"] as! String
            }
            if dict.keys.contains("DtsJobDirection") {
                self.dtsJobDirection = dict["DtsJobDirection"] as! String
            }
            if dict.keys.contains("DtsJobId") {
                self.dtsJobId = dict["DtsJobId"] as! String
            }
            if dict.keys.contains("DtsJobName") {
                self.dtsJobName = dict["DtsJobName"] as! String
            }
            if dict.keys.contains("EndTimestamp") {
                self.endTimestamp = dict["EndTimestamp"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("EtlCalculator") {
                self.etlCalculator = dict["EtlCalculator"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("IsDemoJob") {
                self.isDemoJob = dict["IsDemoJob"] as! Bool
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("MaxDu") {
                self.maxDu = dict["MaxDu"] as! Double
            }
            if dict.keys.contains("MigrationMode") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.MigrationMode()
                model.fromMap(dict["MigrationMode"] as! [String: Any])
                self.migrationMode = model
            }
            if dict.keys.contains("MinDu") {
                self.minDu = dict["MinDu"] as! Double
            }
            if dict.keys.contains("OriginType") {
                self.originType = dict["OriginType"] as! String
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("Performance") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.Performance()
                model.fromMap(dict["Performance"] as! [String: Any])
                self.performance = model
            }
            if dict.keys.contains("PrecheckStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.PrecheckStatus()
                model.fromMap(dict["PrecheckStatus"] as! [String: Any])
                self.precheckStatus = model
            }
            if dict.keys.contains("Reserved") {
                self.reserved = dict["Reserved"] as! String
            }
            if dict.keys.contains("RetryState") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.RetryState()
                model.fromMap(dict["RetryState"] as! [String: Any])
                self.retryState = model
            }
            if dict.keys.contains("ReverseJob") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.ReverseJob()
                model.fromMap(dict["ReverseJob"] as! [String: Any])
                self.reverseJob = model
            }
            if dict.keys.contains("SourceEndpoint") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.SourceEndpoint()
                model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                self.sourceEndpoint = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StructureInitializationStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.StructureInitializationStatus()
                model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
                self.structureInitializationStatus = model
            }
            if dict.keys.contains("SubSyncJob") {
                self.subSyncJob = dict["SubSyncJob"] as! [Any]
            }
            if dict.keys.contains("SubscribeTopic") {
                self.subscribeTopic = dict["SubscribeTopic"] as! String
            }
            if dict.keys.contains("SubscriptionDataType") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.SubscriptionDataType()
                model.fromMap(dict["SubscriptionDataType"] as! [String: Any])
                self.subscriptionDataType = model
            }
            if dict.keys.contains("SubscriptionHost") {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.SubscriptionHost()
                model.fromMap(dict["SubscriptionHost"] as! [String: Any])
                self.subscriptionHost = model
            }
            if dict.keys.contains("SynchronizationDirection") {
                self.synchronizationDirection = dict["SynchronizationDirection"] as! String
            }
            if dict.keys.contains("TagList") {
                var tmp : [DescribeDtsJobDetailResponseBody.SubDistributedJob.TagList] = []
                for v in dict["TagList"] as! [Any] {
                    var model = DescribeDtsJobDetailResponseBody.SubDistributedJob.TagList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagList = tmp
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public class SubSyncJob : Tea.TeaModel {
        public class DataEtlStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataSynchronizationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DestinationEndpoint : Tea.TeaModel {
            public var aliyunUid: String?

            public var databaseName: String?

            public var engineName: String?

            public var instanceID: String?

            public var instanceType: String?

            public var ip: String?

            public var oracleSID: String?

            public var port: String?

            public var region: String?

            public var roleName: String?

            public var sslSolutionEnum: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.instanceID != nil {
                    map["InstanceID"] = self.instanceID!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.oracleSID != nil {
                    map["OracleSID"] = self.oracleSID!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.sslSolutionEnum != nil {
                    map["SslSolutionEnum"] = self.sslSolutionEnum!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunUid") {
                    self.aliyunUid = dict["AliyunUid"] as! String
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("InstanceID") {
                    self.instanceID = dict["InstanceID"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("OracleSID") {
                    self.oracleSID = dict["OracleSID"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("RoleName") {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("SslSolutionEnum") {
                    self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class MigrationMode : Tea.TeaModel {
            public var dataExtractTransformLoad: Bool?

            public var dataInitialization: Bool?

            public var dataSynchronization: Bool?

            public var structureInitialization: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataExtractTransformLoad != nil {
                    map["DataExtractTransformLoad"] = self.dataExtractTransformLoad!
                }
                if self.dataInitialization != nil {
                    map["DataInitialization"] = self.dataInitialization!
                }
                if self.dataSynchronization != nil {
                    map["DataSynchronization"] = self.dataSynchronization!
                }
                if self.structureInitialization != nil {
                    map["StructureInitialization"] = self.structureInitialization!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataExtractTransformLoad") {
                    self.dataExtractTransformLoad = dict["DataExtractTransformLoad"] as! Bool
                }
                if dict.keys.contains("DataInitialization") {
                    self.dataInitialization = dict["DataInitialization"] as! Bool
                }
                if dict.keys.contains("DataSynchronization") {
                    self.dataSynchronization = dict["DataSynchronization"] as! Bool
                }
                if dict.keys.contains("StructureInitialization") {
                    self.structureInitialization = dict["StructureInitialization"] as! Bool
                }
            }
        }
        public class Performance : Tea.TeaModel {
            public var flow: String?

            public var rps: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flow != nil {
                    map["Flow"] = self.flow!
                }
                if self.rps != nil {
                    map["Rps"] = self.rps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Flow") {
                    self.flow = dict["Flow"] as! String
                }
                if dict.keys.contains("Rps") {
                    self.rps = dict["Rps"] as! String
                }
            }
        }
        public class PrecheckStatus : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var checkItem: String?

                public var checkItemDescription: String?

                public var checkResult: String?

                public var failedReason: String?

                public var repairMethod: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItem != nil {
                        map["CheckItem"] = self.checkItem!
                    }
                    if self.checkItemDescription != nil {
                        map["CheckItemDescription"] = self.checkItemDescription!
                    }
                    if self.checkResult != nil {
                        map["CheckResult"] = self.checkResult!
                    }
                    if self.failedReason != nil {
                        map["FailedReason"] = self.failedReason!
                    }
                    if self.repairMethod != nil {
                        map["RepairMethod"] = self.repairMethod!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckItem") {
                        self.checkItem = dict["CheckItem"] as! String
                    }
                    if dict.keys.contains("CheckItemDescription") {
                        self.checkItemDescription = dict["CheckItemDescription"] as! String
                    }
                    if dict.keys.contains("CheckResult") {
                        self.checkResult = dict["CheckResult"] as! String
                    }
                    if dict.keys.contains("FailedReason") {
                        self.failedReason = dict["FailedReason"] as! String
                    }
                    if dict.keys.contains("RepairMethod") {
                        self.repairMethod = dict["RepairMethod"] as! String
                    }
                }
            }
            public var detail: [DescribeDtsJobDetailResponseBody.SubSyncJob.PrecheckStatus.Detail]?

            public var errorMessage: String?

            public var percent: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    var tmp : [Any] = []
                    for k in self.detail! {
                        tmp.append(k.toMap())
                    }
                    map["Detail"] = tmp
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Detail") {
                    var tmp : [DescribeDtsJobDetailResponseBody.SubSyncJob.PrecheckStatus.Detail] = []
                    for v in dict["Detail"] as! [Any] {
                        var model = DescribeDtsJobDetailResponseBody.SubSyncJob.PrecheckStatus.Detail()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.detail = tmp
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RetryState : Tea.TeaModel {
            public var errMsg: String?

            public var jobId: String?

            public var maxRetryTime: Int32?

            public var module: String?

            public var retryCount: Int32?

            public var retryTarget: String?

            public var retryTime: Int32?

            public var retrying: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errMsg != nil {
                    map["ErrMsg"] = self.errMsg!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.maxRetryTime != nil {
                    map["MaxRetryTime"] = self.maxRetryTime!
                }
                if self.module != nil {
                    map["Module"] = self.module!
                }
                if self.retryCount != nil {
                    map["RetryCount"] = self.retryCount!
                }
                if self.retryTarget != nil {
                    map["RetryTarget"] = self.retryTarget!
                }
                if self.retryTime != nil {
                    map["RetryTime"] = self.retryTime!
                }
                if self.retrying != nil {
                    map["Retrying"] = self.retrying!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrMsg") {
                    self.errMsg = dict["ErrMsg"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MaxRetryTime") {
                    self.maxRetryTime = dict["MaxRetryTime"] as! Int32
                }
                if dict.keys.contains("Module") {
                    self.module = dict["Module"] as! String
                }
                if dict.keys.contains("RetryCount") {
                    self.retryCount = dict["RetryCount"] as! Int32
                }
                if dict.keys.contains("RetryTarget") {
                    self.retryTarget = dict["RetryTarget"] as! String
                }
                if dict.keys.contains("RetryTime") {
                    self.retryTime = dict["RetryTime"] as! Int32
                }
                if dict.keys.contains("Retrying") {
                    self.retrying = dict["Retrying"] as! Bool
                }
            }
        }
        public class ReverseJob : Tea.TeaModel {
            public class DataEtlStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DataInitializationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DataSynchronizationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DestinationEndpoint : Tea.TeaModel {
                public var aliyunUid: String?

                public var databaseName: String?

                public var engineName: String?

                public var instanceID: String?

                public var instanceType: String?

                public var ip: String?

                public var oracleSID: String?

                public var port: String?

                public var region: String?

                public var roleName: String?

                public var sslSolutionEnum: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliyunUid != nil {
                        map["AliyunUid"] = self.aliyunUid!
                    }
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    if self.sslSolutionEnum != nil {
                        map["SslSolutionEnum"] = self.sslSolutionEnum!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AliyunUid") {
                        self.aliyunUid = dict["AliyunUid"] as! String
                    }
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("RoleName") {
                        self.roleName = dict["RoleName"] as! String
                    }
                    if dict.keys.contains("SslSolutionEnum") {
                        self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class MigrationMode : Tea.TeaModel {
                public var dataExtractTransformLoad: Bool?

                public var dataInitialization: Bool?

                public var dataSynchronization: Bool?

                public var structureInitialization: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataExtractTransformLoad != nil {
                        map["DataExtractTransformLoad"] = self.dataExtractTransformLoad!
                    }
                    if self.dataInitialization != nil {
                        map["DataInitialization"] = self.dataInitialization!
                    }
                    if self.dataSynchronization != nil {
                        map["DataSynchronization"] = self.dataSynchronization!
                    }
                    if self.structureInitialization != nil {
                        map["StructureInitialization"] = self.structureInitialization!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataExtractTransformLoad") {
                        self.dataExtractTransformLoad = dict["DataExtractTransformLoad"] as! Bool
                    }
                    if dict.keys.contains("DataInitialization") {
                        self.dataInitialization = dict["DataInitialization"] as! Bool
                    }
                    if dict.keys.contains("DataSynchronization") {
                        self.dataSynchronization = dict["DataSynchronization"] as! Bool
                    }
                    if dict.keys.contains("StructureInitialization") {
                        self.structureInitialization = dict["StructureInitialization"] as! Bool
                    }
                }
            }
            public class Performance : Tea.TeaModel {
                public var flow: String?

                public var rps: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.flow != nil {
                        map["Flow"] = self.flow!
                    }
                    if self.rps != nil {
                        map["Rps"] = self.rps!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Flow") {
                        self.flow = dict["Flow"] as! String
                    }
                    if dict.keys.contains("Rps") {
                        self.rps = dict["Rps"] as! String
                    }
                }
            }
            public class PrecheckStatus : Tea.TeaModel {
                public class Detail : Tea.TeaModel {
                    public var checkItem: String?

                    public var checkItemDescription: String?

                    public var checkResult: String?

                    public var failedReason: String?

                    public var repairMethod: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.checkItem != nil {
                            map["CheckItem"] = self.checkItem!
                        }
                        if self.checkItemDescription != nil {
                            map["CheckItemDescription"] = self.checkItemDescription!
                        }
                        if self.checkResult != nil {
                            map["CheckResult"] = self.checkResult!
                        }
                        if self.failedReason != nil {
                            map["FailedReason"] = self.failedReason!
                        }
                        if self.repairMethod != nil {
                            map["RepairMethod"] = self.repairMethod!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CheckItem") {
                            self.checkItem = dict["CheckItem"] as! String
                        }
                        if dict.keys.contains("CheckItemDescription") {
                            self.checkItemDescription = dict["CheckItemDescription"] as! String
                        }
                        if dict.keys.contains("CheckResult") {
                            self.checkResult = dict["CheckResult"] as! String
                        }
                        if dict.keys.contains("FailedReason") {
                            self.failedReason = dict["FailedReason"] as! String
                        }
                        if dict.keys.contains("RepairMethod") {
                            self.repairMethod = dict["RepairMethod"] as! String
                        }
                    }
                }
                public var detail: [DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.PrecheckStatus.Detail]?

                public var errorMessage: String?

                public var percent: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detail != nil {
                        var tmp : [Any] = []
                        for k in self.detail! {
                            tmp.append(k.toMap())
                        }
                        map["Detail"] = tmp
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Detail") {
                        var tmp : [DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.PrecheckStatus.Detail] = []
                        for v in dict["Detail"] as! [Any] {
                            var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.PrecheckStatus.Detail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.detail = tmp
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class RetryState : Tea.TeaModel {
                public var errMsg: String?

                public var jobId: String?

                public var maxRetryTime: Int32?

                public var module: String?

                public var retryCount: Int32?

                public var retryTarget: String?

                public var retryTime: Int32?

                public var retrying: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMsg != nil {
                        map["ErrMsg"] = self.errMsg!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.maxRetryTime != nil {
                        map["MaxRetryTime"] = self.maxRetryTime!
                    }
                    if self.module != nil {
                        map["Module"] = self.module!
                    }
                    if self.retryCount != nil {
                        map["RetryCount"] = self.retryCount!
                    }
                    if self.retryTarget != nil {
                        map["RetryTarget"] = self.retryTarget!
                    }
                    if self.retryTime != nil {
                        map["RetryTime"] = self.retryTime!
                    }
                    if self.retrying != nil {
                        map["Retrying"] = self.retrying!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMsg") {
                        self.errMsg = dict["ErrMsg"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("MaxRetryTime") {
                        self.maxRetryTime = dict["MaxRetryTime"] as! Int32
                    }
                    if dict.keys.contains("Module") {
                        self.module = dict["Module"] as! String
                    }
                    if dict.keys.contains("RetryCount") {
                        self.retryCount = dict["RetryCount"] as! Int32
                    }
                    if dict.keys.contains("RetryTarget") {
                        self.retryTarget = dict["RetryTarget"] as! String
                    }
                    if dict.keys.contains("RetryTime") {
                        self.retryTime = dict["RetryTime"] as! Int32
                    }
                    if dict.keys.contains("Retrying") {
                        self.retrying = dict["Retrying"] as! Bool
                    }
                }
            }
            public class SourceEndpoint : Tea.TeaModel {
                public var aliyunUid: String?

                public var databaseName: String?

                public var engineName: String?

                public var instanceID: String?

                public var instanceType: String?

                public var ip: String?

                public var oracleSID: String?

                public var port: String?

                public var region: String?

                public var roleName: String?

                public var sslSolutionEnum: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliyunUid != nil {
                        map["AliyunUid"] = self.aliyunUid!
                    }
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    if self.sslSolutionEnum != nil {
                        map["SslSolutionEnum"] = self.sslSolutionEnum!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AliyunUid") {
                        self.aliyunUid = dict["AliyunUid"] as! String
                    }
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("RoleName") {
                        self.roleName = dict["RoleName"] as! String
                    }
                    if dict.keys.contains("SslSolutionEnum") {
                        self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class StructureInitializationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class SubscriptionDataType : Tea.TeaModel {
                public var ddl: Bool?

                public var dml: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ddl != nil {
                        map["Ddl"] = self.ddl!
                    }
                    if self.dml != nil {
                        map["Dml"] = self.dml!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ddl") {
                        self.ddl = dict["Ddl"] as! Bool
                    }
                    if dict.keys.contains("Dml") {
                        self.dml = dict["Dml"] as! Bool
                    }
                }
            }
            public class SubscriptionHost : Tea.TeaModel {
                public var privateHost: String?

                public var publicHost: String?

                public var vpcHost: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateHost != nil {
                        map["PrivateHost"] = self.privateHost!
                    }
                    if self.publicHost != nil {
                        map["PublicHost"] = self.publicHost!
                    }
                    if self.vpcHost != nil {
                        map["VpcHost"] = self.vpcHost!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateHost") {
                        self.privateHost = dict["PrivateHost"] as! String
                    }
                    if dict.keys.contains("PublicHost") {
                        self.publicHost = dict["PublicHost"] as! String
                    }
                    if dict.keys.contains("VpcHost") {
                        self.vpcHost = dict["VpcHost"] as! String
                    }
                }
            }
            public class TagList : Tea.TeaModel {
                public var aliUid: Int64?

                public var creator: Int64?

                public var gmtCreate: String?

                public var gmtModified: String?

                public var id: Int64?

                public var regionId: String?

                public var resourceId: String?

                public var resourceType: String?

                public var scope: String?

                public var srcRegion: String?

                public var tagCategory: String?

                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliUid != nil {
                        map["AliUid"] = self.aliUid!
                    }
                    if self.creator != nil {
                        map["Creator"] = self.creator!
                    }
                    if self.gmtCreate != nil {
                        map["GmtCreate"] = self.gmtCreate!
                    }
                    if self.gmtModified != nil {
                        map["GmtModified"] = self.gmtModified!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.resourceId != nil {
                        map["ResourceId"] = self.resourceId!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.scope != nil {
                        map["Scope"] = self.scope!
                    }
                    if self.srcRegion != nil {
                        map["SrcRegion"] = self.srcRegion!
                    }
                    if self.tagCategory != nil {
                        map["TagCategory"] = self.tagCategory!
                    }
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AliUid") {
                        self.aliUid = dict["AliUid"] as! Int64
                    }
                    if dict.keys.contains("Creator") {
                        self.creator = dict["Creator"] as! Int64
                    }
                    if dict.keys.contains("GmtCreate") {
                        self.gmtCreate = dict["GmtCreate"] as! String
                    }
                    if dict.keys.contains("GmtModified") {
                        self.gmtModified = dict["GmtModified"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("ResourceId") {
                        self.resourceId = dict["ResourceId"] as! String
                    }
                    if dict.keys.contains("ResourceType") {
                        self.resourceType = dict["ResourceType"] as! String
                    }
                    if dict.keys.contains("Scope") {
                        self.scope = dict["Scope"] as! String
                    }
                    if dict.keys.contains("SrcRegion") {
                        self.srcRegion = dict["SrcRegion"] as! String
                    }
                    if dict.keys.contains("TagCategory") {
                        self.tagCategory = dict["TagCategory"] as! String
                    }
                    if dict.keys.contains("TagKey") {
                        self.tagKey = dict["TagKey"] as! String
                    }
                    if dict.keys.contains("TagValue") {
                        self.tagValue = dict["TagValue"] as! String
                    }
                }
            }
            public var appName: String?

            public var beginTimestamp: String?

            public var checkpoint: String?

            public var consumptionCheckpoint: String?

            public var consumptionClient: String?

            public var createTime: String?

            public var dataEtlStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.DataEtlStatus?

            public var dataInitializationStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.DataInitializationStatus?

            public var dataSynchronizationStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.DataSynchronizationStatus?

            public var databaseCount: Int32?

            public var dbObject: String?

            public var delay: Int64?

            public var destNetType: String?

            public var destinationEndpoint: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.DestinationEndpoint?

            public var dtsInstanceID: String?

            public var dtsJobClass: String?

            public var dtsJobDirection: String?

            public var dtsJobId: String?

            public var dtsJobName: String?

            public var endTimestamp: String?

            public var errorMessage: String?

            public var etlCalculator: String?

            public var expireTime: String?

            public var finishTime: String?

            public var groupId: String?

            public var isDemoJob: Bool?

            public var jobType: String?

            public var migrationMode: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.MigrationMode?

            public var originType: String?

            public var payType: String?

            public var performance: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.Performance?

            public var precheckStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.PrecheckStatus?

            public var reserved: String?

            public var retryState: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.RetryState?

            public var reverseJob: Any?

            public var sourceEndpoint: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.SourceEndpoint?

            public var status: String?

            public var structureInitializationStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.StructureInitializationStatus?

            public var subscribeTopic: String?

            public var subscriptionDataType: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.SubscriptionDataType?

            public var subscriptionHost: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.SubscriptionHost?

            public var synchronizationDirection: String?

            public var tagList: [DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.TagList]?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataEtlStatus?.validate()
                try self.dataInitializationStatus?.validate()
                try self.dataSynchronizationStatus?.validate()
                try self.destinationEndpoint?.validate()
                try self.migrationMode?.validate()
                try self.performance?.validate()
                try self.precheckStatus?.validate()
                try self.retryState?.validate()
                try self.sourceEndpoint?.validate()
                try self.structureInitializationStatus?.validate()
                try self.subscriptionDataType?.validate()
                try self.subscriptionHost?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.beginTimestamp != nil {
                    map["BeginTimestamp"] = self.beginTimestamp!
                }
                if self.checkpoint != nil {
                    map["Checkpoint"] = self.checkpoint!
                }
                if self.consumptionCheckpoint != nil {
                    map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
                }
                if self.consumptionClient != nil {
                    map["ConsumptionClient"] = self.consumptionClient!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataEtlStatus != nil {
                    map["DataEtlStatus"] = self.dataEtlStatus?.toMap()
                }
                if self.dataInitializationStatus != nil {
                    map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
                }
                if self.dataSynchronizationStatus != nil {
                    map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
                }
                if self.databaseCount != nil {
                    map["DatabaseCount"] = self.databaseCount!
                }
                if self.dbObject != nil {
                    map["DbObject"] = self.dbObject!
                }
                if self.delay != nil {
                    map["Delay"] = self.delay!
                }
                if self.destNetType != nil {
                    map["DestNetType"] = self.destNetType!
                }
                if self.destinationEndpoint != nil {
                    map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
                }
                if self.dtsInstanceID != nil {
                    map["DtsInstanceID"] = self.dtsInstanceID!
                }
                if self.dtsJobClass != nil {
                    map["DtsJobClass"] = self.dtsJobClass!
                }
                if self.dtsJobDirection != nil {
                    map["DtsJobDirection"] = self.dtsJobDirection!
                }
                if self.dtsJobId != nil {
                    map["DtsJobId"] = self.dtsJobId!
                }
                if self.dtsJobName != nil {
                    map["DtsJobName"] = self.dtsJobName!
                }
                if self.endTimestamp != nil {
                    map["EndTimestamp"] = self.endTimestamp!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.etlCalculator != nil {
                    map["EtlCalculator"] = self.etlCalculator!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.isDemoJob != nil {
                    map["IsDemoJob"] = self.isDemoJob!
                }
                if self.jobType != nil {
                    map["JobType"] = self.jobType!
                }
                if self.migrationMode != nil {
                    map["MigrationMode"] = self.migrationMode?.toMap()
                }
                if self.originType != nil {
                    map["OriginType"] = self.originType!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.performance != nil {
                    map["Performance"] = self.performance?.toMap()
                }
                if self.precheckStatus != nil {
                    map["PrecheckStatus"] = self.precheckStatus?.toMap()
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.retryState != nil {
                    map["RetryState"] = self.retryState?.toMap()
                }
                if self.reverseJob != nil {
                    map["ReverseJob"] = self.reverseJob!
                }
                if self.sourceEndpoint != nil {
                    map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.structureInitializationStatus != nil {
                    map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
                }
                if self.subscribeTopic != nil {
                    map["SubscribeTopic"] = self.subscribeTopic!
                }
                if self.subscriptionDataType != nil {
                    map["SubscriptionDataType"] = self.subscriptionDataType?.toMap()
                }
                if self.subscriptionHost != nil {
                    map["SubscriptionHost"] = self.subscriptionHost?.toMap()
                }
                if self.synchronizationDirection != nil {
                    map["SynchronizationDirection"] = self.synchronizationDirection!
                }
                if self.tagList != nil {
                    var tmp : [Any] = []
                    for k in self.tagList! {
                        tmp.append(k.toMap())
                    }
                    map["TagList"] = tmp
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("BeginTimestamp") {
                    self.beginTimestamp = dict["BeginTimestamp"] as! String
                }
                if dict.keys.contains("Checkpoint") {
                    self.checkpoint = dict["Checkpoint"] as! String
                }
                if dict.keys.contains("ConsumptionCheckpoint") {
                    self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
                }
                if dict.keys.contains("ConsumptionClient") {
                    self.consumptionClient = dict["ConsumptionClient"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DataEtlStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.DataEtlStatus()
                    model.fromMap(dict["DataEtlStatus"] as! [String: Any])
                    self.dataEtlStatus = model
                }
                if dict.keys.contains("DataInitializationStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.DataInitializationStatus()
                    model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
                    self.dataInitializationStatus = model
                }
                if dict.keys.contains("DataSynchronizationStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.DataSynchronizationStatus()
                    model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
                    self.dataSynchronizationStatus = model
                }
                if dict.keys.contains("DatabaseCount") {
                    self.databaseCount = dict["DatabaseCount"] as! Int32
                }
                if dict.keys.contains("DbObject") {
                    self.dbObject = dict["DbObject"] as! String
                }
                if dict.keys.contains("Delay") {
                    self.delay = dict["Delay"] as! Int64
                }
                if dict.keys.contains("DestNetType") {
                    self.destNetType = dict["DestNetType"] as! String
                }
                if dict.keys.contains("DestinationEndpoint") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.DestinationEndpoint()
                    model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                    self.destinationEndpoint = model
                }
                if dict.keys.contains("DtsInstanceID") {
                    self.dtsInstanceID = dict["DtsInstanceID"] as! String
                }
                if dict.keys.contains("DtsJobClass") {
                    self.dtsJobClass = dict["DtsJobClass"] as! String
                }
                if dict.keys.contains("DtsJobDirection") {
                    self.dtsJobDirection = dict["DtsJobDirection"] as! String
                }
                if dict.keys.contains("DtsJobId") {
                    self.dtsJobId = dict["DtsJobId"] as! String
                }
                if dict.keys.contains("DtsJobName") {
                    self.dtsJobName = dict["DtsJobName"] as! String
                }
                if dict.keys.contains("EndTimestamp") {
                    self.endTimestamp = dict["EndTimestamp"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("EtlCalculator") {
                    self.etlCalculator = dict["EtlCalculator"] as! String
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("IsDemoJob") {
                    self.isDemoJob = dict["IsDemoJob"] as! Bool
                }
                if dict.keys.contains("JobType") {
                    self.jobType = dict["JobType"] as! String
                }
                if dict.keys.contains("MigrationMode") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.MigrationMode()
                    model.fromMap(dict["MigrationMode"] as! [String: Any])
                    self.migrationMode = model
                }
                if dict.keys.contains("OriginType") {
                    self.originType = dict["OriginType"] as! String
                }
                if dict.keys.contains("PayType") {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("Performance") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.Performance()
                    model.fromMap(dict["Performance"] as! [String: Any])
                    self.performance = model
                }
                if dict.keys.contains("PrecheckStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.PrecheckStatus()
                    model.fromMap(dict["PrecheckStatus"] as! [String: Any])
                    self.precheckStatus = model
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! String
                }
                if dict.keys.contains("RetryState") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.RetryState()
                    model.fromMap(dict["RetryState"] as! [String: Any])
                    self.retryState = model
                }
                if dict.keys.contains("ReverseJob") {
                    self.reverseJob = dict["ReverseJob"] as! Any
                }
                if dict.keys.contains("SourceEndpoint") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.SourceEndpoint()
                    model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                    self.sourceEndpoint = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StructureInitializationStatus") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.StructureInitializationStatus()
                    model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
                    self.structureInitializationStatus = model
                }
                if dict.keys.contains("SubscribeTopic") {
                    self.subscribeTopic = dict["SubscribeTopic"] as! String
                }
                if dict.keys.contains("SubscriptionDataType") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.SubscriptionDataType()
                    model.fromMap(dict["SubscriptionDataType"] as! [String: Any])
                    self.subscriptionDataType = model
                }
                if dict.keys.contains("SubscriptionHost") {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.SubscriptionHost()
                    model.fromMap(dict["SubscriptionHost"] as! [String: Any])
                    self.subscriptionHost = model
                }
                if dict.keys.contains("SynchronizationDirection") {
                    self.synchronizationDirection = dict["SynchronizationDirection"] as! String
                }
                if dict.keys.contains("TagList") {
                    var tmp : [DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.TagList] = []
                    for v in dict["TagList"] as! [Any] {
                        var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob.TagList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tagList = tmp
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! String
                }
            }
        }
        public class SourceEndpoint : Tea.TeaModel {
            public var aliyunUid: String?

            public var databaseName: String?

            public var engineName: String?

            public var instanceID: String?

            public var instanceType: String?

            public var ip: String?

            public var oracleSID: String?

            public var port: String?

            public var region: String?

            public var roleName: String?

            public var sslSolutionEnum: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.instanceID != nil {
                    map["InstanceID"] = self.instanceID!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.oracleSID != nil {
                    map["OracleSID"] = self.oracleSID!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.sslSolutionEnum != nil {
                    map["SslSolutionEnum"] = self.sslSolutionEnum!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunUid") {
                    self.aliyunUid = dict["AliyunUid"] as! String
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("InstanceID") {
                    self.instanceID = dict["InstanceID"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("OracleSID") {
                    self.oracleSID = dict["OracleSID"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("RoleName") {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("SslSolutionEnum") {
                    self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class StructureInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class SubscriptionDataType : Tea.TeaModel {
            public var ddl: Bool?

            public var dml: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ddl != nil {
                    map["Ddl"] = self.ddl!
                }
                if self.dml != nil {
                    map["Dml"] = self.dml!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ddl") {
                    self.ddl = dict["Ddl"] as! Bool
                }
                if dict.keys.contains("Dml") {
                    self.dml = dict["Dml"] as! Bool
                }
            }
        }
        public class SubscriptionHost : Tea.TeaModel {
            public var privateHost: String?

            public var publicHost: String?

            public var vpcHost: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.privateHost != nil {
                    map["PrivateHost"] = self.privateHost!
                }
                if self.publicHost != nil {
                    map["PublicHost"] = self.publicHost!
                }
                if self.vpcHost != nil {
                    map["VpcHost"] = self.vpcHost!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PrivateHost") {
                    self.privateHost = dict["PrivateHost"] as! String
                }
                if dict.keys.contains("PublicHost") {
                    self.publicHost = dict["PublicHost"] as! String
                }
                if dict.keys.contains("VpcHost") {
                    self.vpcHost = dict["VpcHost"] as! String
                }
            }
        }
        public class TagList : Tea.TeaModel {
            public var aliUid: Int64?

            public var creator: Int64?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var id: Int64?

            public var regionId: String?

            public var resourceId: String?

            public var resourceType: String?

            public var scope: String?

            public var srcRegion: String?

            public var tagCategory: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliUid != nil {
                    map["AliUid"] = self.aliUid!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                if self.srcRegion != nil {
                    map["SrcRegion"] = self.srcRegion!
                }
                if self.tagCategory != nil {
                    map["TagCategory"] = self.tagCategory!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliUid") {
                    self.aliUid = dict["AliUid"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! Int64
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("Scope") {
                    self.scope = dict["Scope"] as! String
                }
                if dict.keys.contains("SrcRegion") {
                    self.srcRegion = dict["SrcRegion"] as! String
                }
                if dict.keys.contains("TagCategory") {
                    self.tagCategory = dict["TagCategory"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var appName: String?

        public var beginTimestamp: String?

        public var checkpoint: String?

        public var consumptionCheckpoint: String?

        public var consumptionClient: String?

        public var createTime: String?

        public var dataEtlStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.DataEtlStatus?

        public var dataInitializationStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.DataInitializationStatus?

        public var dataSynchronizationStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.DataSynchronizationStatus?

        public var databaseCount: Int32?

        public var dbObject: String?

        public var delay: Int64?

        public var destNetType: String?

        public var destinationEndpoint: DescribeDtsJobDetailResponseBody.SubSyncJob.DestinationEndpoint?

        public var dtsInstanceID: String?

        public var dtsJobClass: String?

        public var dtsJobDirection: String?

        public var dtsJobId: String?

        public var dtsJobName: String?

        public var endTimestamp: String?

        public var errorMessage: String?

        public var etlCalculator: String?

        public var expireTime: String?

        public var finishTime: String?

        public var groupId: String?

        public var isDemoJob: Bool?

        public var jobType: String?

        public var maxDu: Double?

        public var migrationMode: DescribeDtsJobDetailResponseBody.SubSyncJob.MigrationMode?

        public var minDu: Double?

        public var originType: String?

        public var payType: String?

        public var performance: DescribeDtsJobDetailResponseBody.SubSyncJob.Performance?

        public var precheckStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.PrecheckStatus?

        public var reserved: String?

        public var retryState: DescribeDtsJobDetailResponseBody.SubSyncJob.RetryState?

        public var reverseJob: DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob?

        public var sourceEndpoint: DescribeDtsJobDetailResponseBody.SubSyncJob.SourceEndpoint?

        public var status: String?

        public var structureInitializationStatus: DescribeDtsJobDetailResponseBody.SubSyncJob.StructureInitializationStatus?

        public var subSyncJob: [Any]?

        public var subscribeTopic: String?

        public var subscriptionDataType: DescribeDtsJobDetailResponseBody.SubSyncJob.SubscriptionDataType?

        public var subscriptionHost: DescribeDtsJobDetailResponseBody.SubSyncJob.SubscriptionHost?

        public var synchronizationDirection: String?

        public var tagList: [DescribeDtsJobDetailResponseBody.SubSyncJob.TagList]?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataEtlStatus?.validate()
            try self.dataInitializationStatus?.validate()
            try self.dataSynchronizationStatus?.validate()
            try self.destinationEndpoint?.validate()
            try self.migrationMode?.validate()
            try self.performance?.validate()
            try self.precheckStatus?.validate()
            try self.retryState?.validate()
            try self.reverseJob?.validate()
            try self.sourceEndpoint?.validate()
            try self.structureInitializationStatus?.validate()
            try self.subscriptionDataType?.validate()
            try self.subscriptionHost?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.beginTimestamp != nil {
                map["BeginTimestamp"] = self.beginTimestamp!
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint!
            }
            if self.consumptionCheckpoint != nil {
                map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
            }
            if self.consumptionClient != nil {
                map["ConsumptionClient"] = self.consumptionClient!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataEtlStatus != nil {
                map["DataEtlStatus"] = self.dataEtlStatus?.toMap()
            }
            if self.dataInitializationStatus != nil {
                map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
            }
            if self.dataSynchronizationStatus != nil {
                map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
            }
            if self.databaseCount != nil {
                map["DatabaseCount"] = self.databaseCount!
            }
            if self.dbObject != nil {
                map["DbObject"] = self.dbObject!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.destNetType != nil {
                map["DestNetType"] = self.destNetType!
            }
            if self.destinationEndpoint != nil {
                map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
            }
            if self.dtsInstanceID != nil {
                map["DtsInstanceID"] = self.dtsInstanceID!
            }
            if self.dtsJobClass != nil {
                map["DtsJobClass"] = self.dtsJobClass!
            }
            if self.dtsJobDirection != nil {
                map["DtsJobDirection"] = self.dtsJobDirection!
            }
            if self.dtsJobId != nil {
                map["DtsJobId"] = self.dtsJobId!
            }
            if self.dtsJobName != nil {
                map["DtsJobName"] = self.dtsJobName!
            }
            if self.endTimestamp != nil {
                map["EndTimestamp"] = self.endTimestamp!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.etlCalculator != nil {
                map["EtlCalculator"] = self.etlCalculator!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.isDemoJob != nil {
                map["IsDemoJob"] = self.isDemoJob!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.maxDu != nil {
                map["MaxDu"] = self.maxDu!
            }
            if self.migrationMode != nil {
                map["MigrationMode"] = self.migrationMode?.toMap()
            }
            if self.minDu != nil {
                map["MinDu"] = self.minDu!
            }
            if self.originType != nil {
                map["OriginType"] = self.originType!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.performance != nil {
                map["Performance"] = self.performance?.toMap()
            }
            if self.precheckStatus != nil {
                map["PrecheckStatus"] = self.precheckStatus?.toMap()
            }
            if self.reserved != nil {
                map["Reserved"] = self.reserved!
            }
            if self.retryState != nil {
                map["RetryState"] = self.retryState?.toMap()
            }
            if self.reverseJob != nil {
                map["ReverseJob"] = self.reverseJob?.toMap()
            }
            if self.sourceEndpoint != nil {
                map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.structureInitializationStatus != nil {
                map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
            }
            if self.subSyncJob != nil {
                map["SubSyncJob"] = self.subSyncJob!
            }
            if self.subscribeTopic != nil {
                map["SubscribeTopic"] = self.subscribeTopic!
            }
            if self.subscriptionDataType != nil {
                map["SubscriptionDataType"] = self.subscriptionDataType?.toMap()
            }
            if self.subscriptionHost != nil {
                map["SubscriptionHost"] = self.subscriptionHost?.toMap()
            }
            if self.synchronizationDirection != nil {
                map["SynchronizationDirection"] = self.synchronizationDirection!
            }
            if self.tagList != nil {
                var tmp : [Any] = []
                for k in self.tagList! {
                    tmp.append(k.toMap())
                }
                map["TagList"] = tmp
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("BeginTimestamp") {
                self.beginTimestamp = dict["BeginTimestamp"] as! String
            }
            if dict.keys.contains("Checkpoint") {
                self.checkpoint = dict["Checkpoint"] as! String
            }
            if dict.keys.contains("ConsumptionCheckpoint") {
                self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
            }
            if dict.keys.contains("ConsumptionClient") {
                self.consumptionClient = dict["ConsumptionClient"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DataEtlStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.DataEtlStatus()
                model.fromMap(dict["DataEtlStatus"] as! [String: Any])
                self.dataEtlStatus = model
            }
            if dict.keys.contains("DataInitializationStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.DataInitializationStatus()
                model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
                self.dataInitializationStatus = model
            }
            if dict.keys.contains("DataSynchronizationStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.DataSynchronizationStatus()
                model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
                self.dataSynchronizationStatus = model
            }
            if dict.keys.contains("DatabaseCount") {
                self.databaseCount = dict["DatabaseCount"] as! Int32
            }
            if dict.keys.contains("DbObject") {
                self.dbObject = dict["DbObject"] as! String
            }
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! Int64
            }
            if dict.keys.contains("DestNetType") {
                self.destNetType = dict["DestNetType"] as! String
            }
            if dict.keys.contains("DestinationEndpoint") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.DestinationEndpoint()
                model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                self.destinationEndpoint = model
            }
            if dict.keys.contains("DtsInstanceID") {
                self.dtsInstanceID = dict["DtsInstanceID"] as! String
            }
            if dict.keys.contains("DtsJobClass") {
                self.dtsJobClass = dict["DtsJobClass"] as! String
            }
            if dict.keys.contains("DtsJobDirection") {
                self.dtsJobDirection = dict["DtsJobDirection"] as! String
            }
            if dict.keys.contains("DtsJobId") {
                self.dtsJobId = dict["DtsJobId"] as! String
            }
            if dict.keys.contains("DtsJobName") {
                self.dtsJobName = dict["DtsJobName"] as! String
            }
            if dict.keys.contains("EndTimestamp") {
                self.endTimestamp = dict["EndTimestamp"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("EtlCalculator") {
                self.etlCalculator = dict["EtlCalculator"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("IsDemoJob") {
                self.isDemoJob = dict["IsDemoJob"] as! Bool
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("MaxDu") {
                self.maxDu = dict["MaxDu"] as! Double
            }
            if dict.keys.contains("MigrationMode") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.MigrationMode()
                model.fromMap(dict["MigrationMode"] as! [String: Any])
                self.migrationMode = model
            }
            if dict.keys.contains("MinDu") {
                self.minDu = dict["MinDu"] as! Double
            }
            if dict.keys.contains("OriginType") {
                self.originType = dict["OriginType"] as! String
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("Performance") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.Performance()
                model.fromMap(dict["Performance"] as! [String: Any])
                self.performance = model
            }
            if dict.keys.contains("PrecheckStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.PrecheckStatus()
                model.fromMap(dict["PrecheckStatus"] as! [String: Any])
                self.precheckStatus = model
            }
            if dict.keys.contains("Reserved") {
                self.reserved = dict["Reserved"] as! String
            }
            if dict.keys.contains("RetryState") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.RetryState()
                model.fromMap(dict["RetryState"] as! [String: Any])
                self.retryState = model
            }
            if dict.keys.contains("ReverseJob") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.ReverseJob()
                model.fromMap(dict["ReverseJob"] as! [String: Any])
                self.reverseJob = model
            }
            if dict.keys.contains("SourceEndpoint") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.SourceEndpoint()
                model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                self.sourceEndpoint = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StructureInitializationStatus") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.StructureInitializationStatus()
                model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
                self.structureInitializationStatus = model
            }
            if dict.keys.contains("SubSyncJob") {
                self.subSyncJob = dict["SubSyncJob"] as! [Any]
            }
            if dict.keys.contains("SubscribeTopic") {
                self.subscribeTopic = dict["SubscribeTopic"] as! String
            }
            if dict.keys.contains("SubscriptionDataType") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.SubscriptionDataType()
                model.fromMap(dict["SubscriptionDataType"] as! [String: Any])
                self.subscriptionDataType = model
            }
            if dict.keys.contains("SubscriptionHost") {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob.SubscriptionHost()
                model.fromMap(dict["SubscriptionHost"] as! [String: Any])
                self.subscriptionHost = model
            }
            if dict.keys.contains("SynchronizationDirection") {
                self.synchronizationDirection = dict["SynchronizationDirection"] as! String
            }
            if dict.keys.contains("TagList") {
                var tmp : [DescribeDtsJobDetailResponseBody.SubSyncJob.TagList] = []
                for v in dict["TagList"] as! [Any] {
                    var model = DescribeDtsJobDetailResponseBody.SubSyncJob.TagList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagList = tmp
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public class SubscriptionDataType : Tea.TeaModel {
        public var ddl: Bool?

        public var dml: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ddl != nil {
                map["Ddl"] = self.ddl!
            }
            if self.dml != nil {
                map["Dml"] = self.dml!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ddl") {
                self.ddl = dict["Ddl"] as! Bool
            }
            if dict.keys.contains("Dml") {
                self.dml = dict["Dml"] as! Bool
            }
        }
    }
    public class SubscriptionHost : Tea.TeaModel {
        public var privateHost: String?

        public var publicHost: String?

        public var vpcHost: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privateHost != nil {
                map["PrivateHost"] = self.privateHost!
            }
            if self.publicHost != nil {
                map["PublicHost"] = self.publicHost!
            }
            if self.vpcHost != nil {
                map["VpcHost"] = self.vpcHost!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrivateHost") {
                self.privateHost = dict["PrivateHost"] as! String
            }
            if dict.keys.contains("PublicHost") {
                self.publicHost = dict["PublicHost"] as! String
            }
            if dict.keys.contains("VpcHost") {
                self.vpcHost = dict["VpcHost"] as! String
            }
        }
    }
    public var appName: String?

    public var beginTimestamp: String?

    public var binlog: String?

    public var binlogSite: String?

    public var binlogTime: String?

    public var bootTime: String?

    public var checkpoint: Int64?

    public var code: Int32?

    public var consumptionCheckpoint: String?

    public var consumptionClient: String?

    public var createTime: String?

    public var dataDeliveryChannelInfo: DescribeDtsJobDetailResponseBody.DataDeliveryChannelInfo?

    public var dataSynchronizationStatus: DescribeDtsJobDetailResponseBody.DataSynchronizationStatus?

    public var databaseCount: Int32?

    public var dbObject: String?

    public var dedicatedClusterId: String?

    public var delay: Int64?

    public var demoJob: Bool?

    public var destNetType: String?

    public var destinationEndpoint: DescribeDtsJobDetailResponseBody.DestinationEndpoint?

    public var dtsBisLabel: String?

    public var dtsInstanceID: String?

    public var dtsJobClass: String?

    public var dtsJobDirection: String?

    public var dtsJobId: String?

    public var dtsJobName: String?

    public var dynamicMessage: String?

    public var endTimestamp: String?

    public var errCode: String?

    public var errMessage: String?

    public var errorMessage: String?

    public var etlCalculator: String?

    public var expireTime: String?

    public var finishTime: String?

    public var groupId: String?

    public var httpStatusCode: Int32?

    public var jobType: String?

    public var lastUpdateTime: String?

    public var maxDu: Double?

    public var migrationMode: DescribeDtsJobDetailResponseBody.MigrationMode?

    public var minDu: Double?

    public var payType: String?

    public var requestId: String?

    public var reserved: String?

    public var resourceGroupDisplayName: String?

    public var resourceGroupId: String?

    public var retryState: DescribeDtsJobDetailResponseBody.RetryState?

    public var sourceEndpoint: DescribeDtsJobDetailResponseBody.SourceEndpoint?

    public var status: String?

    public var subDistributedJob: [DescribeDtsJobDetailResponseBody.SubDistributedJob]?

    public var subSyncJob: [DescribeDtsJobDetailResponseBody.SubSyncJob]?

    public var subscribeTopic: String?

    public var subscriptionDataType: DescribeDtsJobDetailResponseBody.SubscriptionDataType?

    public var subscriptionHost: DescribeDtsJobDetailResponseBody.SubscriptionHost?

    public var success: Bool?

    public var synchronizationDirection: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataDeliveryChannelInfo?.validate()
        try self.dataSynchronizationStatus?.validate()
        try self.destinationEndpoint?.validate()
        try self.migrationMode?.validate()
        try self.retryState?.validate()
        try self.sourceEndpoint?.validate()
        try self.subscriptionDataType?.validate()
        try self.subscriptionHost?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.beginTimestamp != nil {
            map["BeginTimestamp"] = self.beginTimestamp!
        }
        if self.binlog != nil {
            map["Binlog"] = self.binlog!
        }
        if self.binlogSite != nil {
            map["BinlogSite"] = self.binlogSite!
        }
        if self.binlogTime != nil {
            map["BinlogTime"] = self.binlogTime!
        }
        if self.bootTime != nil {
            map["BootTime"] = self.bootTime!
        }
        if self.checkpoint != nil {
            map["Checkpoint"] = self.checkpoint!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.consumptionCheckpoint != nil {
            map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
        }
        if self.consumptionClient != nil {
            map["ConsumptionClient"] = self.consumptionClient!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dataDeliveryChannelInfo != nil {
            map["DataDeliveryChannelInfo"] = self.dataDeliveryChannelInfo?.toMap()
        }
        if self.dataSynchronizationStatus != nil {
            map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
        }
        if self.databaseCount != nil {
            map["DatabaseCount"] = self.databaseCount!
        }
        if self.dbObject != nil {
            map["DbObject"] = self.dbObject!
        }
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.delay != nil {
            map["Delay"] = self.delay!
        }
        if self.demoJob != nil {
            map["DemoJob"] = self.demoJob!
        }
        if self.destNetType != nil {
            map["DestNetType"] = self.destNetType!
        }
        if self.destinationEndpoint != nil {
            map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
        }
        if self.dtsBisLabel != nil {
            map["DtsBisLabel"] = self.dtsBisLabel!
        }
        if self.dtsInstanceID != nil {
            map["DtsInstanceID"] = self.dtsInstanceID!
        }
        if self.dtsJobClass != nil {
            map["DtsJobClass"] = self.dtsJobClass!
        }
        if self.dtsJobDirection != nil {
            map["DtsJobDirection"] = self.dtsJobDirection!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dtsJobName != nil {
            map["DtsJobName"] = self.dtsJobName!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.etlCalculator != nil {
            map["EtlCalculator"] = self.etlCalculator!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.finishTime != nil {
            map["FinishTime"] = self.finishTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.lastUpdateTime != nil {
            map["LastUpdateTime"] = self.lastUpdateTime!
        }
        if self.maxDu != nil {
            map["MaxDu"] = self.maxDu!
        }
        if self.migrationMode != nil {
            map["MigrationMode"] = self.migrationMode?.toMap()
        }
        if self.minDu != nil {
            map["MinDu"] = self.minDu!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reserved != nil {
            map["Reserved"] = self.reserved!
        }
        if self.resourceGroupDisplayName != nil {
            map["ResourceGroupDisplayName"] = self.resourceGroupDisplayName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.retryState != nil {
            map["RetryState"] = self.retryState?.toMap()
        }
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subDistributedJob != nil {
            var tmp : [Any] = []
            for k in self.subDistributedJob! {
                tmp.append(k.toMap())
            }
            map["SubDistributedJob"] = tmp
        }
        if self.subSyncJob != nil {
            var tmp : [Any] = []
            for k in self.subSyncJob! {
                tmp.append(k.toMap())
            }
            map["SubSyncJob"] = tmp
        }
        if self.subscribeTopic != nil {
            map["SubscribeTopic"] = self.subscribeTopic!
        }
        if self.subscriptionDataType != nil {
            map["SubscriptionDataType"] = self.subscriptionDataType?.toMap()
        }
        if self.subscriptionHost != nil {
            map["SubscriptionHost"] = self.subscriptionHost?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BeginTimestamp") {
            self.beginTimestamp = dict["BeginTimestamp"] as! String
        }
        if dict.keys.contains("Binlog") {
            self.binlog = dict["Binlog"] as! String
        }
        if dict.keys.contains("BinlogSite") {
            self.binlogSite = dict["BinlogSite"] as! String
        }
        if dict.keys.contains("BinlogTime") {
            self.binlogTime = dict["BinlogTime"] as! String
        }
        if dict.keys.contains("BootTime") {
            self.bootTime = dict["BootTime"] as! String
        }
        if dict.keys.contains("Checkpoint") {
            self.checkpoint = dict["Checkpoint"] as! Int64
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ConsumptionCheckpoint") {
            self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
        }
        if dict.keys.contains("ConsumptionClient") {
            self.consumptionClient = dict["ConsumptionClient"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("DataDeliveryChannelInfo") {
            var model = DescribeDtsJobDetailResponseBody.DataDeliveryChannelInfo()
            model.fromMap(dict["DataDeliveryChannelInfo"] as! [String: Any])
            self.dataDeliveryChannelInfo = model
        }
        if dict.keys.contains("DataSynchronizationStatus") {
            var model = DescribeDtsJobDetailResponseBody.DataSynchronizationStatus()
            model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
            self.dataSynchronizationStatus = model
        }
        if dict.keys.contains("DatabaseCount") {
            self.databaseCount = dict["DatabaseCount"] as! Int32
        }
        if dict.keys.contains("DbObject") {
            self.dbObject = dict["DbObject"] as! String
        }
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("Delay") {
            self.delay = dict["Delay"] as! Int64
        }
        if dict.keys.contains("DemoJob") {
            self.demoJob = dict["DemoJob"] as! Bool
        }
        if dict.keys.contains("DestNetType") {
            self.destNetType = dict["DestNetType"] as! String
        }
        if dict.keys.contains("DestinationEndpoint") {
            var model = DescribeDtsJobDetailResponseBody.DestinationEndpoint()
            model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
            self.destinationEndpoint = model
        }
        if dict.keys.contains("DtsBisLabel") {
            self.dtsBisLabel = dict["DtsBisLabel"] as! String
        }
        if dict.keys.contains("DtsInstanceID") {
            self.dtsInstanceID = dict["DtsInstanceID"] as! String
        }
        if dict.keys.contains("DtsJobClass") {
            self.dtsJobClass = dict["DtsJobClass"] as! String
        }
        if dict.keys.contains("DtsJobDirection") {
            self.dtsJobDirection = dict["DtsJobDirection"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DtsJobName") {
            self.dtsJobName = dict["DtsJobName"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("EtlCalculator") {
            self.etlCalculator = dict["EtlCalculator"] as! String
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! String
        }
        if dict.keys.contains("FinishTime") {
            self.finishTime = dict["FinishTime"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("LastUpdateTime") {
            self.lastUpdateTime = dict["LastUpdateTime"] as! String
        }
        if dict.keys.contains("MaxDu") {
            self.maxDu = dict["MaxDu"] as! Double
        }
        if dict.keys.contains("MigrationMode") {
            var model = DescribeDtsJobDetailResponseBody.MigrationMode()
            model.fromMap(dict["MigrationMode"] as! [String: Any])
            self.migrationMode = model
        }
        if dict.keys.contains("MinDu") {
            self.minDu = dict["MinDu"] as! Double
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Reserved") {
            self.reserved = dict["Reserved"] as! String
        }
        if dict.keys.contains("ResourceGroupDisplayName") {
            self.resourceGroupDisplayName = dict["ResourceGroupDisplayName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RetryState") {
            var model = DescribeDtsJobDetailResponseBody.RetryState()
            model.fromMap(dict["RetryState"] as! [String: Any])
            self.retryState = model
        }
        if dict.keys.contains("SourceEndpoint") {
            var model = DescribeDtsJobDetailResponseBody.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SubDistributedJob") {
            var tmp : [DescribeDtsJobDetailResponseBody.SubDistributedJob] = []
            for v in dict["SubDistributedJob"] as! [Any] {
                var model = DescribeDtsJobDetailResponseBody.SubDistributedJob()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.subDistributedJob = tmp
        }
        if dict.keys.contains("SubSyncJob") {
            var tmp : [DescribeDtsJobDetailResponseBody.SubSyncJob] = []
            for v in dict["SubSyncJob"] as! [Any] {
                var model = DescribeDtsJobDetailResponseBody.SubSyncJob()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.subSyncJob = tmp
        }
        if dict.keys.contains("SubscribeTopic") {
            self.subscribeTopic = dict["SubscribeTopic"] as! String
        }
        if dict.keys.contains("SubscriptionDataType") {
            var model = DescribeDtsJobDetailResponseBody.SubscriptionDataType()
            model.fromMap(dict["SubscriptionDataType"] as! [String: Any])
            self.subscriptionDataType = model
        }
        if dict.keys.contains("SubscriptionHost") {
            var model = DescribeDtsJobDetailResponseBody.SubscriptionHost()
            model.fromMap(dict["SubscriptionHost"] as! [String: Any])
            self.subscriptionHost = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class DescribeDtsJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDtsJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDtsJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDtsJobsRequest : Tea.TeaModel {
    public var dedicatedClusterId: String?

    public var destProductType: String?

    public var dtsBisLabel: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var groupId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var jobType: String?

    public var orderColumn: String?

    public var orderDirection: String?

    public var ownerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var params: String?

    public var region: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var srcProductType: String?

    public var status: String?

    public var tags: String?

    public var type: String?

    public var withoutDbList: Bool?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.destProductType != nil {
            map["DestProductType"] = self.destProductType!
        }
        if self.dtsBisLabel != nil {
            map["DtsBisLabel"] = self.dtsBisLabel!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.orderColumn != nil {
            map["OrderColumn"] = self.orderColumn!
        }
        if self.orderDirection != nil {
            map["OrderDirection"] = self.orderDirection!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.srcProductType != nil {
            map["SrcProductType"] = self.srcProductType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.withoutDbList != nil {
            map["WithoutDbList"] = self.withoutDbList!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DestProductType") {
            self.destProductType = dict["DestProductType"] as! String
        }
        if dict.keys.contains("DtsBisLabel") {
            self.dtsBisLabel = dict["DtsBisLabel"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("JobType") {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("OrderColumn") {
            self.orderColumn = dict["OrderColumn"] as! String
        }
        if dict.keys.contains("OrderDirection") {
            self.orderDirection = dict["OrderDirection"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SrcProductType") {
            self.srcProductType = dict["SrcProductType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WithoutDbList") {
            self.withoutDbList = dict["WithoutDbList"] as! Bool
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class DescribeDtsJobsResponseBody : Tea.TeaModel {
    public class DtsJobList : Tea.TeaModel {
        public class DataCloudStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataEtlStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataSynchronizationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DestinationEndpoint : Tea.TeaModel {
            public var databaseName: String?

            public var engineName: String?

            public var instanceID: String?

            public var instanceType: String?

            public var ip: String?

            public var oracleSID: String?

            public var port: String?

            public var region: String?

            public var sslSolutionEnum: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.instanceID != nil {
                    map["InstanceID"] = self.instanceID!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.oracleSID != nil {
                    map["OracleSID"] = self.oracleSID!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.sslSolutionEnum != nil {
                    map["SslSolutionEnum"] = self.sslSolutionEnum!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("InstanceID") {
                    self.instanceID = dict["InstanceID"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("OracleSID") {
                    self.oracleSID = dict["OracleSID"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("SslSolutionEnum") {
                    self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class ErrorDetails : Tea.TeaModel {
            public var errorCode: String?

            public var helpUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.helpUrl != nil {
                    map["HelpUrl"] = self.helpUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("HelpUrl") {
                    self.helpUrl = dict["HelpUrl"] as! String
                }
            }
        }
        public class FullDataCheckStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class IncDataCheckStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class MigrationMode : Tea.TeaModel {
            public var dataInitialization: Bool?

            public var dataSynchronization: Bool?

            public var fullDataCheck: Bool?

            public var incDataCheck: Bool?

            public var structureInitialization: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataInitialization != nil {
                    map["DataInitialization"] = self.dataInitialization!
                }
                if self.dataSynchronization != nil {
                    map["DataSynchronization"] = self.dataSynchronization!
                }
                if self.fullDataCheck != nil {
                    map["FullDataCheck"] = self.fullDataCheck!
                }
                if self.incDataCheck != nil {
                    map["IncDataCheck"] = self.incDataCheck!
                }
                if self.structureInitialization != nil {
                    map["StructureInitialization"] = self.structureInitialization!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataInitialization") {
                    self.dataInitialization = dict["DataInitialization"] as! Bool
                }
                if dict.keys.contains("DataSynchronization") {
                    self.dataSynchronization = dict["DataSynchronization"] as! Bool
                }
                if dict.keys.contains("FullDataCheck") {
                    self.fullDataCheck = dict["FullDataCheck"] as! Bool
                }
                if dict.keys.contains("IncDataCheck") {
                    self.incDataCheck = dict["IncDataCheck"] as! Bool
                }
                if dict.keys.contains("StructureInitialization") {
                    self.structureInitialization = dict["StructureInitialization"] as! Bool
                }
            }
        }
        public class Performance : Tea.TeaModel {
            public var flow: String?

            public var rps: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flow != nil {
                    map["Flow"] = self.flow!
                }
                if self.rps != nil {
                    map["Rps"] = self.rps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Flow") {
                    self.flow = dict["Flow"] as! String
                }
                if dict.keys.contains("Rps") {
                    self.rps = dict["Rps"] as! String
                }
            }
        }
        public class PrecheckStatus : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var checkItem: String?

                public var checkItemDescription: String?

                public var checkResult: String?

                public var failedReason: String?

                public var repairMethod: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItem != nil {
                        map["CheckItem"] = self.checkItem!
                    }
                    if self.checkItemDescription != nil {
                        map["CheckItemDescription"] = self.checkItemDescription!
                    }
                    if self.checkResult != nil {
                        map["CheckResult"] = self.checkResult!
                    }
                    if self.failedReason != nil {
                        map["FailedReason"] = self.failedReason!
                    }
                    if self.repairMethod != nil {
                        map["RepairMethod"] = self.repairMethod!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckItem") {
                        self.checkItem = dict["CheckItem"] as! String
                    }
                    if dict.keys.contains("CheckItemDescription") {
                        self.checkItemDescription = dict["CheckItemDescription"] as! String
                    }
                    if dict.keys.contains("CheckResult") {
                        self.checkResult = dict["CheckResult"] as! String
                    }
                    if dict.keys.contains("FailedReason") {
                        self.failedReason = dict["FailedReason"] as! String
                    }
                    if dict.keys.contains("RepairMethod") {
                        self.repairMethod = dict["RepairMethod"] as! String
                    }
                }
            }
            public var detail: [DescribeDtsJobsResponseBody.DtsJobList.PrecheckStatus.Detail]?

            public var errorMessage: String?

            public var percent: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    var tmp : [Any] = []
                    for k in self.detail! {
                        tmp.append(k.toMap())
                    }
                    map["Detail"] = tmp
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Detail") {
                    var tmp : [DescribeDtsJobsResponseBody.DtsJobList.PrecheckStatus.Detail] = []
                    for v in dict["Detail"] as! [Any] {
                        var model = DescribeDtsJobsResponseBody.DtsJobList.PrecheckStatus.Detail()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.detail = tmp
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RetryState : Tea.TeaModel {
            public var errMessage: String?

            public var jobId: String?

            public var maxRetryTime: Int32?

            public var migrationErrCode: String?

            public var migrationErrHelpDocId: String?

            public var migrationErrHelpDocKey: String?

            public var migrationErrMsg: String?

            public var migrationErrType: String?

            public var migrationErrWorkaround: String?

            public var module: String?

            public var retryCount: Int32?

            public var retryTarget: String?

            public var retryTime: Int32?

            public var retrying: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errMessage != nil {
                    map["ErrMessage"] = self.errMessage!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.maxRetryTime != nil {
                    map["MaxRetryTime"] = self.maxRetryTime!
                }
                if self.migrationErrCode != nil {
                    map["MigrationErrCode"] = self.migrationErrCode!
                }
                if self.migrationErrHelpDocId != nil {
                    map["MigrationErrHelpDocId"] = self.migrationErrHelpDocId!
                }
                if self.migrationErrHelpDocKey != nil {
                    map["MigrationErrHelpDocKey"] = self.migrationErrHelpDocKey!
                }
                if self.migrationErrMsg != nil {
                    map["MigrationErrMsg"] = self.migrationErrMsg!
                }
                if self.migrationErrType != nil {
                    map["MigrationErrType"] = self.migrationErrType!
                }
                if self.migrationErrWorkaround != nil {
                    map["MigrationErrWorkaround"] = self.migrationErrWorkaround!
                }
                if self.module != nil {
                    map["Module"] = self.module!
                }
                if self.retryCount != nil {
                    map["RetryCount"] = self.retryCount!
                }
                if self.retryTarget != nil {
                    map["RetryTarget"] = self.retryTarget!
                }
                if self.retryTime != nil {
                    map["RetryTime"] = self.retryTime!
                }
                if self.retrying != nil {
                    map["Retrying"] = self.retrying!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrMessage") {
                    self.errMessage = dict["ErrMessage"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MaxRetryTime") {
                    self.maxRetryTime = dict["MaxRetryTime"] as! Int32
                }
                if dict.keys.contains("MigrationErrCode") {
                    self.migrationErrCode = dict["MigrationErrCode"] as! String
                }
                if dict.keys.contains("MigrationErrHelpDocId") {
                    self.migrationErrHelpDocId = dict["MigrationErrHelpDocId"] as! String
                }
                if dict.keys.contains("MigrationErrHelpDocKey") {
                    self.migrationErrHelpDocKey = dict["MigrationErrHelpDocKey"] as! String
                }
                if dict.keys.contains("MigrationErrMsg") {
                    self.migrationErrMsg = dict["MigrationErrMsg"] as! String
                }
                if dict.keys.contains("MigrationErrType") {
                    self.migrationErrType = dict["MigrationErrType"] as! String
                }
                if dict.keys.contains("MigrationErrWorkaround") {
                    self.migrationErrWorkaround = dict["MigrationErrWorkaround"] as! String
                }
                if dict.keys.contains("Module") {
                    self.module = dict["Module"] as! String
                }
                if dict.keys.contains("RetryCount") {
                    self.retryCount = dict["RetryCount"] as! Int32
                }
                if dict.keys.contains("RetryTarget") {
                    self.retryTarget = dict["RetryTarget"] as! String
                }
                if dict.keys.contains("RetryTime") {
                    self.retryTime = dict["RetryTime"] as! Int32
                }
                if dict.keys.contains("Retrying") {
                    self.retrying = dict["Retrying"] as! Bool
                }
            }
        }
        public class ReverseJob : Tea.TeaModel {
            public class DataInitializationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DataSynchronizationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DestinationEndpoint : Tea.TeaModel {
                public var databaseName: String?

                public var engineName: String?

                public var instanceID: String?

                public var instanceType: String?

                public var ip: String?

                public var oracleSID: String?

                public var port: String?

                public var region: String?

                public var sslSolutionEnum: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.sslSolutionEnum != nil {
                        map["SslSolutionEnum"] = self.sslSolutionEnum!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("SslSolutionEnum") {
                        self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class ErrorDetails : Tea.TeaModel {
                public var errorCode: String?

                public var helpUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.helpUrl != nil {
                        map["HelpUrl"] = self.helpUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("HelpUrl") {
                        self.helpUrl = dict["HelpUrl"] as! String
                    }
                }
            }
            public class FullDataCheckStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class IncDataCheckStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class MigrationMode : Tea.TeaModel {
                public var dataInitialization: Bool?

                public var dataSynchronization: Bool?

                public var fullDataCheck: Bool?

                public var incDataCheck: Bool?

                public var structureInitialization: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataInitialization != nil {
                        map["DataInitialization"] = self.dataInitialization!
                    }
                    if self.dataSynchronization != nil {
                        map["DataSynchronization"] = self.dataSynchronization!
                    }
                    if self.fullDataCheck != nil {
                        map["FullDataCheck"] = self.fullDataCheck!
                    }
                    if self.incDataCheck != nil {
                        map["IncDataCheck"] = self.incDataCheck!
                    }
                    if self.structureInitialization != nil {
                        map["StructureInitialization"] = self.structureInitialization!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataInitialization") {
                        self.dataInitialization = dict["DataInitialization"] as! Bool
                    }
                    if dict.keys.contains("DataSynchronization") {
                        self.dataSynchronization = dict["DataSynchronization"] as! Bool
                    }
                    if dict.keys.contains("FullDataCheck") {
                        self.fullDataCheck = dict["FullDataCheck"] as! Bool
                    }
                    if dict.keys.contains("IncDataCheck") {
                        self.incDataCheck = dict["IncDataCheck"] as! Bool
                    }
                    if dict.keys.contains("StructureInitialization") {
                        self.structureInitialization = dict["StructureInitialization"] as! Bool
                    }
                }
            }
            public class Performance : Tea.TeaModel {
                public var flow: String?

                public var rps: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.flow != nil {
                        map["Flow"] = self.flow!
                    }
                    if self.rps != nil {
                        map["Rps"] = self.rps!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Flow") {
                        self.flow = dict["Flow"] as! String
                    }
                    if dict.keys.contains("Rps") {
                        self.rps = dict["Rps"] as! String
                    }
                }
            }
            public class PrecheckStatus : Tea.TeaModel {
                public class Detail : Tea.TeaModel {
                    public var checkItem: String?

                    public var checkItemDescription: String?

                    public var checkResult: String?

                    public var failedReason: String?

                    public var repairMethod: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.checkItem != nil {
                            map["CheckItem"] = self.checkItem!
                        }
                        if self.checkItemDescription != nil {
                            map["CheckItemDescription"] = self.checkItemDescription!
                        }
                        if self.checkResult != nil {
                            map["CheckResult"] = self.checkResult!
                        }
                        if self.failedReason != nil {
                            map["FailedReason"] = self.failedReason!
                        }
                        if self.repairMethod != nil {
                            map["RepairMethod"] = self.repairMethod!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CheckItem") {
                            self.checkItem = dict["CheckItem"] as! String
                        }
                        if dict.keys.contains("CheckItemDescription") {
                            self.checkItemDescription = dict["CheckItemDescription"] as! String
                        }
                        if dict.keys.contains("CheckResult") {
                            self.checkResult = dict["CheckResult"] as! String
                        }
                        if dict.keys.contains("FailedReason") {
                            self.failedReason = dict["FailedReason"] as! String
                        }
                        if dict.keys.contains("RepairMethod") {
                            self.repairMethod = dict["RepairMethod"] as! String
                        }
                    }
                }
                public var detail: [DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.PrecheckStatus.Detail]?

                public var errorMessage: String?

                public var percent: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detail != nil {
                        var tmp : [Any] = []
                        for k in self.detail! {
                            tmp.append(k.toMap())
                        }
                        map["Detail"] = tmp
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Detail") {
                        var tmp : [DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.PrecheckStatus.Detail] = []
                        for v in dict["Detail"] as! [Any] {
                            var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.PrecheckStatus.Detail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.detail = tmp
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class SourceEndpoint : Tea.TeaModel {
                public var databaseName: String?

                public var engineName: String?

                public var instanceID: String?

                public var instanceType: String?

                public var ip: String?

                public var oracleSID: String?

                public var port: String?

                public var region: String?

                public var sslSolutionEnum: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.sslSolutionEnum != nil {
                        map["SslSolutionEnum"] = self.sslSolutionEnum!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("SslSolutionEnum") {
                        self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class StructureInitializationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var checkpoint: String?

            public var cpuUsage: String?

            public var createTime: String?

            public var dataInitializationStatus: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.DataInitializationStatus?

            public var dataSynchronizationStatus: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.DataSynchronizationStatus?

            public var dbObject: String?

            public var dedicatedClusterId: String?

            public var delay: Int64?

            public var destinationEndpoint: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.DestinationEndpoint?

            public var dtsInstanceID: String?

            public var dtsJobClass: String?

            public var dtsJobDirection: String?

            public var dtsJobId: String?

            public var dtsJobName: String?

            public var duUsage: Int64?

            public var errorDetails: [DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.ErrorDetails]?

            public var errorMessage: String?

            public var etlSafeCheckpoint: String?

            public var expireTime: String?

            public var fullDataCheckStatus: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.FullDataCheckStatus?

            public var incDataCheckStatus: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.IncDataCheckStatus?

            public var maxDu: Double?

            public var memUsage: String?

            public var migrationMode: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.MigrationMode?

            public var minDu: Double?

            public var payType: String?

            public var performance: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.Performance?

            public var precheckStatus: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.PrecheckStatus?

            public var reserved: String?

            public var sourceEndpoint: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.SourceEndpoint?

            public var status: String?

            public var structureInitializationStatus: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.StructureInitializationStatus?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataInitializationStatus?.validate()
                try self.dataSynchronizationStatus?.validate()
                try self.destinationEndpoint?.validate()
                try self.fullDataCheckStatus?.validate()
                try self.incDataCheckStatus?.validate()
                try self.migrationMode?.validate()
                try self.performance?.validate()
                try self.precheckStatus?.validate()
                try self.sourceEndpoint?.validate()
                try self.structureInitializationStatus?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkpoint != nil {
                    map["Checkpoint"] = self.checkpoint!
                }
                if self.cpuUsage != nil {
                    map["CpuUsage"] = self.cpuUsage!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataInitializationStatus != nil {
                    map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
                }
                if self.dataSynchronizationStatus != nil {
                    map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
                }
                if self.dbObject != nil {
                    map["DbObject"] = self.dbObject!
                }
                if self.dedicatedClusterId != nil {
                    map["DedicatedClusterId"] = self.dedicatedClusterId!
                }
                if self.delay != nil {
                    map["Delay"] = self.delay!
                }
                if self.destinationEndpoint != nil {
                    map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
                }
                if self.dtsInstanceID != nil {
                    map["DtsInstanceID"] = self.dtsInstanceID!
                }
                if self.dtsJobClass != nil {
                    map["DtsJobClass"] = self.dtsJobClass!
                }
                if self.dtsJobDirection != nil {
                    map["DtsJobDirection"] = self.dtsJobDirection!
                }
                if self.dtsJobId != nil {
                    map["DtsJobId"] = self.dtsJobId!
                }
                if self.dtsJobName != nil {
                    map["DtsJobName"] = self.dtsJobName!
                }
                if self.duUsage != nil {
                    map["DuUsage"] = self.duUsage!
                }
                if self.errorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.errorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorDetails"] = tmp
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.etlSafeCheckpoint != nil {
                    map["EtlSafeCheckpoint"] = self.etlSafeCheckpoint!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.fullDataCheckStatus != nil {
                    map["FullDataCheckStatus"] = self.fullDataCheckStatus?.toMap()
                }
                if self.incDataCheckStatus != nil {
                    map["IncDataCheckStatus"] = self.incDataCheckStatus?.toMap()
                }
                if self.maxDu != nil {
                    map["MaxDu"] = self.maxDu!
                }
                if self.memUsage != nil {
                    map["MemUsage"] = self.memUsage!
                }
                if self.migrationMode != nil {
                    map["MigrationMode"] = self.migrationMode?.toMap()
                }
                if self.minDu != nil {
                    map["MinDu"] = self.minDu!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.performance != nil {
                    map["Performance"] = self.performance?.toMap()
                }
                if self.precheckStatus != nil {
                    map["PrecheckStatus"] = self.precheckStatus?.toMap()
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.sourceEndpoint != nil {
                    map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.structureInitializationStatus != nil {
                    map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Checkpoint") {
                    self.checkpoint = dict["Checkpoint"] as! String
                }
                if dict.keys.contains("CpuUsage") {
                    self.cpuUsage = dict["CpuUsage"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DataInitializationStatus") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.DataInitializationStatus()
                    model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
                    self.dataInitializationStatus = model
                }
                if dict.keys.contains("DataSynchronizationStatus") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.DataSynchronizationStatus()
                    model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
                    self.dataSynchronizationStatus = model
                }
                if dict.keys.contains("DbObject") {
                    self.dbObject = dict["DbObject"] as! String
                }
                if dict.keys.contains("DedicatedClusterId") {
                    self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
                }
                if dict.keys.contains("Delay") {
                    self.delay = dict["Delay"] as! Int64
                }
                if dict.keys.contains("DestinationEndpoint") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.DestinationEndpoint()
                    model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                    self.destinationEndpoint = model
                }
                if dict.keys.contains("DtsInstanceID") {
                    self.dtsInstanceID = dict["DtsInstanceID"] as! String
                }
                if dict.keys.contains("DtsJobClass") {
                    self.dtsJobClass = dict["DtsJobClass"] as! String
                }
                if dict.keys.contains("DtsJobDirection") {
                    self.dtsJobDirection = dict["DtsJobDirection"] as! String
                }
                if dict.keys.contains("DtsJobId") {
                    self.dtsJobId = dict["DtsJobId"] as! String
                }
                if dict.keys.contains("DtsJobName") {
                    self.dtsJobName = dict["DtsJobName"] as! String
                }
                if dict.keys.contains("DuUsage") {
                    self.duUsage = dict["DuUsage"] as! Int64
                }
                if dict.keys.contains("ErrorDetails") {
                    var tmp : [DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.ErrorDetails] = []
                    for v in dict["ErrorDetails"] as! [Any] {
                        var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.ErrorDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorDetails = tmp
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("EtlSafeCheckpoint") {
                    self.etlSafeCheckpoint = dict["EtlSafeCheckpoint"] as! String
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("FullDataCheckStatus") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.FullDataCheckStatus()
                    model.fromMap(dict["FullDataCheckStatus"] as! [String: Any])
                    self.fullDataCheckStatus = model
                }
                if dict.keys.contains("IncDataCheckStatus") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.IncDataCheckStatus()
                    model.fromMap(dict["IncDataCheckStatus"] as! [String: Any])
                    self.incDataCheckStatus = model
                }
                if dict.keys.contains("MaxDu") {
                    self.maxDu = dict["MaxDu"] as! Double
                }
                if dict.keys.contains("MemUsage") {
                    self.memUsage = dict["MemUsage"] as! String
                }
                if dict.keys.contains("MigrationMode") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.MigrationMode()
                    model.fromMap(dict["MigrationMode"] as! [String: Any])
                    self.migrationMode = model
                }
                if dict.keys.contains("MinDu") {
                    self.minDu = dict["MinDu"] as! Double
                }
                if dict.keys.contains("PayType") {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("Performance") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.Performance()
                    model.fromMap(dict["Performance"] as! [String: Any])
                    self.performance = model
                }
                if dict.keys.contains("PrecheckStatus") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.PrecheckStatus()
                    model.fromMap(dict["PrecheckStatus"] as! [String: Any])
                    self.precheckStatus = model
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! String
                }
                if dict.keys.contains("SourceEndpoint") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.SourceEndpoint()
                    model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                    self.sourceEndpoint = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StructureInitializationStatus") {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob.StructureInitializationStatus()
                    model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
                    self.structureInitializationStatus = model
                }
            }
        }
        public class SourceEndpoint : Tea.TeaModel {
            public var databaseName: String?

            public var engineName: String?

            public var instanceID: String?

            public var instanceType: String?

            public var ip: String?

            public var oracleSID: String?

            public var port: String?

            public var region: String?

            public var sslSolutionEnum: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.instanceID != nil {
                    map["InstanceID"] = self.instanceID!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.oracleSID != nil {
                    map["OracleSID"] = self.oracleSID!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.sslSolutionEnum != nil {
                    map["SslSolutionEnum"] = self.sslSolutionEnum!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("InstanceID") {
                    self.instanceID = dict["InstanceID"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("OracleSID") {
                    self.oracleSID = dict["OracleSID"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("SslSolutionEnum") {
                    self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class StructureInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class TagList : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var appName: String?

        public var beginTimestamp: String?

        public var checkpoint: String?

        public var consumptionCheckpoint: String?

        public var consumptionClient: String?

        public var cpuUsage: String?

        public var createTime: String?

        public var dataCloudStatus: DescribeDtsJobsResponseBody.DtsJobList.DataCloudStatus?

        public var dataEtlStatus: DescribeDtsJobsResponseBody.DtsJobList.DataEtlStatus?

        public var dataInitializationStatus: DescribeDtsJobsResponseBody.DtsJobList.DataInitializationStatus?

        public var dataSynchronizationStatus: DescribeDtsJobsResponseBody.DtsJobList.DataSynchronizationStatus?

        public var dbObject: String?

        public var dedicatedClusterId: String?

        public var delay: Int64?

        public var destinationEndpoint: DescribeDtsJobsResponseBody.DtsJobList.DestinationEndpoint?

        public var dtsBisLabel: String?

        public var dtsInstanceID: String?

        public var dtsJobClass: String?

        public var dtsJobDirection: String?

        public var dtsJobId: String?

        public var dtsJobName: String?

        public var duRealUsage: String?

        public var duUsage: Int64?

        public var endTimestamp: String?

        public var errorDetails: [DescribeDtsJobsResponseBody.DtsJobList.ErrorDetails]?

        public var errorMessage: String?

        public var etlSafeCheckpoint: String?

        public var expireTime: String?

        public var fullDataCheckStatus: DescribeDtsJobsResponseBody.DtsJobList.FullDataCheckStatus?

        public var incDataCheckStatus: DescribeDtsJobsResponseBody.DtsJobList.IncDataCheckStatus?

        public var jobType: String?

        public var maxDu: Double?

        public var memUsage: String?

        public var migrationErrCode: String?

        public var migrationErrHelpDocId: String?

        public var migrationErrHelpDocKey: String?

        public var migrationErrMsg: String?

        public var migrationErrType: String?

        public var migrationErrWorkaround: String?

        public var migrationMode: DescribeDtsJobsResponseBody.DtsJobList.MigrationMode?

        public var minDu: Double?

        public var originType: String?

        public var payType: String?

        public var performance: DescribeDtsJobsResponseBody.DtsJobList.Performance?

        public var precheckStatus: DescribeDtsJobsResponseBody.DtsJobList.PrecheckStatus?

        public var reserved: String?

        public var resourceGroupDisplayName: String?

        public var resourceGroupId: String?

        public var retryState: DescribeDtsJobsResponseBody.DtsJobList.RetryState?

        public var reverseJob: DescribeDtsJobsResponseBody.DtsJobList.ReverseJob?

        public var sourceEndpoint: DescribeDtsJobsResponseBody.DtsJobList.SourceEndpoint?

        public var status: String?

        public var structureInitializationStatus: DescribeDtsJobsResponseBody.DtsJobList.StructureInitializationStatus?

        public var tagList: [DescribeDtsJobsResponseBody.DtsJobList.TagList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataCloudStatus?.validate()
            try self.dataEtlStatus?.validate()
            try self.dataInitializationStatus?.validate()
            try self.dataSynchronizationStatus?.validate()
            try self.destinationEndpoint?.validate()
            try self.fullDataCheckStatus?.validate()
            try self.incDataCheckStatus?.validate()
            try self.migrationMode?.validate()
            try self.performance?.validate()
            try self.precheckStatus?.validate()
            try self.retryState?.validate()
            try self.reverseJob?.validate()
            try self.sourceEndpoint?.validate()
            try self.structureInitializationStatus?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.beginTimestamp != nil {
                map["BeginTimestamp"] = self.beginTimestamp!
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint!
            }
            if self.consumptionCheckpoint != nil {
                map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
            }
            if self.consumptionClient != nil {
                map["ConsumptionClient"] = self.consumptionClient!
            }
            if self.cpuUsage != nil {
                map["CpuUsage"] = self.cpuUsage!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataCloudStatus != nil {
                map["DataCloudStatus"] = self.dataCloudStatus?.toMap()
            }
            if self.dataEtlStatus != nil {
                map["DataEtlStatus"] = self.dataEtlStatus?.toMap()
            }
            if self.dataInitializationStatus != nil {
                map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
            }
            if self.dataSynchronizationStatus != nil {
                map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
            }
            if self.dbObject != nil {
                map["DbObject"] = self.dbObject!
            }
            if self.dedicatedClusterId != nil {
                map["DedicatedClusterId"] = self.dedicatedClusterId!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.destinationEndpoint != nil {
                map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
            }
            if self.dtsBisLabel != nil {
                map["DtsBisLabel"] = self.dtsBisLabel!
            }
            if self.dtsInstanceID != nil {
                map["DtsInstanceID"] = self.dtsInstanceID!
            }
            if self.dtsJobClass != nil {
                map["DtsJobClass"] = self.dtsJobClass!
            }
            if self.dtsJobDirection != nil {
                map["DtsJobDirection"] = self.dtsJobDirection!
            }
            if self.dtsJobId != nil {
                map["DtsJobId"] = self.dtsJobId!
            }
            if self.dtsJobName != nil {
                map["DtsJobName"] = self.dtsJobName!
            }
            if self.duRealUsage != nil {
                map["DuRealUsage"] = self.duRealUsage!
            }
            if self.duUsage != nil {
                map["DuUsage"] = self.duUsage!
            }
            if self.endTimestamp != nil {
                map["EndTimestamp"] = self.endTimestamp!
            }
            if self.errorDetails != nil {
                var tmp : [Any] = []
                for k in self.errorDetails! {
                    tmp.append(k.toMap())
                }
                map["ErrorDetails"] = tmp
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.etlSafeCheckpoint != nil {
                map["EtlSafeCheckpoint"] = self.etlSafeCheckpoint!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.fullDataCheckStatus != nil {
                map["FullDataCheckStatus"] = self.fullDataCheckStatus?.toMap()
            }
            if self.incDataCheckStatus != nil {
                map["IncDataCheckStatus"] = self.incDataCheckStatus?.toMap()
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.maxDu != nil {
                map["MaxDu"] = self.maxDu!
            }
            if self.memUsage != nil {
                map["MemUsage"] = self.memUsage!
            }
            if self.migrationErrCode != nil {
                map["MigrationErrCode"] = self.migrationErrCode!
            }
            if self.migrationErrHelpDocId != nil {
                map["MigrationErrHelpDocId"] = self.migrationErrHelpDocId!
            }
            if self.migrationErrHelpDocKey != nil {
                map["MigrationErrHelpDocKey"] = self.migrationErrHelpDocKey!
            }
            if self.migrationErrMsg != nil {
                map["MigrationErrMsg"] = self.migrationErrMsg!
            }
            if self.migrationErrType != nil {
                map["MigrationErrType"] = self.migrationErrType!
            }
            if self.migrationErrWorkaround != nil {
                map["MigrationErrWorkaround"] = self.migrationErrWorkaround!
            }
            if self.migrationMode != nil {
                map["MigrationMode"] = self.migrationMode?.toMap()
            }
            if self.minDu != nil {
                map["MinDu"] = self.minDu!
            }
            if self.originType != nil {
                map["OriginType"] = self.originType!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.performance != nil {
                map["Performance"] = self.performance?.toMap()
            }
            if self.precheckStatus != nil {
                map["PrecheckStatus"] = self.precheckStatus?.toMap()
            }
            if self.reserved != nil {
                map["Reserved"] = self.reserved!
            }
            if self.resourceGroupDisplayName != nil {
                map["ResourceGroupDisplayName"] = self.resourceGroupDisplayName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.retryState != nil {
                map["RetryState"] = self.retryState?.toMap()
            }
            if self.reverseJob != nil {
                map["ReverseJob"] = self.reverseJob?.toMap()
            }
            if self.sourceEndpoint != nil {
                map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.structureInitializationStatus != nil {
                map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
            }
            if self.tagList != nil {
                var tmp : [Any] = []
                for k in self.tagList! {
                    tmp.append(k.toMap())
                }
                map["TagList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("BeginTimestamp") {
                self.beginTimestamp = dict["BeginTimestamp"] as! String
            }
            if dict.keys.contains("Checkpoint") {
                self.checkpoint = dict["Checkpoint"] as! String
            }
            if dict.keys.contains("ConsumptionCheckpoint") {
                self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
            }
            if dict.keys.contains("ConsumptionClient") {
                self.consumptionClient = dict["ConsumptionClient"] as! String
            }
            if dict.keys.contains("CpuUsage") {
                self.cpuUsage = dict["CpuUsage"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DataCloudStatus") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.DataCloudStatus()
                model.fromMap(dict["DataCloudStatus"] as! [String: Any])
                self.dataCloudStatus = model
            }
            if dict.keys.contains("DataEtlStatus") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.DataEtlStatus()
                model.fromMap(dict["DataEtlStatus"] as! [String: Any])
                self.dataEtlStatus = model
            }
            if dict.keys.contains("DataInitializationStatus") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.DataInitializationStatus()
                model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
                self.dataInitializationStatus = model
            }
            if dict.keys.contains("DataSynchronizationStatus") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.DataSynchronizationStatus()
                model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
                self.dataSynchronizationStatus = model
            }
            if dict.keys.contains("DbObject") {
                self.dbObject = dict["DbObject"] as! String
            }
            if dict.keys.contains("DedicatedClusterId") {
                self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
            }
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! Int64
            }
            if dict.keys.contains("DestinationEndpoint") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.DestinationEndpoint()
                model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                self.destinationEndpoint = model
            }
            if dict.keys.contains("DtsBisLabel") {
                self.dtsBisLabel = dict["DtsBisLabel"] as! String
            }
            if dict.keys.contains("DtsInstanceID") {
                self.dtsInstanceID = dict["DtsInstanceID"] as! String
            }
            if dict.keys.contains("DtsJobClass") {
                self.dtsJobClass = dict["DtsJobClass"] as! String
            }
            if dict.keys.contains("DtsJobDirection") {
                self.dtsJobDirection = dict["DtsJobDirection"] as! String
            }
            if dict.keys.contains("DtsJobId") {
                self.dtsJobId = dict["DtsJobId"] as! String
            }
            if dict.keys.contains("DtsJobName") {
                self.dtsJobName = dict["DtsJobName"] as! String
            }
            if dict.keys.contains("DuRealUsage") {
                self.duRealUsage = dict["DuRealUsage"] as! String
            }
            if dict.keys.contains("DuUsage") {
                self.duUsage = dict["DuUsage"] as! Int64
            }
            if dict.keys.contains("EndTimestamp") {
                self.endTimestamp = dict["EndTimestamp"] as! String
            }
            if dict.keys.contains("ErrorDetails") {
                var tmp : [DescribeDtsJobsResponseBody.DtsJobList.ErrorDetails] = []
                for v in dict["ErrorDetails"] as! [Any] {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.ErrorDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorDetails = tmp
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("EtlSafeCheckpoint") {
                self.etlSafeCheckpoint = dict["EtlSafeCheckpoint"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("FullDataCheckStatus") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.FullDataCheckStatus()
                model.fromMap(dict["FullDataCheckStatus"] as! [String: Any])
                self.fullDataCheckStatus = model
            }
            if dict.keys.contains("IncDataCheckStatus") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.IncDataCheckStatus()
                model.fromMap(dict["IncDataCheckStatus"] as! [String: Any])
                self.incDataCheckStatus = model
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("MaxDu") {
                self.maxDu = dict["MaxDu"] as! Double
            }
            if dict.keys.contains("MemUsage") {
                self.memUsage = dict["MemUsage"] as! String
            }
            if dict.keys.contains("MigrationErrCode") {
                self.migrationErrCode = dict["MigrationErrCode"] as! String
            }
            if dict.keys.contains("MigrationErrHelpDocId") {
                self.migrationErrHelpDocId = dict["MigrationErrHelpDocId"] as! String
            }
            if dict.keys.contains("MigrationErrHelpDocKey") {
                self.migrationErrHelpDocKey = dict["MigrationErrHelpDocKey"] as! String
            }
            if dict.keys.contains("MigrationErrMsg") {
                self.migrationErrMsg = dict["MigrationErrMsg"] as! String
            }
            if dict.keys.contains("MigrationErrType") {
                self.migrationErrType = dict["MigrationErrType"] as! String
            }
            if dict.keys.contains("MigrationErrWorkaround") {
                self.migrationErrWorkaround = dict["MigrationErrWorkaround"] as! String
            }
            if dict.keys.contains("MigrationMode") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.MigrationMode()
                model.fromMap(dict["MigrationMode"] as! [String: Any])
                self.migrationMode = model
            }
            if dict.keys.contains("MinDu") {
                self.minDu = dict["MinDu"] as! Double
            }
            if dict.keys.contains("OriginType") {
                self.originType = dict["OriginType"] as! String
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("Performance") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.Performance()
                model.fromMap(dict["Performance"] as! [String: Any])
                self.performance = model
            }
            if dict.keys.contains("PrecheckStatus") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.PrecheckStatus()
                model.fromMap(dict["PrecheckStatus"] as! [String: Any])
                self.precheckStatus = model
            }
            if dict.keys.contains("Reserved") {
                self.reserved = dict["Reserved"] as! String
            }
            if dict.keys.contains("ResourceGroupDisplayName") {
                self.resourceGroupDisplayName = dict["ResourceGroupDisplayName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RetryState") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.RetryState()
                model.fromMap(dict["RetryState"] as! [String: Any])
                self.retryState = model
            }
            if dict.keys.contains("ReverseJob") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.ReverseJob()
                model.fromMap(dict["ReverseJob"] as! [String: Any])
                self.reverseJob = model
            }
            if dict.keys.contains("SourceEndpoint") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.SourceEndpoint()
                model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                self.sourceEndpoint = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StructureInitializationStatus") {
                var model = DescribeDtsJobsResponseBody.DtsJobList.StructureInitializationStatus()
                model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
                self.structureInitializationStatus = model
            }
            if dict.keys.contains("TagList") {
                var tmp : [DescribeDtsJobsResponseBody.DtsJobList.TagList] = []
                for v in dict["TagList"] as! [Any] {
                    var model = DescribeDtsJobsResponseBody.DtsJobList.TagList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagList = tmp
            }
        }
    }
    public class EtlDemoList : Tea.TeaModel {
        public class DataEtlStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataSynchronizationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var needUpgrade: Bool?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.needUpgrade != nil {
                    map["NeedUpgrade"] = self.needUpgrade!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("NeedUpgrade") {
                    self.needUpgrade = dict["NeedUpgrade"] as! Bool
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DestinationEndpoint : Tea.TeaModel {
            public var databaseName: String?

            public var engineName: String?

            public var instanceID: String?

            public var instanceType: String?

            public var ip: String?

            public var oracleSID: String?

            public var port: String?

            public var region: String?

            public var sslSolutionEnum: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.instanceID != nil {
                    map["InstanceID"] = self.instanceID!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.oracleSID != nil {
                    map["OracleSID"] = self.oracleSID!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.sslSolutionEnum != nil {
                    map["SslSolutionEnum"] = self.sslSolutionEnum!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("InstanceID") {
                    self.instanceID = dict["InstanceID"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("OracleSID") {
                    self.oracleSID = dict["OracleSID"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("SslSolutionEnum") {
                    self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class MigrationMode : Tea.TeaModel {
            public var dataInitialization: Bool?

            public var dataSynchronization: Bool?

            public var structureInitialization: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataInitialization != nil {
                    map["DataInitialization"] = self.dataInitialization!
                }
                if self.dataSynchronization != nil {
                    map["DataSynchronization"] = self.dataSynchronization!
                }
                if self.structureInitialization != nil {
                    map["StructureInitialization"] = self.structureInitialization!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataInitialization") {
                    self.dataInitialization = dict["DataInitialization"] as! Bool
                }
                if dict.keys.contains("DataSynchronization") {
                    self.dataSynchronization = dict["DataSynchronization"] as! Bool
                }
                if dict.keys.contains("StructureInitialization") {
                    self.structureInitialization = dict["StructureInitialization"] as! Bool
                }
            }
        }
        public class Performance : Tea.TeaModel {
            public var flow: String?

            public var rps: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flow != nil {
                    map["Flow"] = self.flow!
                }
                if self.rps != nil {
                    map["Rps"] = self.rps!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Flow") {
                    self.flow = dict["Flow"] as! String
                }
                if dict.keys.contains("Rps") {
                    self.rps = dict["Rps"] as! String
                }
            }
        }
        public class PrecheckStatus : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var checkItem: String?

                public var checkItemDescription: String?

                public var checkResult: String?

                public var failedReason: String?

                public var repairMethod: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItem != nil {
                        map["CheckItem"] = self.checkItem!
                    }
                    if self.checkItemDescription != nil {
                        map["CheckItemDescription"] = self.checkItemDescription!
                    }
                    if self.checkResult != nil {
                        map["CheckResult"] = self.checkResult!
                    }
                    if self.failedReason != nil {
                        map["FailedReason"] = self.failedReason!
                    }
                    if self.repairMethod != nil {
                        map["RepairMethod"] = self.repairMethod!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckItem") {
                        self.checkItem = dict["CheckItem"] as! String
                    }
                    if dict.keys.contains("CheckItemDescription") {
                        self.checkItemDescription = dict["CheckItemDescription"] as! String
                    }
                    if dict.keys.contains("CheckResult") {
                        self.checkResult = dict["CheckResult"] as! String
                    }
                    if dict.keys.contains("FailedReason") {
                        self.failedReason = dict["FailedReason"] as! String
                    }
                    if dict.keys.contains("RepairMethod") {
                        self.repairMethod = dict["RepairMethod"] as! String
                    }
                }
            }
            public var detail: [DescribeDtsJobsResponseBody.EtlDemoList.PrecheckStatus.Detail]?

            public var errorMessage: String?

            public var percent: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    var tmp : [Any] = []
                    for k in self.detail! {
                        tmp.append(k.toMap())
                    }
                    map["Detail"] = tmp
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Detail") {
                    var tmp : [DescribeDtsJobsResponseBody.EtlDemoList.PrecheckStatus.Detail] = []
                    for v in dict["Detail"] as! [Any] {
                        var model = DescribeDtsJobsResponseBody.EtlDemoList.PrecheckStatus.Detail()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.detail = tmp
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RetryState : Tea.TeaModel {
            public var errMessage: String?

            public var jobId: String?

            public var maxRetryTime: Int32?

            public var module: String?

            public var retryCount: Int32?

            public var retryTarget: String?

            public var retryTime: Int32?

            public var retrying: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errMessage != nil {
                    map["ErrMessage"] = self.errMessage!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.maxRetryTime != nil {
                    map["MaxRetryTime"] = self.maxRetryTime!
                }
                if self.module != nil {
                    map["Module"] = self.module!
                }
                if self.retryCount != nil {
                    map["RetryCount"] = self.retryCount!
                }
                if self.retryTarget != nil {
                    map["RetryTarget"] = self.retryTarget!
                }
                if self.retryTime != nil {
                    map["RetryTime"] = self.retryTime!
                }
                if self.retrying != nil {
                    map["Retrying"] = self.retrying!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrMessage") {
                    self.errMessage = dict["ErrMessage"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MaxRetryTime") {
                    self.maxRetryTime = dict["MaxRetryTime"] as! Int32
                }
                if dict.keys.contains("Module") {
                    self.module = dict["Module"] as! String
                }
                if dict.keys.contains("RetryCount") {
                    self.retryCount = dict["RetryCount"] as! Int32
                }
                if dict.keys.contains("RetryTarget") {
                    self.retryTarget = dict["RetryTarget"] as! String
                }
                if dict.keys.contains("RetryTime") {
                    self.retryTime = dict["RetryTime"] as! Int32
                }
                if dict.keys.contains("Retrying") {
                    self.retrying = dict["Retrying"] as! Bool
                }
            }
        }
        public class ReverseJob : Tea.TeaModel {
            public class DataInitializationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DataSynchronizationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var needUpgrade: Bool?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.needUpgrade != nil {
                        map["NeedUpgrade"] = self.needUpgrade!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("NeedUpgrade") {
                        self.needUpgrade = dict["NeedUpgrade"] as! Bool
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DestinationEndpoint : Tea.TeaModel {
                public var databaseName: String?

                public var engineName: String?

                public var instanceID: String?

                public var instanceType: String?

                public var ip: String?

                public var oracleSID: String?

                public var port: String?

                public var region: String?

                public var sslSolutionEnum: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.sslSolutionEnum != nil {
                        map["SslSolutionEnum"] = self.sslSolutionEnum!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("SslSolutionEnum") {
                        self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class MigrationMode : Tea.TeaModel {
                public var dataInitialization: Bool?

                public var dataSynchronization: Bool?

                public var structureInitialization: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataInitialization != nil {
                        map["DataInitialization"] = self.dataInitialization!
                    }
                    if self.dataSynchronization != nil {
                        map["DataSynchronization"] = self.dataSynchronization!
                    }
                    if self.structureInitialization != nil {
                        map["StructureInitialization"] = self.structureInitialization!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataInitialization") {
                        self.dataInitialization = dict["DataInitialization"] as! Bool
                    }
                    if dict.keys.contains("DataSynchronization") {
                        self.dataSynchronization = dict["DataSynchronization"] as! Bool
                    }
                    if dict.keys.contains("StructureInitialization") {
                        self.structureInitialization = dict["StructureInitialization"] as! Bool
                    }
                }
            }
            public class Performance : Tea.TeaModel {
                public var flow: String?

                public var rps: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.flow != nil {
                        map["Flow"] = self.flow!
                    }
                    if self.rps != nil {
                        map["Rps"] = self.rps!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Flow") {
                        self.flow = dict["Flow"] as! String
                    }
                    if dict.keys.contains("Rps") {
                        self.rps = dict["Rps"] as! String
                    }
                }
            }
            public class PrecheckStatus : Tea.TeaModel {
                public class Detail : Tea.TeaModel {
                    public var checkItem: String?

                    public var checkItemDescription: String?

                    public var checkResult: String?

                    public var failedReason: String?

                    public var repairMethod: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.checkItem != nil {
                            map["CheckItem"] = self.checkItem!
                        }
                        if self.checkItemDescription != nil {
                            map["CheckItemDescription"] = self.checkItemDescription!
                        }
                        if self.checkResult != nil {
                            map["CheckResult"] = self.checkResult!
                        }
                        if self.failedReason != nil {
                            map["FailedReason"] = self.failedReason!
                        }
                        if self.repairMethod != nil {
                            map["RepairMethod"] = self.repairMethod!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CheckItem") {
                            self.checkItem = dict["CheckItem"] as! String
                        }
                        if dict.keys.contains("CheckItemDescription") {
                            self.checkItemDescription = dict["CheckItemDescription"] as! String
                        }
                        if dict.keys.contains("CheckResult") {
                            self.checkResult = dict["CheckResult"] as! String
                        }
                        if dict.keys.contains("FailedReason") {
                            self.failedReason = dict["FailedReason"] as! String
                        }
                        if dict.keys.contains("RepairMethod") {
                            self.repairMethod = dict["RepairMethod"] as! String
                        }
                    }
                }
                public var detail: [DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.PrecheckStatus.Detail]?

                public var errorMessage: String?

                public var percent: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detail != nil {
                        var tmp : [Any] = []
                        for k in self.detail! {
                            tmp.append(k.toMap())
                        }
                        map["Detail"] = tmp
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Detail") {
                        var tmp : [DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.PrecheckStatus.Detail] = []
                        for v in dict["Detail"] as! [Any] {
                            var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.PrecheckStatus.Detail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.detail = tmp
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class SourceEndpoint : Tea.TeaModel {
                public var databaseName: String?

                public var engineName: String?

                public var instanceID: String?

                public var instanceType: String?

                public var ip: String?

                public var oracleSID: String?

                public var port: String?

                public var region: String?

                public var sslSolutionEnum: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.sslSolutionEnum != nil {
                        map["SslSolutionEnum"] = self.sslSolutionEnum!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("SslSolutionEnum") {
                        self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class StructureInitializationStatus : Tea.TeaModel {
                public var errorMessage: String?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var checkpoint: String?

            public var createTime: String?

            public var dataInitializationStatus: DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.DataInitializationStatus?

            public var dataSynchronizationStatus: DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.DataSynchronizationStatus?

            public var dbObject: String?

            public var delay: Int64?

            public var destinationEndpoint: DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.DestinationEndpoint?

            public var dtsInstanceID: String?

            public var dtsJobClass: String?

            public var dtsJobDirection: String?

            public var dtsJobId: String?

            public var dtsJobName: String?

            public var errorMessage: String?

            public var etlSafeCheckpoint: String?

            public var expireTime: String?

            public var migrationMode: DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.MigrationMode?

            public var payType: String?

            public var performance: DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.Performance?

            public var precheckStatus: DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.PrecheckStatus?

            public var reserved: String?

            public var sourceEndpoint: DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.SourceEndpoint?

            public var status: String?

            public var structureInitializationStatus: DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.StructureInitializationStatus?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataInitializationStatus?.validate()
                try self.dataSynchronizationStatus?.validate()
                try self.destinationEndpoint?.validate()
                try self.migrationMode?.validate()
                try self.performance?.validate()
                try self.precheckStatus?.validate()
                try self.sourceEndpoint?.validate()
                try self.structureInitializationStatus?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkpoint != nil {
                    map["Checkpoint"] = self.checkpoint!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataInitializationStatus != nil {
                    map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
                }
                if self.dataSynchronizationStatus != nil {
                    map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
                }
                if self.dbObject != nil {
                    map["DbObject"] = self.dbObject!
                }
                if self.delay != nil {
                    map["Delay"] = self.delay!
                }
                if self.destinationEndpoint != nil {
                    map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
                }
                if self.dtsInstanceID != nil {
                    map["DtsInstanceID"] = self.dtsInstanceID!
                }
                if self.dtsJobClass != nil {
                    map["DtsJobClass"] = self.dtsJobClass!
                }
                if self.dtsJobDirection != nil {
                    map["DtsJobDirection"] = self.dtsJobDirection!
                }
                if self.dtsJobId != nil {
                    map["DtsJobId"] = self.dtsJobId!
                }
                if self.dtsJobName != nil {
                    map["DtsJobName"] = self.dtsJobName!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.etlSafeCheckpoint != nil {
                    map["EtlSafeCheckpoint"] = self.etlSafeCheckpoint!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.migrationMode != nil {
                    map["MigrationMode"] = self.migrationMode?.toMap()
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.performance != nil {
                    map["Performance"] = self.performance?.toMap()
                }
                if self.precheckStatus != nil {
                    map["PrecheckStatus"] = self.precheckStatus?.toMap()
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.sourceEndpoint != nil {
                    map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.structureInitializationStatus != nil {
                    map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Checkpoint") {
                    self.checkpoint = dict["Checkpoint"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DataInitializationStatus") {
                    var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.DataInitializationStatus()
                    model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
                    self.dataInitializationStatus = model
                }
                if dict.keys.contains("DataSynchronizationStatus") {
                    var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.DataSynchronizationStatus()
                    model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
                    self.dataSynchronizationStatus = model
                }
                if dict.keys.contains("DbObject") {
                    self.dbObject = dict["DbObject"] as! String
                }
                if dict.keys.contains("Delay") {
                    self.delay = dict["Delay"] as! Int64
                }
                if dict.keys.contains("DestinationEndpoint") {
                    var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.DestinationEndpoint()
                    model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                    self.destinationEndpoint = model
                }
                if dict.keys.contains("DtsInstanceID") {
                    self.dtsInstanceID = dict["DtsInstanceID"] as! String
                }
                if dict.keys.contains("DtsJobClass") {
                    self.dtsJobClass = dict["DtsJobClass"] as! String
                }
                if dict.keys.contains("DtsJobDirection") {
                    self.dtsJobDirection = dict["DtsJobDirection"] as! String
                }
                if dict.keys.contains("DtsJobId") {
                    self.dtsJobId = dict["DtsJobId"] as! String
                }
                if dict.keys.contains("DtsJobName") {
                    self.dtsJobName = dict["DtsJobName"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("EtlSafeCheckpoint") {
                    self.etlSafeCheckpoint = dict["EtlSafeCheckpoint"] as! String
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("MigrationMode") {
                    var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.MigrationMode()
                    model.fromMap(dict["MigrationMode"] as! [String: Any])
                    self.migrationMode = model
                }
                if dict.keys.contains("PayType") {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("Performance") {
                    var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.Performance()
                    model.fromMap(dict["Performance"] as! [String: Any])
                    self.performance = model
                }
                if dict.keys.contains("PrecheckStatus") {
                    var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.PrecheckStatus()
                    model.fromMap(dict["PrecheckStatus"] as! [String: Any])
                    self.precheckStatus = model
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! String
                }
                if dict.keys.contains("SourceEndpoint") {
                    var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.SourceEndpoint()
                    model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                    self.sourceEndpoint = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StructureInitializationStatus") {
                    var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob.StructureInitializationStatus()
                    model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
                    self.structureInitializationStatus = model
                }
            }
        }
        public class SourceEndpoint : Tea.TeaModel {
            public var databaseName: String?

            public var engineName: String?

            public var instanceID: String?

            public var instanceType: String?

            public var ip: String?

            public var oracleSID: String?

            public var port: String?

            public var region: String?

            public var sslSolutionEnum: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.instanceID != nil {
                    map["InstanceID"] = self.instanceID!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.oracleSID != nil {
                    map["OracleSID"] = self.oracleSID!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.sslSolutionEnum != nil {
                    map["SslSolutionEnum"] = self.sslSolutionEnum!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("InstanceID") {
                    self.instanceID = dict["InstanceID"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("OracleSID") {
                    self.oracleSID = dict["OracleSID"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("SslSolutionEnum") {
                    self.sslSolutionEnum = dict["SslSolutionEnum"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class StructureInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class TagList : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var appName: String?

        public var beginTimestamp: String?

        public var checkpoint: String?

        public var consumptionCheckpoint: String?

        public var consumptionClient: String?

        public var createTime: String?

        public var dataEtlStatus: DescribeDtsJobsResponseBody.EtlDemoList.DataEtlStatus?

        public var dataInitializationStatus: DescribeDtsJobsResponseBody.EtlDemoList.DataInitializationStatus?

        public var dataSynchronizationStatus: DescribeDtsJobsResponseBody.EtlDemoList.DataSynchronizationStatus?

        public var dbObject: String?

        public var delay: Int64?

        public var destinationEndpoint: DescribeDtsJobsResponseBody.EtlDemoList.DestinationEndpoint?

        public var dtsInstanceID: String?

        public var dtsJobClass: String?

        public var dtsJobDirection: String?

        public var dtsJobId: String?

        public var dtsJobName: String?

        public var endTimestamp: String?

        public var errorMessage: String?

        public var etlSafeCheckpoint: String?

        public var expireTime: String?

        public var jobType: String?

        public var migrationMode: DescribeDtsJobsResponseBody.EtlDemoList.MigrationMode?

        public var originType: String?

        public var payType: String?

        public var performance: DescribeDtsJobsResponseBody.EtlDemoList.Performance?

        public var precheckStatus: DescribeDtsJobsResponseBody.EtlDemoList.PrecheckStatus?

        public var reserved: String?

        public var resourceGroupDisplayName: String?

        public var resourceGroupId: String?

        public var retryState: DescribeDtsJobsResponseBody.EtlDemoList.RetryState?

        public var reverseJob: DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob?

        public var sourceEndpoint: DescribeDtsJobsResponseBody.EtlDemoList.SourceEndpoint?

        public var status: String?

        public var structureInitializationStatus: DescribeDtsJobsResponseBody.EtlDemoList.StructureInitializationStatus?

        public var tagList: [DescribeDtsJobsResponseBody.EtlDemoList.TagList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataEtlStatus?.validate()
            try self.dataInitializationStatus?.validate()
            try self.dataSynchronizationStatus?.validate()
            try self.destinationEndpoint?.validate()
            try self.migrationMode?.validate()
            try self.performance?.validate()
            try self.precheckStatus?.validate()
            try self.retryState?.validate()
            try self.reverseJob?.validate()
            try self.sourceEndpoint?.validate()
            try self.structureInitializationStatus?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.beginTimestamp != nil {
                map["BeginTimestamp"] = self.beginTimestamp!
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint!
            }
            if self.consumptionCheckpoint != nil {
                map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
            }
            if self.consumptionClient != nil {
                map["ConsumptionClient"] = self.consumptionClient!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataEtlStatus != nil {
                map["DataEtlStatus"] = self.dataEtlStatus?.toMap()
            }
            if self.dataInitializationStatus != nil {
                map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
            }
            if self.dataSynchronizationStatus != nil {
                map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
            }
            if self.dbObject != nil {
                map["DbObject"] = self.dbObject!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.destinationEndpoint != nil {
                map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
            }
            if self.dtsInstanceID != nil {
                map["DtsInstanceID"] = self.dtsInstanceID!
            }
            if self.dtsJobClass != nil {
                map["DtsJobClass"] = self.dtsJobClass!
            }
            if self.dtsJobDirection != nil {
                map["DtsJobDirection"] = self.dtsJobDirection!
            }
            if self.dtsJobId != nil {
                map["DtsJobId"] = self.dtsJobId!
            }
            if self.dtsJobName != nil {
                map["DtsJobName"] = self.dtsJobName!
            }
            if self.endTimestamp != nil {
                map["EndTimestamp"] = self.endTimestamp!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.etlSafeCheckpoint != nil {
                map["EtlSafeCheckpoint"] = self.etlSafeCheckpoint!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.migrationMode != nil {
                map["MigrationMode"] = self.migrationMode?.toMap()
            }
            if self.originType != nil {
                map["OriginType"] = self.originType!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.performance != nil {
                map["Performance"] = self.performance?.toMap()
            }
            if self.precheckStatus != nil {
                map["PrecheckStatus"] = self.precheckStatus?.toMap()
            }
            if self.reserved != nil {
                map["Reserved"] = self.reserved!
            }
            if self.resourceGroupDisplayName != nil {
                map["ResourceGroupDisplayName"] = self.resourceGroupDisplayName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.retryState != nil {
                map["RetryState"] = self.retryState?.toMap()
            }
            if self.reverseJob != nil {
                map["ReverseJob"] = self.reverseJob?.toMap()
            }
            if self.sourceEndpoint != nil {
                map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.structureInitializationStatus != nil {
                map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
            }
            if self.tagList != nil {
                var tmp : [Any] = []
                for k in self.tagList! {
                    tmp.append(k.toMap())
                }
                map["TagList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("BeginTimestamp") {
                self.beginTimestamp = dict["BeginTimestamp"] as! String
            }
            if dict.keys.contains("Checkpoint") {
                self.checkpoint = dict["Checkpoint"] as! String
            }
            if dict.keys.contains("ConsumptionCheckpoint") {
                self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
            }
            if dict.keys.contains("ConsumptionClient") {
                self.consumptionClient = dict["ConsumptionClient"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DataEtlStatus") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.DataEtlStatus()
                model.fromMap(dict["DataEtlStatus"] as! [String: Any])
                self.dataEtlStatus = model
            }
            if dict.keys.contains("DataInitializationStatus") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.DataInitializationStatus()
                model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
                self.dataInitializationStatus = model
            }
            if dict.keys.contains("DataSynchronizationStatus") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.DataSynchronizationStatus()
                model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
                self.dataSynchronizationStatus = model
            }
            if dict.keys.contains("DbObject") {
                self.dbObject = dict["DbObject"] as! String
            }
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! Int64
            }
            if dict.keys.contains("DestinationEndpoint") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.DestinationEndpoint()
                model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                self.destinationEndpoint = model
            }
            if dict.keys.contains("DtsInstanceID") {
                self.dtsInstanceID = dict["DtsInstanceID"] as! String
            }
            if dict.keys.contains("DtsJobClass") {
                self.dtsJobClass = dict["DtsJobClass"] as! String
            }
            if dict.keys.contains("DtsJobDirection") {
                self.dtsJobDirection = dict["DtsJobDirection"] as! String
            }
            if dict.keys.contains("DtsJobId") {
                self.dtsJobId = dict["DtsJobId"] as! String
            }
            if dict.keys.contains("DtsJobName") {
                self.dtsJobName = dict["DtsJobName"] as! String
            }
            if dict.keys.contains("EndTimestamp") {
                self.endTimestamp = dict["EndTimestamp"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("EtlSafeCheckpoint") {
                self.etlSafeCheckpoint = dict["EtlSafeCheckpoint"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("MigrationMode") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.MigrationMode()
                model.fromMap(dict["MigrationMode"] as! [String: Any])
                self.migrationMode = model
            }
            if dict.keys.contains("OriginType") {
                self.originType = dict["OriginType"] as! String
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("Performance") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.Performance()
                model.fromMap(dict["Performance"] as! [String: Any])
                self.performance = model
            }
            if dict.keys.contains("PrecheckStatus") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.PrecheckStatus()
                model.fromMap(dict["PrecheckStatus"] as! [String: Any])
                self.precheckStatus = model
            }
            if dict.keys.contains("Reserved") {
                self.reserved = dict["Reserved"] as! String
            }
            if dict.keys.contains("ResourceGroupDisplayName") {
                self.resourceGroupDisplayName = dict["ResourceGroupDisplayName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("RetryState") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.RetryState()
                model.fromMap(dict["RetryState"] as! [String: Any])
                self.retryState = model
            }
            if dict.keys.contains("ReverseJob") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.ReverseJob()
                model.fromMap(dict["ReverseJob"] as! [String: Any])
                self.reverseJob = model
            }
            if dict.keys.contains("SourceEndpoint") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.SourceEndpoint()
                model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                self.sourceEndpoint = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StructureInitializationStatus") {
                var model = DescribeDtsJobsResponseBody.EtlDemoList.StructureInitializationStatus()
                model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
                self.structureInitializationStatus = model
            }
            if dict.keys.contains("TagList") {
                var tmp : [DescribeDtsJobsResponseBody.EtlDemoList.TagList] = []
                for v in dict["TagList"] as! [Any] {
                    var model = DescribeDtsJobsResponseBody.EtlDemoList.TagList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagList = tmp
            }
        }
    }
    public var dtsJobList: [DescribeDtsJobsResponseBody.DtsJobList]?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var etlDemoList: [DescribeDtsJobsResponseBody.EtlDemoList]?

    public var httpStatusCode: Int32?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobList != nil {
            var tmp : [Any] = []
            for k in self.dtsJobList! {
                tmp.append(k.toMap())
            }
            map["DtsJobList"] = tmp
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.etlDemoList != nil {
            var tmp : [Any] = []
            for k in self.etlDemoList! {
                tmp.append(k.toMap())
            }
            map["EtlDemoList"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobList") {
            var tmp : [DescribeDtsJobsResponseBody.DtsJobList] = []
            for v in dict["DtsJobList"] as! [Any] {
                var model = DescribeDtsJobsResponseBody.DtsJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dtsJobList = tmp
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("EtlDemoList") {
            var tmp : [DescribeDtsJobsResponseBody.EtlDemoList] = []
            for v in dict["EtlDemoList"] as! [Any] {
                var model = DescribeDtsJobsResponseBody.EtlDemoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.etlDemoList = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int32
        }
    }
}

public class DescribeDtsJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDtsJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDtsJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDtsServiceLogRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var endTime: Int64?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var startTime: Int64?

    public var status: String?

    public var subJobType: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subJobType != nil {
            map["SubJobType"] = self.subJobType!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SubJobType") {
            self.subJobType = dict["SubJobType"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class DescribeDtsServiceLogResponseBody : Tea.TeaModel {
    public class ServiceLogContexts : Tea.TeaModel {
        public var context: String?

        public var state: String?

        public var time: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.context != nil {
                map["Context"] = self.context!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Context") {
                self.context = dict["Context"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! String
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var serviceLogContexts: [DescribeDtsServiceLogResponseBody.ServiceLogContexts]?

    public var success: Bool?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceLogContexts != nil {
            var tmp : [Any] = []
            for k in self.serviceLogContexts! {
                tmp.append(k.toMap())
            }
            map["ServiceLogContexts"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceLogContexts") {
            var tmp : [DescribeDtsServiceLogResponseBody.ServiceLogContexts] = []
            for v in dict["ServiceLogContexts"] as! [Any] {
                var model = DescribeDtsServiceLogResponseBody.ServiceLogContexts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceLogContexts = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribeDtsServiceLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDtsServiceLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDtsServiceLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEndpointSwitchStatusRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeEndpointSwitchStatusResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var errorMessage: String?

    public var requestId: String?

    public var status: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeEndpointSwitchStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEndpointSwitchStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEndpointSwitchStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEtlJobLogsRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeEtlJobLogsResponseBody : Tea.TeaModel {
    public class EtlRunningLogs : Tea.TeaModel {
        public var content: String?

        public var contentKey: String?

        public var etlId: String?

        public var logDatetime: String?

        public var status: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentKey != nil {
                map["ContentKey"] = self.contentKey!
            }
            if self.etlId != nil {
                map["EtlId"] = self.etlId!
            }
            if self.logDatetime != nil {
                map["LogDatetime"] = self.logDatetime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentKey") {
                self.contentKey = dict["ContentKey"] as! String
            }
            if dict.keys.contains("EtlId") {
                self.etlId = dict["EtlId"] as! String
            }
            if dict.keys.contains("LogDatetime") {
                self.logDatetime = dict["LogDatetime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var etlRunningLogs: [DescribeEtlJobLogsResponseBody.EtlRunningLogs]?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.etlRunningLogs != nil {
            var tmp : [Any] = []
            for k in self.etlRunningLogs! {
                tmp.append(k.toMap())
            }
            map["EtlRunningLogs"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("EtlRunningLogs") {
            var tmp : [DescribeEtlJobLogsResponseBody.EtlRunningLogs] = []
            for v in dict["EtlRunningLogs"] as! [Any] {
                var model = DescribeEtlJobLogsResponseBody.EtlRunningLogs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.etlRunningLogs = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEtlJobLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEtlJobLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEtlJobLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFullProcessListRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class DescribeFullProcessListResponseBody : Tea.TeaModel {
    public class FullProcessList : Tea.TeaModel {
        public var detail: String?

        public var exception: String?

        public var processName: String?

        public var processType: String?

        public var runningSQL: String?

        public var state: String?

        public var taskID: String?

        public var time: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.exception != nil {
                map["Exception"] = self.exception!
            }
            if self.processName != nil {
                map["ProcessName"] = self.processName!
            }
            if self.processType != nil {
                map["ProcessType"] = self.processType!
            }
            if self.runningSQL != nil {
                map["RunningSQL"] = self.runningSQL!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.taskID != nil {
                map["TaskID"] = self.taskID!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Detail") {
                self.detail = dict["Detail"] as! String
            }
            if dict.keys.contains("Exception") {
                self.exception = dict["Exception"] as! String
            }
            if dict.keys.contains("ProcessName") {
                self.processName = dict["ProcessName"] as! String
            }
            if dict.keys.contains("ProcessType") {
                self.processType = dict["ProcessType"] as! String
            }
            if dict.keys.contains("RunningSQL") {
                self.runningSQL = dict["RunningSQL"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TaskID") {
                self.taskID = dict["TaskID"] as! String
            }
            if dict.keys.contains("Time") {
                self.time = dict["Time"] as! Int64
            }
        }
    }
    public var code: String?

    public var configList: [String: Any]?

    public var dtsJobId: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var fullProcessList: [DescribeFullProcessListResponseBody.FullProcessList]?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.configList != nil {
            map["ConfigList"] = self.configList!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.fullProcessList != nil {
            var tmp : [Any] = []
            for k in self.fullProcessList! {
                tmp.append(k.toMap())
            }
            map["FullProcessList"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ConfigList") {
            self.configList = dict["ConfigList"] as! [String: Any]
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("FullProcessList") {
            var tmp : [DescribeFullProcessListResponseBody.FullProcessList] = []
            for v in dict["FullProcessList"] as! [Any] {
                var model = DescribeFullProcessListResponseBody.FullProcessList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fullProcessList = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFullProcessListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFullProcessListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFullProcessListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGadInstancesRequest : Tea.TeaModel {
    public var instanceName: String?

    public var masterDbInstanceId: String?

    public var ownerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var slaveDbInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.masterDbInstanceId != nil {
            map["MasterDbInstanceId"] = self.masterDbInstanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slaveDbInstanceId != nil {
            map["SlaveDbInstanceId"] = self.slaveDbInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("MasterDbInstanceId") {
            self.masterDbInstanceId = dict["MasterDbInstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlaveDbInstanceId") {
            self.slaveDbInstanceId = dict["SlaveDbInstanceId"] as! String
        }
    }
}

public class DescribeGadInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instances : Tea.TeaModel {
            public var createTime: Int64?

            public var dbEngineType: String?

            public var dbInstanceCount: Int32?

            public var instanceId: String?

            public var instanceName: String?

            public var instanceRegion: String?

            public var instanceType: String?

            public var masterDbInstanceId: String?

            public var masterDbInstanceName: String?

            public var masterDbInstanceRegion: String?

            public var masterDbInstanceZoneId: String?

            public var resourceGroupId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dbEngineType != nil {
                    map["DbEngineType"] = self.dbEngineType!
                }
                if self.dbInstanceCount != nil {
                    map["DbInstanceCount"] = self.dbInstanceCount!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instanceRegion != nil {
                    map["InstanceRegion"] = self.instanceRegion!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.masterDbInstanceId != nil {
                    map["MasterDbInstanceId"] = self.masterDbInstanceId!
                }
                if self.masterDbInstanceName != nil {
                    map["MasterDbInstanceName"] = self.masterDbInstanceName!
                }
                if self.masterDbInstanceRegion != nil {
                    map["MasterDbInstanceRegion"] = self.masterDbInstanceRegion!
                }
                if self.masterDbInstanceZoneId != nil {
                    map["MasterDbInstanceZoneId"] = self.masterDbInstanceZoneId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DbEngineType") {
                    self.dbEngineType = dict["DbEngineType"] as! String
                }
                if dict.keys.contains("DbInstanceCount") {
                    self.dbInstanceCount = dict["DbInstanceCount"] as! Int32
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("InstanceRegion") {
                    self.instanceRegion = dict["InstanceRegion"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("MasterDbInstanceId") {
                    self.masterDbInstanceId = dict["MasterDbInstanceId"] as! String
                }
                if dict.keys.contains("MasterDbInstanceName") {
                    self.masterDbInstanceName = dict["MasterDbInstanceName"] as! String
                }
                if dict.keys.contains("MasterDbInstanceRegion") {
                    self.masterDbInstanceRegion = dict["MasterDbInstanceRegion"] as! String
                }
                if dict.keys.contains("MasterDbInstanceZoneId") {
                    self.masterDbInstanceZoneId = dict["MasterDbInstanceZoneId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var instances: [DescribeGadInstancesResponseBody.Instances.Instances]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instances != nil {
                var tmp : [Any] = []
                for k in self.instances! {
                    tmp.append(k.toMap())
                }
                map["Instances"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instances") {
                var tmp : [DescribeGadInstancesResponseBody.Instances.Instances] = []
                for v in dict["Instances"] as! [Any] {
                    var model = DescribeGadInstancesResponseBody.Instances.Instances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instances = tmp
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var instances: DescribeGadInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var success: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Instances") {
            var model = DescribeGadInstancesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int32
        }
    }
}

public class DescribeGadInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGadInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGadInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInitializationStatusRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class DescribeInitializationStatusResponseBody : Tea.TeaModel {
    public class DataInitializationDetails : Tea.TeaModel {
        public var destinationOwnerDBName: String?

        public var errorMessage: String?

        public var finishRowNum: String?

        public var sourceOwnerDBName: String?

        public var status: String?

        public var tableName: String?

        public var totalRowNum: String?

        public var usedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationOwnerDBName != nil {
                map["DestinationOwnerDBName"] = self.destinationOwnerDBName!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.finishRowNum != nil {
                map["FinishRowNum"] = self.finishRowNum!
            }
            if self.sourceOwnerDBName != nil {
                map["SourceOwnerDBName"] = self.sourceOwnerDBName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.totalRowNum != nil {
                map["TotalRowNum"] = self.totalRowNum!
            }
            if self.usedTime != nil {
                map["UsedTime"] = self.usedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DestinationOwnerDBName") {
                self.destinationOwnerDBName = dict["DestinationOwnerDBName"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("FinishRowNum") {
                self.finishRowNum = dict["FinishRowNum"] as! String
            }
            if dict.keys.contains("SourceOwnerDBName") {
                self.sourceOwnerDBName = dict["SourceOwnerDBName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
            if dict.keys.contains("TotalRowNum") {
                self.totalRowNum = dict["TotalRowNum"] as! String
            }
            if dict.keys.contains("UsedTime") {
                self.usedTime = dict["UsedTime"] as! String
            }
        }
    }
    public class DataSynchronizationDetails : Tea.TeaModel {
        public var destinationOwnerDBName: String?

        public var errorMessage: String?

        public var sourceOwnerDBName: String?

        public var status: String?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationOwnerDBName != nil {
                map["DestinationOwnerDBName"] = self.destinationOwnerDBName!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.sourceOwnerDBName != nil {
                map["SourceOwnerDBName"] = self.sourceOwnerDBName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DestinationOwnerDBName") {
                self.destinationOwnerDBName = dict["DestinationOwnerDBName"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("SourceOwnerDBName") {
                self.sourceOwnerDBName = dict["SourceOwnerDBName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TableName") {
                self.tableName = dict["TableName"] as! String
            }
        }
    }
    public class StructureInitializationDetails : Tea.TeaModel {
        public class Constraints : Tea.TeaModel {
            public var destinationOwnerDBName: String?

            public var errorMessage: String?

            public var objectDefinition: String?

            public var objectName: String?

            public var objectType: String?

            public var sourceOwnerDBName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationOwnerDBName != nil {
                    map["DestinationOwnerDBName"] = self.destinationOwnerDBName!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.objectDefinition != nil {
                    map["ObjectDefinition"] = self.objectDefinition!
                }
                if self.objectName != nil {
                    map["ObjectName"] = self.objectName!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                if self.sourceOwnerDBName != nil {
                    map["SourceOwnerDBName"] = self.sourceOwnerDBName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestinationOwnerDBName") {
                    self.destinationOwnerDBName = dict["DestinationOwnerDBName"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("ObjectDefinition") {
                    self.objectDefinition = dict["ObjectDefinition"] as! String
                }
                if dict.keys.contains("ObjectName") {
                    self.objectName = dict["ObjectName"] as! String
                }
                if dict.keys.contains("ObjectType") {
                    self.objectType = dict["ObjectType"] as! String
                }
                if dict.keys.contains("SourceOwnerDBName") {
                    self.sourceOwnerDBName = dict["SourceOwnerDBName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var constraints: [DescribeInitializationStatusResponseBody.StructureInitializationDetails.Constraints]?

        public var destinationOwnerDBName: String?

        public var errorMessage: String?

        public var objectDefinition: String?

        public var objectName: String?

        public var objectType: String?

        public var sourceOwnerDBName: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.constraints != nil {
                var tmp : [Any] = []
                for k in self.constraints! {
                    tmp.append(k.toMap())
                }
                map["Constraints"] = tmp
            }
            if self.destinationOwnerDBName != nil {
                map["DestinationOwnerDBName"] = self.destinationOwnerDBName!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.objectDefinition != nil {
                map["ObjectDefinition"] = self.objectDefinition!
            }
            if self.objectName != nil {
                map["ObjectName"] = self.objectName!
            }
            if self.objectType != nil {
                map["ObjectType"] = self.objectType!
            }
            if self.sourceOwnerDBName != nil {
                map["SourceOwnerDBName"] = self.sourceOwnerDBName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Constraints") {
                var tmp : [DescribeInitializationStatusResponseBody.StructureInitializationDetails.Constraints] = []
                for v in dict["Constraints"] as! [Any] {
                    var model = DescribeInitializationStatusResponseBody.StructureInitializationDetails.Constraints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.constraints = tmp
            }
            if dict.keys.contains("DestinationOwnerDBName") {
                self.destinationOwnerDBName = dict["DestinationOwnerDBName"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("ObjectDefinition") {
                self.objectDefinition = dict["ObjectDefinition"] as! String
            }
            if dict.keys.contains("ObjectName") {
                self.objectName = dict["ObjectName"] as! String
            }
            if dict.keys.contains("ObjectType") {
                self.objectType = dict["ObjectType"] as! String
            }
            if dict.keys.contains("SourceOwnerDBName") {
                self.sourceOwnerDBName = dict["SourceOwnerDBName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var dataInitializationDetails: [DescribeInitializationStatusResponseBody.DataInitializationDetails]?

    public var dataSynchronizationDetails: [DescribeInitializationStatusResponseBody.DataSynchronizationDetails]?

    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var structureInitializationDetails: [DescribeInitializationStatusResponseBody.StructureInitializationDetails]?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInitializationDetails != nil {
            var tmp : [Any] = []
            for k in self.dataInitializationDetails! {
                tmp.append(k.toMap())
            }
            map["DataInitializationDetails"] = tmp
        }
        if self.dataSynchronizationDetails != nil {
            var tmp : [Any] = []
            for k in self.dataSynchronizationDetails! {
                tmp.append(k.toMap())
            }
            map["DataSynchronizationDetails"] = tmp
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structureInitializationDetails != nil {
            var tmp : [Any] = []
            for k in self.structureInitializationDetails! {
                tmp.append(k.toMap())
            }
            map["StructureInitializationDetails"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInitializationDetails") {
            var tmp : [DescribeInitializationStatusResponseBody.DataInitializationDetails] = []
            for v in dict["DataInitializationDetails"] as! [Any] {
                var model = DescribeInitializationStatusResponseBody.DataInitializationDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataInitializationDetails = tmp
        }
        if dict.keys.contains("DataSynchronizationDetails") {
            var tmp : [DescribeInitializationStatusResponseBody.DataSynchronizationDetails] = []
            for v in dict["DataSynchronizationDetails"] as! [Any] {
                var model = DescribeInitializationStatusResponseBody.DataSynchronizationDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataSynchronizationDetails = tmp
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructureInitializationDetails") {
            var tmp : [DescribeInitializationStatusResponseBody.StructureInitializationDetails] = []
            for v in dict["StructureInitializationDetails"] as! [Any] {
                var model = DescribeInitializationStatusResponseBody.StructureInitializationDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.structureInitializationDetails = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeInitializationStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInitializationStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInitializationStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeJobMonitorRuleRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeJobMonitorRuleResponseBody : Tea.TeaModel {
    public class MonitorRules : Tea.TeaModel {
        public var delayRuleTime: Int64?

        public var jobId: String?

        public var jobType: String?

        public var noticeValue: Int32?

        public var period: Int32?

        public var phone: String?

        public var state: String?

        public var times: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delayRuleTime != nil {
                map["DelayRuleTime"] = self.delayRuleTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.noticeValue != nil {
                map["NoticeValue"] = self.noticeValue!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.phone != nil {
                map["Phone"] = self.phone!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.times != nil {
                map["Times"] = self.times!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DelayRuleTime") {
                self.delayRuleTime = dict["DelayRuleTime"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("NoticeValue") {
                self.noticeValue = dict["NoticeValue"] as! Int32
            }
            if dict.keys.contains("Period") {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("Phone") {
                self.phone = dict["Phone"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Times") {
                self.times = dict["Times"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var dtsJobId: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var monitorRules: [DescribeJobMonitorRuleResponseBody.MonitorRules]?

    public var requestId: String?

    public var success: Bool?

    public var topics: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.monitorRules != nil {
            var tmp : [Any] = []
            for k in self.monitorRules! {
                tmp.append(k.toMap())
            }
            map["MonitorRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.topics != nil {
            map["Topics"] = self.topics!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("MonitorRules") {
            var tmp : [DescribeJobMonitorRuleResponseBody.MonitorRules] = []
            for v in dict["MonitorRules"] as! [Any] {
                var model = DescribeJobMonitorRuleResponseBody.MonitorRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.monitorRules = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Topics") {
            self.topics = dict["Topics"] as! [String]
        }
    }
}

public class DescribeJobMonitorRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobMonitorRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeJobMonitorRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricListRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var dtsJobId: String?

    public var endTime: Int64?

    public var env: String?

    public var metricName: String?

    public var metricType: String?

    public var ownerID: String?

    public var param: String?

    public var period: Int64?

    public var resourceGroupId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.env != nil {
            map["Env"] = self.env!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.ownerID != nil {
            map["OwnerID"] = self.ownerID!
        }
        if self.param != nil {
            map["Param"] = self.param!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Env") {
            self.env = dict["Env"] as! String
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("OwnerID") {
            self.ownerID = dict["OwnerID"] as! String
        }
        if dict.keys.contains("Param") {
            self.param = dict["Param"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeMetricListResponseBody : Tea.TeaModel {
    public class DataPoints : Tea.TeaModel {
        public var statistics: Double?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Statistics") {
                self.statistics = dict["Statistics"] as! Double
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: String?

    public var dataPoints: [DescribeMetricListResponseBody.DataPoints]?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var metricName: String?

    public var metricType: String?

    public var param: String?

    public var period: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dataPoints != nil {
            var tmp : [Any] = []
            for k in self.dataPoints! {
                tmp.append(k.toMap())
            }
            map["DataPoints"] = tmp
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.param != nil {
            map["Param"] = self.param!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DataPoints") {
            var tmp : [DescribeMetricListResponseBody.DataPoints] = []
            for v in dict["DataPoints"] as! [Any] {
                var model = DescribeMetricListResponseBody.DataPoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataPoints = tmp
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! String
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Param") {
            self.param = dict["Param"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeMetricListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMetricListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMigrationJobAlertRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var migrationJobId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeMigrationJobAlertResponseBody : Tea.TeaModel {
    public var delayAlertPhone: String?

    public var delayAlertStatus: String?

    public var delayOverSeconds: String?

    public var errCode: String?

    public var errMessage: String?

    public var errorAlertPhone: String?

    public var errorAlertStatus: String?

    public var migrationJobId: String?

    public var migrationJobName: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.delayAlertPhone != nil {
            map["DelayAlertPhone"] = self.delayAlertPhone!
        }
        if self.delayAlertStatus != nil {
            map["DelayAlertStatus"] = self.delayAlertStatus!
        }
        if self.delayOverSeconds != nil {
            map["DelayOverSeconds"] = self.delayOverSeconds!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.errorAlertPhone != nil {
            map["ErrorAlertPhone"] = self.errorAlertPhone!
        }
        if self.errorAlertStatus != nil {
            map["ErrorAlertStatus"] = self.errorAlertStatus!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.migrationJobName != nil {
            map["MigrationJobName"] = self.migrationJobName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DelayAlertPhone") {
            self.delayAlertPhone = dict["DelayAlertPhone"] as! String
        }
        if dict.keys.contains("DelayAlertStatus") {
            self.delayAlertStatus = dict["DelayAlertStatus"] as! String
        }
        if dict.keys.contains("DelayOverSeconds") {
            self.delayOverSeconds = dict["DelayOverSeconds"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("ErrorAlertPhone") {
            self.errorAlertPhone = dict["ErrorAlertPhone"] as! String
        }
        if dict.keys.contains("ErrorAlertStatus") {
            self.errorAlertStatus = dict["ErrorAlertStatus"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("MigrationJobName") {
            self.migrationJobName = dict["MigrationJobName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeMigrationJobAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMigrationJobAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMigrationJobAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMigrationJobDetailRequest : Tea.TeaModel {
    public class MigrationMode : Tea.TeaModel {
        public var dataInitialization: Bool?

        public var dataSynchronization: Bool?

        public var structureInitialization: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataInitialization != nil {
                map["DataInitialization"] = self.dataInitialization!
            }
            if self.dataSynchronization != nil {
                map["DataSynchronization"] = self.dataSynchronization!
            }
            if self.structureInitialization != nil {
                map["StructureInitialization"] = self.structureInitialization!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataInitialization") {
                self.dataInitialization = dict["DataInitialization"] as! Bool
            }
            if dict.keys.contains("DataSynchronization") {
                self.dataSynchronization = dict["DataSynchronization"] as! Bool
            }
            if dict.keys.contains("StructureInitialization") {
                self.structureInitialization = dict["StructureInitialization"] as! Bool
            }
        }
    }
    public var migrationMode: DescribeMigrationJobDetailRequest.MigrationMode?

    public var accountId: String?

    public var clientToken: String?

    public var migrationJobId: String?

    public var ownerId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.migrationMode?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationMode != nil {
            map["MigrationMode"] = self.migrationMode?.toMap()
        }
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationMode") {
            var model = DescribeMigrationJobDetailRequest.MigrationMode()
            model.fromMap(dict["MigrationMode"] as! [String: Any])
            self.migrationMode = model
        }
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeMigrationJobDetailResponseBody : Tea.TeaModel {
    public class DataInitializationDetailList : Tea.TeaModel {
        public class DataInitializationDetail : Tea.TeaModel {
            public var destinationOwnerDBName: String?

            public var errorMessage: String?

            public var finishRowNum: String?

            public var migrationTime: String?

            public var sourceOwnerDBName: String?

            public var status: String?

            public var tableName: String?

            public var totalRowNum: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationOwnerDBName != nil {
                    map["DestinationOwnerDBName"] = self.destinationOwnerDBName!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.finishRowNum != nil {
                    map["FinishRowNum"] = self.finishRowNum!
                }
                if self.migrationTime != nil {
                    map["MigrationTime"] = self.migrationTime!
                }
                if self.sourceOwnerDBName != nil {
                    map["SourceOwnerDBName"] = self.sourceOwnerDBName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.totalRowNum != nil {
                    map["TotalRowNum"] = self.totalRowNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestinationOwnerDBName") {
                    self.destinationOwnerDBName = dict["DestinationOwnerDBName"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("FinishRowNum") {
                    self.finishRowNum = dict["FinishRowNum"] as! String
                }
                if dict.keys.contains("MigrationTime") {
                    self.migrationTime = dict["MigrationTime"] as! String
                }
                if dict.keys.contains("SourceOwnerDBName") {
                    self.sourceOwnerDBName = dict["SourceOwnerDBName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
                if dict.keys.contains("TotalRowNum") {
                    self.totalRowNum = dict["TotalRowNum"] as! String
                }
            }
        }
        public var dataInitializationDetail: [DescribeMigrationJobDetailResponseBody.DataInitializationDetailList.DataInitializationDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataInitializationDetail != nil {
                var tmp : [Any] = []
                for k in self.dataInitializationDetail! {
                    tmp.append(k.toMap())
                }
                map["DataInitializationDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataInitializationDetail") {
                var tmp : [DescribeMigrationJobDetailResponseBody.DataInitializationDetailList.DataInitializationDetail] = []
                for v in dict["DataInitializationDetail"] as! [Any] {
                    var model = DescribeMigrationJobDetailResponseBody.DataInitializationDetailList.DataInitializationDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataInitializationDetail = tmp
            }
        }
    }
    public class DataSynchronizationDetailList : Tea.TeaModel {
        public class DataSynchronizationDetail : Tea.TeaModel {
            public var destinationOwnerDBName: String?

            public var errorMessage: String?

            public var sourceOwnerDBName: String?

            public var status: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationOwnerDBName != nil {
                    map["DestinationOwnerDBName"] = self.destinationOwnerDBName!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.sourceOwnerDBName != nil {
                    map["SourceOwnerDBName"] = self.sourceOwnerDBName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestinationOwnerDBName") {
                    self.destinationOwnerDBName = dict["DestinationOwnerDBName"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("SourceOwnerDBName") {
                    self.sourceOwnerDBName = dict["SourceOwnerDBName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var dataSynchronizationDetail: [DescribeMigrationJobDetailResponseBody.DataSynchronizationDetailList.DataSynchronizationDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSynchronizationDetail != nil {
                var tmp : [Any] = []
                for k in self.dataSynchronizationDetail! {
                    tmp.append(k.toMap())
                }
                map["DataSynchronizationDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSynchronizationDetail") {
                var tmp : [DescribeMigrationJobDetailResponseBody.DataSynchronizationDetailList.DataSynchronizationDetail] = []
                for v in dict["DataSynchronizationDetail"] as! [Any] {
                    var model = DescribeMigrationJobDetailResponseBody.DataSynchronizationDetailList.DataSynchronizationDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataSynchronizationDetail = tmp
            }
        }
    }
    public class StructureInitializationDetailList : Tea.TeaModel {
        public class StructureInitializationDetail : Tea.TeaModel {
            public class ConstraintList : Tea.TeaModel {
                public class StructureInitializationDetail : Tea.TeaModel {
                    public var destinationOwnerDBName: String?

                    public var errorMessage: String?

                    public var objectDefinition: String?

                    public var objectName: String?

                    public var objectType: String?

                    public var sourceOwnerDBName: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.destinationOwnerDBName != nil {
                            map["DestinationOwnerDBName"] = self.destinationOwnerDBName!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.objectDefinition != nil {
                            map["ObjectDefinition"] = self.objectDefinition!
                        }
                        if self.objectName != nil {
                            map["ObjectName"] = self.objectName!
                        }
                        if self.objectType != nil {
                            map["ObjectType"] = self.objectType!
                        }
                        if self.sourceOwnerDBName != nil {
                            map["SourceOwnerDBName"] = self.sourceOwnerDBName!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DestinationOwnerDBName") {
                            self.destinationOwnerDBName = dict["DestinationOwnerDBName"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                        if dict.keys.contains("ObjectDefinition") {
                            self.objectDefinition = dict["ObjectDefinition"] as! String
                        }
                        if dict.keys.contains("ObjectName") {
                            self.objectName = dict["ObjectName"] as! String
                        }
                        if dict.keys.contains("ObjectType") {
                            self.objectType = dict["ObjectType"] as! String
                        }
                        if dict.keys.contains("SourceOwnerDBName") {
                            self.sourceOwnerDBName = dict["SourceOwnerDBName"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var structureInitializationDetail: [DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList.StructureInitializationDetail.ConstraintList.StructureInitializationDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.structureInitializationDetail != nil {
                        var tmp : [Any] = []
                        for k in self.structureInitializationDetail! {
                            tmp.append(k.toMap())
                        }
                        map["StructureInitializationDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StructureInitializationDetail") {
                        var tmp : [DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList.StructureInitializationDetail.ConstraintList.StructureInitializationDetail] = []
                        for v in dict["StructureInitializationDetail"] as! [Any] {
                            var model = DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList.StructureInitializationDetail.ConstraintList.StructureInitializationDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.structureInitializationDetail = tmp
                    }
                }
            }
            public var constraintList: DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList.StructureInitializationDetail.ConstraintList?

            public var destinationOwnerDBName: String?

            public var errorMessage: String?

            public var objectDefinition: String?

            public var objectName: String?

            public var objectType: String?

            public var sourceOwnerDBName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.constraintList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.constraintList != nil {
                    map["ConstraintList"] = self.constraintList?.toMap()
                }
                if self.destinationOwnerDBName != nil {
                    map["DestinationOwnerDBName"] = self.destinationOwnerDBName!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.objectDefinition != nil {
                    map["ObjectDefinition"] = self.objectDefinition!
                }
                if self.objectName != nil {
                    map["ObjectName"] = self.objectName!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                if self.sourceOwnerDBName != nil {
                    map["SourceOwnerDBName"] = self.sourceOwnerDBName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConstraintList") {
                    var model = DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList.StructureInitializationDetail.ConstraintList()
                    model.fromMap(dict["ConstraintList"] as! [String: Any])
                    self.constraintList = model
                }
                if dict.keys.contains("DestinationOwnerDBName") {
                    self.destinationOwnerDBName = dict["DestinationOwnerDBName"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("ObjectDefinition") {
                    self.objectDefinition = dict["ObjectDefinition"] as! String
                }
                if dict.keys.contains("ObjectName") {
                    self.objectName = dict["ObjectName"] as! String
                }
                if dict.keys.contains("ObjectType") {
                    self.objectType = dict["ObjectType"] as! String
                }
                if dict.keys.contains("SourceOwnerDBName") {
                    self.sourceOwnerDBName = dict["SourceOwnerDBName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var structureInitializationDetail: [DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList.StructureInitializationDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.structureInitializationDetail != nil {
                var tmp : [Any] = []
                for k in self.structureInitializationDetail! {
                    tmp.append(k.toMap())
                }
                map["StructureInitializationDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StructureInitializationDetail") {
                var tmp : [DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList.StructureInitializationDetail] = []
                for v in dict["StructureInitializationDetail"] as! [Any] {
                    var model = DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList.StructureInitializationDetail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.structureInitializationDetail = tmp
            }
        }
    }
    public var dataInitializationDetailList: DescribeMigrationJobDetailResponseBody.DataInitializationDetailList?

    public var dataSynchronizationDetailList: DescribeMigrationJobDetailResponseBody.DataSynchronizationDetailList?

    public var errCode: String?

    public var errMessage: String?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var structureInitializationDetailList: DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList?

    public var success: String?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataInitializationDetailList?.validate()
        try self.dataSynchronizationDetailList?.validate()
        try self.structureInitializationDetailList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInitializationDetailList != nil {
            map["DataInitializationDetailList"] = self.dataInitializationDetailList?.toMap()
        }
        if self.dataSynchronizationDetailList != nil {
            map["DataSynchronizationDetailList"] = self.dataSynchronizationDetailList?.toMap()
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.structureInitializationDetailList != nil {
            map["StructureInitializationDetailList"] = self.structureInitializationDetailList?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInitializationDetailList") {
            var model = DescribeMigrationJobDetailResponseBody.DataInitializationDetailList()
            model.fromMap(dict["DataInitializationDetailList"] as! [String: Any])
            self.dataInitializationDetailList = model
        }
        if dict.keys.contains("DataSynchronizationDetailList") {
            var model = DescribeMigrationJobDetailResponseBody.DataSynchronizationDetailList()
            model.fromMap(dict["DataSynchronizationDetailList"] as! [String: Any])
            self.dataSynchronizationDetailList = model
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StructureInitializationDetailList") {
            var model = DescribeMigrationJobDetailResponseBody.StructureInitializationDetailList()
            model.fromMap(dict["StructureInitializationDetailList"] as! [String: Any])
            self.structureInitializationDetailList = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribeMigrationJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMigrationJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMigrationJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMigrationJobStatusRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var migrationJobId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeMigrationJobStatusResponseBody : Tea.TeaModel {
    public class DataInitializationStatus : Tea.TeaModel {
        public var errorMessage: String?

        public var percent: String?

        public var progress: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DataSynchronizationStatus : Tea.TeaModel {
        public var checkpoint: String?

        public var delay: String?

        public var errorMessage: String?

        public var percent: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Checkpoint") {
                self.checkpoint = dict["Checkpoint"] as! String
            }
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DestinationEndpoint : Tea.TeaModel {
        public var databaseName: String?

        public var engineName: String?

        public var IP: String?

        public var instanceId: String?

        public var instanceType: String?

        public var port: String?

        public var userName: String?

        public var oracleSID: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.engineName != nil {
                map["EngineName"] = self.engineName!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.oracleSID != nil {
                map["oracleSID"] = self.oracleSID!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("EngineName") {
                self.engineName = dict["EngineName"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("oracleSID") {
                self.oracleSID = dict["oracleSID"] as! String
            }
        }
    }
    public class MigrationMode : Tea.TeaModel {
        public var dataInitialization: Bool?

        public var dataSynchronization: Bool?

        public var structureInitialization: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataInitialization != nil {
                map["dataInitialization"] = self.dataInitialization!
            }
            if self.dataSynchronization != nil {
                map["dataSynchronization"] = self.dataSynchronization!
            }
            if self.structureInitialization != nil {
                map["structureInitialization"] = self.structureInitialization!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dataInitialization") {
                self.dataInitialization = dict["dataInitialization"] as! Bool
            }
            if dict.keys.contains("dataSynchronization") {
                self.dataSynchronization = dict["dataSynchronization"] as! Bool
            }
            if dict.keys.contains("structureInitialization") {
                self.structureInitialization = dict["structureInitialization"] as! Bool
            }
        }
    }
    public class PrecheckStatus : Tea.TeaModel {
        public class Detail : Tea.TeaModel {
            public class CheckItem : Tea.TeaModel {
                public var checkStatus: String?

                public var errorMessage: String?

                public var itemName: String?

                public var repairMethod: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkStatus != nil {
                        map["CheckStatus"] = self.checkStatus!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.itemName != nil {
                        map["ItemName"] = self.itemName!
                    }
                    if self.repairMethod != nil {
                        map["RepairMethod"] = self.repairMethod!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckStatus") {
                        self.checkStatus = dict["CheckStatus"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("ItemName") {
                        self.itemName = dict["ItemName"] as! String
                    }
                    if dict.keys.contains("RepairMethod") {
                        self.repairMethod = dict["RepairMethod"] as! String
                    }
                }
            }
            public var checkItem: [DescribeMigrationJobStatusResponseBody.PrecheckStatus.Detail.CheckItem]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkItem != nil {
                    var tmp : [Any] = []
                    for k in self.checkItem! {
                        tmp.append(k.toMap())
                    }
                    map["CheckItem"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckItem") {
                    var tmp : [DescribeMigrationJobStatusResponseBody.PrecheckStatus.Detail.CheckItem] = []
                    for v in dict["CheckItem"] as! [Any] {
                        var model = DescribeMigrationJobStatusResponseBody.PrecheckStatus.Detail.CheckItem()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.checkItem = tmp
                }
            }
        }
        public var detail: DescribeMigrationJobStatusResponseBody.PrecheckStatus.Detail?

        public var percent: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.detail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detail != nil {
                map["Detail"] = self.detail?.toMap()
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Detail") {
                var model = DescribeMigrationJobStatusResponseBody.PrecheckStatus.Detail()
                model.fromMap(dict["Detail"] as! [String: Any])
                self.detail = model
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class SourceEndpoint : Tea.TeaModel {
        public var databaseName: String?

        public var engineName: String?

        public var IP: String?

        public var instanceId: String?

        public var instanceType: String?

        public var port: String?

        public var userName: String?

        public var oracleSID: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.engineName != nil {
                map["EngineName"] = self.engineName!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.oracleSID != nil {
                map["oracleSID"] = self.oracleSID!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseName") {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("EngineName") {
                self.engineName = dict["EngineName"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("oracleSID") {
                self.oracleSID = dict["oracleSID"] as! String
            }
        }
    }
    public class StructureInitializationStatus : Tea.TeaModel {
        public var errorMessage: String?

        public var percent: String?

        public var progress: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var dataInitializationStatus: DescribeMigrationJobStatusResponseBody.DataInitializationStatus?

    public var dataSynchronizationStatus: DescribeMigrationJobStatusResponseBody.DataSynchronizationStatus?

    public var destinationEndpoint: DescribeMigrationJobStatusResponseBody.DestinationEndpoint?

    public var errCode: String?

    public var errMessage: String?

    public var migrationJobClass: String?

    public var migrationJobId: String?

    public var migrationJobName: String?

    public var migrationJobStatus: String?

    public var migrationMode: DescribeMigrationJobStatusResponseBody.MigrationMode?

    public var migrationObject: String?

    public var payType: String?

    public var precheckStatus: DescribeMigrationJobStatusResponseBody.PrecheckStatus?

    public var requestId: String?

    public var sourceEndpoint: DescribeMigrationJobStatusResponseBody.SourceEndpoint?

    public var structureInitializationStatus: DescribeMigrationJobStatusResponseBody.StructureInitializationStatus?

    public var success: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataInitializationStatus?.validate()
        try self.dataSynchronizationStatus?.validate()
        try self.destinationEndpoint?.validate()
        try self.migrationMode?.validate()
        try self.precheckStatus?.validate()
        try self.sourceEndpoint?.validate()
        try self.structureInitializationStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInitializationStatus != nil {
            map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
        }
        if self.dataSynchronizationStatus != nil {
            map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
        }
        if self.destinationEndpoint != nil {
            map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.migrationJobClass != nil {
            map["MigrationJobClass"] = self.migrationJobClass!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.migrationJobName != nil {
            map["MigrationJobName"] = self.migrationJobName!
        }
        if self.migrationJobStatus != nil {
            map["MigrationJobStatus"] = self.migrationJobStatus!
        }
        if self.migrationMode != nil {
            map["MigrationMode"] = self.migrationMode?.toMap()
        }
        if self.migrationObject != nil {
            map["MigrationObject"] = self.migrationObject!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.precheckStatus != nil {
            map["PrecheckStatus"] = self.precheckStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.structureInitializationStatus != nil {
            map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInitializationStatus") {
            var model = DescribeMigrationJobStatusResponseBody.DataInitializationStatus()
            model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
            self.dataInitializationStatus = model
        }
        if dict.keys.contains("DataSynchronizationStatus") {
            var model = DescribeMigrationJobStatusResponseBody.DataSynchronizationStatus()
            model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
            self.dataSynchronizationStatus = model
        }
        if dict.keys.contains("DestinationEndpoint") {
            var model = DescribeMigrationJobStatusResponseBody.DestinationEndpoint()
            model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
            self.destinationEndpoint = model
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("MigrationJobClass") {
            self.migrationJobClass = dict["MigrationJobClass"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("MigrationJobName") {
            self.migrationJobName = dict["MigrationJobName"] as! String
        }
        if dict.keys.contains("MigrationJobStatus") {
            self.migrationJobStatus = dict["MigrationJobStatus"] as! String
        }
        if dict.keys.contains("MigrationMode") {
            var model = DescribeMigrationJobStatusResponseBody.MigrationMode()
            model.fromMap(dict["MigrationMode"] as! [String: Any])
            self.migrationMode = model
        }
        if dict.keys.contains("MigrationObject") {
            self.migrationObject = dict["MigrationObject"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("PrecheckStatus") {
            var model = DescribeMigrationJobStatusResponseBody.PrecheckStatus()
            model.fromMap(dict["PrecheckStatus"] as! [String: Any])
            self.precheckStatus = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceEndpoint") {
            var model = DescribeMigrationJobStatusResponseBody.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("StructureInitializationStatus") {
            var model = DescribeMigrationJobStatusResponseBody.StructureInitializationStatus()
            model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
            self.structureInitializationStatus = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeMigrationJobStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMigrationJobStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMigrationJobStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMigrationJobsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var accountId: String?

    public var migrationJobName: String?

    public var ownerId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [DescribeMigrationJobsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.migrationJobName != nil {
            map["MigrationJobName"] = self.migrationJobName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("MigrationJobName") {
            self.migrationJobName = dict["MigrationJobName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeMigrationJobsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeMigrationJobsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeMigrationJobsResponseBody : Tea.TeaModel {
    public class MigrationJobs : Tea.TeaModel {
        public class MigrationJob : Tea.TeaModel {
            public class DataInitialization : Tea.TeaModel {
                public var errorMessage: String?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("status") {
                        self.status = dict["status"] as! String
                    }
                }
            }
            public class DataSynchronization : Tea.TeaModel {
                public var delay: String?

                public var errorMessage: String?

                public var percent: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.delay != nil {
                        map["Delay"] = self.delay!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.status != nil {
                        map["status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Delay") {
                        self.delay = dict["Delay"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("status") {
                        self.status = dict["status"] as! String
                    }
                }
            }
            public class DestinationEndpoint : Tea.TeaModel {
                public var databaseName: String?

                public var engineName: String?

                public var IP: String?

                public var instanceID: String?

                public var instanceType: String?

                public var oracleSID: String?

                public var port: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.IP != nil {
                        map["IP"] = self.IP!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("IP") {
                        self.IP = dict["IP"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class MigrationMode : Tea.TeaModel {
                public var dataInitialization: Bool?

                public var dataSynchronization: Bool?

                public var structureInitialization: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataInitialization != nil {
                        map["DataInitialization"] = self.dataInitialization!
                    }
                    if self.dataSynchronization != nil {
                        map["DataSynchronization"] = self.dataSynchronization!
                    }
                    if self.structureInitialization != nil {
                        map["StructureInitialization"] = self.structureInitialization!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataInitialization") {
                        self.dataInitialization = dict["DataInitialization"] as! Bool
                    }
                    if dict.keys.contains("DataSynchronization") {
                        self.dataSynchronization = dict["DataSynchronization"] as! Bool
                    }
                    if dict.keys.contains("StructureInitialization") {
                        self.structureInitialization = dict["StructureInitialization"] as! Bool
                    }
                }
            }
            public class MigrationObject : Tea.TeaModel {
                public class SynchronousObject : Tea.TeaModel {
                    public class TableList : Tea.TeaModel {
                        public var table: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.table != nil {
                                map["Table"] = self.table!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Table") {
                                self.table = dict["Table"] as! [String]
                            }
                        }
                    }
                    public var databaseName: String?

                    public var tableList: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.MigrationObject.SynchronousObject.TableList?

                    public var wholeDatabase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.tableList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.databaseName != nil {
                            map["DatabaseName"] = self.databaseName!
                        }
                        if self.tableList != nil {
                            map["TableList"] = self.tableList?.toMap()
                        }
                        if self.wholeDatabase != nil {
                            map["WholeDatabase"] = self.wholeDatabase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DatabaseName") {
                            self.databaseName = dict["DatabaseName"] as! String
                        }
                        if dict.keys.contains("TableList") {
                            var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.MigrationObject.SynchronousObject.TableList()
                            model.fromMap(dict["TableList"] as! [String: Any])
                            self.tableList = model
                        }
                        if dict.keys.contains("WholeDatabase") {
                            self.wholeDatabase = dict["WholeDatabase"] as! String
                        }
                    }
                }
                public var synchronousObject: [DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.MigrationObject.SynchronousObject]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.synchronousObject != nil {
                        var tmp : [Any] = []
                        for k in self.synchronousObject! {
                            tmp.append(k.toMap())
                        }
                        map["SynchronousObject"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SynchronousObject") {
                        var tmp : [DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.MigrationObject.SynchronousObject] = []
                        for v in dict["SynchronousObject"] as! [Any] {
                            var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.MigrationObject.SynchronousObject()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.synchronousObject = tmp
                    }
                }
            }
            public class Precheck : Tea.TeaModel {
                public var percent: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class SourceEndpoint : Tea.TeaModel {
                public var databaseName: String?

                public var engineName: String?

                public var IP: String?

                public var instanceID: String?

                public var instanceType: String?

                public var oracleSID: String?

                public var port: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.engineName != nil {
                        map["EngineName"] = self.engineName!
                    }
                    if self.IP != nil {
                        map["IP"] = self.IP!
                    }
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.oracleSID != nil {
                        map["OracleSID"] = self.oracleSID!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.userName != nil {
                        map["UserName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("EngineName") {
                        self.engineName = dict["EngineName"] as! String
                    }
                    if dict.keys.contains("IP") {
                        self.IP = dict["IP"] as! String
                    }
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("OracleSID") {
                        self.oracleSID = dict["OracleSID"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("UserName") {
                        self.userName = dict["UserName"] as! String
                    }
                }
            }
            public class StructureInitialization : Tea.TeaModel {
                public var errorMessage: String?

                public var percent: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("status") {
                        self.status = dict["status"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var dataInitialization: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.DataInitialization?

            public var dataSynchronization: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.DataSynchronization?

            public var destinationEndpoint: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.DestinationEndpoint?

            public var instanceCreateTime: String?

            public var jobCreateTime: String?

            public var migrationJobClass: String?

            public var migrationJobID: String?

            public var migrationJobName: String?

            public var migrationJobStatus: String?

            public var migrationMode: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.MigrationMode?

            public var migrationObject: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.MigrationObject?

            public var payType: String?

            public var precheck: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.Precheck?

            public var sourceEndpoint: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.SourceEndpoint?

            public var structureInitialization: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.StructureInitialization?

            public var tags: DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataInitialization?.validate()
                try self.dataSynchronization?.validate()
                try self.destinationEndpoint?.validate()
                try self.migrationMode?.validate()
                try self.migrationObject?.validate()
                try self.precheck?.validate()
                try self.sourceEndpoint?.validate()
                try self.structureInitialization?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataInitialization != nil {
                    map["DataInitialization"] = self.dataInitialization?.toMap()
                }
                if self.dataSynchronization != nil {
                    map["DataSynchronization"] = self.dataSynchronization?.toMap()
                }
                if self.destinationEndpoint != nil {
                    map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
                }
                if self.instanceCreateTime != nil {
                    map["InstanceCreateTime"] = self.instanceCreateTime!
                }
                if self.jobCreateTime != nil {
                    map["JobCreateTime"] = self.jobCreateTime!
                }
                if self.migrationJobClass != nil {
                    map["MigrationJobClass"] = self.migrationJobClass!
                }
                if self.migrationJobID != nil {
                    map["MigrationJobID"] = self.migrationJobID!
                }
                if self.migrationJobName != nil {
                    map["MigrationJobName"] = self.migrationJobName!
                }
                if self.migrationJobStatus != nil {
                    map["MigrationJobStatus"] = self.migrationJobStatus!
                }
                if self.migrationMode != nil {
                    map["MigrationMode"] = self.migrationMode?.toMap()
                }
                if self.migrationObject != nil {
                    map["MigrationObject"] = self.migrationObject?.toMap()
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.precheck != nil {
                    map["Precheck"] = self.precheck?.toMap()
                }
                if self.sourceEndpoint != nil {
                    map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
                }
                if self.structureInitialization != nil {
                    map["StructureInitialization"] = self.structureInitialization?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataInitialization") {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.DataInitialization()
                    model.fromMap(dict["DataInitialization"] as! [String: Any])
                    self.dataInitialization = model
                }
                if dict.keys.contains("DataSynchronization") {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.DataSynchronization()
                    model.fromMap(dict["DataSynchronization"] as! [String: Any])
                    self.dataSynchronization = model
                }
                if dict.keys.contains("DestinationEndpoint") {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.DestinationEndpoint()
                    model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                    self.destinationEndpoint = model
                }
                if dict.keys.contains("InstanceCreateTime") {
                    self.instanceCreateTime = dict["InstanceCreateTime"] as! String
                }
                if dict.keys.contains("JobCreateTime") {
                    self.jobCreateTime = dict["JobCreateTime"] as! String
                }
                if dict.keys.contains("MigrationJobClass") {
                    self.migrationJobClass = dict["MigrationJobClass"] as! String
                }
                if dict.keys.contains("MigrationJobID") {
                    self.migrationJobID = dict["MigrationJobID"] as! String
                }
                if dict.keys.contains("MigrationJobName") {
                    self.migrationJobName = dict["MigrationJobName"] as! String
                }
                if dict.keys.contains("MigrationJobStatus") {
                    self.migrationJobStatus = dict["MigrationJobStatus"] as! String
                }
                if dict.keys.contains("MigrationMode") {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.MigrationMode()
                    model.fromMap(dict["MigrationMode"] as! [String: Any])
                    self.migrationMode = model
                }
                if dict.keys.contains("MigrationObject") {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.MigrationObject()
                    model.fromMap(dict["MigrationObject"] as! [String: Any])
                    self.migrationObject = model
                }
                if dict.keys.contains("PayType") {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("Precheck") {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.Precheck()
                    model.fromMap(dict["Precheck"] as! [String: Any])
                    self.precheck = model
                }
                if dict.keys.contains("SourceEndpoint") {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.SourceEndpoint()
                    model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                    self.sourceEndpoint = model
                }
                if dict.keys.contains("StructureInitialization") {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.StructureInitialization()
                    model.fromMap(dict["StructureInitialization"] as! [String: Any])
                    self.structureInitialization = model
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var migrationJob: [DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.migrationJob != nil {
                var tmp : [Any] = []
                for k in self.migrationJob! {
                    tmp.append(k.toMap())
                }
                map["MigrationJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MigrationJob") {
                var tmp : [DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob] = []
                for v in dict["MigrationJob"] as! [Any] {
                    var model = DescribeMigrationJobsResponseBody.MigrationJobs.MigrationJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.migrationJob = tmp
            }
        }
    }
    public var errCode: String?

    public var errMessage: String?

    public var migrationJobs: DescribeMigrationJobsResponseBody.MigrationJobs?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var success: String?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.migrationJobs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.migrationJobs != nil {
            map["MigrationJobs"] = self.migrationJobs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("MigrationJobs") {
            var model = DescribeMigrationJobsResponseBody.MigrationJobs()
            model.fromMap(dict["MigrationJobs"] as! [String: Any])
            self.migrationJobs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribeMigrationJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMigrationJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMigrationJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePreCheckCreateGadOrderResultRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribePreCheckCreateGadOrderResultResponseBody : Tea.TeaModel {
    public class PreCheckItems : Tea.TeaModel {
        public class PreCheckItems : Tea.TeaModel {
            public var code: String?

            public var message: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var preCheckItems: [DescribePreCheckCreateGadOrderResultResponseBody.PreCheckItems.PreCheckItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preCheckItems != nil {
                var tmp : [Any] = []
                for k in self.preCheckItems! {
                    tmp.append(k.toMap())
                }
                map["PreCheckItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PreCheckItems") {
                var tmp : [DescribePreCheckCreateGadOrderResultResponseBody.PreCheckItems.PreCheckItems] = []
                for v in dict["PreCheckItems"] as! [Any] {
                    var model = DescribePreCheckCreateGadOrderResultResponseBody.PreCheckItems.PreCheckItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.preCheckItems = tmp
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var instanceId: String?

    public var preCheckItems: DescribePreCheckCreateGadOrderResultResponseBody.PreCheckItems?

    public var preCheckResult: Bool?

    public var regionId: String?

    public var requestId: String?

    public var success: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.preCheckItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.preCheckItems != nil {
            map["PreCheckItems"] = self.preCheckItems?.toMap()
        }
        if self.preCheckResult != nil {
            map["PreCheckResult"] = self.preCheckResult!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PreCheckItems") {
            var model = DescribePreCheckCreateGadOrderResultResponseBody.PreCheckItems()
            model.fromMap(dict["PreCheckItems"] as! [String: Any])
            self.preCheckItems = model
        }
        if dict.keys.contains("PreCheckResult") {
            self.preCheckResult = dict["PreCheckResult"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribePreCheckCreateGadOrderResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePreCheckCreateGadOrderResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePreCheckCreateGadOrderResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePreCheckStatusRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var jobCode: String?

    public var name: String?

    public var pageNo: String?

    public var pageSize: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var structPhase: String?

    public var structType: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.jobCode != nil {
            map["JobCode"] = self.jobCode!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.structPhase != nil {
            map["StructPhase"] = self.structPhase!
        }
        if self.structType != nil {
            map["StructType"] = self.structType!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("JobCode") {
            self.jobCode = dict["JobCode"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StructPhase") {
            self.structPhase = dict["StructPhase"] as! String
        }
        if dict.keys.contains("StructType") {
            self.structType = dict["StructType"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class DescribePreCheckStatusResponseBody : Tea.TeaModel {
    public class AnalysisJobProgress : Tea.TeaModel {
        public class Logs : Tea.TeaModel {
            public var errData: String?

            public var errMsg: String?

            public var errType: String?

            public var logLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errData != nil {
                    map["ErrData"] = self.errData!
                }
                if self.errMsg != nil {
                    map["ErrMsg"] = self.errMsg!
                }
                if self.errType != nil {
                    map["ErrType"] = self.errType!
                }
                if self.logLevel != nil {
                    map["LogLevel"] = self.logLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrData") {
                    self.errData = dict["ErrData"] as! String
                }
                if dict.keys.contains("ErrMsg") {
                    self.errMsg = dict["ErrMsg"] as! String
                }
                if dict.keys.contains("ErrType") {
                    self.errType = dict["ErrType"] as! String
                }
                if dict.keys.contains("LogLevel") {
                    self.logLevel = dict["LogLevel"] as! String
                }
            }
        }
        public var bootTime: String?

        public var canSkip: Bool?

        public var current: String?

        public var ddlSql: String?

        public var delaySeconds: Int32?

        public var destSchema: String?

        public var diffRow: Int64?

        public var errDetail: String?

        public var errMsg: String?

        public var finishTime: String?

        public var id: String?

        public var ignoreFlag: String?

        public var item: String?

        public var jobId: String?

        public var logs: [DescribePreCheckStatusResponseBody.AnalysisJobProgress.Logs]?

        public var names: String?

        public var orderNum: Int32?

        public var parentObj: String?

        public var repairMethod: String?

        public var skip: Bool?

        public var sourceSchema: String?

        public var state: String?

        public var sub: String?

        public var targetNames: String?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bootTime != nil {
                map["BootTime"] = self.bootTime!
            }
            if self.canSkip != nil {
                map["CanSkip"] = self.canSkip!
            }
            if self.current != nil {
                map["Current"] = self.current!
            }
            if self.ddlSql != nil {
                map["DdlSql"] = self.ddlSql!
            }
            if self.delaySeconds != nil {
                map["DelaySeconds"] = self.delaySeconds!
            }
            if self.destSchema != nil {
                map["DestSchema"] = self.destSchema!
            }
            if self.diffRow != nil {
                map["DiffRow"] = self.diffRow!
            }
            if self.errDetail != nil {
                map["ErrDetail"] = self.errDetail!
            }
            if self.errMsg != nil {
                map["ErrMsg"] = self.errMsg!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ignoreFlag != nil {
                map["IgnoreFlag"] = self.ignoreFlag!
            }
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.logs != nil {
                var tmp : [Any] = []
                for k in self.logs! {
                    tmp.append(k.toMap())
                }
                map["Logs"] = tmp
            }
            if self.names != nil {
                map["Names"] = self.names!
            }
            if self.orderNum != nil {
                map["OrderNum"] = self.orderNum!
            }
            if self.parentObj != nil {
                map["ParentObj"] = self.parentObj!
            }
            if self.repairMethod != nil {
                map["RepairMethod"] = self.repairMethod!
            }
            if self.skip != nil {
                map["Skip"] = self.skip!
            }
            if self.sourceSchema != nil {
                map["SourceSchema"] = self.sourceSchema!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.sub != nil {
                map["Sub"] = self.sub!
            }
            if self.targetNames != nil {
                map["TargetNames"] = self.targetNames!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BootTime") {
                self.bootTime = dict["BootTime"] as! String
            }
            if dict.keys.contains("CanSkip") {
                self.canSkip = dict["CanSkip"] as! Bool
            }
            if dict.keys.contains("Current") {
                self.current = dict["Current"] as! String
            }
            if dict.keys.contains("DdlSql") {
                self.ddlSql = dict["DdlSql"] as! String
            }
            if dict.keys.contains("DelaySeconds") {
                self.delaySeconds = dict["DelaySeconds"] as! Int32
            }
            if dict.keys.contains("DestSchema") {
                self.destSchema = dict["DestSchema"] as! String
            }
            if dict.keys.contains("DiffRow") {
                self.diffRow = dict["DiffRow"] as! Int64
            }
            if dict.keys.contains("ErrDetail") {
                self.errDetail = dict["ErrDetail"] as! String
            }
            if dict.keys.contains("ErrMsg") {
                self.errMsg = dict["ErrMsg"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IgnoreFlag") {
                self.ignoreFlag = dict["IgnoreFlag"] as! String
            }
            if dict.keys.contains("Item") {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Logs") {
                var tmp : [DescribePreCheckStatusResponseBody.AnalysisJobProgress.Logs] = []
                for v in dict["Logs"] as! [Any] {
                    var model = DescribePreCheckStatusResponseBody.AnalysisJobProgress.Logs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logs = tmp
            }
            if dict.keys.contains("Names") {
                self.names = dict["Names"] as! String
            }
            if dict.keys.contains("OrderNum") {
                self.orderNum = dict["OrderNum"] as! Int32
            }
            if dict.keys.contains("ParentObj") {
                self.parentObj = dict["ParentObj"] as! String
            }
            if dict.keys.contains("RepairMethod") {
                self.repairMethod = dict["RepairMethod"] as! String
            }
            if dict.keys.contains("Skip") {
                self.skip = dict["Skip"] as! Bool
            }
            if dict.keys.contains("SourceSchema") {
                self.sourceSchema = dict["SourceSchema"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Sub") {
                self.sub = dict["Sub"] as! String
            }
            if dict.keys.contains("TargetNames") {
                self.targetNames = dict["TargetNames"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public class FullNetCheckJobStatus : Tea.TeaModel {
        public class JobProgress : Tea.TeaModel {
            public class Logs : Tea.TeaModel {
                public var errData: String?

                public var errMsg: String?

                public var errType: String?

                public var logLevel: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errData != nil {
                        map["ErrData"] = self.errData!
                    }
                    if self.errMsg != nil {
                        map["ErrMsg"] = self.errMsg!
                    }
                    if self.errType != nil {
                        map["ErrType"] = self.errType!
                    }
                    if self.logLevel != nil {
                        map["LogLevel"] = self.logLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrData") {
                        self.errData = dict["ErrData"] as! String
                    }
                    if dict.keys.contains("ErrMsg") {
                        self.errMsg = dict["ErrMsg"] as! String
                    }
                    if dict.keys.contains("ErrType") {
                        self.errType = dict["ErrType"] as! String
                    }
                    if dict.keys.contains("LogLevel") {
                        self.logLevel = dict["LogLevel"] as! String
                    }
                }
            }
            public var bootTime: String?

            public var canSkip: Bool?

            public var current: String?

            public var ddlSql: String?

            public var delaySeconds: Int32?

            public var destSchema: String?

            public var diffRow: Int64?

            public var errDetail: String?

            public var errMsg: String?

            public var finishTime: String?

            public var id: String?

            public var ignoreFlag: String?

            public var item: String?

            public var jobId: String?

            public var logs: [DescribePreCheckStatusResponseBody.FullNetCheckJobStatus.JobProgress.Logs]?

            public var names: String?

            public var orderNum: Int32?

            public var parentObj: String?

            public var repairMethod: String?

            public var skip: Bool?

            public var sourceSchema: String?

            public var state: String?

            public var sub: String?

            public var targetNames: String?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bootTime != nil {
                    map["BootTime"] = self.bootTime!
                }
                if self.canSkip != nil {
                    map["CanSkip"] = self.canSkip!
                }
                if self.current != nil {
                    map["Current"] = self.current!
                }
                if self.ddlSql != nil {
                    map["DdlSql"] = self.ddlSql!
                }
                if self.delaySeconds != nil {
                    map["DelaySeconds"] = self.delaySeconds!
                }
                if self.destSchema != nil {
                    map["DestSchema"] = self.destSchema!
                }
                if self.diffRow != nil {
                    map["DiffRow"] = self.diffRow!
                }
                if self.errDetail != nil {
                    map["ErrDetail"] = self.errDetail!
                }
                if self.errMsg != nil {
                    map["ErrMsg"] = self.errMsg!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ignoreFlag != nil {
                    map["IgnoreFlag"] = self.ignoreFlag!
                }
                if self.item != nil {
                    map["Item"] = self.item!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.logs != nil {
                    var tmp : [Any] = []
                    for k in self.logs! {
                        tmp.append(k.toMap())
                    }
                    map["Logs"] = tmp
                }
                if self.names != nil {
                    map["Names"] = self.names!
                }
                if self.orderNum != nil {
                    map["OrderNum"] = self.orderNum!
                }
                if self.parentObj != nil {
                    map["ParentObj"] = self.parentObj!
                }
                if self.repairMethod != nil {
                    map["RepairMethod"] = self.repairMethod!
                }
                if self.skip != nil {
                    map["Skip"] = self.skip!
                }
                if self.sourceSchema != nil {
                    map["SourceSchema"] = self.sourceSchema!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.sub != nil {
                    map["Sub"] = self.sub!
                }
                if self.targetNames != nil {
                    map["TargetNames"] = self.targetNames!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BootTime") {
                    self.bootTime = dict["BootTime"] as! String
                }
                if dict.keys.contains("CanSkip") {
                    self.canSkip = dict["CanSkip"] as! Bool
                }
                if dict.keys.contains("Current") {
                    self.current = dict["Current"] as! String
                }
                if dict.keys.contains("DdlSql") {
                    self.ddlSql = dict["DdlSql"] as! String
                }
                if dict.keys.contains("DelaySeconds") {
                    self.delaySeconds = dict["DelaySeconds"] as! Int32
                }
                if dict.keys.contains("DestSchema") {
                    self.destSchema = dict["DestSchema"] as! String
                }
                if dict.keys.contains("DiffRow") {
                    self.diffRow = dict["DiffRow"] as! Int64
                }
                if dict.keys.contains("ErrDetail") {
                    self.errDetail = dict["ErrDetail"] as! String
                }
                if dict.keys.contains("ErrMsg") {
                    self.errMsg = dict["ErrMsg"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("IgnoreFlag") {
                    self.ignoreFlag = dict["IgnoreFlag"] as! String
                }
                if dict.keys.contains("Item") {
                    self.item = dict["Item"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Logs") {
                    var tmp : [DescribePreCheckStatusResponseBody.FullNetCheckJobStatus.JobProgress.Logs] = []
                    for v in dict["Logs"] as! [Any] {
                        var model = DescribePreCheckStatusResponseBody.FullNetCheckJobStatus.JobProgress.Logs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.logs = tmp
                }
                if dict.keys.contains("Names") {
                    self.names = dict["Names"] as! String
                }
                if dict.keys.contains("OrderNum") {
                    self.orderNum = dict["OrderNum"] as! Int32
                }
                if dict.keys.contains("ParentObj") {
                    self.parentObj = dict["ParentObj"] as! String
                }
                if dict.keys.contains("RepairMethod") {
                    self.repairMethod = dict["RepairMethod"] as! String
                }
                if dict.keys.contains("Skip") {
                    self.skip = dict["Skip"] as! Bool
                }
                if dict.keys.contains("SourceSchema") {
                    self.sourceSchema = dict["SourceSchema"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Sub") {
                    self.sub = dict["Sub"] as! String
                }
                if dict.keys.contains("TargetNames") {
                    self.targetNames = dict["TargetNames"] as! String
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var code: String?

        public var destRegion: String?

        public var destRegionCidr: String?

        public var destinationEndpointType: String?

        public var errorItem: Int32?

        public var hostRegion: String?

        public var jobId: String?

        public var jobName: String?

        public var jobProgress: [DescribePreCheckStatusResponseBody.FullNetCheckJobStatus.JobProgress]?

        public var sourceEndpointType: String?

        public var srcRegion: String?

        public var srcRegionCidr: String?

        public var state: String?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.destRegion != nil {
                map["DestRegion"] = self.destRegion!
            }
            if self.destRegionCidr != nil {
                map["DestRegionCidr"] = self.destRegionCidr!
            }
            if self.destinationEndpointType != nil {
                map["DestinationEndpointType"] = self.destinationEndpointType!
            }
            if self.errorItem != nil {
                map["ErrorItem"] = self.errorItem!
            }
            if self.hostRegion != nil {
                map["HostRegion"] = self.hostRegion!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.jobProgress != nil {
                var tmp : [Any] = []
                for k in self.jobProgress! {
                    tmp.append(k.toMap())
                }
                map["JobProgress"] = tmp
            }
            if self.sourceEndpointType != nil {
                map["SourceEndpointType"] = self.sourceEndpointType!
            }
            if self.srcRegion != nil {
                map["SrcRegion"] = self.srcRegion!
            }
            if self.srcRegionCidr != nil {
                map["SrcRegionCidr"] = self.srcRegionCidr!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("DestRegion") {
                self.destRegion = dict["DestRegion"] as! String
            }
            if dict.keys.contains("DestRegionCidr") {
                self.destRegionCidr = dict["DestRegionCidr"] as! String
            }
            if dict.keys.contains("DestinationEndpointType") {
                self.destinationEndpointType = dict["DestinationEndpointType"] as! String
            }
            if dict.keys.contains("ErrorItem") {
                self.errorItem = dict["ErrorItem"] as! Int32
            }
            if dict.keys.contains("HostRegion") {
                self.hostRegion = dict["HostRegion"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("JobProgress") {
                var tmp : [DescribePreCheckStatusResponseBody.FullNetCheckJobStatus.JobProgress] = []
                for v in dict["JobProgress"] as! [Any] {
                    var model = DescribePreCheckStatusResponseBody.FullNetCheckJobStatus.JobProgress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.jobProgress = tmp
            }
            if dict.keys.contains("SourceEndpointType") {
                self.sourceEndpointType = dict["SourceEndpointType"] as! String
            }
            if dict.keys.contains("SrcRegion") {
                self.srcRegion = dict["SrcRegion"] as! String
            }
            if dict.keys.contains("SrcRegionCidr") {
                self.srcRegionCidr = dict["SrcRegionCidr"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public class JobProgress : Tea.TeaModel {
        public class Logs : Tea.TeaModel {
            public var errData: String?

            public var errMsg: String?

            public var errType: String?

            public var logLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errData != nil {
                    map["ErrData"] = self.errData!
                }
                if self.errMsg != nil {
                    map["ErrMsg"] = self.errMsg!
                }
                if self.errType != nil {
                    map["ErrType"] = self.errType!
                }
                if self.logLevel != nil {
                    map["LogLevel"] = self.logLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrData") {
                    self.errData = dict["ErrData"] as! String
                }
                if dict.keys.contains("ErrMsg") {
                    self.errMsg = dict["ErrMsg"] as! String
                }
                if dict.keys.contains("ErrType") {
                    self.errType = dict["ErrType"] as! String
                }
                if dict.keys.contains("LogLevel") {
                    self.logLevel = dict["LogLevel"] as! String
                }
            }
        }
        public var bootTime: String?

        public var canSkip: Bool?

        public var current: String?

        public var ddlSql: String?

        public var delaySeconds: Int32?

        public var destSchema: String?

        public var diffRow: Int64?

        public var errDetail: String?

        public var errMsg: String?

        public var finishTime: String?

        public var id: String?

        public var ignoreFlag: String?

        public var item: String?

        public var jobId: String?

        public var logs: [DescribePreCheckStatusResponseBody.JobProgress.Logs]?

        public var names: String?

        public var orderNum: Int32?

        public var parentObj: String?

        public var repairMethod: String?

        public var skip: Bool?

        public var sourceSchema: String?

        public var state: String?

        public var sub: String?

        public var targetNames: String?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bootTime != nil {
                map["BootTime"] = self.bootTime!
            }
            if self.canSkip != nil {
                map["CanSkip"] = self.canSkip!
            }
            if self.current != nil {
                map["Current"] = self.current!
            }
            if self.ddlSql != nil {
                map["DdlSql"] = self.ddlSql!
            }
            if self.delaySeconds != nil {
                map["DelaySeconds"] = self.delaySeconds!
            }
            if self.destSchema != nil {
                map["DestSchema"] = self.destSchema!
            }
            if self.diffRow != nil {
                map["DiffRow"] = self.diffRow!
            }
            if self.errDetail != nil {
                map["ErrDetail"] = self.errDetail!
            }
            if self.errMsg != nil {
                map["ErrMsg"] = self.errMsg!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.ignoreFlag != nil {
                map["IgnoreFlag"] = self.ignoreFlag!
            }
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.logs != nil {
                var tmp : [Any] = []
                for k in self.logs! {
                    tmp.append(k.toMap())
                }
                map["Logs"] = tmp
            }
            if self.names != nil {
                map["Names"] = self.names!
            }
            if self.orderNum != nil {
                map["OrderNum"] = self.orderNum!
            }
            if self.parentObj != nil {
                map["ParentObj"] = self.parentObj!
            }
            if self.repairMethod != nil {
                map["RepairMethod"] = self.repairMethod!
            }
            if self.skip != nil {
                map["Skip"] = self.skip!
            }
            if self.sourceSchema != nil {
                map["SourceSchema"] = self.sourceSchema!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.sub != nil {
                map["Sub"] = self.sub!
            }
            if self.targetNames != nil {
                map["TargetNames"] = self.targetNames!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BootTime") {
                self.bootTime = dict["BootTime"] as! String
            }
            if dict.keys.contains("CanSkip") {
                self.canSkip = dict["CanSkip"] as! Bool
            }
            if dict.keys.contains("Current") {
                self.current = dict["Current"] as! String
            }
            if dict.keys.contains("DdlSql") {
                self.ddlSql = dict["DdlSql"] as! String
            }
            if dict.keys.contains("DelaySeconds") {
                self.delaySeconds = dict["DelaySeconds"] as! Int32
            }
            if dict.keys.contains("DestSchema") {
                self.destSchema = dict["DestSchema"] as! String
            }
            if dict.keys.contains("DiffRow") {
                self.diffRow = dict["DiffRow"] as! Int64
            }
            if dict.keys.contains("ErrDetail") {
                self.errDetail = dict["ErrDetail"] as! String
            }
            if dict.keys.contains("ErrMsg") {
                self.errMsg = dict["ErrMsg"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("IgnoreFlag") {
                self.ignoreFlag = dict["IgnoreFlag"] as! String
            }
            if dict.keys.contains("Item") {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Logs") {
                var tmp : [DescribePreCheckStatusResponseBody.JobProgress.Logs] = []
                for v in dict["Logs"] as! [Any] {
                    var model = DescribePreCheckStatusResponseBody.JobProgress.Logs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logs = tmp
            }
            if dict.keys.contains("Names") {
                self.names = dict["Names"] as! String
            }
            if dict.keys.contains("OrderNum") {
                self.orderNum = dict["OrderNum"] as! Int32
            }
            if dict.keys.contains("ParentObj") {
                self.parentObj = dict["ParentObj"] as! String
            }
            if dict.keys.contains("RepairMethod") {
                self.repairMethod = dict["RepairMethod"] as! String
            }
            if dict.keys.contains("Skip") {
                self.skip = dict["Skip"] as! Bool
            }
            if dict.keys.contains("SourceSchema") {
                self.sourceSchema = dict["SourceSchema"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Sub") {
                self.sub = dict["Sub"] as! String
            }
            if dict.keys.contains("TargetNames") {
                self.targetNames = dict["TargetNames"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public class NetworkDiagnosisResult : Tea.TeaModel {
        public class Diagnosis : Tea.TeaModel {
            public var cnDocUrl: String?

            public var code: String?

            public var endpointType: String?

            public var internationalDocUrl: String?

            public var result: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cnDocUrl != nil {
                    map["CnDocUrl"] = self.cnDocUrl!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.endpointType != nil {
                    map["EndpointType"] = self.endpointType!
                }
                if self.internationalDocUrl != nil {
                    map["InternationalDocUrl"] = self.internationalDocUrl!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CnDocUrl") {
                    self.cnDocUrl = dict["CnDocUrl"] as! String
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("EndpointType") {
                    self.endpointType = dict["EndpointType"] as! String
                }
                if dict.keys.contains("InternationalDocUrl") {
                    self.internationalDocUrl = dict["InternationalDocUrl"] as! String
                }
                if dict.keys.contains("Result") {
                    self.result = dict["Result"] as! String
                }
            }
        }
        public var diagnosis: [DescribePreCheckStatusResponseBody.NetworkDiagnosisResult.Diagnosis]?

        public var modelVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diagnosis != nil {
                var tmp : [Any] = []
                for k in self.diagnosis! {
                    tmp.append(k.toMap())
                }
                map["Diagnosis"] = tmp
            }
            if self.modelVersion != nil {
                map["ModelVersion"] = self.modelVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Diagnosis") {
                var tmp : [DescribePreCheckStatusResponseBody.NetworkDiagnosisResult.Diagnosis] = []
                for v in dict["Diagnosis"] as! [Any] {
                    var model = DescribePreCheckStatusResponseBody.NetworkDiagnosisResult.Diagnosis()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.diagnosis = tmp
            }
            if dict.keys.contains("ModelVersion") {
                self.modelVersion = dict["ModelVersion"] as! String
            }
        }
    }
    public class SubDistributedJobStatus : Tea.TeaModel {
        public class JobProgress : Tea.TeaModel {
            public class Logs : Tea.TeaModel {
                public var errData: String?

                public var errMsg: String?

                public var errType: String?

                public var logLevel: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errData != nil {
                        map["ErrData"] = self.errData!
                    }
                    if self.errMsg != nil {
                        map["ErrMsg"] = self.errMsg!
                    }
                    if self.errType != nil {
                        map["ErrType"] = self.errType!
                    }
                    if self.logLevel != nil {
                        map["LogLevel"] = self.logLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrData") {
                        self.errData = dict["ErrData"] as! String
                    }
                    if dict.keys.contains("ErrMsg") {
                        self.errMsg = dict["ErrMsg"] as! String
                    }
                    if dict.keys.contains("ErrType") {
                        self.errType = dict["ErrType"] as! String
                    }
                    if dict.keys.contains("LogLevel") {
                        self.logLevel = dict["LogLevel"] as! String
                    }
                }
            }
            public var bootTime: String?

            public var canSkip: Bool?

            public var current: String?

            public var ddlSql: String?

            public var delaySeconds: Int32?

            public var destSchema: String?

            public var diffRow: Int64?

            public var errDetail: String?

            public var errMsg: String?

            public var finishTime: String?

            public var id: String?

            public var ignoreFlag: String?

            public var item: String?

            public var jobId: String?

            public var logs: [DescribePreCheckStatusResponseBody.SubDistributedJobStatus.JobProgress.Logs]?

            public var names: String?

            public var orderNum: Int32?

            public var parentObj: String?

            public var repairMethod: String?

            public var skip: Bool?

            public var sourceSchema: String?

            public var state: String?

            public var sub: String?

            public var targetNames: String?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bootTime != nil {
                    map["BootTime"] = self.bootTime!
                }
                if self.canSkip != nil {
                    map["CanSkip"] = self.canSkip!
                }
                if self.current != nil {
                    map["Current"] = self.current!
                }
                if self.ddlSql != nil {
                    map["DdlSql"] = self.ddlSql!
                }
                if self.delaySeconds != nil {
                    map["DelaySeconds"] = self.delaySeconds!
                }
                if self.destSchema != nil {
                    map["DestSchema"] = self.destSchema!
                }
                if self.diffRow != nil {
                    map["DiffRow"] = self.diffRow!
                }
                if self.errDetail != nil {
                    map["ErrDetail"] = self.errDetail!
                }
                if self.errMsg != nil {
                    map["ErrMsg"] = self.errMsg!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ignoreFlag != nil {
                    map["IgnoreFlag"] = self.ignoreFlag!
                }
                if self.item != nil {
                    map["Item"] = self.item!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.logs != nil {
                    var tmp : [Any] = []
                    for k in self.logs! {
                        tmp.append(k.toMap())
                    }
                    map["Logs"] = tmp
                }
                if self.names != nil {
                    map["Names"] = self.names!
                }
                if self.orderNum != nil {
                    map["OrderNum"] = self.orderNum!
                }
                if self.parentObj != nil {
                    map["ParentObj"] = self.parentObj!
                }
                if self.repairMethod != nil {
                    map["RepairMethod"] = self.repairMethod!
                }
                if self.skip != nil {
                    map["Skip"] = self.skip!
                }
                if self.sourceSchema != nil {
                    map["SourceSchema"] = self.sourceSchema!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.sub != nil {
                    map["Sub"] = self.sub!
                }
                if self.targetNames != nil {
                    map["TargetNames"] = self.targetNames!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BootTime") {
                    self.bootTime = dict["BootTime"] as! String
                }
                if dict.keys.contains("CanSkip") {
                    self.canSkip = dict["CanSkip"] as! Bool
                }
                if dict.keys.contains("Current") {
                    self.current = dict["Current"] as! String
                }
                if dict.keys.contains("DdlSql") {
                    self.ddlSql = dict["DdlSql"] as! String
                }
                if dict.keys.contains("DelaySeconds") {
                    self.delaySeconds = dict["DelaySeconds"] as! Int32
                }
                if dict.keys.contains("DestSchema") {
                    self.destSchema = dict["DestSchema"] as! String
                }
                if dict.keys.contains("DiffRow") {
                    self.diffRow = dict["DiffRow"] as! Int64
                }
                if dict.keys.contains("ErrDetail") {
                    self.errDetail = dict["ErrDetail"] as! String
                }
                if dict.keys.contains("ErrMsg") {
                    self.errMsg = dict["ErrMsg"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("IgnoreFlag") {
                    self.ignoreFlag = dict["IgnoreFlag"] as! String
                }
                if dict.keys.contains("Item") {
                    self.item = dict["Item"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Logs") {
                    var tmp : [DescribePreCheckStatusResponseBody.SubDistributedJobStatus.JobProgress.Logs] = []
                    for v in dict["Logs"] as! [Any] {
                        var model = DescribePreCheckStatusResponseBody.SubDistributedJobStatus.JobProgress.Logs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.logs = tmp
                }
                if dict.keys.contains("Names") {
                    self.names = dict["Names"] as! String
                }
                if dict.keys.contains("OrderNum") {
                    self.orderNum = dict["OrderNum"] as! Int32
                }
                if dict.keys.contains("ParentObj") {
                    self.parentObj = dict["ParentObj"] as! String
                }
                if dict.keys.contains("RepairMethod") {
                    self.repairMethod = dict["RepairMethod"] as! String
                }
                if dict.keys.contains("Skip") {
                    self.skip = dict["Skip"] as! Bool
                }
                if dict.keys.contains("SourceSchema") {
                    self.sourceSchema = dict["SourceSchema"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Sub") {
                    self.sub = dict["Sub"] as! String
                }
                if dict.keys.contains("TargetNames") {
                    self.targetNames = dict["TargetNames"] as! String
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var code: String?

        public var errorItem: Int32?

        public var jobId: String?

        public var jobName: String?

        public var jobProgress: [DescribePreCheckStatusResponseBody.SubDistributedJobStatus.JobProgress]?

        public var state: String?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.errorItem != nil {
                map["ErrorItem"] = self.errorItem!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.jobProgress != nil {
                var tmp : [Any] = []
                for k in self.jobProgress! {
                    tmp.append(k.toMap())
                }
                map["JobProgress"] = tmp
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ErrorItem") {
                self.errorItem = dict["ErrorItem"] as! Int32
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("JobProgress") {
                var tmp : [DescribePreCheckStatusResponseBody.SubDistributedJobStatus.JobProgress] = []
                for v in dict["JobProgress"] as! [Any] {
                    var model = DescribePreCheckStatusResponseBody.SubDistributedJobStatus.JobProgress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.jobProgress = tmp
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var analysisJobProgress: [DescribePreCheckStatusResponseBody.AnalysisJobProgress]?

    public var code: String?

    public var errorAnalysisItem: Int32?

    public var errorItem: Int32?

    public var fullNetCheckJobStatus: [DescribePreCheckStatusResponseBody.FullNetCheckJobStatus]?

    public var httpStatusCode: Int32?

    public var jobId: String?

    public var jobName: String?

    public var jobProgress: [DescribePreCheckStatusResponseBody.JobProgress]?

    public var networkDiagnosisResult: DescribePreCheckStatusResponseBody.NetworkDiagnosisResult?

    public var pageNumber: Int64?

    public var pageRecordCount: Int64?

    public var requestId: String?

    public var state: String?

    public var subDistributedJobStatus: [DescribePreCheckStatusResponseBody.SubDistributedJobStatus]?

    public var success: Bool?

    public var total: Int32?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkDiagnosisResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisJobProgress != nil {
            var tmp : [Any] = []
            for k in self.analysisJobProgress! {
                tmp.append(k.toMap())
            }
            map["AnalysisJobProgress"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorAnalysisItem != nil {
            map["ErrorAnalysisItem"] = self.errorAnalysisItem!
        }
        if self.errorItem != nil {
            map["ErrorItem"] = self.errorItem!
        }
        if self.fullNetCheckJobStatus != nil {
            var tmp : [Any] = []
            for k in self.fullNetCheckJobStatus! {
                tmp.append(k.toMap())
            }
            map["FullNetCheckJobStatus"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobProgress != nil {
            var tmp : [Any] = []
            for k in self.jobProgress! {
                tmp.append(k.toMap())
            }
            map["JobProgress"] = tmp
        }
        if self.networkDiagnosisResult != nil {
            map["NetworkDiagnosisResult"] = self.networkDiagnosisResult?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.subDistributedJobStatus != nil {
            var tmp : [Any] = []
            for k in self.subDistributedJobStatus! {
                tmp.append(k.toMap())
            }
            map["SubDistributedJobStatus"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisJobProgress") {
            var tmp : [DescribePreCheckStatusResponseBody.AnalysisJobProgress] = []
            for v in dict["AnalysisJobProgress"] as! [Any] {
                var model = DescribePreCheckStatusResponseBody.AnalysisJobProgress()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.analysisJobProgress = tmp
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorAnalysisItem") {
            self.errorAnalysisItem = dict["ErrorAnalysisItem"] as! Int32
        }
        if dict.keys.contains("ErrorItem") {
            self.errorItem = dict["ErrorItem"] as! Int32
        }
        if dict.keys.contains("FullNetCheckJobStatus") {
            var tmp : [DescribePreCheckStatusResponseBody.FullNetCheckJobStatus] = []
            for v in dict["FullNetCheckJobStatus"] as! [Any] {
                var model = DescribePreCheckStatusResponseBody.FullNetCheckJobStatus()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fullNetCheckJobStatus = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("JobProgress") {
            var tmp : [DescribePreCheckStatusResponseBody.JobProgress] = []
            for v in dict["JobProgress"] as! [Any] {
                var model = DescribePreCheckStatusResponseBody.JobProgress()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobProgress = tmp
        }
        if dict.keys.contains("NetworkDiagnosisResult") {
            var model = DescribePreCheckStatusResponseBody.NetworkDiagnosisResult()
            model.fromMap(dict["NetworkDiagnosisResult"] as! [String: Any])
            self.networkDiagnosisResult = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("SubDistributedJobStatus") {
            var tmp : [DescribePreCheckStatusResponseBody.SubDistributedJobStatus] = []
            for v in dict["SubDistributedJobStatus"] as! [Any] {
                var model = DescribePreCheckStatusResponseBody.SubDistributedJobStatus()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.subDistributedJobStatus = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribePreCheckStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePreCheckStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePreCheckStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSubscriptionInstanceAlertRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
    }
}

public class DescribeSubscriptionInstanceAlertResponseBody : Tea.TeaModel {
    public var delayAlertPhone: String?

    public var delayAlertStatus: String?

    public var delayOverSeconds: String?

    public var errCode: String?

    public var errMessage: String?

    public var errorAlertPhone: String?

    public var errorAlertStatus: String?

    public var requestId: String?

    public var subscriptionInstanceID: String?

    public var subscriptionInstanceName: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.delayAlertPhone != nil {
            map["DelayAlertPhone"] = self.delayAlertPhone!
        }
        if self.delayAlertStatus != nil {
            map["DelayAlertStatus"] = self.delayAlertStatus!
        }
        if self.delayOverSeconds != nil {
            map["DelayOverSeconds"] = self.delayOverSeconds!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.errorAlertPhone != nil {
            map["ErrorAlertPhone"] = self.errorAlertPhone!
        }
        if self.errorAlertStatus != nil {
            map["ErrorAlertStatus"] = self.errorAlertStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subscriptionInstanceID != nil {
            map["SubscriptionInstanceID"] = self.subscriptionInstanceID!
        }
        if self.subscriptionInstanceName != nil {
            map["SubscriptionInstanceName"] = self.subscriptionInstanceName!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DelayAlertPhone") {
            self.delayAlertPhone = dict["DelayAlertPhone"] as! String
        }
        if dict.keys.contains("DelayAlertStatus") {
            self.delayAlertStatus = dict["DelayAlertStatus"] as! String
        }
        if dict.keys.contains("DelayOverSeconds") {
            self.delayOverSeconds = dict["DelayOverSeconds"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("ErrorAlertPhone") {
            self.errorAlertPhone = dict["ErrorAlertPhone"] as! String
        }
        if dict.keys.contains("ErrorAlertStatus") {
            self.errorAlertStatus = dict["ErrorAlertStatus"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceID") {
            self.subscriptionInstanceID = dict["SubscriptionInstanceID"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceName") {
            self.subscriptionInstanceName = dict["SubscriptionInstanceName"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSubscriptionInstanceAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSubscriptionInstanceAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSubscriptionInstanceAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSubscriptionInstanceStatusRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
    }
}

public class DescribeSubscriptionInstanceStatusResponseBody : Tea.TeaModel {
    public class SourceEndpoint : Tea.TeaModel {
        public var instanceID: String?

        public var instanceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceID != nil {
                map["InstanceID"] = self.instanceID!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceID") {
                self.instanceID = dict["InstanceID"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
        }
    }
    public class SubscriptionDataType : Tea.TeaModel {
        public var DDL: Bool?

        public var DML: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DDL != nil {
                map["DDL"] = self.DDL!
            }
            if self.DML != nil {
                map["DML"] = self.DML!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DDL") {
                self.DDL = dict["DDL"] as! Bool
            }
            if dict.keys.contains("DML") {
                self.DML = dict["DML"] as! Bool
            }
        }
    }
    public class SubscriptionHost : Tea.TeaModel {
        public var privateHost: String?

        public var publicHost: String?

        public var VPCHost: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privateHost != nil {
                map["PrivateHost"] = self.privateHost!
            }
            if self.publicHost != nil {
                map["PublicHost"] = self.publicHost!
            }
            if self.VPCHost != nil {
                map["VPCHost"] = self.VPCHost!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrivateHost") {
                self.privateHost = dict["PrivateHost"] as! String
            }
            if dict.keys.contains("PublicHost") {
                self.publicHost = dict["PublicHost"] as! String
            }
            if dict.keys.contains("VPCHost") {
                self.VPCHost = dict["VPCHost"] as! String
            }
        }
    }
    public class SubscriptionObject : Tea.TeaModel {
        public class SynchronousObject : Tea.TeaModel {
            public class TableList : Tea.TeaModel {
                public var table: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.table != nil {
                        map["Table"] = self.table!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Table") {
                        self.table = dict["Table"] as! [String]
                    }
                }
            }
            public var databaseName: String?

            public var tableList: DescribeSubscriptionInstanceStatusResponseBody.SubscriptionObject.SynchronousObject.TableList?

            public var wholeDatabase: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tableList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.tableList != nil {
                    map["TableList"] = self.tableList?.toMap()
                }
                if self.wholeDatabase != nil {
                    map["WholeDatabase"] = self.wholeDatabase!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("TableList") {
                    var model = DescribeSubscriptionInstanceStatusResponseBody.SubscriptionObject.SynchronousObject.TableList()
                    model.fromMap(dict["TableList"] as! [String: Any])
                    self.tableList = model
                }
                if dict.keys.contains("WholeDatabase") {
                    self.wholeDatabase = dict["WholeDatabase"] as! String
                }
            }
        }
        public var synchronousObject: [DescribeSubscriptionInstanceStatusResponseBody.SubscriptionObject.SynchronousObject]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.synchronousObject != nil {
                var tmp : [Any] = []
                for k in self.synchronousObject! {
                    tmp.append(k.toMap())
                }
                map["SynchronousObject"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SynchronousObject") {
                var tmp : [DescribeSubscriptionInstanceStatusResponseBody.SubscriptionObject.SynchronousObject] = []
                for v in dict["SynchronousObject"] as! [Any] {
                    var model = DescribeSubscriptionInstanceStatusResponseBody.SubscriptionObject.SynchronousObject()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.synchronousObject = tmp
            }
        }
    }
    public var beginTimestamp: String?

    public var consumptionCheckpoint: String?

    public var consumptionClient: String?

    public var endTimestamp: String?

    public var errCode: String?

    public var errMessage: String?

    public var errorMessage: String?

    public var payType: String?

    public var requestId: String?

    public var sourceEndpoint: DescribeSubscriptionInstanceStatusResponseBody.SourceEndpoint?

    public var status: String?

    public var subscribeTopic: String?

    public var subscriptionDataType: DescribeSubscriptionInstanceStatusResponseBody.SubscriptionDataType?

    public var subscriptionHost: DescribeSubscriptionInstanceStatusResponseBody.SubscriptionHost?

    public var subscriptionInstanceID: String?

    public var subscriptionInstanceName: String?

    public var subscriptionObject: DescribeSubscriptionInstanceStatusResponseBody.SubscriptionObject?

    public var success: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceEndpoint?.validate()
        try self.subscriptionDataType?.validate()
        try self.subscriptionHost?.validate()
        try self.subscriptionObject?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTimestamp != nil {
            map["BeginTimestamp"] = self.beginTimestamp!
        }
        if self.consumptionCheckpoint != nil {
            map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
        }
        if self.consumptionClient != nil {
            map["ConsumptionClient"] = self.consumptionClient!
        }
        if self.endTimestamp != nil {
            map["EndTimestamp"] = self.endTimestamp!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subscribeTopic != nil {
            map["SubscribeTopic"] = self.subscribeTopic!
        }
        if self.subscriptionDataType != nil {
            map["SubscriptionDataType"] = self.subscriptionDataType?.toMap()
        }
        if self.subscriptionHost != nil {
            map["SubscriptionHost"] = self.subscriptionHost?.toMap()
        }
        if self.subscriptionInstanceID != nil {
            map["SubscriptionInstanceID"] = self.subscriptionInstanceID!
        }
        if self.subscriptionInstanceName != nil {
            map["SubscriptionInstanceName"] = self.subscriptionInstanceName!
        }
        if self.subscriptionObject != nil {
            map["SubscriptionObject"] = self.subscriptionObject?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTimestamp") {
            self.beginTimestamp = dict["BeginTimestamp"] as! String
        }
        if dict.keys.contains("ConsumptionCheckpoint") {
            self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
        }
        if dict.keys.contains("ConsumptionClient") {
            self.consumptionClient = dict["ConsumptionClient"] as! String
        }
        if dict.keys.contains("EndTimestamp") {
            self.endTimestamp = dict["EndTimestamp"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceEndpoint") {
            var model = DescribeSubscriptionInstanceStatusResponseBody.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SubscribeTopic") {
            self.subscribeTopic = dict["SubscribeTopic"] as! String
        }
        if dict.keys.contains("SubscriptionDataType") {
            var model = DescribeSubscriptionInstanceStatusResponseBody.SubscriptionDataType()
            model.fromMap(dict["SubscriptionDataType"] as! [String: Any])
            self.subscriptionDataType = model
        }
        if dict.keys.contains("SubscriptionHost") {
            var model = DescribeSubscriptionInstanceStatusResponseBody.SubscriptionHost()
            model.fromMap(dict["SubscriptionHost"] as! [String: Any])
            self.subscriptionHost = model
        }
        if dict.keys.contains("SubscriptionInstanceID") {
            self.subscriptionInstanceID = dict["SubscriptionInstanceID"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceName") {
            self.subscriptionInstanceName = dict["SubscriptionInstanceName"] as! String
        }
        if dict.keys.contains("SubscriptionObject") {
            var model = DescribeSubscriptionInstanceStatusResponseBody.SubscriptionObject()
            model.fromMap(dict["SubscriptionObject"] as! [String: Any])
            self.subscriptionObject = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeSubscriptionInstanceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSubscriptionInstanceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSubscriptionInstanceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSubscriptionInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceName: String?

    public var tag: [DescribeSubscriptionInstancesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceName != nil {
            map["SubscriptionInstanceName"] = self.subscriptionInstanceName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceName") {
            self.subscriptionInstanceName = dict["SubscriptionInstanceName"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeSubscriptionInstancesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeSubscriptionInstancesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeSubscriptionInstancesResponseBody : Tea.TeaModel {
    public class SubscriptionInstances : Tea.TeaModel {
        public class SubscriptionInstance : Tea.TeaModel {
            public class SourceEndpoint : Tea.TeaModel {
                public var instanceID: String?

                public var instanceType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceID != nil {
                        map["InstanceID"] = self.instanceID!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceID") {
                        self.instanceID = dict["InstanceID"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                }
            }
            public class SubscriptionDataType : Tea.TeaModel {
                public var DDL: Bool?

                public var DML: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.DDL != nil {
                        map["DDL"] = self.DDL!
                    }
                    if self.DML != nil {
                        map["DML"] = self.DML!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DDL") {
                        self.DDL = dict["DDL"] as! Bool
                    }
                    if dict.keys.contains("DML") {
                        self.DML = dict["DML"] as! Bool
                    }
                }
            }
            public class SubscriptionHost : Tea.TeaModel {
                public var privateHost: String?

                public var publicHost: String?

                public var VPCHost: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateHost != nil {
                        map["PrivateHost"] = self.privateHost!
                    }
                    if self.publicHost != nil {
                        map["PublicHost"] = self.publicHost!
                    }
                    if self.VPCHost != nil {
                        map["VPCHost"] = self.VPCHost!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateHost") {
                        self.privateHost = dict["PrivateHost"] as! String
                    }
                    if dict.keys.contains("PublicHost") {
                        self.publicHost = dict["PublicHost"] as! String
                    }
                    if dict.keys.contains("VPCHost") {
                        self.VPCHost = dict["VPCHost"] as! String
                    }
                }
            }
            public class SubscriptionObject : Tea.TeaModel {
                public class SynchronousObject : Tea.TeaModel {
                    public class TableList : Tea.TeaModel {
                        public var table: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.table != nil {
                                map["Table"] = self.table!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Table") {
                                self.table = dict["Table"] as! [String]
                            }
                        }
                    }
                    public var databaseName: String?

                    public var tableList: DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionObject.SynchronousObject.TableList?

                    public var wholeDatabase: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.tableList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.databaseName != nil {
                            map["DatabaseName"] = self.databaseName!
                        }
                        if self.tableList != nil {
                            map["TableList"] = self.tableList?.toMap()
                        }
                        if self.wholeDatabase != nil {
                            map["WholeDatabase"] = self.wholeDatabase!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DatabaseName") {
                            self.databaseName = dict["DatabaseName"] as! String
                        }
                        if dict.keys.contains("TableList") {
                            var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionObject.SynchronousObject.TableList()
                            model.fromMap(dict["TableList"] as! [String: Any])
                            self.tableList = model
                        }
                        if dict.keys.contains("WholeDatabase") {
                            self.wholeDatabase = dict["WholeDatabase"] as! String
                        }
                    }
                }
                public var synchronousObject: [DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionObject.SynchronousObject]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.synchronousObject != nil {
                        var tmp : [Any] = []
                        for k in self.synchronousObject! {
                            tmp.append(k.toMap())
                        }
                        map["SynchronousObject"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SynchronousObject") {
                        var tmp : [DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionObject.SynchronousObject] = []
                        for v in dict["SynchronousObject"] as! [Any] {
                            var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionObject.SynchronousObject()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.synchronousObject = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var beginTimestamp: String?

            public var consumptionCheckpoint: String?

            public var consumptionClient: String?

            public var endTimestamp: String?

            public var errorMessage: String?

            public var instanceCreateTime: String?

            public var jobCreateTime: String?

            public var payType: String?

            public var sourceEndpoint: DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SourceEndpoint?

            public var status: String?

            public var subscribeTopic: String?

            public var subscriptionDataType: DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionDataType?

            public var subscriptionHost: DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionHost?

            public var subscriptionInstanceID: String?

            public var subscriptionInstanceName: String?

            public var subscriptionObject: DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionObject?

            public var tags: DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.sourceEndpoint?.validate()
                try self.subscriptionDataType?.validate()
                try self.subscriptionHost?.validate()
                try self.subscriptionObject?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginTimestamp != nil {
                    map["BeginTimestamp"] = self.beginTimestamp!
                }
                if self.consumptionCheckpoint != nil {
                    map["ConsumptionCheckpoint"] = self.consumptionCheckpoint!
                }
                if self.consumptionClient != nil {
                    map["ConsumptionClient"] = self.consumptionClient!
                }
                if self.endTimestamp != nil {
                    map["EndTimestamp"] = self.endTimestamp!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.instanceCreateTime != nil {
                    map["InstanceCreateTime"] = self.instanceCreateTime!
                }
                if self.jobCreateTime != nil {
                    map["JobCreateTime"] = self.jobCreateTime!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.sourceEndpoint != nil {
                    map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.subscribeTopic != nil {
                    map["SubscribeTopic"] = self.subscribeTopic!
                }
                if self.subscriptionDataType != nil {
                    map["SubscriptionDataType"] = self.subscriptionDataType?.toMap()
                }
                if self.subscriptionHost != nil {
                    map["SubscriptionHost"] = self.subscriptionHost?.toMap()
                }
                if self.subscriptionInstanceID != nil {
                    map["SubscriptionInstanceID"] = self.subscriptionInstanceID!
                }
                if self.subscriptionInstanceName != nil {
                    map["SubscriptionInstanceName"] = self.subscriptionInstanceName!
                }
                if self.subscriptionObject != nil {
                    map["SubscriptionObject"] = self.subscriptionObject?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeginTimestamp") {
                    self.beginTimestamp = dict["BeginTimestamp"] as! String
                }
                if dict.keys.contains("ConsumptionCheckpoint") {
                    self.consumptionCheckpoint = dict["ConsumptionCheckpoint"] as! String
                }
                if dict.keys.contains("ConsumptionClient") {
                    self.consumptionClient = dict["ConsumptionClient"] as! String
                }
                if dict.keys.contains("EndTimestamp") {
                    self.endTimestamp = dict["EndTimestamp"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("InstanceCreateTime") {
                    self.instanceCreateTime = dict["InstanceCreateTime"] as! String
                }
                if dict.keys.contains("JobCreateTime") {
                    self.jobCreateTime = dict["JobCreateTime"] as! String
                }
                if dict.keys.contains("PayType") {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("SourceEndpoint") {
                    var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SourceEndpoint()
                    model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                    self.sourceEndpoint = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SubscribeTopic") {
                    self.subscribeTopic = dict["SubscribeTopic"] as! String
                }
                if dict.keys.contains("SubscriptionDataType") {
                    var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionDataType()
                    model.fromMap(dict["SubscriptionDataType"] as! [String: Any])
                    self.subscriptionDataType = model
                }
                if dict.keys.contains("SubscriptionHost") {
                    var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionHost()
                    model.fromMap(dict["SubscriptionHost"] as! [String: Any])
                    self.subscriptionHost = model
                }
                if dict.keys.contains("SubscriptionInstanceID") {
                    self.subscriptionInstanceID = dict["SubscriptionInstanceID"] as! String
                }
                if dict.keys.contains("SubscriptionInstanceName") {
                    self.subscriptionInstanceName = dict["SubscriptionInstanceName"] as! String
                }
                if dict.keys.contains("SubscriptionObject") {
                    var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.SubscriptionObject()
                    model.fromMap(dict["SubscriptionObject"] as! [String: Any])
                    self.subscriptionObject = model
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var subscriptionInstance: [DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subscriptionInstance != nil {
                var tmp : [Any] = []
                for k in self.subscriptionInstance! {
                    tmp.append(k.toMap())
                }
                map["SubscriptionInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SubscriptionInstance") {
                var tmp : [DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance] = []
                for v in dict["SubscriptionInstance"] as! [Any] {
                    var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances.SubscriptionInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subscriptionInstance = tmp
            }
        }
    }
    public var errCode: String?

    public var errMessage: String?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var subscriptionInstances: DescribeSubscriptionInstancesResponseBody.SubscriptionInstances?

    public var success: String?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subscriptionInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subscriptionInstances != nil {
            map["SubscriptionInstances"] = self.subscriptionInstances?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubscriptionInstances") {
            var model = DescribeSubscriptionInstancesResponseBody.SubscriptionInstances()
            model.fromMap(dict["SubscriptionInstances"] as! [String: Any])
            self.subscriptionInstances = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribeSubscriptionInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSubscriptionInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSubscriptionInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSubscriptionMetaRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var sid: String?

    public var subMigrationJobIds: [String: Any]?

    public var topics: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.subMigrationJobIds != nil {
            map["SubMigrationJobIds"] = self.subMigrationJobIds!
        }
        if self.topics != nil {
            map["Topics"] = self.topics!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Sid") {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("SubMigrationJobIds") {
            self.subMigrationJobIds = dict["SubMigrationJobIds"] as! [String: Any]
        }
        if dict.keys.contains("Topics") {
            self.topics = dict["Topics"] as! [String: Any]
        }
    }
}

public class DescribeSubscriptionMetaShrinkRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var sid: String?

    public var subMigrationJobIdsShrink: String?

    public var topicsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sid != nil {
            map["Sid"] = self.sid!
        }
        if self.subMigrationJobIdsShrink != nil {
            map["SubMigrationJobIds"] = self.subMigrationJobIdsShrink!
        }
        if self.topicsShrink != nil {
            map["Topics"] = self.topicsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Sid") {
            self.sid = dict["Sid"] as! String
        }
        if dict.keys.contains("SubMigrationJobIds") {
            self.subMigrationJobIdsShrink = dict["SubMigrationJobIds"] as! String
        }
        if dict.keys.contains("Topics") {
            self.topicsShrink = dict["Topics"] as! String
        }
    }
}

public class DescribeSubscriptionMetaResponseBody : Tea.TeaModel {
    public class SubscriptionMetaList : Tea.TeaModel {
        public var checkpoint: Int64?

        public var DBList: String?

        public var DProxyUrl: String?

        public var sid: String?

        public var topic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint!
            }
            if self.DBList != nil {
                map["DBList"] = self.DBList!
            }
            if self.DProxyUrl != nil {
                map["DProxyUrl"] = self.DProxyUrl!
            }
            if self.sid != nil {
                map["Sid"] = self.sid!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Checkpoint") {
                self.checkpoint = dict["Checkpoint"] as! Int64
            }
            if dict.keys.contains("DBList") {
                self.DBList = dict["DBList"] as! String
            }
            if dict.keys.contains("DProxyUrl") {
                self.DProxyUrl = dict["DProxyUrl"] as! String
            }
            if dict.keys.contains("Sid") {
                self.sid = dict["Sid"] as! String
            }
            if dict.keys.contains("Topic") {
                self.topic = dict["Topic"] as! String
            }
        }
    }
    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var subscriptionMetaList: [DescribeSubscriptionMetaResponseBody.SubscriptionMetaList]?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subscriptionMetaList != nil {
            var tmp : [Any] = []
            for k in self.subscriptionMetaList! {
                tmp.append(k.toMap())
            }
            map["SubscriptionMetaList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubscriptionMetaList") {
            var tmp : [DescribeSubscriptionMetaResponseBody.SubscriptionMetaList] = []
            for v in dict["SubscriptionMetaList"] as! [Any] {
                var model = DescribeSubscriptionMetaResponseBody.SubscriptionMetaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.subscriptionMetaList = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSubscriptionMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSubscriptionMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSubscriptionMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSyncStatusRequest : Tea.TeaModel {
    public var direction: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DescribeSyncStatusResponseBody : Tea.TeaModel {
    public class SyncStatusList : Tea.TeaModel {
        public var checkpoint: Int64?

        public var code: String?

        public var delay: Int64?

        public var jobId: String?

        public var rate: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.rate != nil {
                map["Rate"] = self.rate!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Checkpoint") {
                self.checkpoint = dict["Checkpoint"] as! Int64
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Rate") {
                self.rate = dict["Rate"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var pageNumber: Int32?

    public var requestId: String?

    public var success: Bool?

    public var syncStatusList: [DescribeSyncStatusResponseBody.SyncStatusList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.syncStatusList != nil {
            var tmp : [Any] = []
            for k in self.syncStatusList! {
                tmp.append(k.toMap())
            }
            map["SyncStatusList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("SyncStatusList") {
            var tmp : [DescribeSyncStatusResponseBody.SyncStatusList] = []
            for v in dict["SyncStatusList"] as! [Any] {
                var model = DescribeSyncStatusResponseBody.SyncStatusList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.syncStatusList = tmp
        }
    }
}

public class DescribeSyncStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSyncStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSyncStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSynchronizationJobAlertRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class DescribeSynchronizationJobAlertResponseBody : Tea.TeaModel {
    public var delayAlertPhone: String?

    public var delayAlertStatus: String?

    public var delayOverSeconds: String?

    public var errCode: String?

    public var errMessage: String?

    public var errorAlertPhone: String?

    public var errorAlertStatus: String?

    public var requestId: String?

    public var success: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public var synchronizationJobName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.delayAlertPhone != nil {
            map["DelayAlertPhone"] = self.delayAlertPhone!
        }
        if self.delayAlertStatus != nil {
            map["DelayAlertStatus"] = self.delayAlertStatus!
        }
        if self.delayOverSeconds != nil {
            map["DelayOverSeconds"] = self.delayOverSeconds!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.errorAlertPhone != nil {
            map["ErrorAlertPhone"] = self.errorAlertPhone!
        }
        if self.errorAlertStatus != nil {
            map["ErrorAlertStatus"] = self.errorAlertStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        if self.synchronizationJobName != nil {
            map["SynchronizationJobName"] = self.synchronizationJobName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DelayAlertPhone") {
            self.delayAlertPhone = dict["DelayAlertPhone"] as! String
        }
        if dict.keys.contains("DelayAlertStatus") {
            self.delayAlertStatus = dict["DelayAlertStatus"] as! String
        }
        if dict.keys.contains("DelayOverSeconds") {
            self.delayOverSeconds = dict["DelayOverSeconds"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("ErrorAlertPhone") {
            self.errorAlertPhone = dict["ErrorAlertPhone"] as! String
        }
        if dict.keys.contains("ErrorAlertStatus") {
            self.errorAlertStatus = dict["ErrorAlertStatus"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
        if dict.keys.contains("SynchronizationJobName") {
            self.synchronizationJobName = dict["SynchronizationJobName"] as! String
        }
    }
}

public class DescribeSynchronizationJobAlertResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSynchronizationJobAlertResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSynchronizationJobAlertResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSynchronizationJobReplicatorCompareRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class DescribeSynchronizationJobReplicatorCompareResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public var synchronizationReplicatorCompareEnable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchronizationReplicatorCompareEnable != nil {
            map["SynchronizationReplicatorCompareEnable"] = self.synchronizationReplicatorCompareEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("SynchronizationReplicatorCompareEnable") {
            self.synchronizationReplicatorCompareEnable = dict["SynchronizationReplicatorCompareEnable"] as! Bool
        }
    }
}

public class DescribeSynchronizationJobReplicatorCompareResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSynchronizationJobReplicatorCompareResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSynchronizationJobReplicatorCompareResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSynchronizationJobStatusRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class DescribeSynchronizationJobStatusResponseBody : Tea.TeaModel {
    public class DataInitializationStatus : Tea.TeaModel {
        public var errorMessage: String?

        public var percent: String?

        public var progress: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DataSynchronizationStatus : Tea.TeaModel {
        public var checkpoint: String?

        public var delay: String?

        public var delayMillis: Int64?

        public var errorMessage: String?

        public var percent: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.delayMillis != nil {
                map["DelayMillis"] = self.delayMillis!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Checkpoint") {
                self.checkpoint = dict["Checkpoint"] as! String
            }
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! String
            }
            if dict.keys.contains("DelayMillis") {
                self.delayMillis = dict["DelayMillis"] as! Int64
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DestinationEndpoint : Tea.TeaModel {
        public var engineName: String?

        public var IP: String?

        public var instanceId: String?

        public var instanceType: String?

        public var port: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.engineName != nil {
                map["EngineName"] = self.engineName!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EngineName") {
                self.engineName = dict["EngineName"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class Performance : Tea.TeaModel {
        public var FLOW: String?

        public var RPS: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.FLOW != nil {
                map["FLOW"] = self.FLOW!
            }
            if self.RPS != nil {
                map["RPS"] = self.RPS!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FLOW") {
                self.FLOW = dict["FLOW"] as! String
            }
            if dict.keys.contains("RPS") {
                self.RPS = dict["RPS"] as! String
            }
        }
    }
    public class PrecheckStatus : Tea.TeaModel {
        public class Detail : Tea.TeaModel {
            public var checkStatus: String?

            public var errorMessage: String?

            public var itemName: String?

            public var repairMethod: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkStatus != nil {
                    map["CheckStatus"] = self.checkStatus!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                if self.repairMethod != nil {
                    map["RepairMethod"] = self.repairMethod!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckStatus") {
                    self.checkStatus = dict["CheckStatus"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("ItemName") {
                    self.itemName = dict["ItemName"] as! String
                }
                if dict.keys.contains("RepairMethod") {
                    self.repairMethod = dict["RepairMethod"] as! String
                }
            }
        }
        public var detail: [DescribeSynchronizationJobStatusResponseBody.PrecheckStatus.Detail]?

        public var percent: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detail != nil {
                var tmp : [Any] = []
                for k in self.detail! {
                    tmp.append(k.toMap())
                }
                map["Detail"] = tmp
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Detail") {
                var tmp : [DescribeSynchronizationJobStatusResponseBody.PrecheckStatus.Detail] = []
                for v in dict["Detail"] as! [Any] {
                    var model = DescribeSynchronizationJobStatusResponseBody.PrecheckStatus.Detail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.detail = tmp
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class SourceEndpoint : Tea.TeaModel {
        public var engineName: String?

        public var IP: String?

        public var instanceId: String?

        public var instanceType: String?

        public var port: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.engineName != nil {
                map["EngineName"] = self.engineName!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EngineName") {
                self.engineName = dict["EngineName"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public class StructureInitializationStatus : Tea.TeaModel {
        public var errorMessage: String?

        public var percent: String?

        public var progress: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class SynchronizationObjects : Tea.TeaModel {
        public class TableExcludes : Tea.TeaModel {
            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public class TableIncludes : Tea.TeaModel {
            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var newSchemaName: String?

        public var schemaName: String?

        public var tableExcludes: [DescribeSynchronizationJobStatusResponseBody.SynchronizationObjects.TableExcludes]?

        public var tableIncludes: [DescribeSynchronizationJobStatusResponseBody.SynchronizationObjects.TableIncludes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.newSchemaName != nil {
                map["NewSchemaName"] = self.newSchemaName!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.tableExcludes != nil {
                var tmp : [Any] = []
                for k in self.tableExcludes! {
                    tmp.append(k.toMap())
                }
                map["TableExcludes"] = tmp
            }
            if self.tableIncludes != nil {
                var tmp : [Any] = []
                for k in self.tableIncludes! {
                    tmp.append(k.toMap())
                }
                map["TableIncludes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NewSchemaName") {
                self.newSchemaName = dict["NewSchemaName"] as! String
            }
            if dict.keys.contains("SchemaName") {
                self.schemaName = dict["SchemaName"] as! String
            }
            if dict.keys.contains("TableExcludes") {
                var tmp : [DescribeSynchronizationJobStatusResponseBody.SynchronizationObjects.TableExcludes] = []
                for v in dict["TableExcludes"] as! [Any] {
                    var model = DescribeSynchronizationJobStatusResponseBody.SynchronizationObjects.TableExcludes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableExcludes = tmp
            }
            if dict.keys.contains("TableIncludes") {
                var tmp : [DescribeSynchronizationJobStatusResponseBody.SynchronizationObjects.TableIncludes] = []
                for v in dict["TableIncludes"] as! [Any] {
                    var model = DescribeSynchronizationJobStatusResponseBody.SynchronizationObjects.TableIncludes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableIncludes = tmp
            }
        }
    }
    public var checkpoint: String?

    public var dataInitialization: String?

    public var dataInitializationStatus: DescribeSynchronizationJobStatusResponseBody.DataInitializationStatus?

    public var dataSynchronizationStatus: DescribeSynchronizationJobStatusResponseBody.DataSynchronizationStatus?

    public var delay: String?

    public var delayMillis: Int64?

    public var destinationEndpoint: DescribeSynchronizationJobStatusResponseBody.DestinationEndpoint?

    public var errCode: String?

    public var errMessage: String?

    public var errorMessage: String?

    public var expireTime: String?

    public var payType: String?

    public var performance: DescribeSynchronizationJobStatusResponseBody.Performance?

    public var precheckStatus: DescribeSynchronizationJobStatusResponseBody.PrecheckStatus?

    public var requestId: String?

    public var sourceEndpoint: DescribeSynchronizationJobStatusResponseBody.SourceEndpoint?

    public var status: String?

    public var structureInitialization: String?

    public var structureInitializationStatus: DescribeSynchronizationJobStatusResponseBody.StructureInitializationStatus?

    public var success: String?

    public var synchronizationDirection: String?

    public var synchronizationJobClass: String?

    public var synchronizationJobId: String?

    public var synchronizationJobName: String?

    public var synchronizationObjects: [DescribeSynchronizationJobStatusResponseBody.SynchronizationObjects]?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataInitializationStatus?.validate()
        try self.dataSynchronizationStatus?.validate()
        try self.destinationEndpoint?.validate()
        try self.performance?.validate()
        try self.precheckStatus?.validate()
        try self.sourceEndpoint?.validate()
        try self.structureInitializationStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkpoint != nil {
            map["Checkpoint"] = self.checkpoint!
        }
        if self.dataInitialization != nil {
            map["DataInitialization"] = self.dataInitialization!
        }
        if self.dataInitializationStatus != nil {
            map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
        }
        if self.dataSynchronizationStatus != nil {
            map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
        }
        if self.delay != nil {
            map["Delay"] = self.delay!
        }
        if self.delayMillis != nil {
            map["DelayMillis"] = self.delayMillis!
        }
        if self.destinationEndpoint != nil {
            map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.performance != nil {
            map["Performance"] = self.performance?.toMap()
        }
        if self.precheckStatus != nil {
            map["PrecheckStatus"] = self.precheckStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.structureInitialization != nil {
            map["StructureInitialization"] = self.structureInitialization!
        }
        if self.structureInitializationStatus != nil {
            map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobClass != nil {
            map["SynchronizationJobClass"] = self.synchronizationJobClass!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        if self.synchronizationJobName != nil {
            map["SynchronizationJobName"] = self.synchronizationJobName!
        }
        if self.synchronizationObjects != nil {
            var tmp : [Any] = []
            for k in self.synchronizationObjects! {
                tmp.append(k.toMap())
            }
            map["SynchronizationObjects"] = tmp
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Checkpoint") {
            self.checkpoint = dict["Checkpoint"] as! String
        }
        if dict.keys.contains("DataInitialization") {
            self.dataInitialization = dict["DataInitialization"] as! String
        }
        if dict.keys.contains("DataInitializationStatus") {
            var model = DescribeSynchronizationJobStatusResponseBody.DataInitializationStatus()
            model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
            self.dataInitializationStatus = model
        }
        if dict.keys.contains("DataSynchronizationStatus") {
            var model = DescribeSynchronizationJobStatusResponseBody.DataSynchronizationStatus()
            model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
            self.dataSynchronizationStatus = model
        }
        if dict.keys.contains("Delay") {
            self.delay = dict["Delay"] as! String
        }
        if dict.keys.contains("DelayMillis") {
            self.delayMillis = dict["DelayMillis"] as! Int64
        }
        if dict.keys.contains("DestinationEndpoint") {
            var model = DescribeSynchronizationJobStatusResponseBody.DestinationEndpoint()
            model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
            self.destinationEndpoint = model
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("Performance") {
            var model = DescribeSynchronizationJobStatusResponseBody.Performance()
            model.fromMap(dict["Performance"] as! [String: Any])
            self.performance = model
        }
        if dict.keys.contains("PrecheckStatus") {
            var model = DescribeSynchronizationJobStatusResponseBody.PrecheckStatus()
            model.fromMap(dict["PrecheckStatus"] as! [String: Any])
            self.precheckStatus = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SourceEndpoint") {
            var model = DescribeSynchronizationJobStatusResponseBody.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StructureInitialization") {
            self.structureInitialization = dict["StructureInitialization"] as! String
        }
        if dict.keys.contains("StructureInitializationStatus") {
            var model = DescribeSynchronizationJobStatusResponseBody.StructureInitializationStatus()
            model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
            self.structureInitializationStatus = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobClass") {
            self.synchronizationJobClass = dict["SynchronizationJobClass"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
        if dict.keys.contains("SynchronizationJobName") {
            self.synchronizationJobName = dict["SynchronizationJobName"] as! String
        }
        if dict.keys.contains("SynchronizationObjects") {
            var tmp : [DescribeSynchronizationJobStatusResponseBody.SynchronizationObjects] = []
            for v in dict["SynchronizationObjects"] as! [Any] {
                var model = DescribeSynchronizationJobStatusResponseBody.SynchronizationObjects()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.synchronizationObjects = tmp
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeSynchronizationJobStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSynchronizationJobStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSynchronizationJobStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSynchronizationJobStatusListRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationJobIdListJsonStr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationJobIdListJsonStr != nil {
            map["SynchronizationJobIdListJsonStr"] = self.synchronizationJobIdListJsonStr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationJobIdListJsonStr") {
            self.synchronizationJobIdListJsonStr = dict["SynchronizationJobIdListJsonStr"] as! String
        }
    }
}

public class DescribeSynchronizationJobStatusListResponseBody : Tea.TeaModel {
    public class SynchronizationJobListStatusList : Tea.TeaModel {
        public class SynchronizationDirectionInfoList : Tea.TeaModel {
            public var checkpoint: String?

            public var status: String?

            public var synchronizationDirection: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkpoint != nil {
                    map["Checkpoint"] = self.checkpoint!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.synchronizationDirection != nil {
                    map["SynchronizationDirection"] = self.synchronizationDirection!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Checkpoint") {
                    self.checkpoint = dict["Checkpoint"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SynchronizationDirection") {
                    self.synchronizationDirection = dict["SynchronizationDirection"] as! String
                }
            }
        }
        public var synchronizationDirectionInfoList: [DescribeSynchronizationJobStatusListResponseBody.SynchronizationJobListStatusList.SynchronizationDirectionInfoList]?

        public var synchronizationJobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.synchronizationDirectionInfoList != nil {
                var tmp : [Any] = []
                for k in self.synchronizationDirectionInfoList! {
                    tmp.append(k.toMap())
                }
                map["SynchronizationDirectionInfoList"] = tmp
            }
            if self.synchronizationJobId != nil {
                map["SynchronizationJobId"] = self.synchronizationJobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SynchronizationDirectionInfoList") {
                var tmp : [DescribeSynchronizationJobStatusListResponseBody.SynchronizationJobListStatusList.SynchronizationDirectionInfoList] = []
                for v in dict["SynchronizationDirectionInfoList"] as! [Any] {
                    var model = DescribeSynchronizationJobStatusListResponseBody.SynchronizationJobListStatusList.SynchronizationDirectionInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.synchronizationDirectionInfoList = tmp
            }
            if dict.keys.contains("SynchronizationJobId") {
                self.synchronizationJobId = dict["SynchronizationJobId"] as! String
            }
        }
    }
    public var errCode: String?

    public var errMessage: String?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var success: String?

    public var synchronizationJobListStatusList: [DescribeSynchronizationJobStatusListResponseBody.SynchronizationJobListStatusList]?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchronizationJobListStatusList != nil {
            var tmp : [Any] = []
            for k in self.synchronizationJobListStatusList! {
                tmp.append(k.toMap())
            }
            map["SynchronizationJobListStatusList"] = tmp
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("SynchronizationJobListStatusList") {
            var tmp : [DescribeSynchronizationJobStatusListResponseBody.SynchronizationJobListStatusList] = []
            for v in dict["SynchronizationJobListStatusList"] as! [Any] {
                var model = DescribeSynchronizationJobStatusListResponseBody.SynchronizationJobListStatusList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.synchronizationJobListStatusList = tmp
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribeSynchronizationJobStatusListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSynchronizationJobStatusListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSynchronizationJobStatusListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSynchronizationJobsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationJobName: String?

    public var tag: [DescribeSynchronizationJobsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationJobName != nil {
            map["SynchronizationJobName"] = self.synchronizationJobName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationJobName") {
            self.synchronizationJobName = dict["SynchronizationJobName"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeSynchronizationJobsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeSynchronizationJobsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeSynchronizationJobsResponseBody : Tea.TeaModel {
    public class SynchronizationInstances : Tea.TeaModel {
        public class DataInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DataSynchronizationStatus : Tea.TeaModel {
            public var delay: String?

            public var errorMessage: String?

            public var percent: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.delay != nil {
                    map["Delay"] = self.delay!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Delay") {
                    self.delay = dict["Delay"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DestinationEndpoint : Tea.TeaModel {
            public var engineName: String?

            public var IP: String?

            public var instanceId: String?

            public var instanceType: String?

            public var port: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.IP != nil {
                    map["IP"] = self.IP!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("IP") {
                    self.IP = dict["IP"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class Performance : Tea.TeaModel {
            public var FLOW: String?

            public var RPS: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.FLOW != nil {
                    map["FLOW"] = self.FLOW!
                }
                if self.RPS != nil {
                    map["RPS"] = self.RPS!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FLOW") {
                    self.FLOW = dict["FLOW"] as! String
                }
                if dict.keys.contains("RPS") {
                    self.RPS = dict["RPS"] as! String
                }
            }
        }
        public class PrecheckStatus : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var checkStatus: String?

                public var errorMessage: String?

                public var itemName: String?

                public var repairMethod: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkStatus != nil {
                        map["CheckStatus"] = self.checkStatus!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.itemName != nil {
                        map["ItemName"] = self.itemName!
                    }
                    if self.repairMethod != nil {
                        map["RepairMethod"] = self.repairMethod!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckStatus") {
                        self.checkStatus = dict["CheckStatus"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("ItemName") {
                        self.itemName = dict["ItemName"] as! String
                    }
                    if dict.keys.contains("RepairMethod") {
                        self.repairMethod = dict["RepairMethod"] as! String
                    }
                }
            }
            public var detail: [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.PrecheckStatus.Detail]?

            public var percent: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    var tmp : [Any] = []
                    for k in self.detail! {
                        tmp.append(k.toMap())
                    }
                    map["Detail"] = tmp
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Detail") {
                    var tmp : [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.PrecheckStatus.Detail] = []
                    for v in dict["Detail"] as! [Any] {
                        var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.PrecheckStatus.Detail()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.detail = tmp
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class SourceEndpoint : Tea.TeaModel {
            public var engineName: String?

            public var IP: String?

            public var instanceId: String?

            public var instanceType: String?

            public var port: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.engineName != nil {
                    map["EngineName"] = self.engineName!
                }
                if self.IP != nil {
                    map["IP"] = self.IP!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EngineName") {
                    self.engineName = dict["EngineName"] as! String
                }
                if dict.keys.contains("IP") {
                    self.IP = dict["IP"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public class StructureInitializationStatus : Tea.TeaModel {
            public var errorMessage: String?

            public var percent: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class SynchronizationObjects : Tea.TeaModel {
            public class TableExcludes : Tea.TeaModel {
                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public class TableIncludes : Tea.TeaModel {
                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public var newSchemaName: String?

            public var schemaName: String?

            public var tableExcludes: [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SynchronizationObjects.TableExcludes]?

            public var tableIncludes: [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SynchronizationObjects.TableIncludes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.newSchemaName != nil {
                    map["NewSchemaName"] = self.newSchemaName!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.tableExcludes != nil {
                    var tmp : [Any] = []
                    for k in self.tableExcludes! {
                        tmp.append(k.toMap())
                    }
                    map["TableExcludes"] = tmp
                }
                if self.tableIncludes != nil {
                    var tmp : [Any] = []
                    for k in self.tableIncludes! {
                        tmp.append(k.toMap())
                    }
                    map["TableIncludes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NewSchemaName") {
                    self.newSchemaName = dict["NewSchemaName"] as! String
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("TableExcludes") {
                    var tmp : [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SynchronizationObjects.TableExcludes] = []
                    for v in dict["TableExcludes"] as! [Any] {
                        var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SynchronizationObjects.TableExcludes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tableExcludes = tmp
                }
                if dict.keys.contains("TableIncludes") {
                    var tmp : [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SynchronizationObjects.TableIncludes] = []
                    for v in dict["TableIncludes"] as! [Any] {
                        var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SynchronizationObjects.TableIncludes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tableIncludes = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var createTime: String?

        public var dataInitialization: String?

        public var dataInitializationStatus: DescribeSynchronizationJobsResponseBody.SynchronizationInstances.DataInitializationStatus?

        public var dataSynchronizationStatus: DescribeSynchronizationJobsResponseBody.SynchronizationInstances.DataSynchronizationStatus?

        public var delay: String?

        public var destinationEndpoint: DescribeSynchronizationJobsResponseBody.SynchronizationInstances.DestinationEndpoint?

        public var errorMessage: String?

        public var expireTime: String?

        public var instanceCreateTime: String?

        public var jobCreateTime: String?

        public var payType: String?

        public var performance: DescribeSynchronizationJobsResponseBody.SynchronizationInstances.Performance?

        public var precheckStatus: DescribeSynchronizationJobsResponseBody.SynchronizationInstances.PrecheckStatus?

        public var sourceEndpoint: DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SourceEndpoint?

        public var status: String?

        public var structureInitialization: String?

        public var structureInitializationStatus: DescribeSynchronizationJobsResponseBody.SynchronizationInstances.StructureInitializationStatus?

        public var synchronizationDirection: String?

        public var synchronizationJobClass: String?

        public var synchronizationJobId: String?

        public var synchronizationJobName: String?

        public var synchronizationObjects: [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SynchronizationObjects]?

        public var tags: [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataInitializationStatus?.validate()
            try self.dataSynchronizationStatus?.validate()
            try self.destinationEndpoint?.validate()
            try self.performance?.validate()
            try self.precheckStatus?.validate()
            try self.sourceEndpoint?.validate()
            try self.structureInitializationStatus?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataInitialization != nil {
                map["DataInitialization"] = self.dataInitialization!
            }
            if self.dataInitializationStatus != nil {
                map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
            }
            if self.dataSynchronizationStatus != nil {
                map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.destinationEndpoint != nil {
                map["DestinationEndpoint"] = self.destinationEndpoint?.toMap()
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.instanceCreateTime != nil {
                map["InstanceCreateTime"] = self.instanceCreateTime!
            }
            if self.jobCreateTime != nil {
                map["JobCreateTime"] = self.jobCreateTime!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.performance != nil {
                map["Performance"] = self.performance?.toMap()
            }
            if self.precheckStatus != nil {
                map["PrecheckStatus"] = self.precheckStatus?.toMap()
            }
            if self.sourceEndpoint != nil {
                map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.structureInitialization != nil {
                map["StructureInitialization"] = self.structureInitialization!
            }
            if self.structureInitializationStatus != nil {
                map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
            }
            if self.synchronizationDirection != nil {
                map["SynchronizationDirection"] = self.synchronizationDirection!
            }
            if self.synchronizationJobClass != nil {
                map["SynchronizationJobClass"] = self.synchronizationJobClass!
            }
            if self.synchronizationJobId != nil {
                map["SynchronizationJobId"] = self.synchronizationJobId!
            }
            if self.synchronizationJobName != nil {
                map["SynchronizationJobName"] = self.synchronizationJobName!
            }
            if self.synchronizationObjects != nil {
                var tmp : [Any] = []
                for k in self.synchronizationObjects! {
                    tmp.append(k.toMap())
                }
                map["SynchronizationObjects"] = tmp
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DataInitialization") {
                self.dataInitialization = dict["DataInitialization"] as! String
            }
            if dict.keys.contains("DataInitializationStatus") {
                var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.DataInitializationStatus()
                model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
                self.dataInitializationStatus = model
            }
            if dict.keys.contains("DataSynchronizationStatus") {
                var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.DataSynchronizationStatus()
                model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
                self.dataSynchronizationStatus = model
            }
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! String
            }
            if dict.keys.contains("DestinationEndpoint") {
                var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.DestinationEndpoint()
                model.fromMap(dict["DestinationEndpoint"] as! [String: Any])
                self.destinationEndpoint = model
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("InstanceCreateTime") {
                self.instanceCreateTime = dict["InstanceCreateTime"] as! String
            }
            if dict.keys.contains("JobCreateTime") {
                self.jobCreateTime = dict["JobCreateTime"] as! String
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("Performance") {
                var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.Performance()
                model.fromMap(dict["Performance"] as! [String: Any])
                self.performance = model
            }
            if dict.keys.contains("PrecheckStatus") {
                var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.PrecheckStatus()
                model.fromMap(dict["PrecheckStatus"] as! [String: Any])
                self.precheckStatus = model
            }
            if dict.keys.contains("SourceEndpoint") {
                var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SourceEndpoint()
                model.fromMap(dict["SourceEndpoint"] as! [String: Any])
                self.sourceEndpoint = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StructureInitialization") {
                self.structureInitialization = dict["StructureInitialization"] as! String
            }
            if dict.keys.contains("StructureInitializationStatus") {
                var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.StructureInitializationStatus()
                model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
                self.structureInitializationStatus = model
            }
            if dict.keys.contains("SynchronizationDirection") {
                self.synchronizationDirection = dict["SynchronizationDirection"] as! String
            }
            if dict.keys.contains("SynchronizationJobClass") {
                self.synchronizationJobClass = dict["SynchronizationJobClass"] as! String
            }
            if dict.keys.contains("SynchronizationJobId") {
                self.synchronizationJobId = dict["SynchronizationJobId"] as! String
            }
            if dict.keys.contains("SynchronizationJobName") {
                self.synchronizationJobName = dict["SynchronizationJobName"] as! String
            }
            if dict.keys.contains("SynchronizationObjects") {
                var tmp : [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SynchronizationObjects] = []
                for v in dict["SynchronizationObjects"] as! [Any] {
                    var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.SynchronizationObjects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.synchronizationObjects = tmp
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeSynchronizationJobsResponseBody.SynchronizationInstances.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var synchronizationInstances: [DescribeSynchronizationJobsResponseBody.SynchronizationInstances]?

    public var totalRecordCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.synchronizationInstances != nil {
            var tmp : [Any] = []
            for k in self.synchronizationInstances! {
                tmp.append(k.toMap())
            }
            map["SynchronizationInstances"] = tmp
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SynchronizationInstances") {
            var tmp : [DescribeSynchronizationJobsResponseBody.SynchronizationInstances] = []
            for v in dict["SynchronizationInstances"] as! [Any] {
                var model = DescribeSynchronizationJobsResponseBody.SynchronizationInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.synchronizationInstances = tmp
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int64
        }
    }
}

public class DescribeSynchronizationJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSynchronizationJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSynchronizationJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSynchronizationObjectModifyStatusRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeSynchronizationObjectModifyStatusResponseBody : Tea.TeaModel {
    public class DataInitializationStatus : Tea.TeaModel {
        public var errorMessage: String?

        public var percent: String?

        public var progress: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class DataSynchronizationStatus : Tea.TeaModel {
        public var delay: String?

        public var errorMessage: String?

        public var percent: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class PrecheckStatus : Tea.TeaModel {
        public class Detail : Tea.TeaModel {
            public var checkStatus: String?

            public var errorMessage: String?

            public var itemName: String?

            public var repairMethod: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkStatus != nil {
                    map["CheckStatus"] = self.checkStatus!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                if self.repairMethod != nil {
                    map["RepairMethod"] = self.repairMethod!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckStatus") {
                    self.checkStatus = dict["CheckStatus"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("ItemName") {
                    self.itemName = dict["ItemName"] as! String
                }
                if dict.keys.contains("RepairMethod") {
                    self.repairMethod = dict["RepairMethod"] as! String
                }
            }
        }
        public var detail: [DescribeSynchronizationObjectModifyStatusResponseBody.PrecheckStatus.Detail]?

        public var percent: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detail != nil {
                var tmp : [Any] = []
                for k in self.detail! {
                    tmp.append(k.toMap())
                }
                map["Detail"] = tmp
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Detail") {
                var tmp : [DescribeSynchronizationObjectModifyStatusResponseBody.PrecheckStatus.Detail] = []
                for v in dict["Detail"] as! [Any] {
                    var model = DescribeSynchronizationObjectModifyStatusResponseBody.PrecheckStatus.Detail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.detail = tmp
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class StructureInitializationStatus : Tea.TeaModel {
        public var errorMessage: String?

        public var percent: String?

        public var progress: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var dataInitializationStatus: DescribeSynchronizationObjectModifyStatusResponseBody.DataInitializationStatus?

    public var dataSynchronizationStatus: DescribeSynchronizationObjectModifyStatusResponseBody.DataSynchronizationStatus?

    public var errCode: String?

    public var errMessage: String?

    public var errorMessage: String?

    public var precheckStatus: DescribeSynchronizationObjectModifyStatusResponseBody.PrecheckStatus?

    public var requestId: String?

    public var status: String?

    public var structureInitializationStatus: DescribeSynchronizationObjectModifyStatusResponseBody.StructureInitializationStatus?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataInitializationStatus?.validate()
        try self.dataSynchronizationStatus?.validate()
        try self.precheckStatus?.validate()
        try self.structureInitializationStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInitializationStatus != nil {
            map["DataInitializationStatus"] = self.dataInitializationStatus?.toMap()
        }
        if self.dataSynchronizationStatus != nil {
            map["DataSynchronizationStatus"] = self.dataSynchronizationStatus?.toMap()
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.precheckStatus != nil {
            map["PrecheckStatus"] = self.precheckStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.structureInitializationStatus != nil {
            map["StructureInitializationStatus"] = self.structureInitializationStatus?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInitializationStatus") {
            var model = DescribeSynchronizationObjectModifyStatusResponseBody.DataInitializationStatus()
            model.fromMap(dict["DataInitializationStatus"] as! [String: Any])
            self.dataInitializationStatus = model
        }
        if dict.keys.contains("DataSynchronizationStatus") {
            var model = DescribeSynchronizationObjectModifyStatusResponseBody.DataSynchronizationStatus()
            model.fromMap(dict["DataSynchronizationStatus"] as! [String: Any])
            self.dataSynchronizationStatus = model
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("PrecheckStatus") {
            var model = DescribeSynchronizationObjectModifyStatusResponseBody.PrecheckStatus()
            model.fromMap(dict["PrecheckStatus"] as! [String: Any])
            self.precheckStatus = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StructureInitializationStatus") {
            var model = DescribeSynchronizationObjectModifyStatusResponseBody.StructureInitializationStatus()
            model.fromMap(dict["StructureInitializationStatus"] as! [String: Any])
            self.structureInitializationStatus = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSynchronizationObjectModifyStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSynchronizationObjectModifyStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSynchronizationObjectModifyStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagKeysRequest : Tea.TeaModel {
    public var category: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeTagKeysResponseBody : Tea.TeaModel {
    public var category: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var tagKeys: [String]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagKeys") {
            self.tagKeys = dict["TagKeys"] as! [String]
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTagKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagValuesRequest : Tea.TeaModel {
    public var category: String?

    public var key: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeTagValuesResponseBody : Tea.TeaModel {
    public var category: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var tagValues: [String]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagValues != nil {
            map["TagValues"] = self.tagValues!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagValues") {
            self.tagValues = dict["TagValues"] as! [String]
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTagValuesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagValuesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagValuesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachGadInstanceDbMemberRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var slaveDbInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slaveDbInstanceId != nil {
            map["SlaveDbInstanceId"] = self.slaveDbInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlaveDbInstanceId") {
            self.slaveDbInstanceId = dict["SlaveDbInstanceId"] as! String
        }
    }
}

public class DetachGadInstanceDbMemberResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var instanceId: String?

    public var instanceName: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var slaveDbInstanceId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slaveDbInstanceId != nil {
            map["SlaveDbInstanceId"] = self.slaveDbInstanceId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlaveDbInstanceId") {
            self.slaveDbInstanceId = dict["SlaveDbInstanceId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DetachGadInstanceDbMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachGadInstanceDbMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachGadInstanceDbMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitDtsRdsInstanceRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var endpointCenId: String?

    public var endpointInstanceId: String?

    public var endpointInstanceType: String?

    public var endpointRegion: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.endpointCenId != nil {
            map["EndpointCenId"] = self.endpointCenId!
        }
        if self.endpointInstanceId != nil {
            map["EndpointInstanceId"] = self.endpointInstanceId!
        }
        if self.endpointInstanceType != nil {
            map["EndpointInstanceType"] = self.endpointInstanceType!
        }
        if self.endpointRegion != nil {
            map["EndpointRegion"] = self.endpointRegion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("EndpointCenId") {
            self.endpointCenId = dict["EndpointCenId"] as! String
        }
        if dict.keys.contains("EndpointInstanceId") {
            self.endpointInstanceId = dict["EndpointInstanceId"] as! String
        }
        if dict.keys.contains("EndpointInstanceType") {
            self.endpointInstanceType = dict["EndpointInstanceType"] as! String
        }
        if dict.keys.contains("EndpointRegion") {
            self.endpointRegion = dict["EndpointRegion"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class InitDtsRdsInstanceResponseBody : Tea.TeaModel {
    public var adminAccount: String?

    public var adminPassword: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminAccount != nil {
            map["AdminAccount"] = self.adminAccount!
        }
        if self.adminPassword != nil {
            map["AdminPassword"] = self.adminPassword!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdminAccount") {
            self.adminAccount = dict["AdminAccount"] as! String
        }
        if dict.keys.contains("AdminPassword") {
            self.adminPassword = dict["AdminPassword"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class InitDtsRdsInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitDtsRdsInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InitDtsRdsInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDedicatedClusterRequest : Tea.TeaModel {
    public var orderColumn: String?

    public var orderDirection: String?

    public var ownerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var params: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var state: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderColumn != nil {
            map["OrderColumn"] = self.orderColumn!
        }
        if self.orderDirection != nil {
            map["OrderDirection"] = self.orderDirection!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderColumn") {
            self.orderColumn = dict["OrderColumn"] as! String
        }
        if dict.keys.contains("OrderDirection") {
            self.orderDirection = dict["OrderDirection"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListDedicatedClusterResponseBody : Tea.TeaModel {
    public class DedicatedClusterStatusList : Tea.TeaModel {
        public class DedicatedClusterStatus : Tea.TeaModel {
            public var cpuUtilization: Int64?

            public var dedicatedClusterId: String?

            public var dedicatedClusterName: String?

            public var diskUtilization: Int64?

            public var dtsInstanceID: String?

            public var du: Int64?

            public var duUtilization: Int64?

            public var gmtCreated: Int64?

            public var memUtilization: Int64?

            public var nodeCount: Int64?

            public var oversoldDu: Int64?

            public var regionId: String?

            public var state: String?

            public var totalCpuCore: Int64?

            public var totalDiskGBSize: Int64?

            public var totalMemGBSize: Int64?

            public var usedCpuCore: Int64?

            public var usedDiskGBSize: Int64?

            public var usedDu: Int64?

            public var usedMemGBSize: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuUtilization != nil {
                    map["CpuUtilization"] = self.cpuUtilization!
                }
                if self.dedicatedClusterId != nil {
                    map["DedicatedClusterId"] = self.dedicatedClusterId!
                }
                if self.dedicatedClusterName != nil {
                    map["DedicatedClusterName"] = self.dedicatedClusterName!
                }
                if self.diskUtilization != nil {
                    map["DiskUtilization"] = self.diskUtilization!
                }
                if self.dtsInstanceID != nil {
                    map["DtsInstanceID"] = self.dtsInstanceID!
                }
                if self.du != nil {
                    map["Du"] = self.du!
                }
                if self.duUtilization != nil {
                    map["DuUtilization"] = self.duUtilization!
                }
                if self.gmtCreated != nil {
                    map["GmtCreated"] = self.gmtCreated!
                }
                if self.memUtilization != nil {
                    map["MemUtilization"] = self.memUtilization!
                }
                if self.nodeCount != nil {
                    map["NodeCount"] = self.nodeCount!
                }
                if self.oversoldDu != nil {
                    map["OversoldDu"] = self.oversoldDu!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.totalCpuCore != nil {
                    map["TotalCpuCore"] = self.totalCpuCore!
                }
                if self.totalDiskGBSize != nil {
                    map["TotalDiskGBSize"] = self.totalDiskGBSize!
                }
                if self.totalMemGBSize != nil {
                    map["TotalMemGBSize"] = self.totalMemGBSize!
                }
                if self.usedCpuCore != nil {
                    map["UsedCpuCore"] = self.usedCpuCore!
                }
                if self.usedDiskGBSize != nil {
                    map["UsedDiskGBSize"] = self.usedDiskGBSize!
                }
                if self.usedDu != nil {
                    map["UsedDu"] = self.usedDu!
                }
                if self.usedMemGBSize != nil {
                    map["UsedMemGBSize"] = self.usedMemGBSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CpuUtilization") {
                    self.cpuUtilization = dict["CpuUtilization"] as! Int64
                }
                if dict.keys.contains("DedicatedClusterId") {
                    self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
                }
                if dict.keys.contains("DedicatedClusterName") {
                    self.dedicatedClusterName = dict["DedicatedClusterName"] as! String
                }
                if dict.keys.contains("DiskUtilization") {
                    self.diskUtilization = dict["DiskUtilization"] as! Int64
                }
                if dict.keys.contains("DtsInstanceID") {
                    self.dtsInstanceID = dict["DtsInstanceID"] as! String
                }
                if dict.keys.contains("Du") {
                    self.du = dict["Du"] as! Int64
                }
                if dict.keys.contains("DuUtilization") {
                    self.duUtilization = dict["DuUtilization"] as! Int64
                }
                if dict.keys.contains("GmtCreated") {
                    self.gmtCreated = dict["GmtCreated"] as! Int64
                }
                if dict.keys.contains("MemUtilization") {
                    self.memUtilization = dict["MemUtilization"] as! Int64
                }
                if dict.keys.contains("NodeCount") {
                    self.nodeCount = dict["NodeCount"] as! Int64
                }
                if dict.keys.contains("OversoldDu") {
                    self.oversoldDu = dict["OversoldDu"] as! Int64
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TotalCpuCore") {
                    self.totalCpuCore = dict["TotalCpuCore"] as! Int64
                }
                if dict.keys.contains("TotalDiskGBSize") {
                    self.totalDiskGBSize = dict["TotalDiskGBSize"] as! Int64
                }
                if dict.keys.contains("TotalMemGBSize") {
                    self.totalMemGBSize = dict["TotalMemGBSize"] as! Int64
                }
                if dict.keys.contains("UsedCpuCore") {
                    self.usedCpuCore = dict["UsedCpuCore"] as! Int64
                }
                if dict.keys.contains("UsedDiskGBSize") {
                    self.usedDiskGBSize = dict["UsedDiskGBSize"] as! Int64
                }
                if dict.keys.contains("UsedDu") {
                    self.usedDu = dict["UsedDu"] as! Int64
                }
                if dict.keys.contains("UsedMemGBSize") {
                    self.usedMemGBSize = dict["UsedMemGBSize"] as! Int64
                }
            }
        }
        public var dedicatedClusterStatus: [ListDedicatedClusterResponseBody.DedicatedClusterStatusList.DedicatedClusterStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedClusterStatus != nil {
                var tmp : [Any] = []
                for k in self.dedicatedClusterStatus! {
                    tmp.append(k.toMap())
                }
                map["DedicatedClusterStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedClusterStatus") {
                var tmp : [ListDedicatedClusterResponseBody.DedicatedClusterStatusList.DedicatedClusterStatus] = []
                for v in dict["DedicatedClusterStatus"] as! [Any] {
                    var model = ListDedicatedClusterResponseBody.DedicatedClusterStatusList.DedicatedClusterStatus()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dedicatedClusterStatus = tmp
            }
        }
    }
    public var dedicatedClusterStatusList: ListDedicatedClusterResponseBody.DedicatedClusterStatusList?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var pageNumber: Int32?

    public var pageRecordCount: Int32?

    public var requestId: String?

    public var success: String?

    public var totalRecordCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedClusterStatusList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedClusterStatusList != nil {
            map["DedicatedClusterStatusList"] = self.dedicatedClusterStatusList?.toMap()
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageRecordCount != nil {
            map["PageRecordCount"] = self.pageRecordCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalRecordCount != nil {
            map["TotalRecordCount"] = self.totalRecordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedClusterStatusList") {
            var model = ListDedicatedClusterResponseBody.DedicatedClusterStatusList()
            model.fromMap(dict["DedicatedClusterStatusList"] as! [String: Any])
            self.dedicatedClusterStatusList = model
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageRecordCount") {
            self.pageRecordCount = dict["PageRecordCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TotalRecordCount") {
            self.totalRecordCount = dict["TotalRecordCount"] as! Int32
        }
    }
}

public class ListDedicatedClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDedicatedClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDedicatedClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var nextToken: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var errCode: String?

    public var errMessage: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagResources") {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyConsumerChannelRequest : Tea.TeaModel {
    public var consumerGroupId: String?

    public var consumerGroupName: String?

    public var consumerGroupPassword: String?

    public var consumerGroupUserName: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consumerGroupId != nil {
            map["ConsumerGroupId"] = self.consumerGroupId!
        }
        if self.consumerGroupName != nil {
            map["ConsumerGroupName"] = self.consumerGroupName!
        }
        if self.consumerGroupPassword != nil {
            map["ConsumerGroupPassword"] = self.consumerGroupPassword!
        }
        if self.consumerGroupUserName != nil {
            map["ConsumerGroupUserName"] = self.consumerGroupUserName!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsumerGroupId") {
            self.consumerGroupId = dict["ConsumerGroupId"] as! String
        }
        if dict.keys.contains("ConsumerGroupName") {
            self.consumerGroupName = dict["ConsumerGroupName"] as! String
        }
        if dict.keys.contains("ConsumerGroupPassword") {
            self.consumerGroupPassword = dict["ConsumerGroupPassword"] as! String
        }
        if dict.keys.contains("ConsumerGroupUserName") {
            self.consumerGroupUserName = dict["ConsumerGroupUserName"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ModifyConsumerChannelResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyConsumerChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyConsumerChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyConsumerChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyConsumerGroupPasswordRequest : Tea.TeaModel {
    public var accountId: String?

    public var consumerGroupID: String?

    public var consumerGroupName: String?

    public var consumerGroupPassword: String?

    public var consumerGroupUserName: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public var consumerGroupNewPassword: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.consumerGroupID != nil {
            map["ConsumerGroupID"] = self.consumerGroupID!
        }
        if self.consumerGroupName != nil {
            map["ConsumerGroupName"] = self.consumerGroupName!
        }
        if self.consumerGroupPassword != nil {
            map["ConsumerGroupPassword"] = self.consumerGroupPassword!
        }
        if self.consumerGroupUserName != nil {
            map["ConsumerGroupUserName"] = self.consumerGroupUserName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        if self.consumerGroupNewPassword != nil {
            map["consumerGroupNewPassword"] = self.consumerGroupNewPassword!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ConsumerGroupID") {
            self.consumerGroupID = dict["ConsumerGroupID"] as! String
        }
        if dict.keys.contains("ConsumerGroupName") {
            self.consumerGroupName = dict["ConsumerGroupName"] as! String
        }
        if dict.keys.contains("ConsumerGroupPassword") {
            self.consumerGroupPassword = dict["ConsumerGroupPassword"] as! String
        }
        if dict.keys.contains("ConsumerGroupUserName") {
            self.consumerGroupUserName = dict["ConsumerGroupUserName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
        if dict.keys.contains("consumerGroupNewPassword") {
            self.consumerGroupNewPassword = dict["consumerGroupNewPassword"] as! String
        }
    }
}

public class ModifyConsumerGroupPasswordResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyConsumerGroupPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyConsumerGroupPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyConsumerGroupPasswordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyConsumptionTimestampRequest : Tea.TeaModel {
    public var accountId: String?

    public var consumptionTimestamp: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.consumptionTimestamp != nil {
            map["ConsumptionTimestamp"] = self.consumptionTimestamp!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ConsumptionTimestamp") {
            self.consumptionTimestamp = dict["ConsumptionTimestamp"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
    }
}

public class ModifyConsumptionTimestampResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyConsumptionTimestampResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyConsumptionTimestampResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyConsumptionTimestampResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedClusterRequest : Tea.TeaModel {
    public var dedicatedClusterId: String?

    public var dedicatedClusterName: String?

    public var instanceId: String?

    public var oversoldRatio: Int32?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.dedicatedClusterName != nil {
            map["DedicatedClusterName"] = self.dedicatedClusterName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.oversoldRatio != nil {
            map["OversoldRatio"] = self.oversoldRatio!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DedicatedClusterName") {
            self.dedicatedClusterName = dict["DedicatedClusterName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OversoldRatio") {
            self.oversoldRatio = dict["OversoldRatio"] as! Int32
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ModifyDedicatedClusterResponseBody : Tea.TeaModel {
    public var dedicatedClusterId: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyDedicatedClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDtsJobRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dataInitialization: Bool?

    public var dataSynchronization: Bool?

    public var dbList: [String: Any]?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var etlOperatorColumnReference: String?

    public var fileOssUrl: String?

    public var filterTableName: String?

    public var modifyTypeEnum: String?

    public var regionId: String?

    public var reserved: String?

    public var resourceGroupId: String?

    public var structureInitialization: Bool?

    public var synchronizationDirection: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataInitialization != nil {
            map["DataInitialization"] = self.dataInitialization!
        }
        if self.dataSynchronization != nil {
            map["DataSynchronization"] = self.dataSynchronization!
        }
        if self.dbList != nil {
            map["DbList"] = self.dbList!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.etlOperatorColumnReference != nil {
            map["EtlOperatorColumnReference"] = self.etlOperatorColumnReference!
        }
        if self.fileOssUrl != nil {
            map["FileOssUrl"] = self.fileOssUrl!
        }
        if self.filterTableName != nil {
            map["FilterTableName"] = self.filterTableName!
        }
        if self.modifyTypeEnum != nil {
            map["ModifyTypeEnum"] = self.modifyTypeEnum!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reserved != nil {
            map["Reserved"] = self.reserved!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.structureInitialization != nil {
            map["StructureInitialization"] = self.structureInitialization!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DataInitialization") {
            self.dataInitialization = dict["DataInitialization"] as! Bool
        }
        if dict.keys.contains("DataSynchronization") {
            self.dataSynchronization = dict["DataSynchronization"] as! Bool
        }
        if dict.keys.contains("DbList") {
            self.dbList = dict["DbList"] as! [String: Any]
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("EtlOperatorColumnReference") {
            self.etlOperatorColumnReference = dict["EtlOperatorColumnReference"] as! String
        }
        if dict.keys.contains("FileOssUrl") {
            self.fileOssUrl = dict["FileOssUrl"] as! String
        }
        if dict.keys.contains("FilterTableName") {
            self.filterTableName = dict["FilterTableName"] as! String
        }
        if dict.keys.contains("ModifyTypeEnum") {
            self.modifyTypeEnum = dict["ModifyTypeEnum"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reserved") {
            self.reserved = dict["Reserved"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StructureInitialization") {
            self.structureInitialization = dict["StructureInitialization"] as! Bool
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class ModifyDtsJobAdvanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dataInitialization: Bool?

    public var dataSynchronization: Bool?

    public var dbList: [String: Any]?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var etlOperatorColumnReference: String?

    public var fileOssUrlObject: InputStream?

    public var filterTableName: String?

    public var modifyTypeEnum: String?

    public var regionId: String?

    public var reserved: String?

    public var resourceGroupId: String?

    public var structureInitialization: Bool?

    public var synchronizationDirection: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataInitialization != nil {
            map["DataInitialization"] = self.dataInitialization!
        }
        if self.dataSynchronization != nil {
            map["DataSynchronization"] = self.dataSynchronization!
        }
        if self.dbList != nil {
            map["DbList"] = self.dbList!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.etlOperatorColumnReference != nil {
            map["EtlOperatorColumnReference"] = self.etlOperatorColumnReference!
        }
        if self.fileOssUrlObject != nil {
            map["FileOssUrl"] = self.fileOssUrlObject!
        }
        if self.filterTableName != nil {
            map["FilterTableName"] = self.filterTableName!
        }
        if self.modifyTypeEnum != nil {
            map["ModifyTypeEnum"] = self.modifyTypeEnum!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reserved != nil {
            map["Reserved"] = self.reserved!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.structureInitialization != nil {
            map["StructureInitialization"] = self.structureInitialization!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DataInitialization") {
            self.dataInitialization = dict["DataInitialization"] as! Bool
        }
        if dict.keys.contains("DataSynchronization") {
            self.dataSynchronization = dict["DataSynchronization"] as! Bool
        }
        if dict.keys.contains("DbList") {
            self.dbList = dict["DbList"] as! [String: Any]
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("EtlOperatorColumnReference") {
            self.etlOperatorColumnReference = dict["EtlOperatorColumnReference"] as! String
        }
        if dict.keys.contains("FileOssUrl") {
            self.fileOssUrlObject = dict["FileOssUrl"] as! InputStream
        }
        if dict.keys.contains("FilterTableName") {
            self.filterTableName = dict["FilterTableName"] as! String
        }
        if dict.keys.contains("ModifyTypeEnum") {
            self.modifyTypeEnum = dict["ModifyTypeEnum"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reserved") {
            self.reserved = dict["Reserved"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StructureInitialization") {
            self.structureInitialization = dict["StructureInitialization"] as! Bool
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class ModifyDtsJobShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dataInitialization: Bool?

    public var dataSynchronization: Bool?

    public var dbListShrink: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var etlOperatorColumnReference: String?

    public var fileOssUrl: String?

    public var filterTableName: String?

    public var modifyTypeEnum: String?

    public var regionId: String?

    public var reserved: String?

    public var resourceGroupId: String?

    public var structureInitialization: Bool?

    public var synchronizationDirection: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataInitialization != nil {
            map["DataInitialization"] = self.dataInitialization!
        }
        if self.dataSynchronization != nil {
            map["DataSynchronization"] = self.dataSynchronization!
        }
        if self.dbListShrink != nil {
            map["DbList"] = self.dbListShrink!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.etlOperatorColumnReference != nil {
            map["EtlOperatorColumnReference"] = self.etlOperatorColumnReference!
        }
        if self.fileOssUrl != nil {
            map["FileOssUrl"] = self.fileOssUrl!
        }
        if self.filterTableName != nil {
            map["FilterTableName"] = self.filterTableName!
        }
        if self.modifyTypeEnum != nil {
            map["ModifyTypeEnum"] = self.modifyTypeEnum!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reserved != nil {
            map["Reserved"] = self.reserved!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.structureInitialization != nil {
            map["StructureInitialization"] = self.structureInitialization!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DataInitialization") {
            self.dataInitialization = dict["DataInitialization"] as! Bool
        }
        if dict.keys.contains("DataSynchronization") {
            self.dataSynchronization = dict["DataSynchronization"] as! Bool
        }
        if dict.keys.contains("DbList") {
            self.dbListShrink = dict["DbList"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("EtlOperatorColumnReference") {
            self.etlOperatorColumnReference = dict["EtlOperatorColumnReference"] as! String
        }
        if dict.keys.contains("FileOssUrl") {
            self.fileOssUrl = dict["FileOssUrl"] as! String
        }
        if dict.keys.contains("FilterTableName") {
            self.filterTableName = dict["FilterTableName"] as! String
        }
        if dict.keys.contains("ModifyTypeEnum") {
            self.modifyTypeEnum = dict["ModifyTypeEnum"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reserved") {
            self.reserved = dict["Reserved"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StructureInitialization") {
            self.structureInitialization = dict["StructureInitialization"] as! Bool
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class ModifyDtsJobResponseBody : Tea.TeaModel {
    public var dtsJobId: String?

    public var errCode: String?

    public var errMessage: Bool?

    public var requestId: String?

    public var status: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDtsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDtsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDtsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDtsJobConfigRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var ownerId: String?

    public var parameters: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ModifyDtsJobConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDtsJobConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDtsJobConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDtsJobConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDtsJobDedicatedClusterRequest : Tea.TeaModel {
    public var dedicatedClusterId: String?

    public var dtsJobIds: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.dtsJobIds != nil {
            map["DtsJobIds"] = self.dtsJobIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DtsJobIds") {
            self.dtsJobIds = dict["DtsJobIds"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ModifyDtsJobDedicatedClusterResponseBody : Tea.TeaModel {
    public var code: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDtsJobDedicatedClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDtsJobDedicatedClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDtsJobDedicatedClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDtsJobDuLimitRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var duLimit: Int64?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.duLimit != nil {
            map["DuLimit"] = self.duLimit!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DuLimit") {
            self.duLimit = dict["DuLimit"] as! Int64
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ModifyDtsJobDuLimitResponseBody : Tea.TeaModel {
    public var code: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDtsJobDuLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDtsJobDuLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDtsJobDuLimitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDtsJobEndpointRequest : Tea.TeaModel {
    public var aliyunUid: String?

    public var database: String?

    public var dryRun: Bool?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var endpoint: String?

    public var endpointInstanceId: String?

    public var endpointInstanceType: String?

    public var endpointIp: String?

    public var endpointPort: String?

    public var endpointRegionId: String?

    public var modifyAccount: Bool?

    public var password: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var roleName: String?

    public var shardPassword: String?

    public var shardUsername: String?

    public var synchronizationDirection: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunUid != nil {
            map["AliyunUid"] = self.aliyunUid!
        }
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.endpointInstanceId != nil {
            map["EndpointInstanceId"] = self.endpointInstanceId!
        }
        if self.endpointInstanceType != nil {
            map["EndpointInstanceType"] = self.endpointInstanceType!
        }
        if self.endpointIp != nil {
            map["EndpointIp"] = self.endpointIp!
        }
        if self.endpointPort != nil {
            map["EndpointPort"] = self.endpointPort!
        }
        if self.endpointRegionId != nil {
            map["EndpointRegionId"] = self.endpointRegionId!
        }
        if self.modifyAccount != nil {
            map["ModifyAccount"] = self.modifyAccount!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        if self.shardPassword != nil {
            map["ShardPassword"] = self.shardPassword!
        }
        if self.shardUsername != nil {
            map["ShardUsername"] = self.shardUsername!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunUid") {
            self.aliyunUid = dict["AliyunUid"] as! String
        }
        if dict.keys.contains("Database") {
            self.database = dict["Database"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("Endpoint") {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EndpointInstanceId") {
            self.endpointInstanceId = dict["EndpointInstanceId"] as! String
        }
        if dict.keys.contains("EndpointInstanceType") {
            self.endpointInstanceType = dict["EndpointInstanceType"] as! String
        }
        if dict.keys.contains("EndpointIp") {
            self.endpointIp = dict["EndpointIp"] as! String
        }
        if dict.keys.contains("EndpointPort") {
            self.endpointPort = dict["EndpointPort"] as! String
        }
        if dict.keys.contains("EndpointRegionId") {
            self.endpointRegionId = dict["EndpointRegionId"] as! String
        }
        if dict.keys.contains("ModifyAccount") {
            self.modifyAccount = dict["ModifyAccount"] as! Bool
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("RoleName") {
            self.roleName = dict["RoleName"] as! String
        }
        if dict.keys.contains("ShardPassword") {
            self.shardPassword = dict["ShardPassword"] as! String
        }
        if dict.keys.contains("ShardUsername") {
            self.shardUsername = dict["ShardUsername"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class ModifyDtsJobEndpointResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDtsJobEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDtsJobEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDtsJobEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDtsJobNameRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var dtsJobName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dtsJobName != nil {
            map["DtsJobName"] = self.dtsJobName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DtsJobName") {
            self.dtsJobName = dict["DtsJobName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class ModifyDtsJobNameResponseBody : Tea.TeaModel {
    public var code: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDtsJobNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDtsJobNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDtsJobNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDtsJobPasswordRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var endpoint: String?

    public var password: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var userName: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("Endpoint") {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class ModifyDtsJobPasswordResponseBody : Tea.TeaModel {
    public var code: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDtsJobPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDtsJobPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDtsJobPasswordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDynamicConfigRequest : Tea.TeaModel {
    public var configList: String?

    public var dtsJobId: String?

    public var enableLimit: Bool?

    public var jobCode: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configList != nil {
            map["ConfigList"] = self.configList!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.enableLimit != nil {
            map["EnableLimit"] = self.enableLimit!
        }
        if self.jobCode != nil {
            map["JobCode"] = self.jobCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigList") {
            self.configList = dict["ConfigList"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("EnableLimit") {
            self.enableLimit = dict["EnableLimit"] as! Bool
        }
        if dict.keys.contains("JobCode") {
            self.jobCode = dict["JobCode"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ModifyDynamicConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDynamicConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDynamicConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDynamicConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyGadInstanceNameRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceName: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ModifyGadInstanceNameResponseBody : Tea.TeaModel {
    public var createTime: Int64?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var instanceId: String?

    public var instanceName: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyGadInstanceNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGadInstanceNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyGadInstanceNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySubscriptionRequest : Tea.TeaModel {
    public var dbList: String?

    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionDataTypeDDL: Bool?

    public var subscriptionDataTypeDML: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbList != nil {
            map["DbList"] = self.dbList!
        }
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionDataTypeDDL != nil {
            map["SubscriptionDataTypeDDL"] = self.subscriptionDataTypeDDL!
        }
        if self.subscriptionDataTypeDML != nil {
            map["SubscriptionDataTypeDML"] = self.subscriptionDataTypeDML!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbList") {
            self.dbList = dict["DbList"] as! String
        }
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionDataTypeDDL") {
            self.subscriptionDataTypeDDL = dict["SubscriptionDataTypeDDL"] as! Bool
        }
        if dict.keys.contains("SubscriptionDataTypeDML") {
            self.subscriptionDataTypeDML = dict["SubscriptionDataTypeDML"] as! Bool
        }
    }
}

public class ModifySubscriptionResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifySubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySubscriptionObjectRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public var subscriptionObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        if self.subscriptionObject != nil {
            map["SubscriptionObject"] = self.subscriptionObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
        if dict.keys.contains("SubscriptionObject") {
            self.subscriptionObject = dict["SubscriptionObject"] as! String
        }
    }
}

public class ModifySubscriptionObjectResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifySubscriptionObjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySubscriptionObjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySubscriptionObjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySynchronizationObjectRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public var synchronizationObjects: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        if self.synchronizationObjects != nil {
            map["SynchronizationObjects"] = self.synchronizationObjects!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
        if dict.keys.contains("SynchronizationObjects") {
            self.synchronizationObjects = dict["SynchronizationObjects"] as! String
        }
    }
}

public class ModifySynchronizationObjectResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class ModifySynchronizationObjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySynchronizationObjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySynchronizationObjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PreCheckCreateGadOrderRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var slaveDbInstanceId: String?

    public var slaveDbInstanceRegion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.slaveDbInstanceId != nil {
            map["SlaveDbInstanceId"] = self.slaveDbInstanceId!
        }
        if self.slaveDbInstanceRegion != nil {
            map["SlaveDbInstanceRegion"] = self.slaveDbInstanceRegion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SlaveDbInstanceId") {
            self.slaveDbInstanceId = dict["SlaveDbInstanceId"] as! String
        }
        if dict.keys.contains("SlaveDbInstanceRegion") {
            self.slaveDbInstanceRegion = dict["SlaveDbInstanceRegion"] as! String
        }
    }
}

public class PreCheckCreateGadOrderResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var instanceId: String?

    public var regionId: String?

    public var requestId: String?

    public var success: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class PreCheckCreateGadOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreCheckCreateGadOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PreCheckCreateGadOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewInstanceRequest : Tea.TeaModel {
    public var buyCount: String?

    public var chargeType: String?

    public var dtsJobId: String?

    public var period: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.buyCount != nil {
            map["BuyCount"] = self.buyCount!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BuyCount") {
            self.buyCount = dict["BuyCount"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class RenewInstanceResponseBody : Tea.TeaModel {
    public var chargeType: String?

    public var code: String?

    public var dtsJobId: String?

    public var dynamicMessage: String?

    public var endTime: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var instanceId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RenewInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetDtsJobRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
    }
}

public class ResetDtsJobResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ResetDtsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDtsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetDtsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetSynchronizationJobRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class ResetSynchronizationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ResetSynchronizationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetSynchronizationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetSynchronizationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReverseTwoWayDirectionRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var ignoreErrorSubJob: Bool?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.ignoreErrorSubJob != nil {
            map["IgnoreErrorSubJob"] = self.ignoreErrorSubJob!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("IgnoreErrorSubJob") {
            self.ignoreErrorSubJob = dict["IgnoreErrorSubJob"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ReverseTwoWayDirectionResponseBody : Tea.TeaModel {
    public var code: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ReverseTwoWayDirectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReverseTwoWayDirectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReverseTwoWayDirectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ShieldPrecheckRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var precheckItems: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.precheckItems != nil {
            map["PrecheckItems"] = self.precheckItems!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("PrecheckItems") {
            self.precheckItems = dict["PrecheckItems"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ShieldPrecheckResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ShieldPrecheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ShieldPrecheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ShieldPrecheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SkipFullJobTableRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var jobProgressId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.jobProgressId != nil {
            map["JobProgressId"] = self.jobProgressId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("JobProgressId") {
            self.jobProgressId = dict["JobProgressId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class SkipFullJobTableResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SkipFullJobTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SkipFullJobTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SkipFullJobTableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SkipPreCheckRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var jobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var skip: Bool?

    public var skipPreCheckItems: String?

    public var skipPreCheckNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.skip != nil {
            map["Skip"] = self.skip!
        }
        if self.skipPreCheckItems != nil {
            map["SkipPreCheckItems"] = self.skipPreCheckItems!
        }
        if self.skipPreCheckNames != nil {
            map["SkipPreCheckNames"] = self.skipPreCheckNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Skip") {
            self.skip = dict["Skip"] as! Bool
        }
        if dict.keys.contains("SkipPreCheckItems") {
            self.skipPreCheckItems = dict["SkipPreCheckItems"] as! String
        }
        if dict.keys.contains("SkipPreCheckNames") {
            self.skipPreCheckNames = dict["SkipPreCheckNames"] as! String
        }
    }
}

public class SkipPreCheckResponseBody : Tea.TeaModel {
    public var code: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var migrationJobId: String?

    public var requestId: String?

    public var scheduleJobId: String?

    public var skipItems: String?

    public var skipNames: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduleJobId != nil {
            map["ScheduleJobId"] = self.scheduleJobId!
        }
        if self.skipItems != nil {
            map["SkipItems"] = self.skipItems!
        }
        if self.skipNames != nil {
            map["SkipNames"] = self.skipNames!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScheduleJobId") {
            self.scheduleJobId = dict["ScheduleJobId"] as! String
        }
        if dict.keys.contains("SkipItems") {
            self.skipItems = dict["SkipItems"] as! String
        }
        if dict.keys.contains("SkipNames") {
            self.skipNames = dict["SkipNames"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SkipPreCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SkipPreCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SkipPreCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartDtsJobRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class StartDtsJobResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StartDtsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDtsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartDtsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartDtsJobsRequest : Tea.TeaModel {
    public var dtsJobIds: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobIds != nil {
            map["DtsJobIds"] = self.dtsJobIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobIds") {
            self.dtsJobIds = dict["DtsJobIds"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class StartDtsJobsResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StartDtsJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDtsJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartDtsJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartMigrationJobRequest : Tea.TeaModel {
    public var accountId: String?

    public var migrationJobId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class StartMigrationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class StartMigrationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartMigrationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartMigrationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartReverseWriterRequest : Tea.TeaModel {
    public var checkPoint: String?

    public var dtsJobId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkPoint != nil {
            map["CheckPoint"] = self.checkPoint!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckPoint") {
            self.checkPoint = dict["CheckPoint"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class StartReverseWriterResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class StartReverseWriterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartReverseWriterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartReverseWriterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartSubscriptionInstanceRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var subscriptionInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.subscriptionInstanceId != nil {
            map["SubscriptionInstanceId"] = self.subscriptionInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SubscriptionInstanceId") {
            self.subscriptionInstanceId = dict["SubscriptionInstanceId"] as! String
        }
    }
}

public class StartSubscriptionInstanceResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class StartSubscriptionInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartSubscriptionInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartSubscriptionInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartSynchronizationJobRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class StartSynchronizationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class StartSynchronizationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartSynchronizationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartSynchronizationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopDedicatedClusterRequest : Tea.TeaModel {
    public var dedicatedClusterId: String?

    public var dedicatedClusterName: String?

    public var instanceId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedClusterId != nil {
            map["DedicatedClusterId"] = self.dedicatedClusterId!
        }
        if self.dedicatedClusterName != nil {
            map["DedicatedClusterName"] = self.dedicatedClusterName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedClusterId") {
            self.dedicatedClusterId = dict["DedicatedClusterId"] as! String
        }
        if dict.keys.contains("DedicatedClusterName") {
            self.dedicatedClusterName = dict["DedicatedClusterName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class StopDedicatedClusterResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class StopDedicatedClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDedicatedClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopDedicatedClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopDtsJobRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class StopDtsJobResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StopDtsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDtsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopDtsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopDtsJobsRequest : Tea.TeaModel {
    public var dtsJobIds: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobIds != nil {
            map["DtsJobIds"] = self.dtsJobIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobIds") {
            self.dtsJobIds = dict["DtsJobIds"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class StopDtsJobsResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StopDtsJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDtsJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopDtsJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopMigrationJobRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var migrationJobId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class StopMigrationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class StopMigrationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopMigrationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopMigrationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SummaryJobDetailRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var jobCode: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var structType: String?

    public var synchronizationDirection: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.jobCode != nil {
            map["JobCode"] = self.jobCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.structType != nil {
            map["StructType"] = self.structType!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("JobCode") {
            self.jobCode = dict["JobCode"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StructType") {
            self.structType = dict["StructType"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class SummaryJobDetailResponseBody : Tea.TeaModel {
    public class ProgressSummaryDetails : Tea.TeaModel {
        public var key: String?

        public var state: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobId: String?

    public var progressSummaryDetails: [SummaryJobDetailResponseBody.ProgressSummaryDetails]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.progressSummaryDetails != nil {
            var tmp : [Any] = []
            for k in self.progressSummaryDetails! {
                tmp.append(k.toMap())
            }
            map["ProgressSummaryDetails"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("ProgressSummaryDetails") {
            var tmp : [SummaryJobDetailResponseBody.ProgressSummaryDetails] = []
            for v in dict["ProgressSummaryDetails"] as! [Any] {
                var model = SummaryJobDetailResponseBody.ProgressSummaryDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.progressSummaryDetails = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SummaryJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SummaryJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SummaryJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendDtsJobRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class SuspendDtsJobResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SuspendDtsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendDtsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendDtsJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendDtsJobsRequest : Tea.TeaModel {
    public var dtsJobIds: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobIds != nil {
            map["DtsJobIds"] = self.dtsJobIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobIds") {
            self.dtsJobIds = dict["DtsJobIds"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class SuspendDtsJobsResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SuspendDtsJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendDtsJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendDtsJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendMigrationJobRequest : Tea.TeaModel {
    public var accountId: String?

    public var clientToken: String?

    public var migrationJobId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.migrationJobId != nil {
            map["MigrationJobId"] = self.migrationJobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MigrationJobId") {
            self.migrationJobId = dict["MigrationJobId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class SuspendMigrationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class SuspendMigrationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendMigrationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendMigrationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendSynchronizationJobRequest : Tea.TeaModel {
    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class SuspendSynchronizationJobResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class SuspendSynchronizationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendSynchronizationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendSynchronizationJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchPhysicalDtsJobToCloudRequest : Tea.TeaModel {
    public var dtsInstanceId: String?

    public var dtsJobId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsInstanceId != nil {
            map["DtsInstanceId"] = self.dtsInstanceId!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsInstanceId") {
            self.dtsInstanceId = dict["DtsInstanceId"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
    }
}

public class SwitchPhysicalDtsJobToCloudResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SwitchPhysicalDtsJobToCloudResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchPhysicalDtsJobToCloudResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchPhysicalDtsJobToCloudResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchSynchronizationEndpointRequest : Tea.TeaModel {
    public class Endpoint : Tea.TeaModel {
        public var IP: String?

        public var instanceId: String?

        public var instanceType: String?

        public var port: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SourceEndpoint : Tea.TeaModel {
        public var ownerID: String?

        public var role: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ownerID != nil {
                map["OwnerID"] = self.ownerID!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OwnerID") {
                self.ownerID = dict["OwnerID"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
        }
    }
    public var endpoint: SwitchSynchronizationEndpointRequest.Endpoint?

    public var sourceEndpoint: SwitchSynchronizationEndpointRequest.SourceEndpoint?

    public var accountId: String?

    public var ownerId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var synchronizationDirection: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.endpoint?.validate()
        try self.sourceEndpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint?.toMap()
        }
        if self.sourceEndpoint != nil {
            map["SourceEndpoint"] = self.sourceEndpoint?.toMap()
        }
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.synchronizationDirection != nil {
            map["SynchronizationDirection"] = self.synchronizationDirection!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Endpoint") {
            var model = SwitchSynchronizationEndpointRequest.Endpoint()
            model.fromMap(dict["Endpoint"] as! [String: Any])
            self.endpoint = model
        }
        if dict.keys.contains("SourceEndpoint") {
            var model = SwitchSynchronizationEndpointRequest.SourceEndpoint()
            model.fromMap(dict["SourceEndpoint"] as! [String: Any])
            self.sourceEndpoint = model
        }
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SynchronizationDirection") {
            self.synchronizationDirection = dict["SynchronizationDirection"] as! String
        }
        if dict.keys.contains("SynchronizationJobId") {
            self.synchronizationJobId = dict["SynchronizationJobId"] as! String
        }
    }
}

public class SwitchSynchronizationEndpointResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class SwitchSynchronizationEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchSynchronizationEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchSynchronizationEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TransferInstanceClassRequest : Tea.TeaModel {
    public var dtsJobId: String?

    public var instanceClass: String?

    public var orderType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.instanceClass != nil {
            map["InstanceClass"] = self.instanceClass!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("InstanceClass") {
            self.instanceClass = dict["InstanceClass"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class TransferInstanceClassResponseBody : Tea.TeaModel {
    public var chargeType: String?

    public var code: String?

    public var dtsJobId: String?

    public var dynamicMessage: String?

    public var endTime: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var instanceId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TransferInstanceClassResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferInstanceClassResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TransferInstanceClassResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TransferPayTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var buyCount: String?

    public var chargeType: String?

    public var dtsJobId: String?

    public var instanceClass: String?

    public var maxDu: Int32?

    public var minDu: Int32?

    public var period: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.buyCount != nil {
            map["BuyCount"] = self.buyCount!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.instanceClass != nil {
            map["InstanceClass"] = self.instanceClass!
        }
        if self.maxDu != nil {
            map["MaxDu"] = self.maxDu!
        }
        if self.minDu != nil {
            map["MinDu"] = self.minDu!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("BuyCount") {
            self.buyCount = dict["BuyCount"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("InstanceClass") {
            self.instanceClass = dict["InstanceClass"] as! String
        }
        if dict.keys.contains("MaxDu") {
            self.maxDu = dict["MaxDu"] as! Int32
        }
        if dict.keys.contains("MinDu") {
            self.minDu = dict["MinDu"] as! Int32
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class TransferPayTypeResponseBody : Tea.TeaModel {
    public var chargeType: String?

    public var code: String?

    public var dtsJobId: String?

    public var dynamicMessage: String?

    public var endTime: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var instanceId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TransferPayTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferPayTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TransferPayTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeTwoWayRequest : Tea.TeaModel {
    public var instanceClass: String?

    public var instanceId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceClass != nil {
            map["InstanceClass"] = self.instanceClass!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceClass") {
            self.instanceClass = dict["InstanceClass"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class UpgradeTwoWayResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeTwoWayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeTwoWayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeTwoWayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WhiteIpListRequest : Tea.TeaModel {
    public var destAliyunUid: String?

    public var destPrimaryVswId: String?

    public var destRoleName: String?

    public var destSecondaryVswId: String?

    public var destVpcId: String?

    public var destinationRegion: String?

    public var region: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var srcAliyunUid: String?

    public var srcPrimaryVswId: String?

    public var srcRoleName: String?

    public var srcSecondaryVswId: String?

    public var srcVpcId: String?

    public var type: String?

    public var zeroEtlJob: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destAliyunUid != nil {
            map["DestAliyunUid"] = self.destAliyunUid!
        }
        if self.destPrimaryVswId != nil {
            map["DestPrimaryVswId"] = self.destPrimaryVswId!
        }
        if self.destRoleName != nil {
            map["DestRoleName"] = self.destRoleName!
        }
        if self.destSecondaryVswId != nil {
            map["DestSecondaryVswId"] = self.destSecondaryVswId!
        }
        if self.destVpcId != nil {
            map["DestVpcId"] = self.destVpcId!
        }
        if self.destinationRegion != nil {
            map["DestinationRegion"] = self.destinationRegion!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.srcAliyunUid != nil {
            map["SrcAliyunUid"] = self.srcAliyunUid!
        }
        if self.srcPrimaryVswId != nil {
            map["SrcPrimaryVswId"] = self.srcPrimaryVswId!
        }
        if self.srcRoleName != nil {
            map["SrcRoleName"] = self.srcRoleName!
        }
        if self.srcSecondaryVswId != nil {
            map["SrcSecondaryVswId"] = self.srcSecondaryVswId!
        }
        if self.srcVpcId != nil {
            map["SrcVpcId"] = self.srcVpcId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.zeroEtlJob != nil {
            map["ZeroEtlJob"] = self.zeroEtlJob!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestAliyunUid") {
            self.destAliyunUid = dict["DestAliyunUid"] as! String
        }
        if dict.keys.contains("DestPrimaryVswId") {
            self.destPrimaryVswId = dict["DestPrimaryVswId"] as! String
        }
        if dict.keys.contains("DestRoleName") {
            self.destRoleName = dict["DestRoleName"] as! String
        }
        if dict.keys.contains("DestSecondaryVswId") {
            self.destSecondaryVswId = dict["DestSecondaryVswId"] as! String
        }
        if dict.keys.contains("DestVpcId") {
            self.destVpcId = dict["DestVpcId"] as! String
        }
        if dict.keys.contains("DestinationRegion") {
            self.destinationRegion = dict["DestinationRegion"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SrcAliyunUid") {
            self.srcAliyunUid = dict["SrcAliyunUid"] as! String
        }
        if dict.keys.contains("SrcPrimaryVswId") {
            self.srcPrimaryVswId = dict["SrcPrimaryVswId"] as! String
        }
        if dict.keys.contains("SrcRoleName") {
            self.srcRoleName = dict["SrcRoleName"] as! String
        }
        if dict.keys.contains("SrcSecondaryVswId") {
            self.srcSecondaryVswId = dict["SrcSecondaryVswId"] as! String
        }
        if dict.keys.contains("SrcVpcId") {
            self.srcVpcId = dict["SrcVpcId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("ZeroEtlJob") {
            self.zeroEtlJob = dict["ZeroEtlJob"] as! Bool
        }
    }
}

public class WhiteIpListResponseBody : Tea.TeaModel {
    public var destIpList: String?

    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var ipList: String?

    public var requestId: String?

    public var srcIpList: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destIpList != nil {
            map["DestIpList"] = self.destIpList!
        }
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.ipList != nil {
            map["IpList"] = self.ipList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.srcIpList != nil {
            map["SrcIpList"] = self.srcIpList!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestIpList") {
            self.destIpList = dict["DestIpList"] as! String
        }
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrCode") {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("IpList") {
            self.ipList = dict["IpList"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SrcIpList") {
            self.srcIpList = dict["SrcIpList"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class WhiteIpListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WhiteIpListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = WhiteIpListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
