import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ApplyNumberDistrictInfoParsingResultRequest : Tea.TeaModel {
    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VersionId") {
            self.versionId = dict["VersionId"] as! String
        }
    }
}

public class ApplyNumberDistrictInfoParsingResultResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApplyNumberDistrictInfoParsingResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyNumberDistrictInfoParsingResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyNumberDistrictInfoParsingResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssignJobsRequest : Tea.TeaModel {
    public var callingNumber: [String]?

    public var instanceId: String?

    public var isAsynchrony: Bool?

    public var jobDataParsingTaskId: String?

    public var jobGroupId: String?

    public var jobsJson: [String]?

    public var rosterType: String?

    public var strategyJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isAsynchrony != nil {
            map["IsAsynchrony"] = self.isAsynchrony!
        }
        if self.jobDataParsingTaskId != nil {
            map["JobDataParsingTaskId"] = self.jobDataParsingTaskId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobsJson != nil {
            map["JobsJson"] = self.jobsJson!
        }
        if self.rosterType != nil {
            map["RosterType"] = self.rosterType!
        }
        if self.strategyJson != nil {
            map["StrategyJson"] = self.strategyJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsAsynchrony") {
            self.isAsynchrony = dict["IsAsynchrony"] as! Bool
        }
        if dict.keys.contains("JobDataParsingTaskId") {
            self.jobDataParsingTaskId = dict["JobDataParsingTaskId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobsJson") {
            self.jobsJson = dict["JobsJson"] as! [String]
        }
        if dict.keys.contains("RosterType") {
            self.rosterType = dict["RosterType"] as! String
        }
        if dict.keys.contains("StrategyJson") {
            self.strategyJson = dict["StrategyJson"] as! String
        }
    }
}

public class AssignJobsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobGroupId: String?

    public var jobsId: [String]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobsId != nil {
            map["JobsId"] = self.jobsId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobsId") {
            self.jobsId = dict["JobsId"] as! [String]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AssignJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssignJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelJobsRequest : Tea.TeaModel {
    public var all: Bool?

    public var instanceId: String?

    public var jobGroupId: String?

    public var jobId: [String]?

    public var jobReferenceId: [String]?

    public var scenarioId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobReferenceId != nil {
            map["JobReferenceId"] = self.jobReferenceId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! [String]
        }
        if dict.keys.contains("JobReferenceId") {
            self.jobReferenceId = dict["JobReferenceId"] as! [String]
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
    }
}

public class CancelJobsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CancelJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var newResourceGroupId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewResourceGroupId") {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBatchJobsRequest : Tea.TeaModel {
    public var batchJobDescription: String?

    public var batchJobName: String?

    public var callingNumber: [String]?

    public var instanceId: String?

    public var jobFilePath: String?

    public var scenarioId: String?

    public var scriptId: String?

    public var strategyJson: String?

    public var submitted: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchJobDescription != nil {
            map["BatchJobDescription"] = self.batchJobDescription!
        }
        if self.batchJobName != nil {
            map["BatchJobName"] = self.batchJobName!
        }
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobFilePath != nil {
            map["JobFilePath"] = self.jobFilePath!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.strategyJson != nil {
            map["StrategyJson"] = self.strategyJson!
        }
        if self.submitted != nil {
            map["Submitted"] = self.submitted!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchJobDescription") {
            self.batchJobDescription = dict["BatchJobDescription"] as! String
        }
        if dict.keys.contains("BatchJobName") {
            self.batchJobName = dict["BatchJobName"] as! String
        }
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobFilePath") {
            self.jobFilePath = dict["JobFilePath"] as! String
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("StrategyJson") {
            self.strategyJson = dict["StrategyJson"] as! String
        }
        if dict.keys.contains("Submitted") {
            self.submitted = dict["Submitted"] as! Bool
        }
    }
}

public class CreateBatchJobsResponseBody : Tea.TeaModel {
    public class BatchJob : Tea.TeaModel {
        public class Strategy : Tea.TeaModel {
            public class WorkingTime : Tea.TeaModel {
                public var beginTime: String?

                public var endTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.beginTime != nil {
                        map["BeginTime"] = self.beginTime!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BeginTime") {
                        self.beginTime = dict["BeginTime"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                }
            }
            public var customized: String?

            public var endTime: Int64?

            public var followUpStrategy: String?

            public var isTemplate: Bool?

            public var maxAttemptsPerDay: Int32?

            public var minAttemptInterval: Int32?

            public var repeatBy: String?

            public var repeatDays: [String]?

            public var routingStrategy: String?

            public var startTime: Int64?

            public var strategyDescription: String?

            public var strategyId: String?

            public var strategyName: String?

            public var type: String?

            public var workingTime: [CreateBatchJobsResponseBody.BatchJob.Strategy.WorkingTime]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customized != nil {
                    map["Customized"] = self.customized!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.followUpStrategy != nil {
                    map["FollowUpStrategy"] = self.followUpStrategy!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.maxAttemptsPerDay != nil {
                    map["MaxAttemptsPerDay"] = self.maxAttemptsPerDay!
                }
                if self.minAttemptInterval != nil {
                    map["MinAttemptInterval"] = self.minAttemptInterval!
                }
                if self.repeatBy != nil {
                    map["RepeatBy"] = self.repeatBy!
                }
                if self.repeatDays != nil {
                    map["RepeatDays"] = self.repeatDays!
                }
                if self.routingStrategy != nil {
                    map["RoutingStrategy"] = self.routingStrategy!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.strategyDescription != nil {
                    map["StrategyDescription"] = self.strategyDescription!
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workingTime != nil {
                    var tmp : [Any] = []
                    for k in self.workingTime! {
                        tmp.append(k.toMap())
                    }
                    map["WorkingTime"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Customized") {
                    self.customized = dict["Customized"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("FollowUpStrategy") {
                    self.followUpStrategy = dict["FollowUpStrategy"] as! String
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("MaxAttemptsPerDay") {
                    self.maxAttemptsPerDay = dict["MaxAttemptsPerDay"] as! Int32
                }
                if dict.keys.contains("MinAttemptInterval") {
                    self.minAttemptInterval = dict["MinAttemptInterval"] as! Int32
                }
                if dict.keys.contains("RepeatBy") {
                    self.repeatBy = dict["RepeatBy"] as! String
                }
                if dict.keys.contains("RepeatDays") {
                    self.repeatDays = dict["RepeatDays"] as! [String]
                }
                if dict.keys.contains("RoutingStrategy") {
                    self.routingStrategy = dict["RoutingStrategy"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("StrategyDescription") {
                    self.strategyDescription = dict["StrategyDescription"] as! String
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("StrategyName") {
                    self.strategyName = dict["StrategyName"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkingTime") {
                    self.workingTime = dict["WorkingTime"] as! [CreateBatchJobsResponseBody.BatchJob.Strategy.WorkingTime]
                }
            }
        }
        public var batchJobId: String?

        public var callingNumbers: [String]?

        public var creationTime: Int64?

        public var jobFilePath: String?

        public var jobGroupDescription: String?

        public var jobGroupName: String?

        public var scenarioId: String?

        public var strategy: CreateBatchJobsResponseBody.BatchJob.Strategy?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.strategy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchJobId != nil {
                map["BatchJobId"] = self.batchJobId!
            }
            if self.callingNumbers != nil {
                map["CallingNumbers"] = self.callingNumbers!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobFilePath != nil {
                map["JobFilePath"] = self.jobFilePath!
            }
            if self.jobGroupDescription != nil {
                map["JobGroupDescription"] = self.jobGroupDescription!
            }
            if self.jobGroupName != nil {
                map["JobGroupName"] = self.jobGroupName!
            }
            if self.scenarioId != nil {
                map["ScenarioId"] = self.scenarioId!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchJobId") {
                self.batchJobId = dict["BatchJobId"] as! String
            }
            if dict.keys.contains("CallingNumbers") {
                self.callingNumbers = dict["CallingNumbers"] as! [String]
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("JobFilePath") {
                self.jobFilePath = dict["JobFilePath"] as! String
            }
            if dict.keys.contains("JobGroupDescription") {
                self.jobGroupDescription = dict["JobGroupDescription"] as! String
            }
            if dict.keys.contains("JobGroupName") {
                self.jobGroupName = dict["JobGroupName"] as! String
            }
            if dict.keys.contains("ScenarioId") {
                self.scenarioId = dict["ScenarioId"] as! String
            }
            if dict.keys.contains("Strategy") {
                var model = CreateBatchJobsResponseBody.BatchJob.Strategy()
                model.fromMap(dict["Strategy"] as! [String: Any])
                self.strategy = model
            }
        }
    }
    public var batchJob: CreateBatchJobsResponseBody.BatchJob?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.batchJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchJob != nil {
            map["BatchJob"] = self.batchJob?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchJob") {
            var model = CreateBatchJobsResponseBody.BatchJob()
            model.fromMap(dict["BatchJob"] as! [String: Any])
            self.batchJob = model
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateBatchJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBatchJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBatchJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBatchRepeatJobRequest : Tea.TeaModel {
    public var callingNumber: [String]?

    public var description_: String?

    public var filterStatus: String?

    public var instanceId: String?

    public var minConcurrency: Int64?

    public var name: String?

    public var priority: String?

    public var recallStrategyJson: String?

    public var ringingDuration: Int64?

    public var scriptId: String?

    public var sourceGroupId: String?

    public var strategyJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.filterStatus != nil {
            map["FilterStatus"] = self.filterStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.minConcurrency != nil {
            map["MinConcurrency"] = self.minConcurrency!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.recallStrategyJson != nil {
            map["RecallStrategyJson"] = self.recallStrategyJson!
        }
        if self.ringingDuration != nil {
            map["RingingDuration"] = self.ringingDuration!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.sourceGroupId != nil {
            map["SourceGroupId"] = self.sourceGroupId!
        }
        if self.strategyJson != nil {
            map["StrategyJson"] = self.strategyJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! [String]
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FilterStatus") {
            self.filterStatus = dict["FilterStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MinConcurrency") {
            self.minConcurrency = dict["MinConcurrency"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("RecallStrategyJson") {
            self.recallStrategyJson = dict["RecallStrategyJson"] as! String
        }
        if dict.keys.contains("RingingDuration") {
            self.ringingDuration = dict["RingingDuration"] as! Int64
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("SourceGroupId") {
            self.sourceGroupId = dict["SourceGroupId"] as! String
        }
        if dict.keys.contains("StrategyJson") {
            self.strategyJson = dict["StrategyJson"] as! String
        }
    }
}

public class CreateBatchRepeatJobResponseBody : Tea.TeaModel {
    public class JobGroup : Tea.TeaModel {
        public var id: String?

        public var minConcurrency: Int64?

        public var priority: String?

        public var ringingDuration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.minConcurrency != nil {
                map["MinConcurrency"] = self.minConcurrency!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.ringingDuration != nil {
                map["RingingDuration"] = self.ringingDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MinConcurrency") {
                self.minConcurrency = dict["MinConcurrency"] as! Int64
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("RingingDuration") {
                self.ringingDuration = dict["RingingDuration"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobGroup: CreateBatchRepeatJobResponseBody.JobGroup?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobGroup != nil {
            map["JobGroup"] = self.jobGroup?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobGroup") {
            var model = CreateBatchRepeatJobResponseBody.JobGroup()
            model.fromMap(dict["JobGroup"] as! [String: Any])
            self.jobGroup = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateBatchRepeatJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBatchRepeatJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBatchRepeatJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDialogueFlowRequest : Tea.TeaModel {
    public var dialogueFlowType: String?

    public var dialogueName: String?

    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dialogueFlowType != nil {
            map["DialogueFlowType"] = self.dialogueFlowType!
        }
        if self.dialogueName != nil {
            map["DialogueName"] = self.dialogueName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DialogueFlowType") {
            self.dialogueFlowType = dict["DialogueFlowType"] as! String
        }
        if dict.keys.contains("DialogueName") {
            self.dialogueName = dict["DialogueName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class CreateDialogueFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var dialogueFlowId: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dialogueFlowId != nil {
            map["DialogueFlowId"] = self.dialogueFlowId!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DialogueFlowId") {
            self.dialogueFlowId = dict["DialogueFlowId"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDialogueFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDialogueFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDialogueFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDownloadUrlRequest : Tea.TeaModel {
    public var downloadTaskId: String?

    public var fileId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadTaskId != nil {
            map["DownloadTaskId"] = self.downloadTaskId!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadTaskId") {
            self.downloadTaskId = dict["DownloadTaskId"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
    }
}

public class CreateDownloadUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var fileHttpUrl: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.fileHttpUrl != nil {
            map["FileHttpUrl"] = self.fileHttpUrl!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FileHttpUrl") {
            self.fileHttpUrl = dict["FileHttpUrl"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGlobalQuestionRequest : Tea.TeaModel {
    public var answers: String?

    public var globalQuestionName: String?

    public var globalQuestionType: String?

    public var instanceId: String?

    public var questions: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.answers != nil {
            map["Answers"] = self.answers!
        }
        if self.globalQuestionName != nil {
            map["GlobalQuestionName"] = self.globalQuestionName!
        }
        if self.globalQuestionType != nil {
            map["GlobalQuestionType"] = self.globalQuestionType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.questions != nil {
            map["Questions"] = self.questions!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Answers") {
            self.answers = dict["Answers"] as! String
        }
        if dict.keys.contains("GlobalQuestionName") {
            self.globalQuestionName = dict["GlobalQuestionName"] as! String
        }
        if dict.keys.contains("GlobalQuestionType") {
            self.globalQuestionType = dict["GlobalQuestionType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Questions") {
            self.questions = dict["Questions"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class CreateGlobalQuestionResponseBody : Tea.TeaModel {
    public var code: String?

    public var globalQuestionId: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.globalQuestionId != nil {
            map["GlobalQuestionId"] = self.globalQuestionId!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("GlobalQuestionId") {
            self.globalQuestionId = dict["GlobalQuestionId"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateGlobalQuestionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGlobalQuestionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateGlobalQuestionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public var callingNumber: [String]?

    public var instanceDescription: String?

    public var instanceName: String?

    public var maxConcurrentConversation: Int32?

    public var nluServiceType: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.maxConcurrentConversation != nil {
            map["MaxConcurrentConversation"] = self.maxConcurrentConversation!
        }
        if self.nluServiceType != nil {
            map["NluServiceType"] = self.nluServiceType!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! [String]
        }
        if dict.keys.contains("InstanceDescription") {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("MaxConcurrentConversation") {
            self.maxConcurrentConversation = dict["MaxConcurrentConversation"] as! Int32
        }
        if dict.keys.contains("NluServiceType") {
            self.nluServiceType = dict["NluServiceType"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public var creationTime: Int64?

        public var creatorId: Int64?

        public var creatorName: String?

        public var instanceDescription: String?

        public var instanceId: String?

        public var instanceName: String?

        public var maxConcurrentConversation: Int32?

        public var ownerName: String?

        public var resourceGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.maxConcurrentConversation != nil {
                map["MaxConcurrentConversation"] = self.maxConcurrentConversation!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("InstanceDescription") {
                self.instanceDescription = dict["InstanceDescription"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("MaxConcurrentConversation") {
                self.maxConcurrentConversation = dict["MaxConcurrentConversation"] as! Int32
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var instance: CreateInstanceResponseBody.Instance?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Instance") {
            var model = CreateInstanceResponseBody.Instance()
            model.fromMap(dict["Instance"] as! [String: Any])
            self.instance = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceBindNumberRequest : Tea.TeaModel {
    public var instanceList: String?

    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceList != nil {
            map["InstanceList"] = self.instanceList!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceList") {
            self.instanceList = dict["InstanceList"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
    }
}

public class CreateInstanceBindNumberResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var instanceId: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Success") {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var list: [CreateInstanceBindNumberResponseBody.Data.List]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [CreateInstanceBindNumberResponseBody.Data.List]
            }
        }
    }
    public var code: String?

    public var data: CreateInstanceBindNumberResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateInstanceBindNumberResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateInstanceBindNumberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceBindNumberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateInstanceBindNumberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIntentRequest : Tea.TeaModel {
    public var instanceId: String?

    public var intentDescription: String?

    public var intentName: String?

    public var keywords: String?

    public var scriptId: String?

    public var utterances: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.intentDescription != nil {
            map["IntentDescription"] = self.intentDescription!
        }
        if self.intentName != nil {
            map["IntentName"] = self.intentName!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.utterances != nil {
            map["Utterances"] = self.utterances!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IntentDescription") {
            self.intentDescription = dict["IntentDescription"] as! String
        }
        if dict.keys.contains("IntentName") {
            self.intentName = dict["IntentName"] as! String
        }
        if dict.keys.contains("Keywords") {
            self.keywords = dict["Keywords"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("Utterances") {
            self.utterances = dict["Utterances"] as! String
        }
    }
}

public class CreateIntentResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var intentId: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.intentId != nil {
            map["IntentId"] = self.intentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("IntentId") {
            self.intentId = dict["IntentId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateIntentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIntentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIntentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateJobDataParsingTaskRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobFilePath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobFilePath != nil {
            map["JobFilePath"] = self.jobFilePath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobFilePath") {
            self.jobFilePath = dict["JobFilePath"] as! String
        }
    }
}

public class CreateJobDataParsingTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobDataParsingTaskId: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobDataParsingTaskId != nil {
            map["JobDataParsingTaskId"] = self.jobDataParsingTaskId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobDataParsingTaskId") {
            self.jobDataParsingTaskId = dict["JobDataParsingTaskId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateJobDataParsingTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateJobDataParsingTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateJobDataParsingTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateJobGroupRequest : Tea.TeaModel {
    public var callingNumber: [String]?

    public var instanceId: String?

    public var jobGroupDescription: String?

    public var jobGroupName: String?

    public var minConcurrency: Int64?

    public var priority: String?

    public var recallStrategyJson: String?

    public var ringingDuration: Int64?

    public var scenarioId: String?

    public var scriptId: String?

    public var strategyJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupDescription != nil {
            map["JobGroupDescription"] = self.jobGroupDescription!
        }
        if self.jobGroupName != nil {
            map["JobGroupName"] = self.jobGroupName!
        }
        if self.minConcurrency != nil {
            map["MinConcurrency"] = self.minConcurrency!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.recallStrategyJson != nil {
            map["RecallStrategyJson"] = self.recallStrategyJson!
        }
        if self.ringingDuration != nil {
            map["RingingDuration"] = self.ringingDuration!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.strategyJson != nil {
            map["StrategyJson"] = self.strategyJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupDescription") {
            self.jobGroupDescription = dict["JobGroupDescription"] as! String
        }
        if dict.keys.contains("JobGroupName") {
            self.jobGroupName = dict["JobGroupName"] as! String
        }
        if dict.keys.contains("MinConcurrency") {
            self.minConcurrency = dict["MinConcurrency"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("RecallStrategyJson") {
            self.recallStrategyJson = dict["RecallStrategyJson"] as! String
        }
        if dict.keys.contains("RingingDuration") {
            self.ringingDuration = dict["RingingDuration"] as! Int64
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("StrategyJson") {
            self.strategyJson = dict["StrategyJson"] as! String
        }
    }
}

public class CreateJobGroupResponseBody : Tea.TeaModel {
    public class JobGroup : Tea.TeaModel {
        public class ExportProgress : Tea.TeaModel {
            public var fileHttpUrl: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileHttpUrl != nil {
                    map["FileHttpUrl"] = self.fileHttpUrl!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileHttpUrl") {
                    self.fileHttpUrl = dict["FileHttpUrl"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RecallStrategy : Tea.TeaModel {
            public var emptyNumberIgnore: Bool?

            public var inArrearsIgnore: Bool?

            public var outOfServiceIgnore: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.emptyNumberIgnore != nil {
                    map["EmptyNumberIgnore"] = self.emptyNumberIgnore!
                }
                if self.inArrearsIgnore != nil {
                    map["InArrearsIgnore"] = self.inArrearsIgnore!
                }
                if self.outOfServiceIgnore != nil {
                    map["OutOfServiceIgnore"] = self.outOfServiceIgnore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EmptyNumberIgnore") {
                    self.emptyNumberIgnore = dict["EmptyNumberIgnore"] as! Bool
                }
                if dict.keys.contains("InArrearsIgnore") {
                    self.inArrearsIgnore = dict["InArrearsIgnore"] as! Bool
                }
                if dict.keys.contains("OutOfServiceIgnore") {
                    self.outOfServiceIgnore = dict["OutOfServiceIgnore"] as! Bool
                }
            }
        }
        public class Strategy : Tea.TeaModel {
            public class WorkingTime : Tea.TeaModel {
                public var beginTime: String?

                public var endTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.beginTime != nil {
                        map["BeginTime"] = self.beginTime!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BeginTime") {
                        self.beginTime = dict["BeginTime"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                }
            }
            public var customized: String?

            public var endTime: Int64?

            public var followUpStrategy: String?

            public var isTemplate: Bool?

            public var maxAttemptsPerDay: Int32?

            public var minAttemptInterval: Int32?

            public var repeatBy: String?

            public var repeatDays: [String]?

            public var routingStrategy: String?

            public var startTime: Int64?

            public var strategyDescription: String?

            public var strategyId: String?

            public var strategyName: String?

            public var type: String?

            public var workingTime: [CreateJobGroupResponseBody.JobGroup.Strategy.WorkingTime]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customized != nil {
                    map["Customized"] = self.customized!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.followUpStrategy != nil {
                    map["FollowUpStrategy"] = self.followUpStrategy!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.maxAttemptsPerDay != nil {
                    map["MaxAttemptsPerDay"] = self.maxAttemptsPerDay!
                }
                if self.minAttemptInterval != nil {
                    map["MinAttemptInterval"] = self.minAttemptInterval!
                }
                if self.repeatBy != nil {
                    map["RepeatBy"] = self.repeatBy!
                }
                if self.repeatDays != nil {
                    map["RepeatDays"] = self.repeatDays!
                }
                if self.routingStrategy != nil {
                    map["RoutingStrategy"] = self.routingStrategy!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.strategyDescription != nil {
                    map["StrategyDescription"] = self.strategyDescription!
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workingTime != nil {
                    var tmp : [Any] = []
                    for k in self.workingTime! {
                        tmp.append(k.toMap())
                    }
                    map["WorkingTime"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Customized") {
                    self.customized = dict["Customized"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("FollowUpStrategy") {
                    self.followUpStrategy = dict["FollowUpStrategy"] as! String
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("MaxAttemptsPerDay") {
                    self.maxAttemptsPerDay = dict["MaxAttemptsPerDay"] as! Int32
                }
                if dict.keys.contains("MinAttemptInterval") {
                    self.minAttemptInterval = dict["MinAttemptInterval"] as! Int32
                }
                if dict.keys.contains("RepeatBy") {
                    self.repeatBy = dict["RepeatBy"] as! String
                }
                if dict.keys.contains("RepeatDays") {
                    self.repeatDays = dict["RepeatDays"] as! [String]
                }
                if dict.keys.contains("RoutingStrategy") {
                    self.routingStrategy = dict["RoutingStrategy"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("StrategyDescription") {
                    self.strategyDescription = dict["StrategyDescription"] as! String
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("StrategyName") {
                    self.strategyName = dict["StrategyName"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkingTime") {
                    self.workingTime = dict["WorkingTime"] as! [CreateJobGroupResponseBody.JobGroup.Strategy.WorkingTime]
                }
            }
        }
        public var callingNumbers: [String]?

        public var creationTime: Int64?

        public var exportProgress: CreateJobGroupResponseBody.JobGroup.ExportProgress?

        public var jobDataParsingTaskId: String?

        public var jobFilePath: String?

        public var jobGroupDescription: String?

        public var jobGroupId: String?

        public var jobGroupName: String?

        public var minConcurrency: Int64?

        public var modifyTime: String?

        public var priority: String?

        public var recallStrategy: CreateJobGroupResponseBody.JobGroup.RecallStrategy?

        public var ringingDuration: Int64?

        public var scenarioId: String?

        public var scriptName: String?

        public var scriptVersion: String?

        public var status: String?

        public var strategy: CreateJobGroupResponseBody.JobGroup.Strategy?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.exportProgress?.validate()
            try self.recallStrategy?.validate()
            try self.strategy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callingNumbers != nil {
                map["CallingNumbers"] = self.callingNumbers!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.exportProgress != nil {
                map["ExportProgress"] = self.exportProgress?.toMap()
            }
            if self.jobDataParsingTaskId != nil {
                map["JobDataParsingTaskId"] = self.jobDataParsingTaskId!
            }
            if self.jobFilePath != nil {
                map["JobFilePath"] = self.jobFilePath!
            }
            if self.jobGroupDescription != nil {
                map["JobGroupDescription"] = self.jobGroupDescription!
            }
            if self.jobGroupId != nil {
                map["JobGroupId"] = self.jobGroupId!
            }
            if self.jobGroupName != nil {
                map["JobGroupName"] = self.jobGroupName!
            }
            if self.minConcurrency != nil {
                map["MinConcurrency"] = self.minConcurrency!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.recallStrategy != nil {
                map["RecallStrategy"] = self.recallStrategy?.toMap()
            }
            if self.ringingDuration != nil {
                map["RingingDuration"] = self.ringingDuration!
            }
            if self.scenarioId != nil {
                map["ScenarioId"] = self.scenarioId!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.scriptVersion != nil {
                map["ScriptVersion"] = self.scriptVersion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallingNumbers") {
                self.callingNumbers = dict["CallingNumbers"] as! [String]
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("ExportProgress") {
                var model = CreateJobGroupResponseBody.JobGroup.ExportProgress()
                model.fromMap(dict["ExportProgress"] as! [String: Any])
                self.exportProgress = model
            }
            if dict.keys.contains("JobDataParsingTaskId") {
                self.jobDataParsingTaskId = dict["JobDataParsingTaskId"] as! String
            }
            if dict.keys.contains("JobFilePath") {
                self.jobFilePath = dict["JobFilePath"] as! String
            }
            if dict.keys.contains("JobGroupDescription") {
                self.jobGroupDescription = dict["JobGroupDescription"] as! String
            }
            if dict.keys.contains("JobGroupId") {
                self.jobGroupId = dict["JobGroupId"] as! String
            }
            if dict.keys.contains("JobGroupName") {
                self.jobGroupName = dict["JobGroupName"] as! String
            }
            if dict.keys.contains("MinConcurrency") {
                self.minConcurrency = dict["MinConcurrency"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("RecallStrategy") {
                var model = CreateJobGroupResponseBody.JobGroup.RecallStrategy()
                model.fromMap(dict["RecallStrategy"] as! [String: Any])
                self.recallStrategy = model
            }
            if dict.keys.contains("RingingDuration") {
                self.ringingDuration = dict["RingingDuration"] as! Int64
            }
            if dict.keys.contains("ScenarioId") {
                self.scenarioId = dict["ScenarioId"] as! String
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("ScriptVersion") {
                self.scriptVersion = dict["ScriptVersion"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Strategy") {
                var model = CreateJobGroupResponseBody.JobGroup.Strategy()
                model.fromMap(dict["Strategy"] as! [String: Any])
                self.strategy = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobGroup: CreateJobGroupResponseBody.JobGroup?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobGroup != nil {
            map["JobGroup"] = self.jobGroup?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobGroup") {
            var model = CreateJobGroupResponseBody.JobGroup()
            model.fromMap(dict["JobGroup"] as! [String: Any])
            self.jobGroup = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateJobGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateJobGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateJobGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateJobGroupExportTaskRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobGroupId: String?

    public var option: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.option != nil {
            map["Option"] = self.option!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("Option") {
            self.option = dict["Option"] as! [String]
        }
    }
}

public class CreateJobGroupExportTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class CreateJobGroupExportTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateJobGroupExportTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateJobGroupExportTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNumberDistrictInfoDownloadUrlRequest : Tea.TeaModel {
    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VersionId") {
            self.versionId = dict["VersionId"] as! String
        }
    }
}

public class CreateNumberDistrictInfoDownloadUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var fileHttpUrl: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.fileHttpUrl != nil {
            map["FileHttpUrl"] = self.fileHttpUrl!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FileHttpUrl") {
            self.fileHttpUrl = dict["FileHttpUrl"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNumberDistrictInfoDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNumberDistrictInfoDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNumberDistrictInfoDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNumberDistrictInfoParsingTaskRequest : Tea.TeaModel {
    public var filePath: String?

    public var fileSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.fileSize != nil {
            map["FileSize"] = self.fileSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("FileSize") {
            self.fileSize = dict["FileSize"] as! Int64
        }
    }
}

public class CreateNumberDistrictInfoParsingTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNumberDistrictInfoParsingTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNumberDistrictInfoParsingTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNumberDistrictInfoParsingTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOutboundCallNumberRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public var rateLimitCount: Int32?

    public var rateLimitPeriod: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        if self.rateLimitCount != nil {
            map["RateLimitCount"] = self.rateLimitCount!
        }
        if self.rateLimitPeriod != nil {
            map["RateLimitPeriod"] = self.rateLimitPeriod!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
        if dict.keys.contains("RateLimitCount") {
            self.rateLimitCount = dict["RateLimitCount"] as! Int32
        }
        if dict.keys.contains("RateLimitPeriod") {
            self.rateLimitPeriod = dict["RateLimitPeriod"] as! Int32
        }
    }
}

public class CreateOutboundCallNumberResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var outboundCallNumberId: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.outboundCallNumberId != nil {
            map["OutboundCallNumberId"] = self.outboundCallNumberId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OutboundCallNumberId") {
            self.outboundCallNumberId = dict["OutboundCallNumberId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOutboundCallNumberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOutboundCallNumberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOutboundCallNumberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScriptRequest : Tea.TeaModel {
    public var asrConfig: String?

    public var chatbotId: String?

    public var emotionEnable: Bool?

    public var industry: String?

    public var instanceId: String?

    public var longWaitEnable: Bool?

    public var miniPlaybackEnable: Bool?

    public var newBargeInEnable: Bool?

    public var scene: String?

    public var scriptContent: [String]?

    public var scriptDescription: String?

    public var scriptName: String?

    public var scriptWaveform: [String]?

    public var ttsConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asrConfig != nil {
            map["AsrConfig"] = self.asrConfig!
        }
        if self.chatbotId != nil {
            map["ChatbotId"] = self.chatbotId!
        }
        if self.emotionEnable != nil {
            map["EmotionEnable"] = self.emotionEnable!
        }
        if self.industry != nil {
            map["Industry"] = self.industry!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.longWaitEnable != nil {
            map["LongWaitEnable"] = self.longWaitEnable!
        }
        if self.miniPlaybackEnable != nil {
            map["MiniPlaybackEnable"] = self.miniPlaybackEnable!
        }
        if self.newBargeInEnable != nil {
            map["NewBargeInEnable"] = self.newBargeInEnable!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.scriptContent != nil {
            map["ScriptContent"] = self.scriptContent!
        }
        if self.scriptDescription != nil {
            map["ScriptDescription"] = self.scriptDescription!
        }
        if self.scriptName != nil {
            map["ScriptName"] = self.scriptName!
        }
        if self.scriptWaveform != nil {
            map["ScriptWaveform"] = self.scriptWaveform!
        }
        if self.ttsConfig != nil {
            map["TtsConfig"] = self.ttsConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsrConfig") {
            self.asrConfig = dict["AsrConfig"] as! String
        }
        if dict.keys.contains("ChatbotId") {
            self.chatbotId = dict["ChatbotId"] as! String
        }
        if dict.keys.contains("EmotionEnable") {
            self.emotionEnable = dict["EmotionEnable"] as! Bool
        }
        if dict.keys.contains("Industry") {
            self.industry = dict["Industry"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LongWaitEnable") {
            self.longWaitEnable = dict["LongWaitEnable"] as! Bool
        }
        if dict.keys.contains("MiniPlaybackEnable") {
            self.miniPlaybackEnable = dict["MiniPlaybackEnable"] as! Bool
        }
        if dict.keys.contains("NewBargeInEnable") {
            self.newBargeInEnable = dict["NewBargeInEnable"] as! Bool
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
        if dict.keys.contains("ScriptContent") {
            self.scriptContent = dict["ScriptContent"] as! [String]
        }
        if dict.keys.contains("ScriptDescription") {
            self.scriptDescription = dict["ScriptDescription"] as! String
        }
        if dict.keys.contains("ScriptName") {
            self.scriptName = dict["ScriptName"] as! String
        }
        if dict.keys.contains("ScriptWaveform") {
            self.scriptWaveform = dict["ScriptWaveform"] as! [String]
        }
        if dict.keys.contains("TtsConfig") {
            self.ttsConfig = dict["TtsConfig"] as! String
        }
    }
}

public class CreateScriptResponseBody : Tea.TeaModel {
    public class Script : Tea.TeaModel {
        public var debugStatus: String?

        public var industry: String?

        public var isDebugDrafted: Bool?

        public var isDrafted: Bool?

        public var scene: String?

        public var scriptDescription: String?

        public var scriptId: String?

        public var scriptName: String?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.debugStatus != nil {
                map["DebugStatus"] = self.debugStatus!
            }
            if self.industry != nil {
                map["Industry"] = self.industry!
            }
            if self.isDebugDrafted != nil {
                map["IsDebugDrafted"] = self.isDebugDrafted!
            }
            if self.isDrafted != nil {
                map["IsDrafted"] = self.isDrafted!
            }
            if self.scene != nil {
                map["Scene"] = self.scene!
            }
            if self.scriptDescription != nil {
                map["ScriptDescription"] = self.scriptDescription!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DebugStatus") {
                self.debugStatus = dict["DebugStatus"] as! String
            }
            if dict.keys.contains("Industry") {
                self.industry = dict["Industry"] as! String
            }
            if dict.keys.contains("IsDebugDrafted") {
                self.isDebugDrafted = dict["IsDebugDrafted"] as! Bool
            }
            if dict.keys.contains("IsDrafted") {
                self.isDrafted = dict["IsDrafted"] as! Bool
            }
            if dict.keys.contains("Scene") {
                self.scene = dict["Scene"] as! String
            }
            if dict.keys.contains("ScriptDescription") {
                self.scriptDescription = dict["ScriptDescription"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var script: CreateScriptResponseBody.Script?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.script?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.script != nil {
            map["Script"] = self.script?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Script") {
            var model = CreateScriptResponseBody.Script()
            model.fromMap(dict["Script"] as! [String: Any])
            self.script = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScriptWaveformRequest : Tea.TeaModel {
    public var fileId: String?

    public var fileName: String?

    public var instanceId: String?

    public var scriptContent: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptContent != nil {
            map["ScriptContent"] = self.scriptContent!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptContent") {
            self.scriptContent = dict["ScriptContent"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class CreateScriptWaveformResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scriptWaveformId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptWaveformId != nil {
            map["ScriptWaveformId"] = self.scriptWaveformId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptWaveformId") {
            self.scriptWaveformId = dict["ScriptWaveformId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateScriptWaveformResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScriptWaveformResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateScriptWaveformResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTagRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public var tagGroup: String?

    public var tagName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.tagGroup != nil {
            map["TagGroup"] = self.tagGroup!
        }
        if self.tagName != nil {
            map["TagName"] = self.tagName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("TagGroup") {
            self.tagGroup = dict["TagGroup"] as! String
        }
        if dict.keys.contains("TagName") {
            self.tagName = dict["TagName"] as! String
        }
    }
}

public class CreateTagResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var tagId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagId != nil {
            map["TagId"] = self.tagId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagId") {
            self.tagId = dict["TagId"] as! String
        }
    }
}

public class CreateTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTaskExportTaskRequest : Tea.TeaModel {
    public var actualTimeGte: Int64?

    public var actualTimeLte: Int64?

    public var callDurationGte: Int64?

    public var callDurationLte: Int64?

    public var calledNumber: String?

    public var hasAnswered: Bool?

    public var hasHangUpByRejection: Bool?

    public var hasReachedEndOfFlow: Bool?

    public var instanceId: String?

    public var jobGroupId: String?

    public var jobGroupNameQuery: String?

    public var jobId: String?

    public var jobStatusStringList: String?

    public var otherId: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var recordingDurationGte: Int64?

    public var recordingDurationLte: Int64?

    public var scriptNameQuery: String?

    public var sortBy: String?

    public var sortOrder: String?

    public var taskCreateTimeGte: Int64?

    public var taskCreateTimeLte: Int64?

    public var taskId: String?

    public var taskStatusStringList: String?

    public var userIdMatch: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actualTimeGte != nil {
            map["ActualTimeGte"] = self.actualTimeGte!
        }
        if self.actualTimeLte != nil {
            map["ActualTimeLte"] = self.actualTimeLte!
        }
        if self.callDurationGte != nil {
            map["CallDurationGte"] = self.callDurationGte!
        }
        if self.callDurationLte != nil {
            map["CallDurationLte"] = self.callDurationLte!
        }
        if self.calledNumber != nil {
            map["CalledNumber"] = self.calledNumber!
        }
        if self.hasAnswered != nil {
            map["HasAnswered"] = self.hasAnswered!
        }
        if self.hasHangUpByRejection != nil {
            map["HasHangUpByRejection"] = self.hasHangUpByRejection!
        }
        if self.hasReachedEndOfFlow != nil {
            map["HasReachedEndOfFlow"] = self.hasReachedEndOfFlow!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobGroupNameQuery != nil {
            map["JobGroupNameQuery"] = self.jobGroupNameQuery!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobStatusStringList != nil {
            map["JobStatusStringList"] = self.jobStatusStringList!
        }
        if self.otherId != nil {
            map["OtherId"] = self.otherId!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordingDurationGte != nil {
            map["RecordingDurationGte"] = self.recordingDurationGte!
        }
        if self.recordingDurationLte != nil {
            map["RecordingDurationLte"] = self.recordingDurationLte!
        }
        if self.scriptNameQuery != nil {
            map["ScriptNameQuery"] = self.scriptNameQuery!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.taskCreateTimeGte != nil {
            map["TaskCreateTimeGte"] = self.taskCreateTimeGte!
        }
        if self.taskCreateTimeLte != nil {
            map["TaskCreateTimeLte"] = self.taskCreateTimeLte!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskStatusStringList != nil {
            map["TaskStatusStringList"] = self.taskStatusStringList!
        }
        if self.userIdMatch != nil {
            map["UserIdMatch"] = self.userIdMatch!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActualTimeGte") {
            self.actualTimeGte = dict["ActualTimeGte"] as! Int64
        }
        if dict.keys.contains("ActualTimeLte") {
            self.actualTimeLte = dict["ActualTimeLte"] as! Int64
        }
        if dict.keys.contains("CallDurationGte") {
            self.callDurationGte = dict["CallDurationGte"] as! Int64
        }
        if dict.keys.contains("CallDurationLte") {
            self.callDurationLte = dict["CallDurationLte"] as! Int64
        }
        if dict.keys.contains("CalledNumber") {
            self.calledNumber = dict["CalledNumber"] as! String
        }
        if dict.keys.contains("HasAnswered") {
            self.hasAnswered = dict["HasAnswered"] as! Bool
        }
        if dict.keys.contains("HasHangUpByRejection") {
            self.hasHangUpByRejection = dict["HasHangUpByRejection"] as! Bool
        }
        if dict.keys.contains("HasReachedEndOfFlow") {
            self.hasReachedEndOfFlow = dict["HasReachedEndOfFlow"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobGroupNameQuery") {
            self.jobGroupNameQuery = dict["JobGroupNameQuery"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobStatusStringList") {
            self.jobStatusStringList = dict["JobStatusStringList"] as! String
        }
        if dict.keys.contains("OtherId") {
            self.otherId = dict["OtherId"] as! String
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecordingDurationGte") {
            self.recordingDurationGte = dict["RecordingDurationGte"] as! Int64
        }
        if dict.keys.contains("RecordingDurationLte") {
            self.recordingDurationLte = dict["RecordingDurationLte"] as! Int64
        }
        if dict.keys.contains("ScriptNameQuery") {
            self.scriptNameQuery = dict["ScriptNameQuery"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("TaskCreateTimeGte") {
            self.taskCreateTimeGte = dict["TaskCreateTimeGte"] as! Int64
        }
        if dict.keys.contains("TaskCreateTimeLte") {
            self.taskCreateTimeLte = dict["TaskCreateTimeLte"] as! Int64
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskStatusStringList") {
            self.taskStatusStringList = dict["TaskStatusStringList"] as! String
        }
        if dict.keys.contains("UserIdMatch") {
            self.userIdMatch = dict["UserIdMatch"] as! String
        }
    }
}

public class CreateTaskExportTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class CreateTaskExportTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTaskExportTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTaskExportTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAllNumberDistrictInfoResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAllNumberDistrictInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAllNumberDistrictInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAllNumberDistrictInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactBlockListRequest : Tea.TeaModel {
    public var contactBlockListId: String?

    public var instanceId: String?

    public var operator_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactBlockListId != nil {
            map["ContactBlockListId"] = self.contactBlockListId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactBlockListId") {
            self.contactBlockListId = dict["ContactBlockListId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Operator") {
            self.operator_ = dict["Operator"] as! String
        }
    }
}

public class DeleteContactBlockListResponseBody : Tea.TeaModel {
    public var affectedRows: Int32?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affectedRows != nil {
            map["AffectedRows"] = self.affectedRows!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AffectedRows") {
            self.affectedRows = dict["AffectedRows"] as! Int32
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteContactBlockListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactBlockListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteContactBlockListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactWhiteListRequest : Tea.TeaModel {
    public var contactWhiteListId: String?

    public var instanceId: String?

    public var operator_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactWhiteListId != nil {
            map["ContactWhiteListId"] = self.contactWhiteListId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.operator_ != nil {
            map["Operator"] = self.operator_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactWhiteListId") {
            self.contactWhiteListId = dict["ContactWhiteListId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Operator") {
            self.operator_ = dict["Operator"] as! String
        }
    }
}

public class DeleteContactWhiteListResponseBody : Tea.TeaModel {
    public var affectedRows: Int32?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affectedRows != nil {
            map["AffectedRows"] = self.affectedRows!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AffectedRows") {
            self.affectedRows = dict["AffectedRows"] as! Int32
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteContactWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteContactWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDialogueFlowRequest : Tea.TeaModel {
    public var dialogueFlowId: String?

    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dialogueFlowId != nil {
            map["DialogueFlowId"] = self.dialogueFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DialogueFlowId") {
            self.dialogueFlowId = dict["DialogueFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class DeleteDialogueFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDialogueFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDialogueFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDialogueFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGlobalQuestionRequest : Tea.TeaModel {
    public var globalQuestionId: String?

    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalQuestionId != nil {
            map["GlobalQuestionId"] = self.globalQuestionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalQuestionId") {
            self.globalQuestionId = dict["GlobalQuestionId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class DeleteGlobalQuestionResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGlobalQuestionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGlobalQuestionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGlobalQuestionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIntentRequest : Tea.TeaModel {
    public var instanceId: String?

    public var intentId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.intentId != nil {
            map["IntentId"] = self.intentId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IntentId") {
            self.intentId = dict["IntentId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class DeleteIntentResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteIntentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIntentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIntentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteJobGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
    }
}

public class DeleteJobGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteJobGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteJobGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteJobGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteOutboundCallNumberRequest : Tea.TeaModel {
    public var instanceId: String?

    public var outboundCallNumberId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.outboundCallNumberId != nil {
            map["OutboundCallNumberId"] = self.outboundCallNumberId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OutboundCallNumberId") {
            self.outboundCallNumberId = dict["OutboundCallNumberId"] as! String
        }
    }
}

public class DeleteOutboundCallNumberResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteOutboundCallNumberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteOutboundCallNumberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteOutboundCallNumberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScriptRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class DeleteScriptResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScriptRecordingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public var uuidsJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.uuidsJson != nil {
            map["UuidsJson"] = self.uuidsJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("UuidsJson") {
            self.uuidsJson = dict["UuidsJson"] as! String
        }
    }
}

public class DeleteScriptRecordingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteScriptRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScriptRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScriptRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteScriptWaveformRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public var scriptWaveformId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.scriptWaveformId != nil {
            map["ScriptWaveformId"] = self.scriptWaveformId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("ScriptWaveformId") {
            self.scriptWaveformId = dict["ScriptWaveformId"] as! String
        }
    }
}

public class DeleteScriptWaveformResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteScriptWaveformResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteScriptWaveformResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteScriptWaveformResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDialogueNodeStatisticsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobGroupId: String?

    public var limit: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
    }
}

public class DescribeDialogueNodeStatisticsResponseBody : Tea.TeaModel {
    public class NoAnswerDialogueNodes : Tea.TeaModel {
        public var groupId: String?

        public var hangUpNum: Int32?

        public var hitNum: Int32?

        public var id: String?

        public var instanceId: String?

        public var noAnswerNum: Int32?

        public var nodeId: String?

        public var nodeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.hangUpNum != nil {
                map["HangUpNum"] = self.hangUpNum!
            }
            if self.hitNum != nil {
                map["HitNum"] = self.hitNum!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.noAnswerNum != nil {
                map["NoAnswerNum"] = self.noAnswerNum!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("HangUpNum") {
                self.hangUpNum = dict["HangUpNum"] as! Int32
            }
            if dict.keys.contains("HitNum") {
                self.hitNum = dict["HitNum"] as! Int32
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("NoAnswerNum") {
                self.noAnswerNum = dict["NoAnswerNum"] as! Int32
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
        }
    }
    public var code: String?

    public var groupId: String?

    public var httpStatusCode: Int32?

    public var instanceId: String?

    public var message: String?

    public var noAnswerDialogueNodes: [DescribeDialogueNodeStatisticsResponseBody.NoAnswerDialogueNodes]?

    public var requestId: String?

    public var success: Bool?

    public var totalCompleted: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.noAnswerDialogueNodes != nil {
            var tmp : [Any] = []
            for k in self.noAnswerDialogueNodes! {
                tmp.append(k.toMap())
            }
            map["NoAnswerDialogueNodes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCompleted != nil {
            map["TotalCompleted"] = self.totalCompleted!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NoAnswerDialogueNodes") {
            self.noAnswerDialogueNodes = dict["NoAnswerDialogueNodes"] as! [DescribeDialogueNodeStatisticsResponseBody.NoAnswerDialogueNodes]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCompleted") {
            self.totalCompleted = dict["TotalCompleted"] as! Int32
        }
    }
}

public class DescribeDialogueNodeStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDialogueNodeStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDialogueNodeStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDsReportsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
    }
}

public class DescribeDsReportsResponseBody : Tea.TeaModel {
    public var code: String?

    public var dsReports: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dsReports != nil {
            map["DsReports"] = self.dsReports!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DsReports") {
            self.dsReports = dict["DsReports"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeDsReportsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDsReportsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDsReportsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGlobalQuestionRequest : Tea.TeaModel {
    public var globalQuestionId: String?

    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalQuestionId != nil {
            map["GlobalQuestionId"] = self.globalQuestionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalQuestionId") {
            self.globalQuestionId = dict["GlobalQuestionId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class DescribeGlobalQuestionResponseBody : Tea.TeaModel {
    public class GlobalQuestion : Tea.TeaModel {
        public var answers: String?

        public var globalQuestionId: String?

        public var globalQuestionName: String?

        public var globalQuestionType: String?

        public var questions: String?

        public var scriptId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.answers != nil {
                map["Answers"] = self.answers!
            }
            if self.globalQuestionId != nil {
                map["GlobalQuestionId"] = self.globalQuestionId!
            }
            if self.globalQuestionName != nil {
                map["GlobalQuestionName"] = self.globalQuestionName!
            }
            if self.globalQuestionType != nil {
                map["GlobalQuestionType"] = self.globalQuestionType!
            }
            if self.questions != nil {
                map["Questions"] = self.questions!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Answers") {
                self.answers = dict["Answers"] as! String
            }
            if dict.keys.contains("GlobalQuestionId") {
                self.globalQuestionId = dict["GlobalQuestionId"] as! String
            }
            if dict.keys.contains("GlobalQuestionName") {
                self.globalQuestionName = dict["GlobalQuestionName"] as! String
            }
            if dict.keys.contains("GlobalQuestionType") {
                self.globalQuestionType = dict["GlobalQuestionType"] as! String
            }
            if dict.keys.contains("Questions") {
                self.questions = dict["Questions"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
        }
    }
    public var code: String?

    public var globalQuestion: DescribeGlobalQuestionResponseBody.GlobalQuestion?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.globalQuestion?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.globalQuestion != nil {
            map["GlobalQuestion"] = self.globalQuestion?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("GlobalQuestion") {
            var model = DescribeGlobalQuestionResponseBody.GlobalQuestion()
            model.fromMap(dict["GlobalQuestion"] as! [String: Any])
            self.globalQuestion = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeGlobalQuestionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGlobalQuestionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGlobalQuestionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupExecutingInfoRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
    }
}

public class DescribeGroupExecutingInfoResponseBody : Tea.TeaModel {
    public class ExecutingInfo : Tea.TeaModel {
        public class JobsProgress : Tea.TeaModel {
            public var cancelledNum: Int32?

            public var executingNum: Int32?

            public var failedNum: Int32?

            public var pausedNum: Int32?

            public var schedulingNum: Int32?

            public var totalCompletedNum: Int32?

            public var totalJobs: Int32?

            public var totalNotAnsweredNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cancelledNum != nil {
                    map["CancelledNum"] = self.cancelledNum!
                }
                if self.executingNum != nil {
                    map["ExecutingNum"] = self.executingNum!
                }
                if self.failedNum != nil {
                    map["FailedNum"] = self.failedNum!
                }
                if self.pausedNum != nil {
                    map["PausedNum"] = self.pausedNum!
                }
                if self.schedulingNum != nil {
                    map["SchedulingNum"] = self.schedulingNum!
                }
                if self.totalCompletedNum != nil {
                    map["TotalCompletedNum"] = self.totalCompletedNum!
                }
                if self.totalJobs != nil {
                    map["TotalJobs"] = self.totalJobs!
                }
                if self.totalNotAnsweredNum != nil {
                    map["TotalNotAnsweredNum"] = self.totalNotAnsweredNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CancelledNum") {
                    self.cancelledNum = dict["CancelledNum"] as! Int32
                }
                if dict.keys.contains("ExecutingNum") {
                    self.executingNum = dict["ExecutingNum"] as! Int32
                }
                if dict.keys.contains("FailedNum") {
                    self.failedNum = dict["FailedNum"] as! Int32
                }
                if dict.keys.contains("PausedNum") {
                    self.pausedNum = dict["PausedNum"] as! Int32
                }
                if dict.keys.contains("SchedulingNum") {
                    self.schedulingNum = dict["SchedulingNum"] as! Int32
                }
                if dict.keys.contains("TotalCompletedNum") {
                    self.totalCompletedNum = dict["TotalCompletedNum"] as! Int32
                }
                if dict.keys.contains("TotalJobs") {
                    self.totalJobs = dict["TotalJobs"] as! Int32
                }
                if dict.keys.contains("TotalNotAnsweredNum") {
                    self.totalNotAnsweredNum = dict["TotalNotAnsweredNum"] as! Int32
                }
            }
        }
        public var callFailedNum: Int32?

        public var callNum: Int32?

        public var creatorName: String?

        public var endTime: Int64?

        public var finishedNum: Int32?

        public var hangUpByClientNum: Int32?

        public var jobsProgress: DescribeGroupExecutingInfoResponseBody.ExecutingInfo.JobsProgress?

        public var startTime: Int64?

        public var transferByIntentNum: Int32?

        public var transferByNoAnswer: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.jobsProgress?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callFailedNum != nil {
                map["CallFailedNum"] = self.callFailedNum!
            }
            if self.callNum != nil {
                map["CallNum"] = self.callNum!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.finishedNum != nil {
                map["FinishedNum"] = self.finishedNum!
            }
            if self.hangUpByClientNum != nil {
                map["HangUpByClientNum"] = self.hangUpByClientNum!
            }
            if self.jobsProgress != nil {
                map["JobsProgress"] = self.jobsProgress?.toMap()
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.transferByIntentNum != nil {
                map["TransferByIntentNum"] = self.transferByIntentNum!
            }
            if self.transferByNoAnswer != nil {
                map["TransferByNoAnswer"] = self.transferByNoAnswer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallFailedNum") {
                self.callFailedNum = dict["CallFailedNum"] as! Int32
            }
            if dict.keys.contains("CallNum") {
                self.callNum = dict["CallNum"] as! Int32
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("FinishedNum") {
                self.finishedNum = dict["FinishedNum"] as! Int32
            }
            if dict.keys.contains("HangUpByClientNum") {
                self.hangUpByClientNum = dict["HangUpByClientNum"] as! Int32
            }
            if dict.keys.contains("JobsProgress") {
                var model = DescribeGroupExecutingInfoResponseBody.ExecutingInfo.JobsProgress()
                model.fromMap(dict["JobsProgress"] as! [String: Any])
                self.jobsProgress = model
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("TransferByIntentNum") {
                self.transferByIntentNum = dict["TransferByIntentNum"] as! Int32
            }
            if dict.keys.contains("TransferByNoAnswer") {
                self.transferByNoAnswer = dict["TransferByNoAnswer"] as! Int32
            }
        }
    }
    public var code: String?

    public var executingInfo: DescribeGroupExecutingInfoResponseBody.ExecutingInfo?

    public var groupId: String?

    public var httpStatusCode: Int32?

    public var instanceId: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.executingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.executingInfo != nil {
            map["ExecutingInfo"] = self.executingInfo?.toMap()
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ExecutingInfo") {
            var model = DescribeGroupExecutingInfoResponseBody.ExecutingInfo()
            model.fromMap(dict["ExecutingInfo"] as! [String: Any])
            self.executingInfo = model
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeGroupExecutingInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupExecutingInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGroupExecutingInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public var creationTime: Int64?

        public var creatorId: Int64?

        public var creatorName: String?

        public var instanceDescription: String?

        public var instanceId: String?

        public var instanceName: String?

        public var maxConcurrentConversation: Int32?

        public var ownerName: String?

        public var resourceGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.maxConcurrentConversation != nil {
                map["MaxConcurrentConversation"] = self.maxConcurrentConversation!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("InstanceDescription") {
                self.instanceDescription = dict["InstanceDescription"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("MaxConcurrentConversation") {
                self.maxConcurrentConversation = dict["MaxConcurrentConversation"] as! Int32
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var instance: DescribeInstanceResponseBody.Instance?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Instance") {
            var model = DescribeInstanceResponseBody.Instance()
            model.fromMap(dict["Instance"] as! [String: Any])
            self.instance = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIntentRequest : Tea.TeaModel {
    public var instanceId: String?

    public var intentId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.intentId != nil {
            map["IntentId"] = self.intentId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IntentId") {
            self.intentId = dict["IntentId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class DescribeIntentResponseBody : Tea.TeaModel {
    public class Intent : Tea.TeaModel {
        public var createTime: Int64?

        public var intentDescription: String?

        public var intentId: String?

        public var intentName: String?

        public var keywords: String?

        public var scriptId: String?

        public var updateTime: Int64?

        public var utterances: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.intentDescription != nil {
                map["IntentDescription"] = self.intentDescription!
            }
            if self.intentId != nil {
                map["IntentId"] = self.intentId!
            }
            if self.intentName != nil {
                map["IntentName"] = self.intentName!
            }
            if self.keywords != nil {
                map["Keywords"] = self.keywords!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.utterances != nil {
                map["Utterances"] = self.utterances!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("IntentDescription") {
                self.intentDescription = dict["IntentDescription"] as! String
            }
            if dict.keys.contains("IntentId") {
                self.intentId = dict["IntentId"] as! String
            }
            if dict.keys.contains("IntentName") {
                self.intentName = dict["IntentName"] as! String
            }
            if dict.keys.contains("Keywords") {
                self.keywords = dict["Keywords"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("Utterances") {
                self.utterances = dict["Utterances"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var intent: DescribeIntentResponseBody.Intent?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.intent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.intent != nil {
            map["Intent"] = self.intent?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Intent") {
            var model = DescribeIntentResponseBody.Intent()
            model.fromMap(dict["Intent"] as! [String: Any])
            self.intent = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeIntentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIntentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIntentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIntentStatisticsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobGroupId: String?

    public var limit: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
    }
}

public class DescribeIntentStatisticsResponseBody : Tea.TeaModel {
    public class GlobalIntents : Tea.TeaModel {
        public var groupId: String?

        public var hitAfterNoAnswer: Int32?

        public var hitNum: Int32?

        public var instanceId: String?

        public var intentId: String?

        public var intentName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.hitAfterNoAnswer != nil {
                map["HitAfterNoAnswer"] = self.hitAfterNoAnswer!
            }
            if self.hitNum != nil {
                map["HitNum"] = self.hitNum!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.intentId != nil {
                map["IntentId"] = self.intentId!
            }
            if self.intentName != nil {
                map["IntentName"] = self.intentName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("HitAfterNoAnswer") {
                self.hitAfterNoAnswer = dict["HitAfterNoAnswer"] as! Int32
            }
            if dict.keys.contains("HitNum") {
                self.hitNum = dict["HitNum"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("IntentId") {
                self.intentId = dict["IntentId"] as! String
            }
            if dict.keys.contains("IntentName") {
                self.intentName = dict["IntentName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class IntentsAfterNoAnswer : Tea.TeaModel {
        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public class ProcessIntents : Tea.TeaModel {
        public var groupId: String?

        public var hitAfterNoAnswer: Int32?

        public var hitNum: Int32?

        public var instanceId: String?

        public var intentId: String?

        public var intentName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.hitAfterNoAnswer != nil {
                map["HitAfterNoAnswer"] = self.hitAfterNoAnswer!
            }
            if self.hitNum != nil {
                map["HitNum"] = self.hitNum!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.intentId != nil {
                map["IntentId"] = self.intentId!
            }
            if self.intentName != nil {
                map["IntentName"] = self.intentName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("HitAfterNoAnswer") {
                self.hitAfterNoAnswer = dict["HitAfterNoAnswer"] as! Int32
            }
            if dict.keys.contains("HitNum") {
                self.hitNum = dict["HitNum"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("IntentId") {
                self.intentId = dict["IntentId"] as! String
            }
            if dict.keys.contains("IntentName") {
                self.intentName = dict["IntentName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var globalIntentNum: Int32?

    public var globalIntents: [DescribeIntentStatisticsResponseBody.GlobalIntents]?

    public var groupId: String?

    public var httpStatusCode: Int32?

    public var instanceId: String?

    public var intentsAfterNoAnswer: [DescribeIntentStatisticsResponseBody.IntentsAfterNoAnswer]?

    public var message: String?

    public var processIntentNum: Int32?

    public var processIntents: [DescribeIntentStatisticsResponseBody.ProcessIntents]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.globalIntentNum != nil {
            map["GlobalIntentNum"] = self.globalIntentNum!
        }
        if self.globalIntents != nil {
            var tmp : [Any] = []
            for k in self.globalIntents! {
                tmp.append(k.toMap())
            }
            map["GlobalIntents"] = tmp
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.intentsAfterNoAnswer != nil {
            var tmp : [Any] = []
            for k in self.intentsAfterNoAnswer! {
                tmp.append(k.toMap())
            }
            map["IntentsAfterNoAnswer"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.processIntentNum != nil {
            map["ProcessIntentNum"] = self.processIntentNum!
        }
        if self.processIntents != nil {
            var tmp : [Any] = []
            for k in self.processIntents! {
                tmp.append(k.toMap())
            }
            map["ProcessIntents"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("GlobalIntentNum") {
            self.globalIntentNum = dict["GlobalIntentNum"] as! Int32
        }
        if dict.keys.contains("GlobalIntents") {
            self.globalIntents = dict["GlobalIntents"] as! [DescribeIntentStatisticsResponseBody.GlobalIntents]
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IntentsAfterNoAnswer") {
            self.intentsAfterNoAnswer = dict["IntentsAfterNoAnswer"] as! [DescribeIntentStatisticsResponseBody.IntentsAfterNoAnswer]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("ProcessIntentNum") {
            self.processIntentNum = dict["ProcessIntentNum"] as! Int32
        }
        if dict.keys.contains("ProcessIntents") {
            self.processIntents = dict["ProcessIntents"] as! [DescribeIntentStatisticsResponseBody.ProcessIntents]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeIntentStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIntentStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIntentStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeJobRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public var withScript: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.withScript != nil {
            map["WithScript"] = self.withScript!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("WithScript") {
            self.withScript = dict["WithScript"] as! Bool
        }
    }
}

public class DescribeJobResponseBody : Tea.TeaModel {
    public class Job : Tea.TeaModel {
        public class Contacts : Tea.TeaModel {
            public var contactId: String?

            public var contactName: String?

            public var honorific: String?

            public var jobId: String?

            public var phoneNumber: String?

            public var referenceId: String?

            public var role: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.honorific != nil {
                    map["Honorific"] = self.honorific!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("ContactName") {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("Honorific") {
                    self.honorific = dict["Honorific"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("PhoneNumber") {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public class Extras : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Script : Tea.TeaModel {
            public var asrConfig: String?

            public var chatbotId: String?

            public var debugStatus: String?

            public var industry: String?

            public var isDebugDrafted: Bool?

            public var isDrafted: Bool?

            public var miniPlaybackConfigEnabled: Bool?

            public var name: String?

            public var scene: String?

            public var scriptDescription: String?

            public var scriptId: String?

            public var status: String?

            public var ttsConfig: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.asrConfig != nil {
                    map["AsrConfig"] = self.asrConfig!
                }
                if self.chatbotId != nil {
                    map["ChatbotId"] = self.chatbotId!
                }
                if self.debugStatus != nil {
                    map["DebugStatus"] = self.debugStatus!
                }
                if self.industry != nil {
                    map["Industry"] = self.industry!
                }
                if self.isDebugDrafted != nil {
                    map["IsDebugDrafted"] = self.isDebugDrafted!
                }
                if self.isDrafted != nil {
                    map["IsDrafted"] = self.isDrafted!
                }
                if self.miniPlaybackConfigEnabled != nil {
                    map["MiniPlaybackConfigEnabled"] = self.miniPlaybackConfigEnabled!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.scriptDescription != nil {
                    map["ScriptDescription"] = self.scriptDescription!
                }
                if self.scriptId != nil {
                    map["ScriptId"] = self.scriptId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.ttsConfig != nil {
                    map["TtsConfig"] = self.ttsConfig!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AsrConfig") {
                    self.asrConfig = dict["AsrConfig"] as! String
                }
                if dict.keys.contains("ChatbotId") {
                    self.chatbotId = dict["ChatbotId"] as! String
                }
                if dict.keys.contains("DebugStatus") {
                    self.debugStatus = dict["DebugStatus"] as! String
                }
                if dict.keys.contains("Industry") {
                    self.industry = dict["Industry"] as! String
                }
                if dict.keys.contains("IsDebugDrafted") {
                    self.isDebugDrafted = dict["IsDebugDrafted"] as! Bool
                }
                if dict.keys.contains("IsDrafted") {
                    self.isDrafted = dict["IsDrafted"] as! Bool
                }
                if dict.keys.contains("MiniPlaybackConfigEnabled") {
                    self.miniPlaybackConfigEnabled = dict["MiniPlaybackConfigEnabled"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("ScriptDescription") {
                    self.scriptDescription = dict["ScriptDescription"] as! String
                }
                if dict.keys.contains("ScriptId") {
                    self.scriptId = dict["ScriptId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TtsConfig") {
                    self.ttsConfig = dict["TtsConfig"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public class Summary : Tea.TeaModel {
            public var category: String?

            public var content: String?

            public var summaryName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.summaryName != nil {
                    map["SummaryName"] = self.summaryName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("SummaryName") {
                    self.summaryName = dict["SummaryName"] as! String
                }
            }
        }
        public class Tasks : Tea.TeaModel {
            public class Contact : Tea.TeaModel {
                public var contactId: String?

                public var contactName: String?

                public var honorific: String?

                public var jobId: String?

                public var phoneNumber: String?

                public var referenceId: String?

                public var role: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactId != nil {
                        map["ContactId"] = self.contactId!
                    }
                    if self.contactName != nil {
                        map["ContactName"] = self.contactName!
                    }
                    if self.honorific != nil {
                        map["Honorific"] = self.honorific!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.phoneNumber != nil {
                        map["PhoneNumber"] = self.phoneNumber!
                    }
                    if self.referenceId != nil {
                        map["ReferenceId"] = self.referenceId!
                    }
                    if self.role != nil {
                        map["Role"] = self.role!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactId") {
                        self.contactId = dict["ContactId"] as! String
                    }
                    if dict.keys.contains("ContactName") {
                        self.contactName = dict["ContactName"] as! String
                    }
                    if dict.keys.contains("Honorific") {
                        self.honorific = dict["Honorific"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("PhoneNumber") {
                        self.phoneNumber = dict["PhoneNumber"] as! String
                    }
                    if dict.keys.contains("ReferenceId") {
                        self.referenceId = dict["ReferenceId"] as! String
                    }
                    if dict.keys.contains("Role") {
                        self.role = dict["Role"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                }
            }
            public class Conversation : Tea.TeaModel {
                public class Summary : Tea.TeaModel {
                    public var category: String?

                    public var content: String?

                    public var summaryName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.category != nil {
                            map["Category"] = self.category!
                        }
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.summaryName != nil {
                            map["SummaryName"] = self.summaryName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Category") {
                            self.category = dict["Category"] as! String
                        }
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("SummaryName") {
                            self.summaryName = dict["SummaryName"] as! String
                        }
                    }
                }
                public var action: String?

                public var actionParams: String?

                public var script: String?

                public var sequenceId: String?

                public var speaker: String?

                public var summary: [DescribeJobResponseBody.Job.Tasks.Conversation.Summary]?

                public var timestamp: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["Action"] = self.action!
                    }
                    if self.actionParams != nil {
                        map["ActionParams"] = self.actionParams!
                    }
                    if self.script != nil {
                        map["Script"] = self.script!
                    }
                    if self.sequenceId != nil {
                        map["SequenceId"] = self.sequenceId!
                    }
                    if self.speaker != nil {
                        map["Speaker"] = self.speaker!
                    }
                    if self.summary != nil {
                        var tmp : [Any] = []
                        for k in self.summary! {
                            tmp.append(k.toMap())
                        }
                        map["Summary"] = tmp
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Action") {
                        self.action = dict["Action"] as! String
                    }
                    if dict.keys.contains("ActionParams") {
                        self.actionParams = dict["ActionParams"] as! String
                    }
                    if dict.keys.contains("Script") {
                        self.script = dict["Script"] as! String
                    }
                    if dict.keys.contains("SequenceId") {
                        self.sequenceId = dict["SequenceId"] as! String
                    }
                    if dict.keys.contains("Speaker") {
                        self.speaker = dict["Speaker"] as! String
                    }
                    if dict.keys.contains("Summary") {
                        self.summary = dict["Summary"] as! [DescribeJobResponseBody.Job.Tasks.Conversation.Summary]
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                }
            }
            public var actualTime: Int64?

            public var brief: String?

            public var callId: String?

            public var calledNumber: String?

            public var callingNumber: String?

            public var chatbotId: String?

            public var contact: DescribeJobResponseBody.Job.Tasks.Contact?

            public var conversation: [DescribeJobResponseBody.Job.Tasks.Conversation]?

            public var duration: Int32?

            public var endReason: String?

            public var endTime: Int64?

            public var hangUpDirection: String?

            public var jobId: String?

            public var planedTime: Int64?

            public var ringingDuration: Int64?

            public var scenarioId: String?

            public var status: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.contact?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualTime != nil {
                    map["ActualTime"] = self.actualTime!
                }
                if self.brief != nil {
                    map["Brief"] = self.brief!
                }
                if self.callId != nil {
                    map["CallId"] = self.callId!
                }
                if self.calledNumber != nil {
                    map["CalledNumber"] = self.calledNumber!
                }
                if self.callingNumber != nil {
                    map["CallingNumber"] = self.callingNumber!
                }
                if self.chatbotId != nil {
                    map["ChatbotId"] = self.chatbotId!
                }
                if self.contact != nil {
                    map["Contact"] = self.contact?.toMap()
                }
                if self.conversation != nil {
                    var tmp : [Any] = []
                    for k in self.conversation! {
                        tmp.append(k.toMap())
                    }
                    map["Conversation"] = tmp
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.endReason != nil {
                    map["EndReason"] = self.endReason!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.hangUpDirection != nil {
                    map["HangUpDirection"] = self.hangUpDirection!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.planedTime != nil {
                    map["PlanedTime"] = self.planedTime!
                }
                if self.ringingDuration != nil {
                    map["RingingDuration"] = self.ringingDuration!
                }
                if self.scenarioId != nil {
                    map["ScenarioId"] = self.scenarioId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualTime") {
                    self.actualTime = dict["ActualTime"] as! Int64
                }
                if dict.keys.contains("Brief") {
                    self.brief = dict["Brief"] as! String
                }
                if dict.keys.contains("CallId") {
                    self.callId = dict["CallId"] as! String
                }
                if dict.keys.contains("CalledNumber") {
                    self.calledNumber = dict["CalledNumber"] as! String
                }
                if dict.keys.contains("CallingNumber") {
                    self.callingNumber = dict["CallingNumber"] as! String
                }
                if dict.keys.contains("ChatbotId") {
                    self.chatbotId = dict["ChatbotId"] as! String
                }
                if dict.keys.contains("Contact") {
                    var model = DescribeJobResponseBody.Job.Tasks.Contact()
                    model.fromMap(dict["Contact"] as! [String: Any])
                    self.contact = model
                }
                if dict.keys.contains("Conversation") {
                    self.conversation = dict["Conversation"] as! [DescribeJobResponseBody.Job.Tasks.Conversation]
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("EndReason") {
                    self.endReason = dict["EndReason"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("HangUpDirection") {
                    self.hangUpDirection = dict["HangUpDirection"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("PlanedTime") {
                    self.planedTime = dict["PlanedTime"] as! Int64
                }
                if dict.keys.contains("RingingDuration") {
                    self.ringingDuration = dict["RingingDuration"] as! Int64
                }
                if dict.keys.contains("ScenarioId") {
                    self.scenarioId = dict["ScenarioId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
            }
        }
        public var actualTime: Int64?

        public var calledNumber: String?

        public var callingNumbers: [String]?

        public var contacts: [DescribeJobResponseBody.Job.Contacts]?

        public var dsReport: String?

        public var endReason: Int32?

        public var extras: [DescribeJobResponseBody.Job.Extras]?

        public var failureReason: String?

        public var instanceId: String?

        public var jobGroupId: String?

        public var jobId: String?

        public var nextExecutionTime: Int64?

        public var priority: Int32?

        public var referenceId: String?

        public var scenarioId: String?

        public var script: DescribeJobResponseBody.Job.Script?

        public var status: String?

        public var strategyId: String?

        public var summary: [DescribeJobResponseBody.Job.Summary]?

        public var systemPriority: Int32?

        public var tasks: [DescribeJobResponseBody.Job.Tasks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.script?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualTime != nil {
                map["ActualTime"] = self.actualTime!
            }
            if self.calledNumber != nil {
                map["CalledNumber"] = self.calledNumber!
            }
            if self.callingNumbers != nil {
                map["CallingNumbers"] = self.callingNumbers!
            }
            if self.contacts != nil {
                var tmp : [Any] = []
                for k in self.contacts! {
                    tmp.append(k.toMap())
                }
                map["Contacts"] = tmp
            }
            if self.dsReport != nil {
                map["DsReport"] = self.dsReport!
            }
            if self.endReason != nil {
                map["EndReason"] = self.endReason!
            }
            if self.extras != nil {
                var tmp : [Any] = []
                for k in self.extras! {
                    tmp.append(k.toMap())
                }
                map["Extras"] = tmp
            }
            if self.failureReason != nil {
                map["FailureReason"] = self.failureReason!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobGroupId != nil {
                map["JobGroupId"] = self.jobGroupId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.nextExecutionTime != nil {
                map["NextExecutionTime"] = self.nextExecutionTime!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.referenceId != nil {
                map["ReferenceId"] = self.referenceId!
            }
            if self.scenarioId != nil {
                map["ScenarioId"] = self.scenarioId!
            }
            if self.script != nil {
                map["Script"] = self.script?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strategyId != nil {
                map["StrategyId"] = self.strategyId!
            }
            if self.summary != nil {
                var tmp : [Any] = []
                for k in self.summary! {
                    tmp.append(k.toMap())
                }
                map["Summary"] = tmp
            }
            if self.systemPriority != nil {
                map["SystemPriority"] = self.systemPriority!
            }
            if self.tasks != nil {
                var tmp : [Any] = []
                for k in self.tasks! {
                    tmp.append(k.toMap())
                }
                map["Tasks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualTime") {
                self.actualTime = dict["ActualTime"] as! Int64
            }
            if dict.keys.contains("CalledNumber") {
                self.calledNumber = dict["CalledNumber"] as! String
            }
            if dict.keys.contains("CallingNumbers") {
                self.callingNumbers = dict["CallingNumbers"] as! [String]
            }
            if dict.keys.contains("Contacts") {
                self.contacts = dict["Contacts"] as! [DescribeJobResponseBody.Job.Contacts]
            }
            if dict.keys.contains("DsReport") {
                self.dsReport = dict["DsReport"] as! String
            }
            if dict.keys.contains("EndReason") {
                self.endReason = dict["EndReason"] as! Int32
            }
            if dict.keys.contains("Extras") {
                self.extras = dict["Extras"] as! [DescribeJobResponseBody.Job.Extras]
            }
            if dict.keys.contains("FailureReason") {
                self.failureReason = dict["FailureReason"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobGroupId") {
                self.jobGroupId = dict["JobGroupId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("NextExecutionTime") {
                self.nextExecutionTime = dict["NextExecutionTime"] as! Int64
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("ReferenceId") {
                self.referenceId = dict["ReferenceId"] as! String
            }
            if dict.keys.contains("ScenarioId") {
                self.scenarioId = dict["ScenarioId"] as! String
            }
            if dict.keys.contains("Script") {
                var model = DescribeJobResponseBody.Job.Script()
                model.fromMap(dict["Script"] as! [String: Any])
                self.script = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StrategyId") {
                self.strategyId = dict["StrategyId"] as! String
            }
            if dict.keys.contains("Summary") {
                self.summary = dict["Summary"] as! [DescribeJobResponseBody.Job.Summary]
            }
            if dict.keys.contains("SystemPriority") {
                self.systemPriority = dict["SystemPriority"] as! Int32
            }
            if dict.keys.contains("Tasks") {
                self.tasks = dict["Tasks"] as! [DescribeJobResponseBody.Job.Tasks]
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var job: DescribeJobResponseBody.Job?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.job?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.job != nil {
            map["Job"] = self.job?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Job") {
            var model = DescribeJobResponseBody.Job()
            model.fromMap(dict["Job"] as! [String: Any])
            self.job = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeJobDataParsingTaskProgressRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobDataParsingTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobDataParsingTaskId != nil {
            map["JobDataParsingTaskId"] = self.jobDataParsingTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobDataParsingTaskId") {
            self.jobDataParsingTaskId = dict["JobDataParsingTaskId"] as! String
        }
    }
}

public class DescribeJobDataParsingTaskProgressResponseBody : Tea.TeaModel {
    public class Progress : Tea.TeaModel {
        public var failErrorCode: String?

        public var failReason: String?

        public var feedbackUrl: String?

        public var handledJobCount: Int32?

        public var status: String?

        public var totalJobCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failErrorCode != nil {
                map["FailErrorCode"] = self.failErrorCode!
            }
            if self.failReason != nil {
                map["FailReason"] = self.failReason!
            }
            if self.feedbackUrl != nil {
                map["FeedbackUrl"] = self.feedbackUrl!
            }
            if self.handledJobCount != nil {
                map["HandledJobCount"] = self.handledJobCount!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalJobCount != nil {
                map["TotalJobCount"] = self.totalJobCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailErrorCode") {
                self.failErrorCode = dict["FailErrorCode"] as! String
            }
            if dict.keys.contains("FailReason") {
                self.failReason = dict["FailReason"] as! String
            }
            if dict.keys.contains("FeedbackUrl") {
                self.feedbackUrl = dict["FeedbackUrl"] as! String
            }
            if dict.keys.contains("HandledJobCount") {
                self.handledJobCount = dict["HandledJobCount"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TotalJobCount") {
                self.totalJobCount = dict["TotalJobCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var progress: DescribeJobDataParsingTaskProgressResponseBody.Progress?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.progress?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.progress != nil {
            map["Progress"] = self.progress?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Progress") {
            var model = DescribeJobDataParsingTaskProgressResponseBody.Progress()
            model.fromMap(dict["Progress"] as! [String: Any])
            self.progress = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeJobDataParsingTaskProgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobDataParsingTaskProgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeJobDataParsingTaskProgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeJobGroupRequest : Tea.TeaModel {
    public var briefTypes: [String]?

    public var instanceId: String?

    public var jobGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.briefTypes != nil {
            map["BriefTypes"] = self.briefTypes!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BriefTypes") {
            self.briefTypes = dict["BriefTypes"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
    }
}

public class DescribeJobGroupResponseBody : Tea.TeaModel {
    public class JobGroup : Tea.TeaModel {
        public class ExportProgress : Tea.TeaModel {
            public var fileHttpUrl: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileHttpUrl != nil {
                    map["FileHttpUrl"] = self.fileHttpUrl!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileHttpUrl") {
                    self.fileHttpUrl = dict["FileHttpUrl"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Progress : Tea.TeaModel {
            public class Briefs : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Categories : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var briefs: [DescribeJobGroupResponseBody.JobGroup.Progress.Briefs]?

            public var cancelled: Int32?

            public var categories: [DescribeJobGroupResponseBody.JobGroup.Progress.Categories]?

            public var duration: Int32?

            public var executing: Int32?

            public var failed: Int32?

            public var paused: Int32?

            public var scheduling: Int32?

            public var startTime: Int64?

            public var status: String?

            public var totalCompleted: Int32?

            public var totalJobs: Int32?

            public var totalNotAnswered: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.briefs != nil {
                    var tmp : [Any] = []
                    for k in self.briefs! {
                        tmp.append(k.toMap())
                    }
                    map["Briefs"] = tmp
                }
                if self.cancelled != nil {
                    map["Cancelled"] = self.cancelled!
                }
                if self.categories != nil {
                    var tmp : [Any] = []
                    for k in self.categories! {
                        tmp.append(k.toMap())
                    }
                    map["Categories"] = tmp
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.executing != nil {
                    map["Executing"] = self.executing!
                }
                if self.failed != nil {
                    map["Failed"] = self.failed!
                }
                if self.paused != nil {
                    map["Paused"] = self.paused!
                }
                if self.scheduling != nil {
                    map["Scheduling"] = self.scheduling!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.totalCompleted != nil {
                    map["TotalCompleted"] = self.totalCompleted!
                }
                if self.totalJobs != nil {
                    map["TotalJobs"] = self.totalJobs!
                }
                if self.totalNotAnswered != nil {
                    map["TotalNotAnswered"] = self.totalNotAnswered!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Briefs") {
                    self.briefs = dict["Briefs"] as! [DescribeJobGroupResponseBody.JobGroup.Progress.Briefs]
                }
                if dict.keys.contains("Cancelled") {
                    self.cancelled = dict["Cancelled"] as! Int32
                }
                if dict.keys.contains("Categories") {
                    self.categories = dict["Categories"] as! [DescribeJobGroupResponseBody.JobGroup.Progress.Categories]
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("Executing") {
                    self.executing = dict["Executing"] as! Int32
                }
                if dict.keys.contains("Failed") {
                    self.failed = dict["Failed"] as! Int32
                }
                if dict.keys.contains("Paused") {
                    self.paused = dict["Paused"] as! Int32
                }
                if dict.keys.contains("Scheduling") {
                    self.scheduling = dict["Scheduling"] as! Int32
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TotalCompleted") {
                    self.totalCompleted = dict["TotalCompleted"] as! Int32
                }
                if dict.keys.contains("TotalJobs") {
                    self.totalJobs = dict["TotalJobs"] as! Int32
                }
                if dict.keys.contains("TotalNotAnswered") {
                    self.totalNotAnswered = dict["TotalNotAnswered"] as! Int32
                }
            }
        }
        public class RecallStrategy : Tea.TeaModel {
            public var emptyNumberIgnore: Bool?

            public var inArrearsIgnore: Bool?

            public var outOfServiceIgnore: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.emptyNumberIgnore != nil {
                    map["EmptyNumberIgnore"] = self.emptyNumberIgnore!
                }
                if self.inArrearsIgnore != nil {
                    map["InArrearsIgnore"] = self.inArrearsIgnore!
                }
                if self.outOfServiceIgnore != nil {
                    map["OutOfServiceIgnore"] = self.outOfServiceIgnore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EmptyNumberIgnore") {
                    self.emptyNumberIgnore = dict["EmptyNumberIgnore"] as! Bool
                }
                if dict.keys.contains("InArrearsIgnore") {
                    self.inArrearsIgnore = dict["InArrearsIgnore"] as! Bool
                }
                if dict.keys.contains("OutOfServiceIgnore") {
                    self.outOfServiceIgnore = dict["OutOfServiceIgnore"] as! Bool
                }
            }
        }
        public class Result : Tea.TeaModel {
            public var clientHangupNum: Int32?

            public var finishedNum: Int32?

            public var noInteractNum: Int32?

            public var timeoutHangupNum: Int32?

            public var unrecognizedNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clientHangupNum != nil {
                    map["ClientHangupNum"] = self.clientHangupNum!
                }
                if self.finishedNum != nil {
                    map["FinishedNum"] = self.finishedNum!
                }
                if self.noInteractNum != nil {
                    map["NoInteractNum"] = self.noInteractNum!
                }
                if self.timeoutHangupNum != nil {
                    map["TimeoutHangupNum"] = self.timeoutHangupNum!
                }
                if self.unrecognizedNum != nil {
                    map["UnrecognizedNum"] = self.unrecognizedNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClientHangupNum") {
                    self.clientHangupNum = dict["ClientHangupNum"] as! Int32
                }
                if dict.keys.contains("FinishedNum") {
                    self.finishedNum = dict["FinishedNum"] as! Int32
                }
                if dict.keys.contains("NoInteractNum") {
                    self.noInteractNum = dict["NoInteractNum"] as! Int32
                }
                if dict.keys.contains("TimeoutHangupNum") {
                    self.timeoutHangupNum = dict["TimeoutHangupNum"] as! Int32
                }
                if dict.keys.contains("UnrecognizedNum") {
                    self.unrecognizedNum = dict["UnrecognizedNum"] as! Int32
                }
            }
        }
        public class Strategy : Tea.TeaModel {
            public class WorkingTime : Tea.TeaModel {
                public var beginTime: String?

                public var endTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.beginTime != nil {
                        map["BeginTime"] = self.beginTime!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BeginTime") {
                        self.beginTime = dict["BeginTime"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                }
            }
            public var customized: String?

            public var endTime: Int64?

            public var followUpStrategy: String?

            public var isTemplate: Bool?

            public var maxAttemptsPerDay: Int32?

            public var minAttemptInterval: Int32?

            public var repeatBy: String?

            public var repeatDays: [String]?

            public var routingStrategy: String?

            public var startTime: Int64?

            public var strategyDescription: String?

            public var strategyId: String?

            public var strategyName: String?

            public var type: String?

            public var workingTime: [DescribeJobGroupResponseBody.JobGroup.Strategy.WorkingTime]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customized != nil {
                    map["Customized"] = self.customized!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.followUpStrategy != nil {
                    map["FollowUpStrategy"] = self.followUpStrategy!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.maxAttemptsPerDay != nil {
                    map["MaxAttemptsPerDay"] = self.maxAttemptsPerDay!
                }
                if self.minAttemptInterval != nil {
                    map["MinAttemptInterval"] = self.minAttemptInterval!
                }
                if self.repeatBy != nil {
                    map["RepeatBy"] = self.repeatBy!
                }
                if self.repeatDays != nil {
                    map["RepeatDays"] = self.repeatDays!
                }
                if self.routingStrategy != nil {
                    map["RoutingStrategy"] = self.routingStrategy!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.strategyDescription != nil {
                    map["StrategyDescription"] = self.strategyDescription!
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workingTime != nil {
                    var tmp : [Any] = []
                    for k in self.workingTime! {
                        tmp.append(k.toMap())
                    }
                    map["WorkingTime"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Customized") {
                    self.customized = dict["Customized"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("FollowUpStrategy") {
                    self.followUpStrategy = dict["FollowUpStrategy"] as! String
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("MaxAttemptsPerDay") {
                    self.maxAttemptsPerDay = dict["MaxAttemptsPerDay"] as! Int32
                }
                if dict.keys.contains("MinAttemptInterval") {
                    self.minAttemptInterval = dict["MinAttemptInterval"] as! Int32
                }
                if dict.keys.contains("RepeatBy") {
                    self.repeatBy = dict["RepeatBy"] as! String
                }
                if dict.keys.contains("RepeatDays") {
                    self.repeatDays = dict["RepeatDays"] as! [String]
                }
                if dict.keys.contains("RoutingStrategy") {
                    self.routingStrategy = dict["RoutingStrategy"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("StrategyDescription") {
                    self.strategyDescription = dict["StrategyDescription"] as! String
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("StrategyName") {
                    self.strategyName = dict["StrategyName"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkingTime") {
                    self.workingTime = dict["WorkingTime"] as! [DescribeJobGroupResponseBody.JobGroup.Strategy.WorkingTime]
                }
            }
        }
        public var callingNumbers: [String]?

        public var creationTime: Int64?

        public var exportProgress: DescribeJobGroupResponseBody.JobGroup.ExportProgress?

        public var jobDataParsingTaskId: String?

        public var jobFilePath: String?

        public var jobGroupDescription: String?

        public var jobGroupId: String?

        public var jobGroupName: String?

        public var minConcurrency: Int64?

        public var modifyTime: String?

        public var priority: String?

        public var progress: DescribeJobGroupResponseBody.JobGroup.Progress?

        public var recallStrategy: DescribeJobGroupResponseBody.JobGroup.RecallStrategy?

        public var result: DescribeJobGroupResponseBody.JobGroup.Result?

        public var ringingDuration: Int64?

        public var scenarioId: String?

        public var scriptId: String?

        public var scriptName: String?

        public var scriptVersion: String?

        public var status: String?

        public var strategy: DescribeJobGroupResponseBody.JobGroup.Strategy?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.exportProgress?.validate()
            try self.progress?.validate()
            try self.recallStrategy?.validate()
            try self.result?.validate()
            try self.strategy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callingNumbers != nil {
                map["CallingNumbers"] = self.callingNumbers!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.exportProgress != nil {
                map["ExportProgress"] = self.exportProgress?.toMap()
            }
            if self.jobDataParsingTaskId != nil {
                map["JobDataParsingTaskId"] = self.jobDataParsingTaskId!
            }
            if self.jobFilePath != nil {
                map["JobFilePath"] = self.jobFilePath!
            }
            if self.jobGroupDescription != nil {
                map["JobGroupDescription"] = self.jobGroupDescription!
            }
            if self.jobGroupId != nil {
                map["JobGroupId"] = self.jobGroupId!
            }
            if self.jobGroupName != nil {
                map["JobGroupName"] = self.jobGroupName!
            }
            if self.minConcurrency != nil {
                map["MinConcurrency"] = self.minConcurrency!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.progress != nil {
                map["Progress"] = self.progress?.toMap()
            }
            if self.recallStrategy != nil {
                map["RecallStrategy"] = self.recallStrategy?.toMap()
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.ringingDuration != nil {
                map["RingingDuration"] = self.ringingDuration!
            }
            if self.scenarioId != nil {
                map["ScenarioId"] = self.scenarioId!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.scriptVersion != nil {
                map["ScriptVersion"] = self.scriptVersion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallingNumbers") {
                self.callingNumbers = dict["CallingNumbers"] as! [String]
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("ExportProgress") {
                var model = DescribeJobGroupResponseBody.JobGroup.ExportProgress()
                model.fromMap(dict["ExportProgress"] as! [String: Any])
                self.exportProgress = model
            }
            if dict.keys.contains("JobDataParsingTaskId") {
                self.jobDataParsingTaskId = dict["JobDataParsingTaskId"] as! String
            }
            if dict.keys.contains("JobFilePath") {
                self.jobFilePath = dict["JobFilePath"] as! String
            }
            if dict.keys.contains("JobGroupDescription") {
                self.jobGroupDescription = dict["JobGroupDescription"] as! String
            }
            if dict.keys.contains("JobGroupId") {
                self.jobGroupId = dict["JobGroupId"] as! String
            }
            if dict.keys.contains("JobGroupName") {
                self.jobGroupName = dict["JobGroupName"] as! String
            }
            if dict.keys.contains("MinConcurrency") {
                self.minConcurrency = dict["MinConcurrency"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("Progress") {
                var model = DescribeJobGroupResponseBody.JobGroup.Progress()
                model.fromMap(dict["Progress"] as! [String: Any])
                self.progress = model
            }
            if dict.keys.contains("RecallStrategy") {
                var model = DescribeJobGroupResponseBody.JobGroup.RecallStrategy()
                model.fromMap(dict["RecallStrategy"] as! [String: Any])
                self.recallStrategy = model
            }
            if dict.keys.contains("Result") {
                var model = DescribeJobGroupResponseBody.JobGroup.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("RingingDuration") {
                self.ringingDuration = dict["RingingDuration"] as! Int64
            }
            if dict.keys.contains("ScenarioId") {
                self.scenarioId = dict["ScenarioId"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("ScriptVersion") {
                self.scriptVersion = dict["ScriptVersion"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Strategy") {
                var model = DescribeJobGroupResponseBody.JobGroup.Strategy()
                model.fromMap(dict["Strategy"] as! [String: Any])
                self.strategy = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobGroup: DescribeJobGroupResponseBody.JobGroup?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobGroup != nil {
            map["JobGroup"] = self.jobGroup?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobGroup") {
            var model = DescribeJobGroupResponseBody.JobGroup()
            model.fromMap(dict["JobGroup"] as! [String: Any])
            self.jobGroup = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeJobGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeJobGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeJobGroupExportTaskProgressRequest : Tea.TeaModel {
    public var instanceId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeJobGroupExportTaskProgressResponseBody : Tea.TeaModel {
    public var code: String?

    public var fileHttpUrl: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var progress: Double?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.fileHttpUrl != nil {
            map["FileHttpUrl"] = self.fileHttpUrl!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.progress != nil {
            map["Progress"] = self.progress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FileHttpUrl") {
            self.fileHttpUrl = dict["FileHttpUrl"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Progress") {
            self.progress = dict["Progress"] as! Double
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeJobGroupExportTaskProgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobGroupExportTaskProgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeJobGroupExportTaskProgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNumberDistrictInfoStatusResponseBody : Tea.TeaModel {
    public class AppliedVersion : Tea.TeaModel {
        public var fileName: String?

        public var fileSize: Int64?

        public var versionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.versionId != nil {
                map["VersionId"] = self.versionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("VersionId") {
                self.versionId = dict["VersionId"] as! String
            }
        }
    }
    public class ParsingVersion : Tea.TeaModel {
        public var fileName: String?

        public var fileSize: Int64?

        public var parseProgress: Int64?

        public var versionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.parseProgress != nil {
                map["ParseProgress"] = self.parseProgress!
            }
            if self.versionId != nil {
                map["VersionId"] = self.versionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileSize") {
                self.fileSize = dict["FileSize"] as! Int64
            }
            if dict.keys.contains("ParseProgress") {
                self.parseProgress = dict["ParseProgress"] as! Int64
            }
            if dict.keys.contains("VersionId") {
                self.versionId = dict["VersionId"] as! String
            }
        }
    }
    public var appliedVersion: DescribeNumberDistrictInfoStatusResponseBody.AppliedVersion?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var parsingVersion: DescribeNumberDistrictInfoStatusResponseBody.ParsingVersion?

    public var requestId: String?

    public var status: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appliedVersion?.validate()
        try self.parsingVersion?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appliedVersion != nil {
            map["AppliedVersion"] = self.appliedVersion?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.parsingVersion != nil {
            map["ParsingVersion"] = self.parsingVersion?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppliedVersion") {
            var model = DescribeNumberDistrictInfoStatusResponseBody.AppliedVersion()
            model.fromMap(dict["AppliedVersion"] as! [String: Any])
            self.appliedVersion = model
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("ParsingVersion") {
            var model = DescribeNumberDistrictInfoStatusResponseBody.ParsingVersion()
            model.fromMap(dict["ParsingVersion"] as! [String: Any])
            self.parsingVersion = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeNumberDistrictInfoStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNumberDistrictInfoStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNumberDistrictInfoStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScriptRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class DescribeScriptResponseBody : Tea.TeaModel {
    public class Script : Tea.TeaModel {
        public var asrConfig: String?

        public var chatbotId: String?

        public var debugStatus: String?

        public var emotionEnable: Bool?

        public var industry: String?

        public var isDebugDrafted: Bool?

        public var isDrafted: Bool?

        public var longWaitEnable: Bool?

        public var miniPlaybackEnable: Bool?

        public var newBargeInEnable: Bool?

        public var scene: String?

        public var scriptDescription: String?

        public var scriptId: String?

        public var scriptName: String?

        public var status: String?

        public var ttsConfig: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asrConfig != nil {
                map["AsrConfig"] = self.asrConfig!
            }
            if self.chatbotId != nil {
                map["ChatbotId"] = self.chatbotId!
            }
            if self.debugStatus != nil {
                map["DebugStatus"] = self.debugStatus!
            }
            if self.emotionEnable != nil {
                map["EmotionEnable"] = self.emotionEnable!
            }
            if self.industry != nil {
                map["Industry"] = self.industry!
            }
            if self.isDebugDrafted != nil {
                map["IsDebugDrafted"] = self.isDebugDrafted!
            }
            if self.isDrafted != nil {
                map["IsDrafted"] = self.isDrafted!
            }
            if self.longWaitEnable != nil {
                map["LongWaitEnable"] = self.longWaitEnable!
            }
            if self.miniPlaybackEnable != nil {
                map["MiniPlaybackEnable"] = self.miniPlaybackEnable!
            }
            if self.newBargeInEnable != nil {
                map["NewBargeInEnable"] = self.newBargeInEnable!
            }
            if self.scene != nil {
                map["Scene"] = self.scene!
            }
            if self.scriptDescription != nil {
                map["ScriptDescription"] = self.scriptDescription!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.ttsConfig != nil {
                map["TtsConfig"] = self.ttsConfig!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsrConfig") {
                self.asrConfig = dict["AsrConfig"] as! String
            }
            if dict.keys.contains("ChatbotId") {
                self.chatbotId = dict["ChatbotId"] as! String
            }
            if dict.keys.contains("DebugStatus") {
                self.debugStatus = dict["DebugStatus"] as! String
            }
            if dict.keys.contains("EmotionEnable") {
                self.emotionEnable = dict["EmotionEnable"] as! Bool
            }
            if dict.keys.contains("Industry") {
                self.industry = dict["Industry"] as! String
            }
            if dict.keys.contains("IsDebugDrafted") {
                self.isDebugDrafted = dict["IsDebugDrafted"] as! Bool
            }
            if dict.keys.contains("IsDrafted") {
                self.isDrafted = dict["IsDrafted"] as! Bool
            }
            if dict.keys.contains("LongWaitEnable") {
                self.longWaitEnable = dict["LongWaitEnable"] as! Bool
            }
            if dict.keys.contains("MiniPlaybackEnable") {
                self.miniPlaybackEnable = dict["MiniPlaybackEnable"] as! Bool
            }
            if dict.keys.contains("NewBargeInEnable") {
                self.newBargeInEnable = dict["NewBargeInEnable"] as! Bool
            }
            if dict.keys.contains("Scene") {
                self.scene = dict["Scene"] as! String
            }
            if dict.keys.contains("ScriptDescription") {
                self.scriptDescription = dict["ScriptDescription"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TtsConfig") {
                self.ttsConfig = dict["TtsConfig"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var nlsConfig: String?

    public var requestId: String?

    public var script: DescribeScriptResponseBody.Script?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.script?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nlsConfig != nil {
            map["NlsConfig"] = self.nlsConfig!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.script != nil {
            map["Script"] = self.script?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NlsConfig") {
            self.nlsConfig = dict["NlsConfig"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Script") {
            var model = DescribeScriptResponseBody.Script()
            model.fromMap(dict["Script"] as! [String: Any])
            self.script = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScriptVoiceConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public var scriptVoiceConfigId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.scriptVoiceConfigId != nil {
            map["ScriptVoiceConfigId"] = self.scriptVoiceConfigId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("ScriptVoiceConfigId") {
            self.scriptVoiceConfigId = dict["ScriptVoiceConfigId"] as! String
        }
    }
}

public class DescribeScriptVoiceConfigResponseBody : Tea.TeaModel {
    public class ScriptVoiceConfig : Tea.TeaModel {
        public var instanceId: String?

        public var scriptContent: String?

        public var scriptId: String?

        public var scriptVoiceConfigId: String?

        public var scriptWaveformRelation: String?

        public var source: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.scriptContent != nil {
                map["ScriptContent"] = self.scriptContent!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptVoiceConfigId != nil {
                map["ScriptVoiceConfigId"] = self.scriptVoiceConfigId!
            }
            if self.scriptWaveformRelation != nil {
                map["ScriptWaveformRelation"] = self.scriptWaveformRelation!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("ScriptContent") {
                self.scriptContent = dict["ScriptContent"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptVoiceConfigId") {
                self.scriptVoiceConfigId = dict["ScriptVoiceConfigId"] as! String
            }
            if dict.keys.contains("ScriptWaveformRelation") {
                self.scriptWaveformRelation = dict["ScriptWaveformRelation"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scriptVoiceConfig: DescribeScriptVoiceConfigResponseBody.ScriptVoiceConfig?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scriptVoiceConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptVoiceConfig != nil {
            map["ScriptVoiceConfig"] = self.scriptVoiceConfig?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptVoiceConfig") {
            var model = DescribeScriptVoiceConfigResponseBody.ScriptVoiceConfig()
            model.fromMap(dict["ScriptVoiceConfig"] as! [String: Any])
            self.scriptVoiceConfig = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeScriptVoiceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScriptVoiceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScriptVoiceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTTSConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class DescribeTTSConfigResponseBody : Tea.TeaModel {
    public class TTSConfig : Tea.TeaModel {
        public var appKey: String?

        public var instanceId: String?

        public var nlsServiceType: String?

        public var speechRate: String?

        public var voice: String?

        public var volume: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appKey != nil {
                map["AppKey"] = self.appKey!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.nlsServiceType != nil {
                map["NlsServiceType"] = self.nlsServiceType!
            }
            if self.speechRate != nil {
                map["SpeechRate"] = self.speechRate!
            }
            if self.voice != nil {
                map["Voice"] = self.voice!
            }
            if self.volume != nil {
                map["Volume"] = self.volume!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppKey") {
                self.appKey = dict["AppKey"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("NlsServiceType") {
                self.nlsServiceType = dict["NlsServiceType"] as! String
            }
            if dict.keys.contains("SpeechRate") {
                self.speechRate = dict["SpeechRate"] as! String
            }
            if dict.keys.contains("Voice") {
                self.voice = dict["Voice"] as! String
            }
            if dict.keys.contains("Volume") {
                self.volume = dict["Volume"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var TTSConfig: DescribeTTSConfigResponseBody.TTSConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.TTSConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.TTSConfig != nil {
            map["TTSConfig"] = self.TTSConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TTSConfig") {
            var model = DescribeTTSConfigResponseBody.TTSConfig()
            model.fromMap(dict["TTSConfig"] as! [String: Any])
            self.TTSConfig = model
        }
    }
}

public class DescribeTTSConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTTSConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTTSConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTTSDemoRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pitchRate: Int32?

    public var scriptId: String?

    public var speechRate: Int32?

    public var text: String?

    public var voice: String?

    public var volume: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pitchRate != nil {
            map["PitchRate"] = self.pitchRate!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.speechRate != nil {
            map["SpeechRate"] = self.speechRate!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        if self.voice != nil {
            map["Voice"] = self.voice!
        }
        if self.volume != nil {
            map["Volume"] = self.volume!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PitchRate") {
            self.pitchRate = dict["PitchRate"] as! Int32
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("SpeechRate") {
            self.speechRate = dict["SpeechRate"] as! Int32
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
        if dict.keys.contains("Voice") {
            self.voice = dict["Voice"] as! String
        }
        if dict.keys.contains("Volume") {
            self.volume = dict["Volume"] as! Int32
        }
    }
}

public class DescribeTTSDemoResponseBody : Tea.TeaModel {
    public var auditionUrl: String?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auditionUrl != nil {
            map["AuditionUrl"] = self.auditionUrl!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuditionUrl") {
            self.auditionUrl = dict["AuditionUrl"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeTTSDemoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTTSDemoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTTSDemoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagHitsSummaryRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
    }
}

public class DescribeTagHitsSummaryResponseBody : Tea.TeaModel {
    public class TagGroups : Tea.TeaModel {
        public var id: String?

        public var scriptId: String?

        public var tagGroup: String?

        public var tagGroupIndex: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.tagGroup != nil {
                map["TagGroup"] = self.tagGroup!
            }
            if self.tagGroupIndex != nil {
                map["TagGroupIndex"] = self.tagGroupIndex!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("TagGroup") {
                self.tagGroup = dict["TagGroup"] as! String
            }
            if dict.keys.contains("TagGroupIndex") {
                self.tagGroupIndex = dict["TagGroupIndex"] as! Int32
            }
        }
    }
    public class TagHitsList : Tea.TeaModel {
        public var hitCount: Int32?

        public var tagGroup: String?

        public var tagName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hitCount != nil {
                map["HitCount"] = self.hitCount!
            }
            if self.tagGroup != nil {
                map["TagGroup"] = self.tagGroup!
            }
            if self.tagName != nil {
                map["TagName"] = self.tagName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HitCount") {
                self.hitCount = dict["HitCount"] as! Int32
            }
            if dict.keys.contains("TagGroup") {
                self.tagGroup = dict["TagGroup"] as! String
            }
            if dict.keys.contains("TagName") {
                self.tagName = dict["TagName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var tagGroups: [DescribeTagHitsSummaryResponseBody.TagGroups]?

    public var tagHitsList: [DescribeTagHitsSummaryResponseBody.TagHitsList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagGroups != nil {
            var tmp : [Any] = []
            for k in self.tagGroups! {
                tmp.append(k.toMap())
            }
            map["TagGroups"] = tmp
        }
        if self.tagHitsList != nil {
            var tmp : [Any] = []
            for k in self.tagHitsList! {
                tmp.append(k.toMap())
            }
            map["TagHitsList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagGroups") {
            self.tagGroups = dict["TagGroups"] as! [DescribeTagHitsSummaryResponseBody.TagGroups]
        }
        if dict.keys.contains("TagHitsList") {
            self.tagHitsList = dict["TagHitsList"] as! [DescribeTagHitsSummaryResponseBody.TagHitsList]
        }
    }
}

public class DescribeTagHitsSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagHitsSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagHitsSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTenantBindNumberRequest : Tea.TeaModel {
    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
    }
}

public class DescribeTenantBindNumberResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var instanceId: String?

            public var instanceName: String?

            public var isBinding: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.isBinding != nil {
                    map["IsBinding"] = self.isBinding!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("IsBinding") {
                    self.isBinding = dict["IsBinding"] as! Bool
                }
            }
        }
        public var list: [DescribeTenantBindNumberResponseBody.Data.List]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [DescribeTenantBindNumberResponseBody.Data.List]
            }
        }
    }
    public var code: String?

    public var data: DescribeTenantBindNumberResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeTenantBindNumberResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeTenantBindNumberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTenantBindNumberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTenantBindNumberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DialogueRequest : Tea.TeaModel {
    public var actionKey: String?

    public var actionParams: String?

    public var callId: String?

    public var callType: String?

    public var calledNumber: String?

    public var callingNumber: String?

    public var instanceId: String?

    public var scenarioId: String?

    public var scriptId: String?

    public var taskId: String?

    public var utterance: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionKey != nil {
            map["ActionKey"] = self.actionKey!
        }
        if self.actionParams != nil {
            map["ActionParams"] = self.actionParams!
        }
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.callType != nil {
            map["CallType"] = self.callType!
        }
        if self.calledNumber != nil {
            map["CalledNumber"] = self.calledNumber!
        }
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.utterance != nil {
            map["Utterance"] = self.utterance!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionKey") {
            self.actionKey = dict["ActionKey"] as! String
        }
        if dict.keys.contains("ActionParams") {
            self.actionParams = dict["ActionParams"] as! String
        }
        if dict.keys.contains("CallId") {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("CallType") {
            self.callType = dict["CallType"] as! String
        }
        if dict.keys.contains("CalledNumber") {
            self.calledNumber = dict["CalledNumber"] as! String
        }
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("Utterance") {
            self.utterance = dict["Utterance"] as! String
        }
    }
}

public class DialogueResponseBody : Tea.TeaModel {
    public class Feedback : Tea.TeaModel {
        public var action: String?

        public var actionParams: String?

        public var content: String?

        public var contentParams: String?

        public var interruptible: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.actionParams != nil {
                map["ActionParams"] = self.actionParams!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentParams != nil {
                map["ContentParams"] = self.contentParams!
            }
            if self.interruptible != nil {
                map["Interruptible"] = self.interruptible!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ActionParams") {
                self.actionParams = dict["ActionParams"] as! String
            }
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentParams") {
                self.contentParams = dict["ContentParams"] as! String
            }
            if dict.keys.contains("Interruptible") {
                self.interruptible = dict["Interruptible"] as! Bool
            }
        }
    }
    public var code: String?

    public var feedback: DialogueResponseBody.Feedback?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.feedback?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.feedback != nil {
            map["Feedback"] = self.feedback?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Feedback") {
            var model = DialogueResponseBody.Feedback()
            model.fromMap(dict["Feedback"] as! [String: Any])
            self.feedback = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DialogueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DialogueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DialogueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DismissNumberDistrictInfoParsingResultRequest : Tea.TeaModel {
    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VersionId") {
            self.versionId = dict["VersionId"] as! String
        }
    }
}

public class DismissNumberDistrictInfoParsingResultResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DismissNumberDistrictInfoParsingResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DismissNumberDistrictInfoParsingResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DismissNumberDistrictInfoParsingResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadRecordingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var needVoiceSliceRecording: Bool?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.needVoiceSliceRecording != nil {
            map["NeedVoiceSliceRecording"] = self.needVoiceSliceRecording!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NeedVoiceSliceRecording") {
            self.needVoiceSliceRecording = dict["NeedVoiceSliceRecording"] as! Bool
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DownloadRecordingResponseBody : Tea.TeaModel {
    public class DownloadParams : Tea.TeaModel {
        public var fileName: String?

        public var signatureUrl: String?

        public var voiceSliceRecordingListJson: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.signatureUrl != nil {
                map["SignatureUrl"] = self.signatureUrl!
            }
            if self.voiceSliceRecordingListJson != nil {
                map["VoiceSliceRecordingListJson"] = self.voiceSliceRecordingListJson!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("SignatureUrl") {
                self.signatureUrl = dict["SignatureUrl"] as! String
            }
            if dict.keys.contains("VoiceSliceRecordingListJson") {
                self.voiceSliceRecordingListJson = dict["VoiceSliceRecordingListJson"] as! String
            }
        }
    }
    public var code: String?

    public var downloadParams: DownloadRecordingResponseBody.DownloadParams?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.downloadParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.downloadParams != nil {
            map["DownloadParams"] = self.downloadParams?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DownloadParams") {
            var model = DownloadRecordingResponseBody.DownloadParams()
            model.fromMap(dict["DownloadParams"] as! [String: Any])
            self.downloadParams = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DownloadRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadScriptRecordingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DownloadScriptRecordingResponseBody : Tea.TeaModel {
    public class DownloadParams : Tea.TeaModel {
        public var fileName: String?

        public var signatureUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.signatureUrl != nil {
                map["SignatureUrl"] = self.signatureUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("SignatureUrl") {
                self.signatureUrl = dict["SignatureUrl"] as! String
            }
        }
    }
    public var code: String?

    public var downloadParams: DownloadScriptRecordingResponseBody.DownloadParams?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.downloadParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.downloadParams != nil {
            map["DownloadParams"] = self.downloadParams?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DownloadParams") {
            var model = DownloadScriptRecordingResponseBody.DownloadParams()
            model.fromMap(dict["DownloadParams"] as! [String: Any])
            self.downloadParams = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DownloadScriptRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadScriptRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadScriptRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DuplicateScriptRequest : Tea.TeaModel {
    public var instanceId: String?

    public var name: String?

    public var sourceScriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.sourceScriptId != nil {
            map["SourceScriptId"] = self.sourceScriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SourceScriptId") {
            self.sourceScriptId = dict["SourceScriptId"] as! String
        }
    }
}

public class DuplicateScriptResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scriptId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DuplicateScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DuplicateScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DuplicateScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportScriptRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class ExportScriptResponseBody : Tea.TeaModel {
    public class DownloadParams : Tea.TeaModel {
        public var signatureUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.signatureUrl != nil {
                map["SignatureUrl"] = self.signatureUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SignatureUrl") {
                self.signatureUrl = dict["SignatureUrl"] as! String
            }
        }
    }
    public var code: String?

    public var downloadParams: ExportScriptResponseBody.DownloadParams?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.downloadParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.downloadParams != nil {
            map["DownloadParams"] = self.downloadParams?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DownloadParams") {
            var model = ExportScriptResponseBody.DownloadParams()
            model.fromMap(dict["DownloadParams"] as! [String: Any])
            self.downloadParams = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExportScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateUploadUrlRequest : Tea.TeaModel {
    public var fileName: String?

    public var key: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
    }
}

public class GenerateUploadUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accessId: String?

        public var expire: Int32?

        public var folder: String?

        public var host: String?

        public var message: String?

        public var policy: String?

        public var signature: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessId != nil {
                map["AccessId"] = self.accessId!
            }
            if self.expire != nil {
                map["Expire"] = self.expire!
            }
            if self.folder != nil {
                map["Folder"] = self.folder!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessId") {
                self.accessId = dict["AccessId"] as! String
            }
            if dict.keys.contains("Expire") {
                self.expire = dict["Expire"] as! Int32
            }
            if dict.keys.contains("Folder") {
                self.folder = dict["Folder"] as! String
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Signature") {
                self.signature = dict["Signature"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: String?

    public var data: GenerateUploadUrlResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GenerateUploadUrlResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GenerateUploadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateUploadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GenerateUploadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAfterAnswerDelayPlaybackRequest : Tea.TeaModel {
    public var entryId: String?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class GetAfterAnswerDelayPlaybackResponseBody : Tea.TeaModel {
    public var afterAnswerDelayPlayback: Int32?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.afterAnswerDelayPlayback != nil {
            map["AfterAnswerDelayPlayback"] = self.afterAnswerDelayPlayback!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AfterAnswerDelayPlayback") {
            self.afterAnswerDelayPlayback = dict["AfterAnswerDelayPlayback"] as! Int32
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAfterAnswerDelayPlaybackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAfterAnswerDelayPlaybackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAfterAnswerDelayPlaybackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAsrServerInfoRequest : Tea.TeaModel {
    public var entryId: String?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class GetAsrServerInfoResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAsrServerInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAsrServerInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAsrServerInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBaseStrategyPeriodRequest : Tea.TeaModel {
    public var entryId: String?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class GetBaseStrategyPeriodResponseBody : Tea.TeaModel {
    public class WorkingTime : Tea.TeaModel {
        public var beginTime: String?

        public var beginTimeMillis: Int64?

        public var endTime: String?

        public var endTimeMillis: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beginTime != nil {
                map["BeginTime"] = self.beginTime!
            }
            if self.beginTimeMillis != nil {
                map["BeginTimeMillis"] = self.beginTimeMillis!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.endTimeMillis != nil {
                map["EndTimeMillis"] = self.endTimeMillis!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeginTime") {
                self.beginTime = dict["BeginTime"] as! String
            }
            if dict.keys.contains("BeginTimeMillis") {
                self.beginTimeMillis = dict["BeginTimeMillis"] as! Int64
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("EndTimeMillis") {
                self.endTimeMillis = dict["EndTimeMillis"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var onlyWeekdays: Bool?

    public var requestId: String?

    public var success: Bool?

    public var workingTime: [GetBaseStrategyPeriodResponseBody.WorkingTime]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.onlyWeekdays != nil {
            map["OnlyWeekdays"] = self.onlyWeekdays!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.workingTime != nil {
            var tmp : [Any] = []
            for k in self.workingTime! {
                tmp.append(k.toMap())
            }
            map["WorkingTime"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OnlyWeekdays") {
            self.onlyWeekdays = dict["OnlyWeekdays"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("WorkingTime") {
            self.workingTime = dict["WorkingTime"] as! [GetBaseStrategyPeriodResponseBody.WorkingTime]
        }
    }
}

public class GetBaseStrategyPeriodResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBaseStrategyPeriodResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBaseStrategyPeriodResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetConcurrentConversationQuotaResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var maxConcurrent: Int32?

    public var message: String?

    public var remainingConcurrent: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.maxConcurrent != nil {
            map["MaxConcurrent"] = self.maxConcurrent!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.remainingConcurrent != nil {
            map["RemainingConcurrent"] = self.remainingConcurrent!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("MaxConcurrent") {
            self.maxConcurrent = dict["MaxConcurrent"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RemainingConcurrent") {
            self.remainingConcurrent = dict["RemainingConcurrent"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetConcurrentConversationQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConcurrentConversationQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetConcurrentConversationQuotaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetContactBlockListRequest : Tea.TeaModel {
    public var countTotalRow: Bool?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.countTotalRow != nil {
            map["CountTotalRow"] = self.countTotalRow!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CountTotalRow") {
            self.countTotalRow = dict["CountTotalRow"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetContactBlockListResponseBody : Tea.TeaModel {
    public class ContactBlocklistList : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var contactBlockListId: String?

            public var creationTime: Int64?

            public var creator: String?

            public var instanceId: String?

            public var name: String?

            public var operator_: String?

            public var phoneNumber: String?

            public var remark: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactBlockListId != nil {
                    map["ContactBlockListId"] = self.contactBlockListId!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactBlockListId") {
                    self.contactBlockListId = dict["ContactBlockListId"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("PhoneNumber") {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
            }
        }
        public var list: [GetContactBlockListResponseBody.ContactBlocklistList.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [GetContactBlockListResponseBody.ContactBlocklistList.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var contactBlocklistList: GetContactBlockListResponseBody.ContactBlocklistList?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.contactBlocklistList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.contactBlocklistList != nil {
            map["ContactBlocklistList"] = self.contactBlocklistList?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ContactBlocklistList") {
            var model = GetContactBlockListResponseBody.ContactBlocklistList()
            model.fromMap(dict["ContactBlocklistList"] as! [String: Any])
            self.contactBlocklistList = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetContactBlockListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetContactBlockListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetContactBlockListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetContactWhiteListRequest : Tea.TeaModel {
    public var countTotalRow: Bool?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.countTotalRow != nil {
            map["CountTotalRow"] = self.countTotalRow!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CountTotalRow") {
            self.countTotalRow = dict["CountTotalRow"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetContactWhiteListResponseBody : Tea.TeaModel {
    public class ContactWhitelistList : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var contactWhiteListId: String?

            public var creationTime: Int64?

            public var creator: String?

            public var instanceId: String?

            public var name: String?

            public var operator_: String?

            public var phoneNumber: String?

            public var remark: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactWhiteListId != nil {
                    map["ContactWhiteListId"] = self.contactWhiteListId!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactWhiteListId") {
                    self.contactWhiteListId = dict["ContactWhiteListId"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("PhoneNumber") {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
            }
        }
        public var list: [GetContactWhiteListResponseBody.ContactWhitelistList.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [GetContactWhiteListResponseBody.ContactWhitelistList.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var contactWhitelistList: GetContactWhiteListResponseBody.ContactWhitelistList?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.contactWhitelistList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.contactWhitelistList != nil {
            map["ContactWhitelistList"] = self.contactWhitelistList?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ContactWhitelistList") {
            var model = GetContactWhiteListResponseBody.ContactWhitelistList()
            model.fromMap(dict["ContactWhitelistList"] as! [String: Any])
            self.contactWhitelistList = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetContactWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetContactWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetContactWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCurrentConcurrencyRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetCurrentConcurrencyResponseBody : Tea.TeaModel {
    public var code: String?

    public var currentConcurrency: Int32?

    public var httpStatusCode: Int32?

    public var instanceId: String?

    public var maxConcurrentConversation: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.currentConcurrency != nil {
            map["CurrentConcurrency"] = self.currentConcurrency!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxConcurrentConversation != nil {
            map["MaxConcurrentConversation"] = self.maxConcurrentConversation!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CurrentConcurrency") {
            self.currentConcurrency = dict["CurrentConcurrency"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaxConcurrentConversation") {
            self.maxConcurrentConversation = dict["MaxConcurrentConversation"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetCurrentConcurrencyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCurrentConcurrencyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCurrentConcurrencyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEffectiveDaysRequest : Tea.TeaModel {
    public var entryId: String?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class GetEffectiveDaysResponseBody : Tea.TeaModel {
    public var code: String?

    public var effectiveDays: Int32?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.effectiveDays != nil {
            map["EffectiveDays"] = self.effectiveDays!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("EffectiveDays") {
            self.effectiveDays = dict["EffectiveDays"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetEffectiveDaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEffectiveDaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEffectiveDaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEmptyNumberNoMoreCallsInfoRequest : Tea.TeaModel {
    public var entryId: String?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class GetEmptyNumberNoMoreCallsInfoResponseBody : Tea.TeaModel {
    public var code: String?

    public var emptyNumberNoMoreCalls: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.emptyNumberNoMoreCalls != nil {
            map["EmptyNumberNoMoreCalls"] = self.emptyNumberNoMoreCalls!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("EmptyNumberNoMoreCalls") {
            self.emptyNumberNoMoreCalls = dict["EmptyNumberNoMoreCalls"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetEmptyNumberNoMoreCallsInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEmptyNumberNoMoreCallsInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEmptyNumberNoMoreCallsInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMaxAttemptsPerDayRequest : Tea.TeaModel {
    public var entryId: String?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class GetMaxAttemptsPerDayResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var maxAttemptsPerDay: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.maxAttemptsPerDay != nil {
            map["MaxAttemptsPerDay"] = self.maxAttemptsPerDay!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("MaxAttemptsPerDay") {
            self.maxAttemptsPerDay = dict["MaxAttemptsPerDay"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMaxAttemptsPerDayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMaxAttemptsPerDayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMaxAttemptsPerDayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNumberDistrictInfoTemplateDownloadUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var fileHttpUrl: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.fileHttpUrl != nil {
            map["FileHttpUrl"] = self.fileHttpUrl!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("FileHttpUrl") {
            self.fileHttpUrl = dict["FileHttpUrl"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNumberDistrictInfoTemplateDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNumberDistrictInfoTemplateDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNumberDistrictInfoTemplateDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSummaryInfoRequest : Tea.TeaModel {
    public var instanceIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdList != nil {
            map["InstanceIdList"] = self.instanceIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIdList") {
            self.instanceIdList = dict["InstanceIdList"] as! [String]
        }
    }
}

public class GetSummaryInfoResponseBody : Tea.TeaModel {
    public class AgentBotInstanceSummaryList : Tea.TeaModel {
        public var instanceId: String?

        public var totalCallCount: Int64?

        public var totalCallTime: Int64?

        public var usedRecordingStorageSpace: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.totalCallCount != nil {
                map["TotalCallCount"] = self.totalCallCount!
            }
            if self.totalCallTime != nil {
                map["TotalCallTime"] = self.totalCallTime!
            }
            if self.usedRecordingStorageSpace != nil {
                map["UsedRecordingStorageSpace"] = self.usedRecordingStorageSpace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("TotalCallCount") {
                self.totalCallCount = dict["TotalCallCount"] as! Int64
            }
            if dict.keys.contains("TotalCallTime") {
                self.totalCallTime = dict["TotalCallTime"] as! Int64
            }
            if dict.keys.contains("UsedRecordingStorageSpace") {
                self.usedRecordingStorageSpace = dict["UsedRecordingStorageSpace"] as! Int32
            }
        }
    }
    public var agentBotInstanceSummaryList: [GetSummaryInfoResponseBody.AgentBotInstanceSummaryList]?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentBotInstanceSummaryList != nil {
            var tmp : [Any] = []
            for k in self.agentBotInstanceSummaryList! {
                tmp.append(k.toMap())
            }
            map["AgentBotInstanceSummaryList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentBotInstanceSummaryList") {
            self.agentBotInstanceSummaryList = dict["AgentBotInstanceSummaryList"] as! [GetSummaryInfoResponseBody.AgentBotInstanceSummaryList]
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetSummaryInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSummaryInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSummaryInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskByUuidRequest : Tea.TeaModel {
    public var instanceId: String?

    public var taskId: String?

    public var withConversations: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.withConversations != nil {
            map["WithConversations"] = self.withConversations!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("WithConversations") {
            self.withConversations = dict["WithConversations"] as! Bool
        }
    }
}

public class GetTaskByUuidResponseBody : Tea.TeaModel {
    public class Task : Tea.TeaModel {
        public var actualTime: Int64?

        public var callId: String?

        public var calledNumber: String?

        public var callingNumber: String?

        public var endReason: Int32?

        public var endTime: Int64?

        public var id: String?

        public var instanceId: String?

        public var jobGroupId: String?

        public var jobId: String?

        public var plannedTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualTime != nil {
                map["ActualTime"] = self.actualTime!
            }
            if self.callId != nil {
                map["CallId"] = self.callId!
            }
            if self.calledNumber != nil {
                map["CalledNumber"] = self.calledNumber!
            }
            if self.callingNumber != nil {
                map["CallingNumber"] = self.callingNumber!
            }
            if self.endReason != nil {
                map["EndReason"] = self.endReason!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobGroupId != nil {
                map["JobGroupId"] = self.jobGroupId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.plannedTime != nil {
                map["PlannedTime"] = self.plannedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualTime") {
                self.actualTime = dict["ActualTime"] as! Int64
            }
            if dict.keys.contains("CallId") {
                self.callId = dict["CallId"] as! String
            }
            if dict.keys.contains("CalledNumber") {
                self.calledNumber = dict["CalledNumber"] as! String
            }
            if dict.keys.contains("CallingNumber") {
                self.callingNumber = dict["CallingNumber"] as! String
            }
            if dict.keys.contains("EndReason") {
                self.endReason = dict["EndReason"] as! Int32
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobGroupId") {
                self.jobGroupId = dict["JobGroupId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("PlannedTime") {
                self.plannedTime = dict["PlannedTime"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var task: GetTaskByUuidResponseBody.Task?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.task?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.task != nil {
            map["Task"] = self.task?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Task") {
            var model = GetTaskByUuidResponseBody.Task()
            model.fromMap(dict["Task"] as! [String: Any])
            self.task = model
        }
    }
}

public class GetTaskByUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskByUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTaskByUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVersionResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Version") {
            self.version = dict["Version"] as! String
        }
    }
}

public class GetVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportScriptRequest : Tea.TeaModel {
    public var instanceId: String?

    public var signatureUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.signatureUrl != nil {
            map["SignatureUrl"] = self.signatureUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SignatureUrl") {
            self.signatureUrl = dict["SignatureUrl"] as! String
        }
    }
}

public class ImportScriptResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scriptId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ImportScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InflightTaskTimeoutRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceOwnerId: Int64?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceOwnerId != nil {
            map["InstanceOwnerId"] = self.instanceOwnerId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceOwnerId") {
            self.instanceOwnerId = dict["InstanceOwnerId"] as! Int64
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class InflightTaskTimeoutResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InflightTaskTimeoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InflightTaskTimeoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InflightTaskTimeoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllTenantBindNumberBindingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var billingType: String?

            public var bindingId: String?

            public var instanceNameList: [String]?

            public var number: String?

            public var serializedParams: String?

            public var trunkName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.billingType != nil {
                    map["BillingType"] = self.billingType!
                }
                if self.bindingId != nil {
                    map["BindingId"] = self.bindingId!
                }
                if self.instanceNameList != nil {
                    map["InstanceNameList"] = self.instanceNameList!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.serializedParams != nil {
                    map["SerializedParams"] = self.serializedParams!
                }
                if self.trunkName != nil {
                    map["TrunkName"] = self.trunkName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BillingType") {
                    self.billingType = dict["BillingType"] as! String
                }
                if dict.keys.contains("BindingId") {
                    self.bindingId = dict["BindingId"] as! String
                }
                if dict.keys.contains("InstanceNameList") {
                    self.instanceNameList = dict["InstanceNameList"] as! [String]
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("SerializedParams") {
                    self.serializedParams = dict["SerializedParams"] as! String
                }
                if dict.keys.contains("TrunkName") {
                    self.trunkName = dict["TrunkName"] as! String
                }
            }
        }
        public var list: [ListAllTenantBindNumberBindingResponseBody.Data.List]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListAllTenantBindNumberBindingResponseBody.Data.List]
            }
        }
    }
    public var code: String?

    public var data: ListAllTenantBindNumberBindingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListAllTenantBindNumberBindingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAllTenantBindNumberBindingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllTenantBindNumberBindingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAllTenantBindNumberBindingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListChatbotInstancesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListChatbotInstancesResponseBody : Tea.TeaModel {
    public class Bots : Tea.TeaModel {
        public var avatar: String?

        public var createTime: String?

        public var instanceId: String?

        public var introduction: String?

        public var languageCode: String?

        public var name: String?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatar != nil {
                map["Avatar"] = self.avatar!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.introduction != nil {
                map["Introduction"] = self.introduction!
            }
            if self.languageCode != nil {
                map["LanguageCode"] = self.languageCode!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Avatar") {
                self.avatar = dict["Avatar"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Introduction") {
                self.introduction = dict["Introduction"] as! String
            }
            if dict.keys.contains("LanguageCode") {
                self.languageCode = dict["LanguageCode"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public var bots: [ListChatbotInstancesResponseBody.Bots]?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bots != nil {
            var tmp : [Any] = []
            for k in self.bots! {
                tmp.append(k.toMap())
            }
            map["Bots"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bots") {
            self.bots = dict["Bots"] as! [ListChatbotInstancesResponseBody.Bots]
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListChatbotInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChatbotInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListChatbotInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDialogueFlowsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class ListDialogueFlowsResponseBody : Tea.TeaModel {
    public class DialogueFlows : Tea.TeaModel {
        public var dialogueFlowDefinition: String?

        public var dialogueFlowId: String?

        public var dialogueFlowName: String?

        public var dialogueFlowType: String?

        public var scriptId: String?

        public var scriptVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dialogueFlowDefinition != nil {
                map["DialogueFlowDefinition"] = self.dialogueFlowDefinition!
            }
            if self.dialogueFlowId != nil {
                map["DialogueFlowId"] = self.dialogueFlowId!
            }
            if self.dialogueFlowName != nil {
                map["DialogueFlowName"] = self.dialogueFlowName!
            }
            if self.dialogueFlowType != nil {
                map["DialogueFlowType"] = self.dialogueFlowType!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptVersion != nil {
                map["ScriptVersion"] = self.scriptVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DialogueFlowDefinition") {
                self.dialogueFlowDefinition = dict["DialogueFlowDefinition"] as! String
            }
            if dict.keys.contains("DialogueFlowId") {
                self.dialogueFlowId = dict["DialogueFlowId"] as! String
            }
            if dict.keys.contains("DialogueFlowName") {
                self.dialogueFlowName = dict["DialogueFlowName"] as! String
            }
            if dict.keys.contains("DialogueFlowType") {
                self.dialogueFlowType = dict["DialogueFlowType"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptVersion") {
                self.scriptVersion = dict["ScriptVersion"] as! String
            }
        }
    }
    public var code: String?

    public var dialogueFlows: [ListDialogueFlowsResponseBody.DialogueFlows]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dialogueFlows != nil {
            var tmp : [Any] = []
            for k in self.dialogueFlows! {
                tmp.append(k.toMap())
            }
            map["DialogueFlows"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DialogueFlows") {
            self.dialogueFlows = dict["DialogueFlows"] as! [ListDialogueFlowsResponseBody.DialogueFlows]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDialogueFlowsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDialogueFlowsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDialogueFlowsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDownloadTasksRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListDownloadTasksResponseBody : Tea.TeaModel {
    public class DownloadTasks : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class DownloadTaskFiles : Tea.TeaModel {
                public var fileId: String?

                public var progress: Int32?

                public var status: String?

                public var title: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fileId != nil {
                        map["FileId"] = self.fileId!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FileId") {
                        self.fileId = dict["FileId"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! Int32
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                }
            }
            public var downloadTaskFiles: [ListDownloadTasksResponseBody.DownloadTasks.List.DownloadTaskFiles]?

            public var expireTime: Int64?

            public var status: String?

            public var taskId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downloadTaskFiles != nil {
                    var tmp : [Any] = []
                    for k in self.downloadTaskFiles! {
                        tmp.append(k.toMap())
                    }
                    map["DownloadTaskFiles"] = tmp
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DownloadTaskFiles") {
                    self.downloadTaskFiles = dict["DownloadTaskFiles"] as! [ListDownloadTasksResponseBody.DownloadTasks.List.DownloadTaskFiles]
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var list: [ListDownloadTasksResponseBody.DownloadTasks.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListDownloadTasksResponseBody.DownloadTasks.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var downloadTasks: ListDownloadTasksResponseBody.DownloadTasks?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.downloadTasks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.downloadTasks != nil {
            map["DownloadTasks"] = self.downloadTasks?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DownloadTasks") {
            var model = ListDownloadTasksResponseBody.DownloadTasks()
            model.fromMap(dict["DownloadTasks"] as! [String: Any])
            self.downloadTasks = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListDownloadTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDownloadTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDownloadTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGlobalQuestionsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class ListGlobalQuestionsResponseBody : Tea.TeaModel {
    public class GlobalQuestions : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var answers: String?

            public var globalQuestionId: String?

            public var globalQuestionName: String?

            public var globalQuestionType: String?

            public var questions: String?

            public var scriptId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answers != nil {
                    map["Answers"] = self.answers!
                }
                if self.globalQuestionId != nil {
                    map["GlobalQuestionId"] = self.globalQuestionId!
                }
                if self.globalQuestionName != nil {
                    map["GlobalQuestionName"] = self.globalQuestionName!
                }
                if self.globalQuestionType != nil {
                    map["GlobalQuestionType"] = self.globalQuestionType!
                }
                if self.questions != nil {
                    map["Questions"] = self.questions!
                }
                if self.scriptId != nil {
                    map["ScriptId"] = self.scriptId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Answers") {
                    self.answers = dict["Answers"] as! String
                }
                if dict.keys.contains("GlobalQuestionId") {
                    self.globalQuestionId = dict["GlobalQuestionId"] as! String
                }
                if dict.keys.contains("GlobalQuestionName") {
                    self.globalQuestionName = dict["GlobalQuestionName"] as! String
                }
                if dict.keys.contains("GlobalQuestionType") {
                    self.globalQuestionType = dict["GlobalQuestionType"] as! String
                }
                if dict.keys.contains("Questions") {
                    self.questions = dict["Questions"] as! String
                }
                if dict.keys.contains("ScriptId") {
                    self.scriptId = dict["ScriptId"] as! String
                }
            }
        }
        public var list: [ListGlobalQuestionsResponseBody.GlobalQuestions.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListGlobalQuestionsResponseBody.GlobalQuestions.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var globalQuestions: ListGlobalQuestionsResponseBody.GlobalQuestions?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.globalQuestions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.globalQuestions != nil {
            map["GlobalQuestions"] = self.globalQuestions?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("GlobalQuestions") {
            var model = ListGlobalQuestionsResponseBody.GlobalQuestions()
            model.fromMap(dict["GlobalQuestions"] as! [String: Any])
            self.globalQuestions = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListGlobalQuestionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGlobalQuestionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGlobalQuestionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var resourceGroupId: String?

    public var tag: [ListInstancesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ListInstancesRequest.Tag]
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class ResourceTags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var creationTime: Int64?

        public var creatorId: Int64?

        public var creatorName: String?

        public var instanceDescription: String?

        public var instanceId: String?

        public var instanceName: String?

        public var isPreset: Bool?

        public var maxConcurrentConversation: Int32?

        public var ownerName: String?

        public var resourceGroupId: String?

        public var resourceTags: [ListInstancesResponseBody.Instances.ResourceTags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.isPreset != nil {
                map["IsPreset"] = self.isPreset!
            }
            if self.maxConcurrentConversation != nil {
                map["MaxConcurrentConversation"] = self.maxConcurrentConversation!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourceTags != nil {
                var tmp : [Any] = []
                for k in self.resourceTags! {
                    tmp.append(k.toMap())
                }
                map["ResourceTags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("InstanceDescription") {
                self.instanceDescription = dict["InstanceDescription"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("IsPreset") {
                self.isPreset = dict["IsPreset"] as! Bool
            }
            if dict.keys.contains("MaxConcurrentConversation") {
                self.maxConcurrentConversation = dict["MaxConcurrentConversation"] as! Int32
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ResourceTags") {
                self.resourceTags = dict["ResourceTags"] as! [ListInstancesResponseBody.Instances.ResourceTags]
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var instances: [ListInstancesResponseBody.Instances]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Instances") {
            self.instances = dict["Instances"] as! [ListInstancesResponseBody.Instances]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntentsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var keyword: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class ListIntentsResponseBody : Tea.TeaModel {
    public class Intents : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var createTime: Int64?

            public var intentDescription: String?

            public var intentId: String?

            public var intentName: String?

            public var keywords: String?

            public var scriptId: String?

            public var updateTime: Int64?

            public var utterances: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.intentDescription != nil {
                    map["IntentDescription"] = self.intentDescription!
                }
                if self.intentId != nil {
                    map["IntentId"] = self.intentId!
                }
                if self.intentName != nil {
                    map["IntentName"] = self.intentName!
                }
                if self.keywords != nil {
                    map["Keywords"] = self.keywords!
                }
                if self.scriptId != nil {
                    map["ScriptId"] = self.scriptId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.utterances != nil {
                    map["Utterances"] = self.utterances!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("IntentDescription") {
                    self.intentDescription = dict["IntentDescription"] as! String
                }
                if dict.keys.contains("IntentId") {
                    self.intentId = dict["IntentId"] as! String
                }
                if dict.keys.contains("IntentName") {
                    self.intentName = dict["IntentName"] as! String
                }
                if dict.keys.contains("Keywords") {
                    self.keywords = dict["Keywords"] as! String
                }
                if dict.keys.contains("ScriptId") {
                    self.scriptId = dict["ScriptId"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Utterances") {
                    self.utterances = dict["Utterances"] as! String
                }
            }
        }
        public var list: [ListIntentsResponseBody.Intents.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListIntentsResponseBody.Intents.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var intents: ListIntentsResponseBody.Intents?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.intents?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.intents != nil {
            map["Intents"] = self.intents?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Intents") {
            var model = ListIntentsResponseBody.Intents()
            model.fromMap(dict["Intents"] as! [String: Any])
            self.intents = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListIntentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIntentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListJobGroupsRequest : Tea.TeaModel {
    public var asyncQuery: Bool?

    public var endTime: Int64?

    public var instanceId: String?

    public var jobGroupStatusFilter: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchText: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncQuery != nil {
            map["AsyncQuery"] = self.asyncQuery!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupStatusFilter != nil {
            map["JobGroupStatusFilter"] = self.jobGroupStatusFilter!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchText != nil {
            map["SearchText"] = self.searchText!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsyncQuery") {
            self.asyncQuery = dict["AsyncQuery"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupStatusFilter") {
            self.jobGroupStatusFilter = dict["JobGroupStatusFilter"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchText") {
            self.searchText = dict["SearchText"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListJobGroupsResponseBody : Tea.TeaModel {
    public class JobGroups : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class ExportProgress : Tea.TeaModel {
                public var fileHttpUrl: String?

                public var progress: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fileHttpUrl != nil {
                        map["FileHttpUrl"] = self.fileHttpUrl!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FileHttpUrl") {
                        self.fileHttpUrl = dict["FileHttpUrl"] as! String
                    }
                    if dict.keys.contains("Progress") {
                        self.progress = dict["Progress"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class Progress : Tea.TeaModel {
                public var cancelledNum: Int32?

                public var duration: Int32?

                public var executingNum: Int32?

                public var failedNum: Int32?

                public var pausedNum: Int32?

                public var scheduling: Int32?

                public var startTime: Int64?

                public var status: String?

                public var totalCompleted: Int32?

                public var totalJobs: Int32?

                public var totalNotAnswered: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cancelledNum != nil {
                        map["CancelledNum"] = self.cancelledNum!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.executingNum != nil {
                        map["ExecutingNum"] = self.executingNum!
                    }
                    if self.failedNum != nil {
                        map["FailedNum"] = self.failedNum!
                    }
                    if self.pausedNum != nil {
                        map["PausedNum"] = self.pausedNum!
                    }
                    if self.scheduling != nil {
                        map["Scheduling"] = self.scheduling!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.totalCompleted != nil {
                        map["TotalCompleted"] = self.totalCompleted!
                    }
                    if self.totalJobs != nil {
                        map["TotalJobs"] = self.totalJobs!
                    }
                    if self.totalNotAnswered != nil {
                        map["TotalNotAnswered"] = self.totalNotAnswered!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CancelledNum") {
                        self.cancelledNum = dict["CancelledNum"] as! Int32
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int32
                    }
                    if dict.keys.contains("ExecutingNum") {
                        self.executingNum = dict["ExecutingNum"] as! Int32
                    }
                    if dict.keys.contains("FailedNum") {
                        self.failedNum = dict["FailedNum"] as! Int32
                    }
                    if dict.keys.contains("PausedNum") {
                        self.pausedNum = dict["PausedNum"] as! Int32
                    }
                    if dict.keys.contains("Scheduling") {
                        self.scheduling = dict["Scheduling"] as! Int32
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("TotalCompleted") {
                        self.totalCompleted = dict["TotalCompleted"] as! Int32
                    }
                    if dict.keys.contains("TotalJobs") {
                        self.totalJobs = dict["TotalJobs"] as! Int32
                    }
                    if dict.keys.contains("TotalNotAnswered") {
                        self.totalNotAnswered = dict["TotalNotAnswered"] as! Int32
                    }
                }
            }
            public class Strategy : Tea.TeaModel {
                public var endTime: Int64?

                public var startTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! Int64
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                }
            }
            public var creationTime: Int64?

            public var exportProgress: ListJobGroupsResponseBody.JobGroups.List.ExportProgress?

            public var jobDataParsingTaskId: String?

            public var jobGroupDescription: String?

            public var jobGroupId: String?

            public var jobGroupName: String?

            public var modifyTime: String?

            public var progress: ListJobGroupsResponseBody.JobGroups.List.Progress?

            public var scriptId: String?

            public var scriptName: String?

            public var scriptVersion: String?

            public var status: String?

            public var strategy: ListJobGroupsResponseBody.JobGroups.List.Strategy?

            public var totalCallNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.exportProgress?.validate()
                try self.progress?.validate()
                try self.strategy?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.exportProgress != nil {
                    map["ExportProgress"] = self.exportProgress?.toMap()
                }
                if self.jobDataParsingTaskId != nil {
                    map["JobDataParsingTaskId"] = self.jobDataParsingTaskId!
                }
                if self.jobGroupDescription != nil {
                    map["JobGroupDescription"] = self.jobGroupDescription!
                }
                if self.jobGroupId != nil {
                    map["JobGroupId"] = self.jobGroupId!
                }
                if self.jobGroupName != nil {
                    map["JobGroupName"] = self.jobGroupName!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress?.toMap()
                }
                if self.scriptId != nil {
                    map["ScriptId"] = self.scriptId!
                }
                if self.scriptName != nil {
                    map["ScriptName"] = self.scriptName!
                }
                if self.scriptVersion != nil {
                    map["ScriptVersion"] = self.scriptVersion!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy?.toMap()
                }
                if self.totalCallNum != nil {
                    map["TotalCallNum"] = self.totalCallNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! Int64
                }
                if dict.keys.contains("ExportProgress") {
                    var model = ListJobGroupsResponseBody.JobGroups.List.ExportProgress()
                    model.fromMap(dict["ExportProgress"] as! [String: Any])
                    self.exportProgress = model
                }
                if dict.keys.contains("JobDataParsingTaskId") {
                    self.jobDataParsingTaskId = dict["JobDataParsingTaskId"] as! String
                }
                if dict.keys.contains("JobGroupDescription") {
                    self.jobGroupDescription = dict["JobGroupDescription"] as! String
                }
                if dict.keys.contains("JobGroupId") {
                    self.jobGroupId = dict["JobGroupId"] as! String
                }
                if dict.keys.contains("JobGroupName") {
                    self.jobGroupName = dict["JobGroupName"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! String
                }
                if dict.keys.contains("Progress") {
                    var model = ListJobGroupsResponseBody.JobGroups.List.Progress()
                    model.fromMap(dict["Progress"] as! [String: Any])
                    self.progress = model
                }
                if dict.keys.contains("ScriptId") {
                    self.scriptId = dict["ScriptId"] as! String
                }
                if dict.keys.contains("ScriptName") {
                    self.scriptName = dict["ScriptName"] as! String
                }
                if dict.keys.contains("ScriptVersion") {
                    self.scriptVersion = dict["ScriptVersion"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Strategy") {
                    var model = ListJobGroupsResponseBody.JobGroups.List.Strategy()
                    model.fromMap(dict["Strategy"] as! [String: Any])
                    self.strategy = model
                }
                if dict.keys.contains("TotalCallNum") {
                    self.totalCallNum = dict["TotalCallNum"] as! Int32
                }
            }
        }
        public var list: [ListJobGroupsResponseBody.JobGroups.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListJobGroupsResponseBody.JobGroups.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var asyncTaskId: String?

    public var code: String?

    public var httpStatusCode: Int32?

    public var jobGroups: ListJobGroupsResponseBody.JobGroups?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncTaskId != nil {
            map["AsyncTaskId"] = self.asyncTaskId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobGroups != nil {
            map["JobGroups"] = self.jobGroups?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsyncTaskId") {
            self.asyncTaskId = dict["AsyncTaskId"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobGroups") {
            var model = ListJobGroupsResponseBody.JobGroups()
            model.fromMap(dict["JobGroups"] as! [String: Any])
            self.jobGroups = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListJobGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJobGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListJobGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListJobGroupsAsyncRequest : Tea.TeaModel {
    public var asyncTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncTaskId != nil {
            map["AsyncTaskId"] = self.asyncTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsyncTaskId") {
            self.asyncTaskId = dict["AsyncTaskId"] as! String
        }
    }
}

public class ListJobGroupsAsyncResponseBody : Tea.TeaModel {
    public class JobGroups : Tea.TeaModel {
        public class ExportProgress : Tea.TeaModel {
            public var fileHttpUrl: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileHttpUrl != nil {
                    map["FileHttpUrl"] = self.fileHttpUrl!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileHttpUrl") {
                    self.fileHttpUrl = dict["FileHttpUrl"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Progress : Tea.TeaModel {
            public var cancelledNum: Int32?

            public var duration: Int32?

            public var executingNum: Int32?

            public var failedNum: Int32?

            public var pausedNum: Int32?

            public var scheduling: Int32?

            public var startTime: Int64?

            public var status: String?

            public var totalCompleted: Int32?

            public var totalJobs: Int32?

            public var totalNotAnswered: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cancelledNum != nil {
                    map["CancelledNum"] = self.cancelledNum!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.executingNum != nil {
                    map["ExecutingNum"] = self.executingNum!
                }
                if self.failedNum != nil {
                    map["FailedNum"] = self.failedNum!
                }
                if self.pausedNum != nil {
                    map["PausedNum"] = self.pausedNum!
                }
                if self.scheduling != nil {
                    map["Scheduling"] = self.scheduling!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.totalCompleted != nil {
                    map["TotalCompleted"] = self.totalCompleted!
                }
                if self.totalJobs != nil {
                    map["TotalJobs"] = self.totalJobs!
                }
                if self.totalNotAnswered != nil {
                    map["TotalNotAnswered"] = self.totalNotAnswered!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CancelledNum") {
                    self.cancelledNum = dict["CancelledNum"] as! Int32
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("ExecutingNum") {
                    self.executingNum = dict["ExecutingNum"] as! Int32
                }
                if dict.keys.contains("FailedNum") {
                    self.failedNum = dict["FailedNum"] as! Int32
                }
                if dict.keys.contains("PausedNum") {
                    self.pausedNum = dict["PausedNum"] as! Int32
                }
                if dict.keys.contains("Scheduling") {
                    self.scheduling = dict["Scheduling"] as! Int32
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TotalCompleted") {
                    self.totalCompleted = dict["TotalCompleted"] as! Int32
                }
                if dict.keys.contains("TotalJobs") {
                    self.totalJobs = dict["TotalJobs"] as! Int32
                }
                if dict.keys.contains("TotalNotAnswered") {
                    self.totalNotAnswered = dict["TotalNotAnswered"] as! Int32
                }
            }
        }
        public class Strategy : Tea.TeaModel {
            public var endTime: Int64?

            public var startTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
            }
        }
        public var creationTime: Int64?

        public var exportProgress: ListJobGroupsAsyncResponseBody.JobGroups.ExportProgress?

        public var jobDataParsingTaskId: String?

        public var jobGroupDescription: String?

        public var jobGroupId: String?

        public var jobGroupName: String?

        public var modifyTime: String?

        public var progress: ListJobGroupsAsyncResponseBody.JobGroups.Progress?

        public var scriptId: String?

        public var scriptName: String?

        public var scriptVersion: String?

        public var status: String?

        public var strategy: ListJobGroupsAsyncResponseBody.JobGroups.Strategy?

        public var totalCallNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.exportProgress?.validate()
            try self.progress?.validate()
            try self.strategy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.exportProgress != nil {
                map["ExportProgress"] = self.exportProgress?.toMap()
            }
            if self.jobDataParsingTaskId != nil {
                map["JobDataParsingTaskId"] = self.jobDataParsingTaskId!
            }
            if self.jobGroupDescription != nil {
                map["JobGroupDescription"] = self.jobGroupDescription!
            }
            if self.jobGroupId != nil {
                map["JobGroupId"] = self.jobGroupId!
            }
            if self.jobGroupName != nil {
                map["JobGroupName"] = self.jobGroupName!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.progress != nil {
                map["Progress"] = self.progress?.toMap()
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.scriptVersion != nil {
                map["ScriptVersion"] = self.scriptVersion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy?.toMap()
            }
            if self.totalCallNum != nil {
                map["TotalCallNum"] = self.totalCallNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("ExportProgress") {
                var model = ListJobGroupsAsyncResponseBody.JobGroups.ExportProgress()
                model.fromMap(dict["ExportProgress"] as! [String: Any])
                self.exportProgress = model
            }
            if dict.keys.contains("JobDataParsingTaskId") {
                self.jobDataParsingTaskId = dict["JobDataParsingTaskId"] as! String
            }
            if dict.keys.contains("JobGroupDescription") {
                self.jobGroupDescription = dict["JobGroupDescription"] as! String
            }
            if dict.keys.contains("JobGroupId") {
                self.jobGroupId = dict["JobGroupId"] as! String
            }
            if dict.keys.contains("JobGroupName") {
                self.jobGroupName = dict["JobGroupName"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Progress") {
                var model = ListJobGroupsAsyncResponseBody.JobGroups.Progress()
                model.fromMap(dict["Progress"] as! [String: Any])
                self.progress = model
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("ScriptVersion") {
                self.scriptVersion = dict["ScriptVersion"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Strategy") {
                var model = ListJobGroupsAsyncResponseBody.JobGroups.Strategy()
                model.fromMap(dict["Strategy"] as! [String: Any])
                self.strategy = model
            }
            if dict.keys.contains("TotalCallNum") {
                self.totalCallNum = dict["TotalCallNum"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobGroups: [ListJobGroupsAsyncResponseBody.JobGroups]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var timeout: Bool?

    public var totalCount: Int32?

    public var vaild: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobGroups != nil {
            var tmp : [Any] = []
            for k in self.jobGroups! {
                tmp.append(k.toMap())
            }
            map["JobGroups"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vaild != nil {
            map["Vaild"] = self.vaild!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobGroups") {
            self.jobGroups = dict["JobGroups"] as! [ListJobGroupsAsyncResponseBody.JobGroups]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("Vaild") {
            self.vaild = dict["Vaild"] as! Bool
        }
    }
}

public class ListJobGroupsAsyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJobGroupsAsyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListJobGroupsAsyncResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListJobsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! [String]
        }
    }
}

public class ListJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class Contacts : Tea.TeaModel {
            public var contactId: String?

            public var contactName: String?

            public var honorific: String?

            public var jobId: String?

            public var phoneNumber: String?

            public var referenceId: String?

            public var role: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactName != nil {
                    map["ContactName"] = self.contactName!
                }
                if self.honorific != nil {
                    map["Honorific"] = self.honorific!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("ContactName") {
                    self.contactName = dict["ContactName"] as! String
                }
                if dict.keys.contains("Honorific") {
                    self.honorific = dict["Honorific"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("PhoneNumber") {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public class Extras : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Summary : Tea.TeaModel {
            public var category: String?

            public var content: String?

            public var summaryName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.summaryName != nil {
                    map["SummaryName"] = self.summaryName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("SummaryName") {
                    self.summaryName = dict["SummaryName"] as! String
                }
            }
        }
        public class Tasks : Tea.TeaModel {
            public class Contact : Tea.TeaModel {
                public var contactId: String?

                public var contactName: String?

                public var honorific: String?

                public var jobId: String?

                public var phoneNumber: String?

                public var referenceId: String?

                public var role: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactId != nil {
                        map["ContactId"] = self.contactId!
                    }
                    if self.contactName != nil {
                        map["ContactName"] = self.contactName!
                    }
                    if self.honorific != nil {
                        map["Honorific"] = self.honorific!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.phoneNumber != nil {
                        map["PhoneNumber"] = self.phoneNumber!
                    }
                    if self.referenceId != nil {
                        map["ReferenceId"] = self.referenceId!
                    }
                    if self.role != nil {
                        map["Role"] = self.role!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactId") {
                        self.contactId = dict["ContactId"] as! String
                    }
                    if dict.keys.contains("ContactName") {
                        self.contactName = dict["ContactName"] as! String
                    }
                    if dict.keys.contains("Honorific") {
                        self.honorific = dict["Honorific"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("PhoneNumber") {
                        self.phoneNumber = dict["PhoneNumber"] as! String
                    }
                    if dict.keys.contains("ReferenceId") {
                        self.referenceId = dict["ReferenceId"] as! String
                    }
                    if dict.keys.contains("Role") {
                        self.role = dict["Role"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                }
            }
            public class Conversation : Tea.TeaModel {
                public class Summary : Tea.TeaModel {
                    public var category: String?

                    public var content: String?

                    public var summaryName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.category != nil {
                            map["Category"] = self.category!
                        }
                        if self.content != nil {
                            map["Content"] = self.content!
                        }
                        if self.summaryName != nil {
                            map["SummaryName"] = self.summaryName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Category") {
                            self.category = dict["Category"] as! String
                        }
                        if dict.keys.contains("Content") {
                            self.content = dict["Content"] as! String
                        }
                        if dict.keys.contains("SummaryName") {
                            self.summaryName = dict["SummaryName"] as! String
                        }
                    }
                }
                public var script: String?

                public var speaker: String?

                public var summary: [ListJobsResponseBody.Jobs.Tasks.Conversation.Summary]?

                public var timestamp: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.script != nil {
                        map["Script"] = self.script!
                    }
                    if self.speaker != nil {
                        map["Speaker"] = self.speaker!
                    }
                    if self.summary != nil {
                        var tmp : [Any] = []
                        for k in self.summary! {
                            tmp.append(k.toMap())
                        }
                        map["Summary"] = tmp
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Script") {
                        self.script = dict["Script"] as! String
                    }
                    if dict.keys.contains("Speaker") {
                        self.speaker = dict["Speaker"] as! String
                    }
                    if dict.keys.contains("Summary") {
                        self.summary = dict["Summary"] as! [ListJobsResponseBody.Jobs.Tasks.Conversation.Summary]
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                }
            }
            public var actualTime: Int64?

            public var brief: String?

            public var callId: String?

            public var calledNumber: String?

            public var callingNumber: String?

            public var chatbotId: String?

            public var contact: ListJobsResponseBody.Jobs.Tasks.Contact?

            public var conversation: [ListJobsResponseBody.Jobs.Tasks.Conversation]?

            public var duration: Int32?

            public var jobId: String?

            public var planedTime: Int64?

            public var scenarioId: String?

            public var status: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.contact?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualTime != nil {
                    map["ActualTime"] = self.actualTime!
                }
                if self.brief != nil {
                    map["Brief"] = self.brief!
                }
                if self.callId != nil {
                    map["CallId"] = self.callId!
                }
                if self.calledNumber != nil {
                    map["CalledNumber"] = self.calledNumber!
                }
                if self.callingNumber != nil {
                    map["CallingNumber"] = self.callingNumber!
                }
                if self.chatbotId != nil {
                    map["ChatbotId"] = self.chatbotId!
                }
                if self.contact != nil {
                    map["Contact"] = self.contact?.toMap()
                }
                if self.conversation != nil {
                    var tmp : [Any] = []
                    for k in self.conversation! {
                        tmp.append(k.toMap())
                    }
                    map["Conversation"] = tmp
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.planedTime != nil {
                    map["PlanedTime"] = self.planedTime!
                }
                if self.scenarioId != nil {
                    map["ScenarioId"] = self.scenarioId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualTime") {
                    self.actualTime = dict["ActualTime"] as! Int64
                }
                if dict.keys.contains("Brief") {
                    self.brief = dict["Brief"] as! String
                }
                if dict.keys.contains("CallId") {
                    self.callId = dict["CallId"] as! String
                }
                if dict.keys.contains("CalledNumber") {
                    self.calledNumber = dict["CalledNumber"] as! String
                }
                if dict.keys.contains("CallingNumber") {
                    self.callingNumber = dict["CallingNumber"] as! String
                }
                if dict.keys.contains("ChatbotId") {
                    self.chatbotId = dict["ChatbotId"] as! String
                }
                if dict.keys.contains("Contact") {
                    var model = ListJobsResponseBody.Jobs.Tasks.Contact()
                    model.fromMap(dict["Contact"] as! [String: Any])
                    self.contact = model
                }
                if dict.keys.contains("Conversation") {
                    self.conversation = dict["Conversation"] as! [ListJobsResponseBody.Jobs.Tasks.Conversation]
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("PlanedTime") {
                    self.planedTime = dict["PlanedTime"] as! Int64
                }
                if dict.keys.contains("ScenarioId") {
                    self.scenarioId = dict["ScenarioId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
            }
        }
        public var callingNumbers: [String]?

        public var contacts: [ListJobsResponseBody.Jobs.Contacts]?

        public var extras: [ListJobsResponseBody.Jobs.Extras]?

        public var failureReason: String?

        public var jobGroupId: String?

        public var jobId: String?

        public var priority: Int32?

        public var referenceId: String?

        public var scenarioId: String?

        public var status: String?

        public var strategyId: String?

        public var summary: [ListJobsResponseBody.Jobs.Summary]?

        public var systemPriority: Int32?

        public var tasks: [ListJobsResponseBody.Jobs.Tasks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callingNumbers != nil {
                map["CallingNumbers"] = self.callingNumbers!
            }
            if self.contacts != nil {
                var tmp : [Any] = []
                for k in self.contacts! {
                    tmp.append(k.toMap())
                }
                map["Contacts"] = tmp
            }
            if self.extras != nil {
                var tmp : [Any] = []
                for k in self.extras! {
                    tmp.append(k.toMap())
                }
                map["Extras"] = tmp
            }
            if self.failureReason != nil {
                map["FailureReason"] = self.failureReason!
            }
            if self.jobGroupId != nil {
                map["JobGroupId"] = self.jobGroupId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.referenceId != nil {
                map["ReferenceId"] = self.referenceId!
            }
            if self.scenarioId != nil {
                map["ScenarioId"] = self.scenarioId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strategyId != nil {
                map["StrategyId"] = self.strategyId!
            }
            if self.summary != nil {
                var tmp : [Any] = []
                for k in self.summary! {
                    tmp.append(k.toMap())
                }
                map["Summary"] = tmp
            }
            if self.systemPriority != nil {
                map["SystemPriority"] = self.systemPriority!
            }
            if self.tasks != nil {
                var tmp : [Any] = []
                for k in self.tasks! {
                    tmp.append(k.toMap())
                }
                map["Tasks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallingNumbers") {
                self.callingNumbers = dict["CallingNumbers"] as! [String]
            }
            if dict.keys.contains("Contacts") {
                self.contacts = dict["Contacts"] as! [ListJobsResponseBody.Jobs.Contacts]
            }
            if dict.keys.contains("Extras") {
                self.extras = dict["Extras"] as! [ListJobsResponseBody.Jobs.Extras]
            }
            if dict.keys.contains("FailureReason") {
                self.failureReason = dict["FailureReason"] as! String
            }
            if dict.keys.contains("JobGroupId") {
                self.jobGroupId = dict["JobGroupId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("ReferenceId") {
                self.referenceId = dict["ReferenceId"] as! String
            }
            if dict.keys.contains("ScenarioId") {
                self.scenarioId = dict["ScenarioId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StrategyId") {
                self.strategyId = dict["StrategyId"] as! String
            }
            if dict.keys.contains("Summary") {
                self.summary = dict["Summary"] as! [ListJobsResponseBody.Jobs.Summary]
            }
            if dict.keys.contains("SystemPriority") {
                self.systemPriority = dict["SystemPriority"] as! Int32
            }
            if dict.keys.contains("Tasks") {
                self.tasks = dict["Tasks"] as! [ListJobsResponseBody.Jobs.Tasks]
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobs: [ListJobsResponseBody.Jobs]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Jobs") {
            self.jobs = dict["Jobs"] as! [ListJobsResponseBody.Jobs]
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListJobsByGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobFailureReason: String?

    public var jobGroupId: String?

    public var jobStatus: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobFailureReason != nil {
            map["JobFailureReason"] = self.jobFailureReason!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobStatus != nil {
            map["JobStatus"] = self.jobStatus!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobFailureReason") {
            self.jobFailureReason = dict["JobFailureReason"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobStatus") {
            self.jobStatus = dict["JobStatus"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListJobsByGroupResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Contacts : Tea.TeaModel {
                public var contactId: String?

                public var contactName: String?

                public var honorific: String?

                public var jobId: String?

                public var phoneNumber: String?

                public var referenceId: String?

                public var role: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactId != nil {
                        map["ContactId"] = self.contactId!
                    }
                    if self.contactName != nil {
                        map["ContactName"] = self.contactName!
                    }
                    if self.honorific != nil {
                        map["Honorific"] = self.honorific!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.phoneNumber != nil {
                        map["PhoneNumber"] = self.phoneNumber!
                    }
                    if self.referenceId != nil {
                        map["ReferenceId"] = self.referenceId!
                    }
                    if self.role != nil {
                        map["Role"] = self.role!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactId") {
                        self.contactId = dict["ContactId"] as! String
                    }
                    if dict.keys.contains("ContactName") {
                        self.contactName = dict["ContactName"] as! String
                    }
                    if dict.keys.contains("Honorific") {
                        self.honorific = dict["Honorific"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("PhoneNumber") {
                        self.phoneNumber = dict["PhoneNumber"] as! String
                    }
                    if dict.keys.contains("ReferenceId") {
                        self.referenceId = dict["ReferenceId"] as! String
                    }
                    if dict.keys.contains("Role") {
                        self.role = dict["Role"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                }
            }
            public class Extras : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Summary : Tea.TeaModel {
                public var category: String?

                public var content: String?

                public var conversationDetailId: String?

                public var jobGroupId: String?

                public var jobId: String?

                public var summaryId: String?

                public var summaryName: String?

                public var taskId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.conversationDetailId != nil {
                        map["ConversationDetailId"] = self.conversationDetailId!
                    }
                    if self.jobGroupId != nil {
                        map["JobGroupId"] = self.jobGroupId!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.summaryId != nil {
                        map["SummaryId"] = self.summaryId!
                    }
                    if self.summaryName != nil {
                        map["SummaryName"] = self.summaryName!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("ConversationDetailId") {
                        self.conversationDetailId = dict["ConversationDetailId"] as! String
                    }
                    if dict.keys.contains("JobGroupId") {
                        self.jobGroupId = dict["JobGroupId"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("SummaryId") {
                        self.summaryId = dict["SummaryId"] as! String
                    }
                    if dict.keys.contains("SummaryName") {
                        self.summaryName = dict["SummaryName"] as! String
                    }
                    if dict.keys.contains("TaskId") {
                        self.taskId = dict["TaskId"] as! String
                    }
                }
            }
            public var callingNumbers: [String]?

            public var contacts: [ListJobsByGroupResponseBody.Jobs.List.Contacts]?

            public var extras: [ListJobsByGroupResponseBody.Jobs.List.Extras]?

            public var failureReason: String?

            public var jobGroupId: String?

            public var jobId: String?

            public var priority: Int32?

            public var referenceId: String?

            public var scenarioId: String?

            public var status: String?

            public var strategyId: String?

            public var summary: [ListJobsByGroupResponseBody.Jobs.List.Summary]?

            public var systemPriority: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callingNumbers != nil {
                    map["CallingNumbers"] = self.callingNumbers!
                }
                if self.contacts != nil {
                    var tmp : [Any] = []
                    for k in self.contacts! {
                        tmp.append(k.toMap())
                    }
                    map["Contacts"] = tmp
                }
                if self.extras != nil {
                    var tmp : [Any] = []
                    for k in self.extras! {
                        tmp.append(k.toMap())
                    }
                    map["Extras"] = tmp
                }
                if self.failureReason != nil {
                    map["FailureReason"] = self.failureReason!
                }
                if self.jobGroupId != nil {
                    map["JobGroupId"] = self.jobGroupId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.scenarioId != nil {
                    map["ScenarioId"] = self.scenarioId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.summary != nil {
                    var tmp : [Any] = []
                    for k in self.summary! {
                        tmp.append(k.toMap())
                    }
                    map["Summary"] = tmp
                }
                if self.systemPriority != nil {
                    map["SystemPriority"] = self.systemPriority!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallingNumbers") {
                    self.callingNumbers = dict["CallingNumbers"] as! [String]
                }
                if dict.keys.contains("Contacts") {
                    self.contacts = dict["Contacts"] as! [ListJobsByGroupResponseBody.Jobs.List.Contacts]
                }
                if dict.keys.contains("Extras") {
                    self.extras = dict["Extras"] as! [ListJobsByGroupResponseBody.Jobs.List.Extras]
                }
                if dict.keys.contains("FailureReason") {
                    self.failureReason = dict["FailureReason"] as! String
                }
                if dict.keys.contains("JobGroupId") {
                    self.jobGroupId = dict["JobGroupId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("ScenarioId") {
                    self.scenarioId = dict["ScenarioId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("Summary") {
                    self.summary = dict["Summary"] as! [ListJobsByGroupResponseBody.Jobs.List.Summary]
                }
                if dict.keys.contains("SystemPriority") {
                    self.systemPriority = dict["SystemPriority"] as! Int32
                }
            }
        }
        public var list: [ListJobsByGroupResponseBody.Jobs.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListJobsByGroupResponseBody.Jobs.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobs: ListJobsByGroupResponseBody.Jobs?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobs != nil {
            map["Jobs"] = self.jobs?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Jobs") {
            var model = ListJobsByGroupResponseBody.Jobs()
            model.fromMap(dict["Jobs"] as! [String: Any])
            self.jobs = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListJobsByGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJobsByGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListJobsByGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOutboundCallNumbersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListOutboundCallNumbersResponseBody : Tea.TeaModel {
    public class OutboundCallNumbers : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var number: String?

            public var outboundCallNumberId: String?

            public var rateLimitCount: String?

            public var rateLimitPeriod: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.outboundCallNumberId != nil {
                    map["OutboundCallNumberId"] = self.outboundCallNumberId!
                }
                if self.rateLimitCount != nil {
                    map["RateLimitCount"] = self.rateLimitCount!
                }
                if self.rateLimitPeriod != nil {
                    map["RateLimitPeriod"] = self.rateLimitPeriod!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("OutboundCallNumberId") {
                    self.outboundCallNumberId = dict["OutboundCallNumberId"] as! String
                }
                if dict.keys.contains("RateLimitCount") {
                    self.rateLimitCount = dict["RateLimitCount"] as! String
                }
                if dict.keys.contains("RateLimitPeriod") {
                    self.rateLimitPeriod = dict["RateLimitPeriod"] as! String
                }
            }
        }
        public var list: [ListOutboundCallNumbersResponseBody.OutboundCallNumbers.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListOutboundCallNumbersResponseBody.OutboundCallNumbers.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var outboundCallNumbers: ListOutboundCallNumbersResponseBody.OutboundCallNumbers?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.outboundCallNumbers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.outboundCallNumbers != nil {
            map["OutboundCallNumbers"] = self.outboundCallNumbers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OutboundCallNumbers") {
            var model = ListOutboundCallNumbersResponseBody.OutboundCallNumbers()
            model.fromMap(dict["OutboundCallNumbers"] as! [String: Any])
            self.outboundCallNumbers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListOutboundCallNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOutboundCallNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListOutboundCallNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListResourceTagsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ListResourceTagsResponseBody : Tea.TeaModel {
    public class ResourceTags : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var list: [ListResourceTagsResponseBody.ResourceTags.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListResourceTagsResponseBody.ResourceTags.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var resourceTags: ListResourceTagsResponseBody.ResourceTags?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceTags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceTags != nil {
            map["ResourceTags"] = self.resourceTags?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceTags") {
            var model = ListResourceTagsResponseBody.ResourceTags()
            model.fromMap(dict["ResourceTags"] as! [String: Any])
            self.resourceTags = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListResourceTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListResourceTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSchedulerInstancesRequest : Tea.TeaModel {
    public var instanceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceOwnerId != nil {
            map["InstanceOwnerId"] = self.instanceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceOwnerId") {
            self.instanceOwnerId = dict["InstanceOwnerId"] as! Int64
        }
    }
}

public class ListSchedulerInstancesResponseBody : Tea.TeaModel {
    public class SchedulerInstances : Tea.TeaModel {
        public var baseStrategy: String?

        public var business: String?

        public var instanceId: String?

        public var maxConcurrency: Int32?

        public var ownerId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baseStrategy != nil {
                map["BaseStrategy"] = self.baseStrategy!
            }
            if self.business != nil {
                map["Business"] = self.business!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.maxConcurrency != nil {
                map["MaxConcurrency"] = self.maxConcurrency!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaseStrategy") {
                self.baseStrategy = dict["BaseStrategy"] as! String
            }
            if dict.keys.contains("Business") {
                self.business = dict["Business"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MaxConcurrency") {
                self.maxConcurrency = dict["MaxConcurrency"] as! Int32
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var schedulerInstances: [ListSchedulerInstancesResponseBody.SchedulerInstances]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schedulerInstances != nil {
            var tmp : [Any] = []
            for k in self.schedulerInstances! {
                tmp.append(k.toMap())
            }
            map["SchedulerInstances"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchedulerInstances") {
            self.schedulerInstances = dict["SchedulerInstances"] as! [ListSchedulerInstancesResponseBody.SchedulerInstances]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSchedulerInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSchedulerInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSchedulerInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScriptPublishHistoriesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class ListScriptPublishHistoriesResponseBody : Tea.TeaModel {
    public class ScriptPublishHistories : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var description_: String?

            public var instanceId: String?

            public var publishTime: Int64?

            public var scriptId: String?

            public var scriptVersion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.publishTime != nil {
                    map["PublishTime"] = self.publishTime!
                }
                if self.scriptId != nil {
                    map["ScriptId"] = self.scriptId!
                }
                if self.scriptVersion != nil {
                    map["ScriptVersion"] = self.scriptVersion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PublishTime") {
                    self.publishTime = dict["PublishTime"] as! Int64
                }
                if dict.keys.contains("ScriptId") {
                    self.scriptId = dict["ScriptId"] as! String
                }
                if dict.keys.contains("ScriptVersion") {
                    self.scriptVersion = dict["ScriptVersion"] as! String
                }
            }
        }
        public var list: [ListScriptPublishHistoriesResponseBody.ScriptPublishHistories.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListScriptPublishHistoriesResponseBody.ScriptPublishHistories.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scriptPublishHistories: ListScriptPublishHistoriesResponseBody.ScriptPublishHistories?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scriptPublishHistories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptPublishHistories != nil {
            map["ScriptPublishHistories"] = self.scriptPublishHistories?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptPublishHistories") {
            var model = ListScriptPublishHistoriesResponseBody.ScriptPublishHistories()
            model.fromMap(dict["ScriptPublishHistories"] as! [String: Any])
            self.scriptPublishHistories = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListScriptPublishHistoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScriptPublishHistoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListScriptPublishHistoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScriptRecordingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var scriptId: String?

    public var search: String?

    public var statesJson: String?

    public var uuidsJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.search != nil {
            map["Search"] = self.search!
        }
        if self.statesJson != nil {
            map["StatesJson"] = self.statesJson!
        }
        if self.uuidsJson != nil {
            map["UuidsJson"] = self.uuidsJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("Search") {
            self.search = dict["Search"] as! String
        }
        if dict.keys.contains("StatesJson") {
            self.statesJson = dict["StatesJson"] as! String
        }
        if dict.keys.contains("UuidsJson") {
            self.uuidsJson = dict["UuidsJson"] as! String
        }
    }
}

public class ListScriptRecordingResponseBody : Tea.TeaModel {
    public class ScriptRecordings : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var gmtUpload: Int64?

        public var innerId: String?

        public var instanceId: String?

        public var recordingContent: String?

        public var recordingDuration: Int32?

        public var recordingName: String?

        public var scriptId: String?

        public var state: Int32?

        public var stateExtend: String?

        public var storageUuid: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.gmtUpload != nil {
                map["GmtUpload"] = self.gmtUpload!
            }
            if self.innerId != nil {
                map["InnerId"] = self.innerId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.recordingContent != nil {
                map["RecordingContent"] = self.recordingContent!
            }
            if self.recordingDuration != nil {
                map["RecordingDuration"] = self.recordingDuration!
            }
            if self.recordingName != nil {
                map["RecordingName"] = self.recordingName!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.stateExtend != nil {
                map["StateExtend"] = self.stateExtend!
            }
            if self.storageUuid != nil {
                map["StorageUuid"] = self.storageUuid!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("GmtUpload") {
                self.gmtUpload = dict["GmtUpload"] as! Int64
            }
            if dict.keys.contains("InnerId") {
                self.innerId = dict["InnerId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RecordingContent") {
                self.recordingContent = dict["RecordingContent"] as! String
            }
            if dict.keys.contains("RecordingDuration") {
                self.recordingDuration = dict["RecordingDuration"] as! Int32
            }
            if dict.keys.contains("RecordingName") {
                self.recordingName = dict["RecordingName"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! Int32
            }
            if dict.keys.contains("StateExtend") {
                self.stateExtend = dict["StateExtend"] as! String
            }
            if dict.keys.contains("StorageUuid") {
                self.storageUuid = dict["StorageUuid"] as! String
            }
            if dict.keys.contains("Uuid") {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var scriptRecordings: [ListScriptRecordingResponseBody.ScriptRecordings]?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptRecordings != nil {
            var tmp : [Any] = []
            for k in self.scriptRecordings! {
                tmp.append(k.toMap())
            }
            map["ScriptRecordings"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptRecordings") {
            self.scriptRecordings = dict["ScriptRecordings"] as! [ListScriptRecordingResponseBody.ScriptRecordings]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListScriptRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScriptRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListScriptRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScriptVoiceConfigsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class ListScriptVoiceConfigsResponseBody : Tea.TeaModel {
    public class ScriptVoiceConfigs : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var instanceId: String?

            public var scriptContent: String?

            public var scriptId: String?

            public var scriptVoiceConfigId: String?

            public var scriptWaveformRelation: String?

            public var source: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.scriptContent != nil {
                    map["ScriptContent"] = self.scriptContent!
                }
                if self.scriptId != nil {
                    map["ScriptId"] = self.scriptId!
                }
                if self.scriptVoiceConfigId != nil {
                    map["ScriptVoiceConfigId"] = self.scriptVoiceConfigId!
                }
                if self.scriptWaveformRelation != nil {
                    map["ScriptWaveformRelation"] = self.scriptWaveformRelation!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("ScriptContent") {
                    self.scriptContent = dict["ScriptContent"] as! String
                }
                if dict.keys.contains("ScriptId") {
                    self.scriptId = dict["ScriptId"] as! String
                }
                if dict.keys.contains("ScriptVoiceConfigId") {
                    self.scriptVoiceConfigId = dict["ScriptVoiceConfigId"] as! String
                }
                if dict.keys.contains("ScriptWaveformRelation") {
                    self.scriptWaveformRelation = dict["ScriptWaveformRelation"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var list: [ListScriptVoiceConfigsResponseBody.ScriptVoiceConfigs.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListScriptVoiceConfigsResponseBody.ScriptVoiceConfigs.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scriptVoiceConfigs: ListScriptVoiceConfigsResponseBody.ScriptVoiceConfigs?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scriptVoiceConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptVoiceConfigs != nil {
            map["ScriptVoiceConfigs"] = self.scriptVoiceConfigs?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptVoiceConfigs") {
            var model = ListScriptVoiceConfigsResponseBody.ScriptVoiceConfigs()
            model.fromMap(dict["ScriptVoiceConfigs"] as! [String: Any])
            self.scriptVoiceConfigs = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListScriptVoiceConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScriptVoiceConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListScriptVoiceConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScriptsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListScriptsResponseBody : Tea.TeaModel {
    public class Scripts : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var debugStatus: String?

            public var emotionEnable: Bool?

            public var industry: String?

            public var isDebugDrafted: Bool?

            public var isDrafted: Bool?

            public var isPreset: Bool?

            public var longWaitEnable: Bool?

            public var miniPlaybackEnable: Bool?

            public var newBargeInEnable: Bool?

            public var rejectReason: String?

            public var scene: String?

            public var scriptDescription: String?

            public var scriptId: String?

            public var scriptName: String?

            public var status: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.debugStatus != nil {
                    map["DebugStatus"] = self.debugStatus!
                }
                if self.emotionEnable != nil {
                    map["EmotionEnable"] = self.emotionEnable!
                }
                if self.industry != nil {
                    map["Industry"] = self.industry!
                }
                if self.isDebugDrafted != nil {
                    map["IsDebugDrafted"] = self.isDebugDrafted!
                }
                if self.isDrafted != nil {
                    map["IsDrafted"] = self.isDrafted!
                }
                if self.isPreset != nil {
                    map["IsPreset"] = self.isPreset!
                }
                if self.longWaitEnable != nil {
                    map["LongWaitEnable"] = self.longWaitEnable!
                }
                if self.miniPlaybackEnable != nil {
                    map["MiniPlaybackEnable"] = self.miniPlaybackEnable!
                }
                if self.newBargeInEnable != nil {
                    map["NewBargeInEnable"] = self.newBargeInEnable!
                }
                if self.rejectReason != nil {
                    map["RejectReason"] = self.rejectReason!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.scriptDescription != nil {
                    map["ScriptDescription"] = self.scriptDescription!
                }
                if self.scriptId != nil {
                    map["ScriptId"] = self.scriptId!
                }
                if self.scriptName != nil {
                    map["ScriptName"] = self.scriptName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DebugStatus") {
                    self.debugStatus = dict["DebugStatus"] as! String
                }
                if dict.keys.contains("EmotionEnable") {
                    self.emotionEnable = dict["EmotionEnable"] as! Bool
                }
                if dict.keys.contains("Industry") {
                    self.industry = dict["Industry"] as! String
                }
                if dict.keys.contains("IsDebugDrafted") {
                    self.isDebugDrafted = dict["IsDebugDrafted"] as! Bool
                }
                if dict.keys.contains("IsDrafted") {
                    self.isDrafted = dict["IsDrafted"] as! Bool
                }
                if dict.keys.contains("IsPreset") {
                    self.isPreset = dict["IsPreset"] as! Bool
                }
                if dict.keys.contains("LongWaitEnable") {
                    self.longWaitEnable = dict["LongWaitEnable"] as! Bool
                }
                if dict.keys.contains("MiniPlaybackEnable") {
                    self.miniPlaybackEnable = dict["MiniPlaybackEnable"] as! Bool
                }
                if dict.keys.contains("NewBargeInEnable") {
                    self.newBargeInEnable = dict["NewBargeInEnable"] as! Bool
                }
                if dict.keys.contains("RejectReason") {
                    self.rejectReason = dict["RejectReason"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("ScriptDescription") {
                    self.scriptDescription = dict["ScriptDescription"] as! String
                }
                if dict.keys.contains("ScriptId") {
                    self.scriptId = dict["ScriptId"] as! String
                }
                if dict.keys.contains("ScriptName") {
                    self.scriptName = dict["ScriptName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var list: [ListScriptsResponseBody.Scripts.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [ListScriptsResponseBody.Scripts.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scripts: ListScriptsResponseBody.Scripts?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scripts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scripts != nil {
            map["Scripts"] = self.scripts?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Scripts") {
            var model = ListScriptsResponseBody.Scripts()
            model.fromMap(dict["Scripts"] as! [String: Any])
            self.scripts = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListScriptsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScriptsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListScriptsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var nextToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ListTagResourcesRequest.Tag]
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagResources") {
            self.tagResources = dict["TagResources"] as! [ListTagResourcesResponseBody.TagResources]
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class ListTagsResponseBody : Tea.TeaModel {
    public class TagGroups : Tea.TeaModel {
        public var scriptId: String?

        public var tagGroup: String?

        public var tagGroupId: String?

        public var tagGroupIndex: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.tagGroup != nil {
                map["TagGroup"] = self.tagGroup!
            }
            if self.tagGroupId != nil {
                map["TagGroupId"] = self.tagGroupId!
            }
            if self.tagGroupIndex != nil {
                map["TagGroupIndex"] = self.tagGroupIndex!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("TagGroup") {
                self.tagGroup = dict["TagGroup"] as! String
            }
            if dict.keys.contains("TagGroupId") {
                self.tagGroupId = dict["TagGroupId"] as! String
            }
            if dict.keys.contains("TagGroupIndex") {
                self.tagGroupIndex = dict["TagGroupIndex"] as! Int32
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var scriptId: String?

        public var tagGroup: String?

        public var tagId: String?

        public var tagIndex: Int32?

        public var tagName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.tagGroup != nil {
                map["TagGroup"] = self.tagGroup!
            }
            if self.tagId != nil {
                map["TagId"] = self.tagId!
            }
            if self.tagIndex != nil {
                map["TagIndex"] = self.tagIndex!
            }
            if self.tagName != nil {
                map["TagName"] = self.tagName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("TagGroup") {
                self.tagGroup = dict["TagGroup"] as! String
            }
            if dict.keys.contains("TagId") {
                self.tagId = dict["TagId"] as! String
            }
            if dict.keys.contains("TagIndex") {
                self.tagIndex = dict["TagIndex"] as! Int32
            }
            if dict.keys.contains("TagName") {
                self.tagName = dict["TagName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var tagGroups: [ListTagsResponseBody.TagGroups]?

    public var tags: [ListTagsResponseBody.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagGroups != nil {
            var tmp : [Any] = []
            for k in self.tagGroups! {
                tmp.append(k.toMap())
            }
            map["TagGroups"] = tmp
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagGroups") {
            self.tagGroups = dict["TagGroups"] as! [ListTagsResponseBody.TagGroups]
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! [ListTagsResponseBody.Tags]
        }
    }
}

public class ListTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBatchJobsRequest : Tea.TeaModel {
    public var batchJobName: String?

    public var callingNumber: [String]?

    public var description_: String?

    public var instanceId: String?

    public var jobFilePath: String?

    public var jobGroupId: String?

    public var scenarioId: String?

    public var scriptId: String?

    public var strategyJson: String?

    public var submitted: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchJobName != nil {
            map["BatchJobName"] = self.batchJobName!
        }
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobFilePath != nil {
            map["JobFilePath"] = self.jobFilePath!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.strategyJson != nil {
            map["StrategyJson"] = self.strategyJson!
        }
        if self.submitted != nil {
            map["Submitted"] = self.submitted!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchJobName") {
            self.batchJobName = dict["BatchJobName"] as! String
        }
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! [String]
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobFilePath") {
            self.jobFilePath = dict["JobFilePath"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("StrategyJson") {
            self.strategyJson = dict["StrategyJson"] as! String
        }
        if dict.keys.contains("Submitted") {
            self.submitted = dict["Submitted"] as! Bool
        }
    }
}

public class ModifyBatchJobsResponseBody : Tea.TeaModel {
    public class JobGroup : Tea.TeaModel {
        public class Strategy : Tea.TeaModel {
            public class WorkingTime : Tea.TeaModel {
                public var beginTime: String?

                public var endTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.beginTime != nil {
                        map["BeginTime"] = self.beginTime!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BeginTime") {
                        self.beginTime = dict["BeginTime"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                }
            }
            public var customized: String?

            public var endTime: Int64?

            public var followUpStrategy: String?

            public var isTemplate: Bool?

            public var maxAttemptsPerDay: Int32?

            public var minAttemptInterval: Int32?

            public var repeatBy: String?

            public var repeatDays: [String]?

            public var routingStrategy: String?

            public var startTime: Int64?

            public var strategyDescription: String?

            public var strategyId: String?

            public var strategyName: String?

            public var type: String?

            public var workingTime: [ModifyBatchJobsResponseBody.JobGroup.Strategy.WorkingTime]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customized != nil {
                    map["Customized"] = self.customized!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.followUpStrategy != nil {
                    map["FollowUpStrategy"] = self.followUpStrategy!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.maxAttemptsPerDay != nil {
                    map["MaxAttemptsPerDay"] = self.maxAttemptsPerDay!
                }
                if self.minAttemptInterval != nil {
                    map["MinAttemptInterval"] = self.minAttemptInterval!
                }
                if self.repeatBy != nil {
                    map["RepeatBy"] = self.repeatBy!
                }
                if self.repeatDays != nil {
                    map["RepeatDays"] = self.repeatDays!
                }
                if self.routingStrategy != nil {
                    map["RoutingStrategy"] = self.routingStrategy!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.strategyDescription != nil {
                    map["StrategyDescription"] = self.strategyDescription!
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workingTime != nil {
                    var tmp : [Any] = []
                    for k in self.workingTime! {
                        tmp.append(k.toMap())
                    }
                    map["WorkingTime"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Customized") {
                    self.customized = dict["Customized"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("FollowUpStrategy") {
                    self.followUpStrategy = dict["FollowUpStrategy"] as! String
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("MaxAttemptsPerDay") {
                    self.maxAttemptsPerDay = dict["MaxAttemptsPerDay"] as! Int32
                }
                if dict.keys.contains("MinAttemptInterval") {
                    self.minAttemptInterval = dict["MinAttemptInterval"] as! Int32
                }
                if dict.keys.contains("RepeatBy") {
                    self.repeatBy = dict["RepeatBy"] as! String
                }
                if dict.keys.contains("RepeatDays") {
                    self.repeatDays = dict["RepeatDays"] as! [String]
                }
                if dict.keys.contains("RoutingStrategy") {
                    self.routingStrategy = dict["RoutingStrategy"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("StrategyDescription") {
                    self.strategyDescription = dict["StrategyDescription"] as! String
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("StrategyName") {
                    self.strategyName = dict["StrategyName"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkingTime") {
                    self.workingTime = dict["WorkingTime"] as! [ModifyBatchJobsResponseBody.JobGroup.Strategy.WorkingTime]
                }
            }
        }
        public var callingNumbers: [String]?

        public var creationTime: Int64?

        public var jobFilePath: String?

        public var jobGroupDescription: String?

        public var jobGroupId: String?

        public var jobGroupName: String?

        public var scenarioId: String?

        public var strategy: ModifyBatchJobsResponseBody.JobGroup.Strategy?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.strategy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callingNumbers != nil {
                map["CallingNumbers"] = self.callingNumbers!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.jobFilePath != nil {
                map["JobFilePath"] = self.jobFilePath!
            }
            if self.jobGroupDescription != nil {
                map["JobGroupDescription"] = self.jobGroupDescription!
            }
            if self.jobGroupId != nil {
                map["JobGroupId"] = self.jobGroupId!
            }
            if self.jobGroupName != nil {
                map["JobGroupName"] = self.jobGroupName!
            }
            if self.scenarioId != nil {
                map["ScenarioId"] = self.scenarioId!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallingNumbers") {
                self.callingNumbers = dict["CallingNumbers"] as! [String]
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("JobFilePath") {
                self.jobFilePath = dict["JobFilePath"] as! String
            }
            if dict.keys.contains("JobGroupDescription") {
                self.jobGroupDescription = dict["JobGroupDescription"] as! String
            }
            if dict.keys.contains("JobGroupId") {
                self.jobGroupId = dict["JobGroupId"] as! String
            }
            if dict.keys.contains("JobGroupName") {
                self.jobGroupName = dict["JobGroupName"] as! String
            }
            if dict.keys.contains("ScenarioId") {
                self.scenarioId = dict["ScenarioId"] as! String
            }
            if dict.keys.contains("Strategy") {
                var model = ModifyBatchJobsResponseBody.JobGroup.Strategy()
                model.fromMap(dict["Strategy"] as! [String: Any])
                self.strategy = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobGroup: ModifyBatchJobsResponseBody.JobGroup?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobGroup != nil {
            map["JobGroup"] = self.jobGroup?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobGroup") {
            var model = ModifyBatchJobsResponseBody.JobGroup()
            model.fromMap(dict["JobGroup"] as! [String: Any])
            self.jobGroup = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyBatchJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBatchJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyBatchJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDialogueFlowRequest : Tea.TeaModel {
    public var dialogueFlowDefinition: String?

    public var dialogueFlowId: String?

    public var instanceId: String?

    public var isDrafted: Bool?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dialogueFlowDefinition != nil {
            map["DialogueFlowDefinition"] = self.dialogueFlowDefinition!
        }
        if self.dialogueFlowId != nil {
            map["DialogueFlowId"] = self.dialogueFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isDrafted != nil {
            map["IsDrafted"] = self.isDrafted!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DialogueFlowDefinition") {
            self.dialogueFlowDefinition = dict["DialogueFlowDefinition"] as! String
        }
        if dict.keys.contains("DialogueFlowId") {
            self.dialogueFlowId = dict["DialogueFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsDrafted") {
            self.isDrafted = dict["IsDrafted"] as! Bool
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class ModifyDialogueFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var dialogueFlowDefinition: String?

    public var dialogueFlowId: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dialogueFlowDefinition != nil {
            map["DialogueFlowDefinition"] = self.dialogueFlowDefinition!
        }
        if self.dialogueFlowId != nil {
            map["DialogueFlowId"] = self.dialogueFlowId!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DialogueFlowDefinition") {
            self.dialogueFlowDefinition = dict["DialogueFlowDefinition"] as! String
        }
        if dict.keys.contains("DialogueFlowId") {
            self.dialogueFlowId = dict["DialogueFlowId"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyDialogueFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDialogueFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDialogueFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEmptyNumberNoMoreCallsInfoRequest : Tea.TeaModel {
    public var emptyNumberNoMoreCalls: Bool?

    public var entryId: String?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.emptyNumberNoMoreCalls != nil {
            map["EmptyNumberNoMoreCalls"] = self.emptyNumberNoMoreCalls!
        }
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EmptyNumberNoMoreCalls") {
            self.emptyNumberNoMoreCalls = dict["EmptyNumberNoMoreCalls"] as! Bool
        }
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class ModifyEmptyNumberNoMoreCallsInfoResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyEmptyNumberNoMoreCallsInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEmptyNumberNoMoreCallsInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEmptyNumberNoMoreCallsInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyGlobalQuestionRequest : Tea.TeaModel {
    public var answers: String?

    public var globalQuestionId: String?

    public var globalQuestionName: String?

    public var globalQuestionType: String?

    public var instanceId: String?

    public var questions: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.answers != nil {
            map["Answers"] = self.answers!
        }
        if self.globalQuestionId != nil {
            map["GlobalQuestionId"] = self.globalQuestionId!
        }
        if self.globalQuestionName != nil {
            map["GlobalQuestionName"] = self.globalQuestionName!
        }
        if self.globalQuestionType != nil {
            map["GlobalQuestionType"] = self.globalQuestionType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.questions != nil {
            map["Questions"] = self.questions!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Answers") {
            self.answers = dict["Answers"] as! String
        }
        if dict.keys.contains("GlobalQuestionId") {
            self.globalQuestionId = dict["GlobalQuestionId"] as! String
        }
        if dict.keys.contains("GlobalQuestionName") {
            self.globalQuestionName = dict["GlobalQuestionName"] as! String
        }
        if dict.keys.contains("GlobalQuestionType") {
            self.globalQuestionType = dict["GlobalQuestionType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Questions") {
            self.questions = dict["Questions"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class ModifyGlobalQuestionResponseBody : Tea.TeaModel {
    public var code: String?

    public var dialogueQuestionId: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dialogueQuestionId != nil {
            map["DialogueQuestionId"] = self.dialogueQuestionId!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DialogueQuestionId") {
            self.dialogueQuestionId = dict["DialogueQuestionId"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyGlobalQuestionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGlobalQuestionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyGlobalQuestionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceRequest : Tea.TeaModel {
    public var callingNumber: [String]?

    public var instanceDescription: String?

    public var instanceId: String?

    public var instanceName: String?

    public var maxConcurrentConversation: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.instanceDescription != nil {
            map["InstanceDescription"] = self.instanceDescription!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.maxConcurrentConversation != nil {
            map["MaxConcurrentConversation"] = self.maxConcurrentConversation!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! [String]
        }
        if dict.keys.contains("InstanceDescription") {
            self.instanceDescription = dict["InstanceDescription"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("MaxConcurrentConversation") {
            self.maxConcurrentConversation = dict["MaxConcurrentConversation"] as! Int32
        }
    }
}

public class ModifyInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public var creationTime: Int64?

        public var creatorId: Int64?

        public var creatorName: String?

        public var instanceDescription: String?

        public var instanceId: String?

        public var instanceName: String?

        public var maxConcurrentConversation: Int32?

        public var ownerName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.maxConcurrentConversation != nil {
                map["MaxConcurrentConversation"] = self.maxConcurrentConversation!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! Int64
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("InstanceDescription") {
                self.instanceDescription = dict["InstanceDescription"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("MaxConcurrentConversation") {
                self.maxConcurrentConversation = dict["MaxConcurrentConversation"] as! Int32
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var instance: ModifyInstanceResponseBody.Instance?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Instance") {
            var model = ModifyInstanceResponseBody.Instance()
            model.fromMap(dict["Instance"] as! [String: Any])
            self.instance = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIntentRequest : Tea.TeaModel {
    public var instanceId: String?

    public var intentDescription: String?

    public var intentId: String?

    public var intentName: String?

    public var keywords: String?

    public var scriptId: String?

    public var utterances: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.intentDescription != nil {
            map["IntentDescription"] = self.intentDescription!
        }
        if self.intentId != nil {
            map["IntentId"] = self.intentId!
        }
        if self.intentName != nil {
            map["IntentName"] = self.intentName!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.utterances != nil {
            map["Utterances"] = self.utterances!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IntentDescription") {
            self.intentDescription = dict["IntentDescription"] as! String
        }
        if dict.keys.contains("IntentId") {
            self.intentId = dict["IntentId"] as! String
        }
        if dict.keys.contains("IntentName") {
            self.intentName = dict["IntentName"] as! String
        }
        if dict.keys.contains("Keywords") {
            self.keywords = dict["Keywords"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("Utterances") {
            self.utterances = dict["Utterances"] as! String
        }
    }
}

public class ModifyIntentResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var intentId: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.intentId != nil {
            map["IntentId"] = self.intentId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("IntentId") {
            self.intentId = dict["IntentId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyIntentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIntentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIntentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyJobGroupRequest : Tea.TeaModel {
    public var callingNumber: [String]?

    public var description_: String?

    public var instanceId: String?

    public var jobGroupId: String?

    public var jobGroupStatus: String?

    public var minConcurrency: Int64?

    public var name: String?

    public var priority: String?

    public var recallStrategyJson: String?

    public var ringingDuration: Int64?

    public var scenarioId: String?

    public var scriptId: String?

    public var strategyJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobGroupStatus != nil {
            map["JobGroupStatus"] = self.jobGroupStatus!
        }
        if self.minConcurrency != nil {
            map["MinConcurrency"] = self.minConcurrency!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.recallStrategyJson != nil {
            map["RecallStrategyJson"] = self.recallStrategyJson!
        }
        if self.ringingDuration != nil {
            map["RingingDuration"] = self.ringingDuration!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.strategyJson != nil {
            map["StrategyJson"] = self.strategyJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! [String]
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobGroupStatus") {
            self.jobGroupStatus = dict["JobGroupStatus"] as! String
        }
        if dict.keys.contains("MinConcurrency") {
            self.minConcurrency = dict["MinConcurrency"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("RecallStrategyJson") {
            self.recallStrategyJson = dict["RecallStrategyJson"] as! String
        }
        if dict.keys.contains("RingingDuration") {
            self.ringingDuration = dict["RingingDuration"] as! Int64
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("StrategyJson") {
            self.strategyJson = dict["StrategyJson"] as! String
        }
    }
}

public class ModifyJobGroupResponseBody : Tea.TeaModel {
    public class JobGroup : Tea.TeaModel {
        public class ExportProgress : Tea.TeaModel {
            public var fileHttpUrl: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileHttpUrl != nil {
                    map["FileHttpUrl"] = self.fileHttpUrl!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileHttpUrl") {
                    self.fileHttpUrl = dict["FileHttpUrl"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class RecallStrategy : Tea.TeaModel {
            public var emptyNumberIgnore: Bool?

            public var inArrearsIgnore: Bool?

            public var outOfServiceIgnore: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.emptyNumberIgnore != nil {
                    map["EmptyNumberIgnore"] = self.emptyNumberIgnore!
                }
                if self.inArrearsIgnore != nil {
                    map["InArrearsIgnore"] = self.inArrearsIgnore!
                }
                if self.outOfServiceIgnore != nil {
                    map["OutOfServiceIgnore"] = self.outOfServiceIgnore!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EmptyNumberIgnore") {
                    self.emptyNumberIgnore = dict["EmptyNumberIgnore"] as! Bool
                }
                if dict.keys.contains("InArrearsIgnore") {
                    self.inArrearsIgnore = dict["InArrearsIgnore"] as! Bool
                }
                if dict.keys.contains("OutOfServiceIgnore") {
                    self.outOfServiceIgnore = dict["OutOfServiceIgnore"] as! Bool
                }
            }
        }
        public class Strategy : Tea.TeaModel {
            public class WorkingTime : Tea.TeaModel {
                public var beginTime: String?

                public var endTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.beginTime != nil {
                        map["BeginTime"] = self.beginTime!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BeginTime") {
                        self.beginTime = dict["BeginTime"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                }
            }
            public var customized: String?

            public var endTime: Int64?

            public var followUpStrategy: String?

            public var isTemplate: Bool?

            public var maxAttemptsPerDay: Int32?

            public var minAttemptInterval: Int32?

            public var repeatBy: String?

            public var repeatDays: [String]?

            public var routingStrategy: String?

            public var startTime: Int64?

            public var strategyDescription: String?

            public var strategyId: String?

            public var strategyName: String?

            public var type: String?

            public var workingTime: [ModifyJobGroupResponseBody.JobGroup.Strategy.WorkingTime]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customized != nil {
                    map["Customized"] = self.customized!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.followUpStrategy != nil {
                    map["FollowUpStrategy"] = self.followUpStrategy!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.maxAttemptsPerDay != nil {
                    map["MaxAttemptsPerDay"] = self.maxAttemptsPerDay!
                }
                if self.minAttemptInterval != nil {
                    map["MinAttemptInterval"] = self.minAttemptInterval!
                }
                if self.repeatBy != nil {
                    map["RepeatBy"] = self.repeatBy!
                }
                if self.repeatDays != nil {
                    map["RepeatDays"] = self.repeatDays!
                }
                if self.routingStrategy != nil {
                    map["RoutingStrategy"] = self.routingStrategy!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.strategyDescription != nil {
                    map["StrategyDescription"] = self.strategyDescription!
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.strategyName != nil {
                    map["StrategyName"] = self.strategyName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workingTime != nil {
                    var tmp : [Any] = []
                    for k in self.workingTime! {
                        tmp.append(k.toMap())
                    }
                    map["WorkingTime"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Customized") {
                    self.customized = dict["Customized"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("FollowUpStrategy") {
                    self.followUpStrategy = dict["FollowUpStrategy"] as! String
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("MaxAttemptsPerDay") {
                    self.maxAttemptsPerDay = dict["MaxAttemptsPerDay"] as! Int32
                }
                if dict.keys.contains("MinAttemptInterval") {
                    self.minAttemptInterval = dict["MinAttemptInterval"] as! Int32
                }
                if dict.keys.contains("RepeatBy") {
                    self.repeatBy = dict["RepeatBy"] as! String
                }
                if dict.keys.contains("RepeatDays") {
                    self.repeatDays = dict["RepeatDays"] as! [String]
                }
                if dict.keys.contains("RoutingStrategy") {
                    self.routingStrategy = dict["RoutingStrategy"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("StrategyDescription") {
                    self.strategyDescription = dict["StrategyDescription"] as! String
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("StrategyName") {
                    self.strategyName = dict["StrategyName"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkingTime") {
                    self.workingTime = dict["WorkingTime"] as! [ModifyJobGroupResponseBody.JobGroup.Strategy.WorkingTime]
                }
            }
        }
        public var callingNumbers: [String]?

        public var creationTime: Int64?

        public var exportProgress: ModifyJobGroupResponseBody.JobGroup.ExportProgress?

        public var jobDataParsingTaskId: String?

        public var jobFilePath: String?

        public var jobGroupDescription: String?

        public var jobGroupId: String?

        public var jobGroupName: String?

        public var minConcurrency: Int64?

        public var modifyTime: String?

        public var priority: String?

        public var recallStrategy: ModifyJobGroupResponseBody.JobGroup.RecallStrategy?

        public var ringingDuration: Int64?

        public var scenarioId: String?

        public var scriptName: String?

        public var scriptVersion: String?

        public var status: String?

        public var strategy: ModifyJobGroupResponseBody.JobGroup.Strategy?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.exportProgress?.validate()
            try self.recallStrategy?.validate()
            try self.strategy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callingNumbers != nil {
                map["CallingNumbers"] = self.callingNumbers!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.exportProgress != nil {
                map["ExportProgress"] = self.exportProgress?.toMap()
            }
            if self.jobDataParsingTaskId != nil {
                map["JobDataParsingTaskId"] = self.jobDataParsingTaskId!
            }
            if self.jobFilePath != nil {
                map["JobFilePath"] = self.jobFilePath!
            }
            if self.jobGroupDescription != nil {
                map["JobGroupDescription"] = self.jobGroupDescription!
            }
            if self.jobGroupId != nil {
                map["JobGroupId"] = self.jobGroupId!
            }
            if self.jobGroupName != nil {
                map["JobGroupName"] = self.jobGroupName!
            }
            if self.minConcurrency != nil {
                map["MinConcurrency"] = self.minConcurrency!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.recallStrategy != nil {
                map["RecallStrategy"] = self.recallStrategy?.toMap()
            }
            if self.ringingDuration != nil {
                map["RingingDuration"] = self.ringingDuration!
            }
            if self.scenarioId != nil {
                map["ScenarioId"] = self.scenarioId!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.scriptVersion != nil {
                map["ScriptVersion"] = self.scriptVersion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallingNumbers") {
                self.callingNumbers = dict["CallingNumbers"] as! [String]
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! Int64
            }
            if dict.keys.contains("ExportProgress") {
                var model = ModifyJobGroupResponseBody.JobGroup.ExportProgress()
                model.fromMap(dict["ExportProgress"] as! [String: Any])
                self.exportProgress = model
            }
            if dict.keys.contains("JobDataParsingTaskId") {
                self.jobDataParsingTaskId = dict["JobDataParsingTaskId"] as! String
            }
            if dict.keys.contains("JobFilePath") {
                self.jobFilePath = dict["JobFilePath"] as! String
            }
            if dict.keys.contains("JobGroupDescription") {
                self.jobGroupDescription = dict["JobGroupDescription"] as! String
            }
            if dict.keys.contains("JobGroupId") {
                self.jobGroupId = dict["JobGroupId"] as! String
            }
            if dict.keys.contains("JobGroupName") {
                self.jobGroupName = dict["JobGroupName"] as! String
            }
            if dict.keys.contains("MinConcurrency") {
                self.minConcurrency = dict["MinConcurrency"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("RecallStrategy") {
                var model = ModifyJobGroupResponseBody.JobGroup.RecallStrategy()
                model.fromMap(dict["RecallStrategy"] as! [String: Any])
                self.recallStrategy = model
            }
            if dict.keys.contains("RingingDuration") {
                self.ringingDuration = dict["RingingDuration"] as! Int64
            }
            if dict.keys.contains("ScenarioId") {
                self.scenarioId = dict["ScenarioId"] as! String
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("ScriptVersion") {
                self.scriptVersion = dict["ScriptVersion"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Strategy") {
                var model = ModifyJobGroupResponseBody.JobGroup.Strategy()
                model.fromMap(dict["Strategy"] as! [String: Any])
                self.strategy = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobGroup: ModifyJobGroupResponseBody.JobGroup?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobGroup != nil {
            map["JobGroup"] = self.jobGroup?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("JobGroup") {
            var model = ModifyJobGroupResponseBody.JobGroup()
            model.fromMap(dict["JobGroup"] as! [String: Any])
            self.jobGroup = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyJobGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyJobGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyJobGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyOutboundCallNumberRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public var outboundCallNumberId: String?

    public var rateLimitCount: Int32?

    public var rateLimitPeriod: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        if self.outboundCallNumberId != nil {
            map["OutboundCallNumberId"] = self.outboundCallNumberId!
        }
        if self.rateLimitCount != nil {
            map["RateLimitCount"] = self.rateLimitCount!
        }
        if self.rateLimitPeriod != nil {
            map["RateLimitPeriod"] = self.rateLimitPeriod!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
        if dict.keys.contains("OutboundCallNumberId") {
            self.outboundCallNumberId = dict["OutboundCallNumberId"] as! String
        }
        if dict.keys.contains("RateLimitCount") {
            self.rateLimitCount = dict["RateLimitCount"] as! Int32
        }
        if dict.keys.contains("RateLimitPeriod") {
            self.rateLimitPeriod = dict["RateLimitPeriod"] as! Int32
        }
    }
}

public class ModifyOutboundCallNumberResponseBody : Tea.TeaModel {
    public class OutboundCallNumber : Tea.TeaModel {
        public var number: String?

        public var outboundCallNumberId: String?

        public var rateLimitCount: String?

        public var rateLimitPeriod: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.number != nil {
                map["Number"] = self.number!
            }
            if self.outboundCallNumberId != nil {
                map["OutboundCallNumberId"] = self.outboundCallNumberId!
            }
            if self.rateLimitCount != nil {
                map["RateLimitCount"] = self.rateLimitCount!
            }
            if self.rateLimitPeriod != nil {
                map["RateLimitPeriod"] = self.rateLimitPeriod!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Number") {
                self.number = dict["Number"] as! String
            }
            if dict.keys.contains("OutboundCallNumberId") {
                self.outboundCallNumberId = dict["OutboundCallNumberId"] as! String
            }
            if dict.keys.contains("RateLimitCount") {
                self.rateLimitCount = dict["RateLimitCount"] as! String
            }
            if dict.keys.contains("RateLimitPeriod") {
                self.rateLimitPeriod = dict["RateLimitPeriod"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var outboundCallNumber: ModifyOutboundCallNumberResponseBody.OutboundCallNumber?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.outboundCallNumber?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.outboundCallNumber != nil {
            map["OutboundCallNumber"] = self.outboundCallNumber?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OutboundCallNumber") {
            var model = ModifyOutboundCallNumberResponseBody.OutboundCallNumber()
            model.fromMap(dict["OutboundCallNumber"] as! [String: Any])
            self.outboundCallNumber = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyOutboundCallNumberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyOutboundCallNumberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyOutboundCallNumberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScriptRequest : Tea.TeaModel {
    public var asrConfig: String?

    public var chatbotId: String?

    public var emotionEnable: Bool?

    public var industry: String?

    public var instanceId: String?

    public var longWaitEnable: Bool?

    public var miniPlaybackConfigListJsonString: String?

    public var miniPlaybackEnable: Bool?

    public var newBargeInEnable: Bool?

    public var nlsConfig: String?

    public var scene: String?

    public var scriptContent: [String]?

    public var scriptDescription: String?

    public var scriptId: String?

    public var scriptName: String?

    public var scriptWaveform: [String]?

    public var ttsConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asrConfig != nil {
            map["AsrConfig"] = self.asrConfig!
        }
        if self.chatbotId != nil {
            map["ChatbotId"] = self.chatbotId!
        }
        if self.emotionEnable != nil {
            map["EmotionEnable"] = self.emotionEnable!
        }
        if self.industry != nil {
            map["Industry"] = self.industry!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.longWaitEnable != nil {
            map["LongWaitEnable"] = self.longWaitEnable!
        }
        if self.miniPlaybackConfigListJsonString != nil {
            map["MiniPlaybackConfigListJsonString"] = self.miniPlaybackConfigListJsonString!
        }
        if self.miniPlaybackEnable != nil {
            map["MiniPlaybackEnable"] = self.miniPlaybackEnable!
        }
        if self.newBargeInEnable != nil {
            map["NewBargeInEnable"] = self.newBargeInEnable!
        }
        if self.nlsConfig != nil {
            map["NlsConfig"] = self.nlsConfig!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.scriptContent != nil {
            map["ScriptContent"] = self.scriptContent!
        }
        if self.scriptDescription != nil {
            map["ScriptDescription"] = self.scriptDescription!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.scriptName != nil {
            map["ScriptName"] = self.scriptName!
        }
        if self.scriptWaveform != nil {
            map["ScriptWaveform"] = self.scriptWaveform!
        }
        if self.ttsConfig != nil {
            map["TtsConfig"] = self.ttsConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsrConfig") {
            self.asrConfig = dict["AsrConfig"] as! String
        }
        if dict.keys.contains("ChatbotId") {
            self.chatbotId = dict["ChatbotId"] as! String
        }
        if dict.keys.contains("EmotionEnable") {
            self.emotionEnable = dict["EmotionEnable"] as! Bool
        }
        if dict.keys.contains("Industry") {
            self.industry = dict["Industry"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LongWaitEnable") {
            self.longWaitEnable = dict["LongWaitEnable"] as! Bool
        }
        if dict.keys.contains("MiniPlaybackConfigListJsonString") {
            self.miniPlaybackConfigListJsonString = dict["MiniPlaybackConfigListJsonString"] as! String
        }
        if dict.keys.contains("MiniPlaybackEnable") {
            self.miniPlaybackEnable = dict["MiniPlaybackEnable"] as! Bool
        }
        if dict.keys.contains("NewBargeInEnable") {
            self.newBargeInEnable = dict["NewBargeInEnable"] as! Bool
        }
        if dict.keys.contains("NlsConfig") {
            self.nlsConfig = dict["NlsConfig"] as! String
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
        if dict.keys.contains("ScriptContent") {
            self.scriptContent = dict["ScriptContent"] as! [String]
        }
        if dict.keys.contains("ScriptDescription") {
            self.scriptDescription = dict["ScriptDescription"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("ScriptName") {
            self.scriptName = dict["ScriptName"] as! String
        }
        if dict.keys.contains("ScriptWaveform") {
            self.scriptWaveform = dict["ScriptWaveform"] as! [String]
        }
        if dict.keys.contains("TtsConfig") {
            self.ttsConfig = dict["TtsConfig"] as! String
        }
    }
}

public class ModifyScriptResponseBody : Tea.TeaModel {
    public class Script : Tea.TeaModel {
        public var debugStatus: String?

        public var industry: String?

        public var isDebugDrafted: Bool?

        public var isDrafted: Bool?

        public var scene: String?

        public var scriptDescription: String?

        public var scriptId: String?

        public var scriptName: String?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.debugStatus != nil {
                map["DebugStatus"] = self.debugStatus!
            }
            if self.industry != nil {
                map["Industry"] = self.industry!
            }
            if self.isDebugDrafted != nil {
                map["IsDebugDrafted"] = self.isDebugDrafted!
            }
            if self.isDrafted != nil {
                map["IsDrafted"] = self.isDrafted!
            }
            if self.scene != nil {
                map["Scene"] = self.scene!
            }
            if self.scriptDescription != nil {
                map["ScriptDescription"] = self.scriptDescription!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DebugStatus") {
                self.debugStatus = dict["DebugStatus"] as! String
            }
            if dict.keys.contains("Industry") {
                self.industry = dict["Industry"] as! String
            }
            if dict.keys.contains("IsDebugDrafted") {
                self.isDebugDrafted = dict["IsDebugDrafted"] as! Bool
            }
            if dict.keys.contains("IsDrafted") {
                self.isDrafted = dict["IsDrafted"] as! Bool
            }
            if dict.keys.contains("Scene") {
                self.scene = dict["Scene"] as! String
            }
            if dict.keys.contains("ScriptDescription") {
                self.scriptDescription = dict["ScriptDescription"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var script: ModifyScriptResponseBody.Script?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.script?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.script != nil {
            map["Script"] = self.script?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Script") {
            var model = ModifyScriptResponseBody.Script()
            model.fromMap(dict["Script"] as! [String: Any])
            self.script = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScriptVoiceConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public var scriptVoiceConfigId: String?

    public var scriptWaveformRelation: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.scriptVoiceConfigId != nil {
            map["ScriptVoiceConfigId"] = self.scriptVoiceConfigId!
        }
        if self.scriptWaveformRelation != nil {
            map["ScriptWaveformRelation"] = self.scriptWaveformRelation!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("ScriptVoiceConfigId") {
            self.scriptVoiceConfigId = dict["ScriptVoiceConfigId"] as! String
        }
        if dict.keys.contains("ScriptWaveformRelation") {
            self.scriptWaveformRelation = dict["ScriptWaveformRelation"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ModifyScriptVoiceConfigResponseBody : Tea.TeaModel {
    public class ScriptVoiceConfig : Tea.TeaModel {
        public var instanceId: String?

        public var scriptContent: String?

        public var scriptId: String?

        public var scriptVoiceConfigId: String?

        public var scriptWaveformRelation: String?

        public var source: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.scriptContent != nil {
                map["ScriptContent"] = self.scriptContent!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptVoiceConfigId != nil {
                map["ScriptVoiceConfigId"] = self.scriptVoiceConfigId!
            }
            if self.scriptWaveformRelation != nil {
                map["ScriptWaveformRelation"] = self.scriptWaveformRelation!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("ScriptContent") {
                self.scriptContent = dict["ScriptContent"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptVoiceConfigId") {
                self.scriptVoiceConfigId = dict["ScriptVoiceConfigId"] as! String
            }
            if dict.keys.contains("ScriptWaveformRelation") {
                self.scriptWaveformRelation = dict["ScriptWaveformRelation"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scriptVoiceConfig: ModifyScriptVoiceConfigResponseBody.ScriptVoiceConfig?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scriptVoiceConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptVoiceConfig != nil {
            map["ScriptVoiceConfig"] = self.scriptVoiceConfig?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptVoiceConfig") {
            var model = ModifyScriptVoiceConfigResponseBody.ScriptVoiceConfig()
            model.fromMap(dict["ScriptVoiceConfig"] as! [String: Any])
            self.scriptVoiceConfig = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyScriptVoiceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScriptVoiceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyScriptVoiceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTTSConfigRequest : Tea.TeaModel {
    public var appKey: String?

    public var instanceId: String?

    public var nlsServiceType: String?

    public var scriptId: String?

    public var speechRate: String?

    public var voice: String?

    public var volume: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nlsServiceType != nil {
            map["NlsServiceType"] = self.nlsServiceType!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.speechRate != nil {
            map["SpeechRate"] = self.speechRate!
        }
        if self.voice != nil {
            map["Voice"] = self.voice!
        }
        if self.volume != nil {
            map["Volume"] = self.volume!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKey") {
            self.appKey = dict["AppKey"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NlsServiceType") {
            self.nlsServiceType = dict["NlsServiceType"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("SpeechRate") {
            self.speechRate = dict["SpeechRate"] as! String
        }
        if dict.keys.contains("Voice") {
            self.voice = dict["Voice"] as! String
        }
        if dict.keys.contains("Volume") {
            self.volume = dict["Volume"] as! String
        }
    }
}

public class ModifyTTSConfigResponseBody : Tea.TeaModel {
    public class TTSConfig : Tea.TeaModel {
        public var instanceId: String?

        public var scriptId: String?

        public var speechRate: String?

        public var TTSConfigId: String?

        public var voice: String?

        public var volume: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.speechRate != nil {
                map["SpeechRate"] = self.speechRate!
            }
            if self.TTSConfigId != nil {
                map["TTSConfigId"] = self.TTSConfigId!
            }
            if self.voice != nil {
                map["Voice"] = self.voice!
            }
            if self.volume != nil {
                map["Volume"] = self.volume!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("SpeechRate") {
                self.speechRate = dict["SpeechRate"] as! String
            }
            if dict.keys.contains("TTSConfigId") {
                self.TTSConfigId = dict["TTSConfigId"] as! String
            }
            if dict.keys.contains("Voice") {
                self.voice = dict["Voice"] as! String
            }
            if dict.keys.contains("Volume") {
                self.volume = dict["Volume"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var TTSConfig: ModifyTTSConfigResponseBody.TTSConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.TTSConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.TTSConfig != nil {
            map["TTSConfig"] = self.TTSConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TTSConfig") {
            var model = ModifyTTSConfigResponseBody.TTSConfig()
            model.fromMap(dict["TTSConfig"] as! [String: Any])
            self.TTSConfig = model
        }
    }
}

public class ModifyTTSConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTTSConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTTSConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTagGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public var tagGroups: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        if self.tagGroups != nil {
            map["TagGroups"] = self.tagGroups!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
        if dict.keys.contains("TagGroups") {
            self.tagGroups = dict["TagGroups"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class ModifyTagGroupsResponseBody : Tea.TeaModel {
    public class TagGroups : Tea.TeaModel {
        public var scriptId: String?

        public var tagGroup: String?

        public var tagGroupId: String?

        public var tagGroupIndex: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.tagGroup != nil {
                map["TagGroup"] = self.tagGroup!
            }
            if self.tagGroupId != nil {
                map["TagGroupId"] = self.tagGroupId!
            }
            if self.tagGroupIndex != nil {
                map["TagGroupIndex"] = self.tagGroupIndex!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("TagGroup") {
                self.tagGroup = dict["TagGroup"] as! String
            }
            if dict.keys.contains("TagGroupId") {
                self.tagGroupId = dict["TagGroupId"] as! String
            }
            if dict.keys.contains("TagGroupIndex") {
                self.tagGroupIndex = dict["TagGroupIndex"] as! Int32
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var scriptId: String?

        public var tagGroup: String?

        public var tagId: String?

        public var tagIndex: Int32?

        public var tagName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.tagGroup != nil {
                map["TagGroup"] = self.tagGroup!
            }
            if self.tagId != nil {
                map["TagId"] = self.tagId!
            }
            if self.tagIndex != nil {
                map["TagIndex"] = self.tagIndex!
            }
            if self.tagName != nil {
                map["TagName"] = self.tagName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("TagGroup") {
                self.tagGroup = dict["TagGroup"] as! String
            }
            if dict.keys.contains("TagId") {
                self.tagId = dict["TagId"] as! String
            }
            if dict.keys.contains("TagIndex") {
                self.tagIndex = dict["TagIndex"] as! Int32
            }
            if dict.keys.contains("TagName") {
                self.tagName = dict["TagName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var tagGroups: [ModifyTagGroupsResponseBody.TagGroups]?

    public var tags: [ModifyTagGroupsResponseBody.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tagGroups != nil {
            var tmp : [Any] = []
            for k in self.tagGroups! {
                tmp.append(k.toMap())
            }
            map["TagGroups"] = tmp
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TagGroups") {
            self.tagGroups = dict["TagGroups"] as! [ModifyTagGroupsResponseBody.TagGroups]
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! [ModifyTagGroupsResponseBody.Tags]
        }
    }
}

public class ModifyTagGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTagGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTagGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishScriptRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class PublishScriptResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PublishScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PublishScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishScriptForDebugRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class PublishScriptForDebugResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PublishScriptForDebugResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishScriptForDebugResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PublishScriptForDebugResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryJobsRequest : Tea.TeaModel {
    public var contactName: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var jobGroupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var phoneNumber: String?

    public var scenarioId: String?

    public var startTime: Int64?

    public var timeAlignment: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.timeAlignment != nil {
            map["TimeAlignment"] = self.timeAlignment!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PhoneNumber") {
            self.phoneNumber = dict["PhoneNumber"] as! String
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TimeAlignment") {
            self.timeAlignment = dict["TimeAlignment"] as! String
        }
    }
}

public class QueryJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Contacts : Tea.TeaModel {
                public var contactId: String?

                public var contactName: String?

                public var honorific: String?

                public var jobId: String?

                public var phoneNumber: String?

                public var referenceId: String?

                public var role: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.contactId != nil {
                        map["ContactId"] = self.contactId!
                    }
                    if self.contactName != nil {
                        map["ContactName"] = self.contactName!
                    }
                    if self.honorific != nil {
                        map["Honorific"] = self.honorific!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.phoneNumber != nil {
                        map["PhoneNumber"] = self.phoneNumber!
                    }
                    if self.referenceId != nil {
                        map["ReferenceId"] = self.referenceId!
                    }
                    if self.role != nil {
                        map["Role"] = self.role!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContactId") {
                        self.contactId = dict["ContactId"] as! String
                    }
                    if dict.keys.contains("ContactName") {
                        self.contactName = dict["ContactName"] as! String
                    }
                    if dict.keys.contains("Honorific") {
                        self.honorific = dict["Honorific"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("PhoneNumber") {
                        self.phoneNumber = dict["PhoneNumber"] as! String
                    }
                    if dict.keys.contains("ReferenceId") {
                        self.referenceId = dict["ReferenceId"] as! String
                    }
                    if dict.keys.contains("Role") {
                        self.role = dict["Role"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                }
            }
            public class Extras : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Summary : Tea.TeaModel {
                public var category: String?

                public var content: String?

                public var conversationDetailId: String?

                public var groupId: String?

                public var jobId: String?

                public var summaryId: String?

                public var summaryName: String?

                public var taskId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.content != nil {
                        map["Content"] = self.content!
                    }
                    if self.conversationDetailId != nil {
                        map["ConversationDetailId"] = self.conversationDetailId!
                    }
                    if self.groupId != nil {
                        map["GroupId"] = self.groupId!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.summaryId != nil {
                        map["SummaryId"] = self.summaryId!
                    }
                    if self.summaryName != nil {
                        map["SummaryName"] = self.summaryName!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("Content") {
                        self.content = dict["Content"] as! String
                    }
                    if dict.keys.contains("ConversationDetailId") {
                        self.conversationDetailId = dict["ConversationDetailId"] as! String
                    }
                    if dict.keys.contains("GroupId") {
                        self.groupId = dict["GroupId"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("SummaryId") {
                        self.summaryId = dict["SummaryId"] as! String
                    }
                    if dict.keys.contains("SummaryName") {
                        self.summaryName = dict["SummaryName"] as! String
                    }
                    if dict.keys.contains("TaskId") {
                        self.taskId = dict["TaskId"] as! String
                    }
                }
            }
            public class Tasks : Tea.TeaModel {
                public class Contact : Tea.TeaModel {
                    public var contactId: String?

                    public var contactName: String?

                    public var honorific: String?

                    public var jobId: String?

                    public var phoneNumber: String?

                    public var referenceId: String?

                    public var role: String?

                    public var state: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.contactId != nil {
                            map["ContactId"] = self.contactId!
                        }
                        if self.contactName != nil {
                            map["ContactName"] = self.contactName!
                        }
                        if self.honorific != nil {
                            map["Honorific"] = self.honorific!
                        }
                        if self.jobId != nil {
                            map["JobId"] = self.jobId!
                        }
                        if self.phoneNumber != nil {
                            map["PhoneNumber"] = self.phoneNumber!
                        }
                        if self.referenceId != nil {
                            map["ReferenceId"] = self.referenceId!
                        }
                        if self.role != nil {
                            map["Role"] = self.role!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ContactId") {
                            self.contactId = dict["ContactId"] as! String
                        }
                        if dict.keys.contains("ContactName") {
                            self.contactName = dict["ContactName"] as! String
                        }
                        if dict.keys.contains("Honorific") {
                            self.honorific = dict["Honorific"] as! String
                        }
                        if dict.keys.contains("JobId") {
                            self.jobId = dict["JobId"] as! String
                        }
                        if dict.keys.contains("PhoneNumber") {
                            self.phoneNumber = dict["PhoneNumber"] as! String
                        }
                        if dict.keys.contains("ReferenceId") {
                            self.referenceId = dict["ReferenceId"] as! String
                        }
                        if dict.keys.contains("Role") {
                            self.role = dict["Role"] as! String
                        }
                        if dict.keys.contains("State") {
                            self.state = dict["State"] as! String
                        }
                    }
                }
                public var actualTime: Int64?

                public var brief: String?

                public var callId: String?

                public var calledNumber: String?

                public var callingNumber: String?

                public var chatbotId: String?

                public var contact: QueryJobsResponseBody.Jobs.List.Tasks.Contact?

                public var duration: Int32?

                public var jobId: String?

                public var planedTime: Int64?

                public var scenarioId: String?

                public var status: String?

                public var taskId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.contact?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.actualTime != nil {
                        map["ActualTime"] = self.actualTime!
                    }
                    if self.brief != nil {
                        map["Brief"] = self.brief!
                    }
                    if self.callId != nil {
                        map["CallId"] = self.callId!
                    }
                    if self.calledNumber != nil {
                        map["CalledNumber"] = self.calledNumber!
                    }
                    if self.callingNumber != nil {
                        map["CallingNumber"] = self.callingNumber!
                    }
                    if self.chatbotId != nil {
                        map["ChatbotId"] = self.chatbotId!
                    }
                    if self.contact != nil {
                        map["Contact"] = self.contact?.toMap()
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.planedTime != nil {
                        map["PlanedTime"] = self.planedTime!
                    }
                    if self.scenarioId != nil {
                        map["ScenarioId"] = self.scenarioId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActualTime") {
                        self.actualTime = dict["ActualTime"] as! Int64
                    }
                    if dict.keys.contains("Brief") {
                        self.brief = dict["Brief"] as! String
                    }
                    if dict.keys.contains("CallId") {
                        self.callId = dict["CallId"] as! String
                    }
                    if dict.keys.contains("CalledNumber") {
                        self.calledNumber = dict["CalledNumber"] as! String
                    }
                    if dict.keys.contains("CallingNumber") {
                        self.callingNumber = dict["CallingNumber"] as! String
                    }
                    if dict.keys.contains("ChatbotId") {
                        self.chatbotId = dict["ChatbotId"] as! String
                    }
                    if dict.keys.contains("Contact") {
                        var model = QueryJobsResponseBody.Jobs.List.Tasks.Contact()
                        model.fromMap(dict["Contact"] as! [String: Any])
                        self.contact = model
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("PlanedTime") {
                        self.planedTime = dict["PlanedTime"] as! Int64
                    }
                    if dict.keys.contains("ScenarioId") {
                        self.scenarioId = dict["ScenarioId"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("TaskId") {
                        self.taskId = dict["TaskId"] as! String
                    }
                }
            }
            public var callingNumbers: [String]?

            public var contacts: [QueryJobsResponseBody.Jobs.List.Contacts]?

            public var extras: [QueryJobsResponseBody.Jobs.List.Extras]?

            public var failureReason: String?

            public var jobGroupId: String?

            public var jobId: String?

            public var priority: Int32?

            public var referenceId: String?

            public var scenarioId: String?

            public var status: String?

            public var strategyId: String?

            public var summary: [QueryJobsResponseBody.Jobs.List.Summary]?

            public var tasks: [QueryJobsResponseBody.Jobs.List.Tasks]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callingNumbers != nil {
                    map["CallingNumbers"] = self.callingNumbers!
                }
                if self.contacts != nil {
                    var tmp : [Any] = []
                    for k in self.contacts! {
                        tmp.append(k.toMap())
                    }
                    map["Contacts"] = tmp
                }
                if self.extras != nil {
                    var tmp : [Any] = []
                    for k in self.extras! {
                        tmp.append(k.toMap())
                    }
                    map["Extras"] = tmp
                }
                if self.failureReason != nil {
                    map["FailureReason"] = self.failureReason!
                }
                if self.jobGroupId != nil {
                    map["JobGroupId"] = self.jobGroupId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.referenceId != nil {
                    map["ReferenceId"] = self.referenceId!
                }
                if self.scenarioId != nil {
                    map["ScenarioId"] = self.scenarioId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.strategyId != nil {
                    map["StrategyId"] = self.strategyId!
                }
                if self.summary != nil {
                    var tmp : [Any] = []
                    for k in self.summary! {
                        tmp.append(k.toMap())
                    }
                    map["Summary"] = tmp
                }
                if self.tasks != nil {
                    var tmp : [Any] = []
                    for k in self.tasks! {
                        tmp.append(k.toMap())
                    }
                    map["Tasks"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallingNumbers") {
                    self.callingNumbers = dict["CallingNumbers"] as! [String]
                }
                if dict.keys.contains("Contacts") {
                    self.contacts = dict["Contacts"] as! [QueryJobsResponseBody.Jobs.List.Contacts]
                }
                if dict.keys.contains("Extras") {
                    self.extras = dict["Extras"] as! [QueryJobsResponseBody.Jobs.List.Extras]
                }
                if dict.keys.contains("FailureReason") {
                    self.failureReason = dict["FailureReason"] as! String
                }
                if dict.keys.contains("JobGroupId") {
                    self.jobGroupId = dict["JobGroupId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ReferenceId") {
                    self.referenceId = dict["ReferenceId"] as! String
                }
                if dict.keys.contains("ScenarioId") {
                    self.scenarioId = dict["ScenarioId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StrategyId") {
                    self.strategyId = dict["StrategyId"] as! String
                }
                if dict.keys.contains("Summary") {
                    self.summary = dict["Summary"] as! [QueryJobsResponseBody.Jobs.List.Summary]
                }
                if dict.keys.contains("Tasks") {
                    self.tasks = dict["Tasks"] as! [QueryJobsResponseBody.Jobs.List.Tasks]
                }
            }
        }
        public var list: [QueryJobsResponseBody.Jobs.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [QueryJobsResponseBody.Jobs.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobs: QueryJobsResponseBody.Jobs?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobs != nil {
            map["Jobs"] = self.jobs?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Jobs") {
            var model = QueryJobsResponseBody.Jobs()
            model.fromMap(dict["Jobs"] as! [String: Any])
            self.jobs = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryJobsWithResultRequest : Tea.TeaModel {
    public var hasAnsweredFilter: Bool?

    public var hasHangUpByRejectionFilter: Bool?

    public var hasReachedEndOfFlowFilter: Bool?

    public var instanceId: String?

    public var jobGroupId: String?

    public var jobStatusFilter: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var queryText: String?

    public var taskStatusFilter: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hasAnsweredFilter != nil {
            map["HasAnsweredFilter"] = self.hasAnsweredFilter!
        }
        if self.hasHangUpByRejectionFilter != nil {
            map["HasHangUpByRejectionFilter"] = self.hasHangUpByRejectionFilter!
        }
        if self.hasReachedEndOfFlowFilter != nil {
            map["HasReachedEndOfFlowFilter"] = self.hasReachedEndOfFlowFilter!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobStatusFilter != nil {
            map["JobStatusFilter"] = self.jobStatusFilter!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryText != nil {
            map["QueryText"] = self.queryText!
        }
        if self.taskStatusFilter != nil {
            map["TaskStatusFilter"] = self.taskStatusFilter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HasAnsweredFilter") {
            self.hasAnsweredFilter = dict["HasAnsweredFilter"] as! Bool
        }
        if dict.keys.contains("HasHangUpByRejectionFilter") {
            self.hasHangUpByRejectionFilter = dict["HasHangUpByRejectionFilter"] as! Bool
        }
        if dict.keys.contains("HasReachedEndOfFlowFilter") {
            self.hasReachedEndOfFlowFilter = dict["HasReachedEndOfFlowFilter"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobStatusFilter") {
            self.jobStatusFilter = dict["JobStatusFilter"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueryText") {
            self.queryText = dict["QueryText"] as! String
        }
        if dict.keys.contains("TaskStatusFilter") {
            self.taskStatusFilter = dict["TaskStatusFilter"] as! String
        }
    }
}

public class QueryJobsWithResultResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class LatestTask : Tea.TeaModel {
                public class Contact : Tea.TeaModel {
                    public var honorific: String?

                    public var id: String?

                    public var jobUuid: String?

                    public var name: String?

                    public var phoneNumber: String?

                    public var preferredPhoneNumber: String?

                    public var referenceId: String?

                    public var role: String?

                    public var round: Int32?

                    public var state: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.honorific != nil {
                            map["Honorific"] = self.honorific!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.jobUuid != nil {
                            map["JobUuid"] = self.jobUuid!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.phoneNumber != nil {
                            map["PhoneNumber"] = self.phoneNumber!
                        }
                        if self.preferredPhoneNumber != nil {
                            map["PreferredPhoneNumber"] = self.preferredPhoneNumber!
                        }
                        if self.referenceId != nil {
                            map["ReferenceId"] = self.referenceId!
                        }
                        if self.role != nil {
                            map["Role"] = self.role!
                        }
                        if self.round != nil {
                            map["Round"] = self.round!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Honorific") {
                            self.honorific = dict["Honorific"] as! String
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("JobUuid") {
                            self.jobUuid = dict["JobUuid"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("PhoneNumber") {
                            self.phoneNumber = dict["PhoneNumber"] as! String
                        }
                        if dict.keys.contains("PreferredPhoneNumber") {
                            self.preferredPhoneNumber = dict["PreferredPhoneNumber"] as! String
                        }
                        if dict.keys.contains("ReferenceId") {
                            self.referenceId = dict["ReferenceId"] as! String
                        }
                        if dict.keys.contains("Role") {
                            self.role = dict["Role"] as! String
                        }
                        if dict.keys.contains("Round") {
                            self.round = dict["Round"] as! Int32
                        }
                        if dict.keys.contains("State") {
                            self.state = dict["State"] as! String
                        }
                    }
                }
                public class DialExceptionCodes : Tea.TeaModel {
                    public var code: String?

                    public var hint: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.hint != nil {
                            map["Hint"] = self.hint!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("Hint") {
                            self.hint = dict["Hint"] as! String
                        }
                    }
                }
                public class Extras : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class TagHits : Tea.TeaModel {
                    public var tagGroup: String?

                    public var tagName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagGroup != nil {
                            map["TagGroup"] = self.tagGroup!
                        }
                        if self.tagName != nil {
                            map["TagName"] = self.tagName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagGroup") {
                            self.tagGroup = dict["TagGroup"] as! String
                        }
                        if dict.keys.contains("TagName") {
                            self.tagName = dict["TagName"] as! String
                        }
                    }
                }
                public var callDuration: Int32?

                public var callDurationDisplay: String?

                public var callTime: Int64?

                public var contact: QueryJobsWithResultResponseBody.Jobs.List.LatestTask.Contact?

                public var dialExceptionCodes: [QueryJobsWithResultResponseBody.Jobs.List.LatestTask.DialExceptionCodes]?

                public var extras: [QueryJobsWithResultResponseBody.Jobs.List.LatestTask.Extras]?

                public var hasAnswered: Bool?

                public var hasHangUpByRejection: Bool?

                public var hasLastPlaybackCompleted: Bool?

                public var hasReachedEndOfFlow: Bool?

                public var status: String?

                public var statusName: String?

                public var tagHits: [QueryJobsWithResultResponseBody.Jobs.List.LatestTask.TagHits]?

                public var taskEndReason: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.contact?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callDuration != nil {
                        map["CallDuration"] = self.callDuration!
                    }
                    if self.callDurationDisplay != nil {
                        map["CallDurationDisplay"] = self.callDurationDisplay!
                    }
                    if self.callTime != nil {
                        map["CallTime"] = self.callTime!
                    }
                    if self.contact != nil {
                        map["Contact"] = self.contact?.toMap()
                    }
                    if self.dialExceptionCodes != nil {
                        var tmp : [Any] = []
                        for k in self.dialExceptionCodes! {
                            tmp.append(k.toMap())
                        }
                        map["DialExceptionCodes"] = tmp
                    }
                    if self.extras != nil {
                        var tmp : [Any] = []
                        for k in self.extras! {
                            tmp.append(k.toMap())
                        }
                        map["Extras"] = tmp
                    }
                    if self.hasAnswered != nil {
                        map["HasAnswered"] = self.hasAnswered!
                    }
                    if self.hasHangUpByRejection != nil {
                        map["HasHangUpByRejection"] = self.hasHangUpByRejection!
                    }
                    if self.hasLastPlaybackCompleted != nil {
                        map["HasLastPlaybackCompleted"] = self.hasLastPlaybackCompleted!
                    }
                    if self.hasReachedEndOfFlow != nil {
                        map["HasReachedEndOfFlow"] = self.hasReachedEndOfFlow!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.statusName != nil {
                        map["StatusName"] = self.statusName!
                    }
                    if self.tagHits != nil {
                        var tmp : [Any] = []
                        for k in self.tagHits! {
                            tmp.append(k.toMap())
                        }
                        map["TagHits"] = tmp
                    }
                    if self.taskEndReason != nil {
                        map["TaskEndReason"] = self.taskEndReason!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallDuration") {
                        self.callDuration = dict["CallDuration"] as! Int32
                    }
                    if dict.keys.contains("CallDurationDisplay") {
                        self.callDurationDisplay = dict["CallDurationDisplay"] as! String
                    }
                    if dict.keys.contains("CallTime") {
                        self.callTime = dict["CallTime"] as! Int64
                    }
                    if dict.keys.contains("Contact") {
                        var model = QueryJobsWithResultResponseBody.Jobs.List.LatestTask.Contact()
                        model.fromMap(dict["Contact"] as! [String: Any])
                        self.contact = model
                    }
                    if dict.keys.contains("DialExceptionCodes") {
                        self.dialExceptionCodes = dict["DialExceptionCodes"] as! [QueryJobsWithResultResponseBody.Jobs.List.LatestTask.DialExceptionCodes]
                    }
                    if dict.keys.contains("Extras") {
                        self.extras = dict["Extras"] as! [QueryJobsWithResultResponseBody.Jobs.List.LatestTask.Extras]
                    }
                    if dict.keys.contains("HasAnswered") {
                        self.hasAnswered = dict["HasAnswered"] as! Bool
                    }
                    if dict.keys.contains("HasHangUpByRejection") {
                        self.hasHangUpByRejection = dict["HasHangUpByRejection"] as! Bool
                    }
                    if dict.keys.contains("HasLastPlaybackCompleted") {
                        self.hasLastPlaybackCompleted = dict["HasLastPlaybackCompleted"] as! Bool
                    }
                    if dict.keys.contains("HasReachedEndOfFlow") {
                        self.hasReachedEndOfFlow = dict["HasReachedEndOfFlow"] as! Bool
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("StatusName") {
                        self.statusName = dict["StatusName"] as! String
                    }
                    if dict.keys.contains("TagHits") {
                        self.tagHits = dict["TagHits"] as! [QueryJobsWithResultResponseBody.Jobs.List.LatestTask.TagHits]
                    }
                    if dict.keys.contains("TaskEndReason") {
                        self.taskEndReason = dict["TaskEndReason"] as! String
                    }
                }
            }
            public var id: String?

            public var jobFailureReason: String?

            public var latestTask: QueryJobsWithResultResponseBody.Jobs.List.LatestTask?

            public var status: String?

            public var statusName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.latestTask?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.jobFailureReason != nil {
                    map["JobFailureReason"] = self.jobFailureReason!
                }
                if self.latestTask != nil {
                    map["LatestTask"] = self.latestTask?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusName != nil {
                    map["StatusName"] = self.statusName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("JobFailureReason") {
                    self.jobFailureReason = dict["JobFailureReason"] as! String
                }
                if dict.keys.contains("LatestTask") {
                    var model = QueryJobsWithResultResponseBody.Jobs.List.LatestTask()
                    model.fromMap(dict["LatestTask"] as! [String: Any])
                    self.latestTask = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StatusName") {
                    self.statusName = dict["StatusName"] as! String
                }
            }
        }
        public var list: [QueryJobsWithResultResponseBody.Jobs.List]?

        public var pageCount: Int32?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var rowCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageCount != nil {
                map["PageCount"] = self.pageCount!
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.rowCount != nil {
                map["RowCount"] = self.rowCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [QueryJobsWithResultResponseBody.Jobs.List]
            }
            if dict.keys.contains("PageCount") {
                self.pageCount = dict["PageCount"] as! Int32
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("RowCount") {
                self.rowCount = dict["RowCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var jobs: QueryJobsWithResultResponseBody.Jobs?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var variableNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.jobs != nil {
            map["Jobs"] = self.jobs?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.variableNames != nil {
            map["VariableNames"] = self.variableNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Jobs") {
            var model = QueryJobsWithResultResponseBody.Jobs()
            model.fromMap(dict["Jobs"] as! [String: Any])
            self.jobs = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("VariableNames") {
            self.variableNames = dict["VariableNames"] as! [String]
        }
    }
}

public class QueryJobsWithResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryJobsWithResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryJobsWithResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryScriptWaveformsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptContent: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptContent != nil {
            map["ScriptContent"] = self.scriptContent!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptContent") {
            self.scriptContent = dict["ScriptContent"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class QueryScriptWaveformsResponseBody : Tea.TeaModel {
    public class ScriptWaveforms : Tea.TeaModel {
        public var fileId: String?

        public var fileName: String?

        public var scriptContent: String?

        public var scriptId: String?

        public var scriptWaveformId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileId != nil {
                map["FileId"] = self.fileId!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.scriptContent != nil {
                map["ScriptContent"] = self.scriptContent!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptWaveformId != nil {
                map["ScriptWaveformId"] = self.scriptWaveformId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileId") {
                self.fileId = dict["FileId"] as! String
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("ScriptContent") {
                self.scriptContent = dict["ScriptContent"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptWaveformId") {
                self.scriptWaveformId = dict["ScriptWaveformId"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scriptWaveforms: [QueryScriptWaveformsResponseBody.ScriptWaveforms]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scriptWaveforms != nil {
            var tmp : [Any] = []
            for k in self.scriptWaveforms! {
                tmp.append(k.toMap())
            }
            map["ScriptWaveforms"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScriptWaveforms") {
            self.scriptWaveforms = dict["ScriptWaveforms"] as! [QueryScriptWaveformsResponseBody.ScriptWaveforms]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryScriptWaveformsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryScriptWaveformsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryScriptWaveformsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryScriptsByStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var statusList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StatusList") {
            self.statusList = dict["StatusList"] as! [String]
        }
    }
}

public class QueryScriptsByStatusResponseBody : Tea.TeaModel {
    public class Scripts : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var appliedVersion: String?

            public var debugStatus: String?

            public var debugVersion: String?

            public var industry: String?

            public var isDebugDrafted: Bool?

            public var isDrafted: Bool?

            public var scene: String?

            public var scriptDescription: String?

            public var scriptId: String?

            public var scriptName: String?

            public var status: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appliedVersion != nil {
                    map["AppliedVersion"] = self.appliedVersion!
                }
                if self.debugStatus != nil {
                    map["DebugStatus"] = self.debugStatus!
                }
                if self.debugVersion != nil {
                    map["DebugVersion"] = self.debugVersion!
                }
                if self.industry != nil {
                    map["Industry"] = self.industry!
                }
                if self.isDebugDrafted != nil {
                    map["IsDebugDrafted"] = self.isDebugDrafted!
                }
                if self.isDrafted != nil {
                    map["IsDrafted"] = self.isDrafted!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.scriptDescription != nil {
                    map["ScriptDescription"] = self.scriptDescription!
                }
                if self.scriptId != nil {
                    map["ScriptId"] = self.scriptId!
                }
                if self.scriptName != nil {
                    map["ScriptName"] = self.scriptName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppliedVersion") {
                    self.appliedVersion = dict["AppliedVersion"] as! String
                }
                if dict.keys.contains("DebugStatus") {
                    self.debugStatus = dict["DebugStatus"] as! String
                }
                if dict.keys.contains("DebugVersion") {
                    self.debugVersion = dict["DebugVersion"] as! String
                }
                if dict.keys.contains("Industry") {
                    self.industry = dict["Industry"] as! String
                }
                if dict.keys.contains("IsDebugDrafted") {
                    self.isDebugDrafted = dict["IsDebugDrafted"] as! Bool
                }
                if dict.keys.contains("IsDrafted") {
                    self.isDrafted = dict["IsDrafted"] as! Bool
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("ScriptDescription") {
                    self.scriptDescription = dict["ScriptDescription"] as! String
                }
                if dict.keys.contains("ScriptId") {
                    self.scriptId = dict["ScriptId"] as! String
                }
                if dict.keys.contains("ScriptName") {
                    self.scriptName = dict["ScriptName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var list: [QueryScriptsByStatusResponseBody.Scripts.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                self.list = dict["List"] as! [QueryScriptsByStatusResponseBody.Scripts.List]
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var scripts: QueryScriptsByStatusResponseBody.Scripts?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scripts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scripts != nil {
            map["Scripts"] = self.scripts?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Scripts") {
            var model = QueryScriptsByStatusResponseBody.Scripts()
            model.fromMap(dict["Scripts"] as! [String: Any])
            self.scripts = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryScriptsByStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryScriptsByStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryScriptsByStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecordFailureRequest : Tea.TeaModel {
    public var actualTime: Int64?

    public var callId: String?

    public var calledNumber: String?

    public var callingNumber: String?

    public var dispositionCode: String?

    public var exceptionCodes: String?

    public var instanceId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actualTime != nil {
            map["ActualTime"] = self.actualTime!
        }
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.calledNumber != nil {
            map["CalledNumber"] = self.calledNumber!
        }
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.dispositionCode != nil {
            map["DispositionCode"] = self.dispositionCode!
        }
        if self.exceptionCodes != nil {
            map["ExceptionCodes"] = self.exceptionCodes!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActualTime") {
            self.actualTime = dict["ActualTime"] as! Int64
        }
        if dict.keys.contains("CallId") {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("CalledNumber") {
            self.calledNumber = dict["CalledNumber"] as! String
        }
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! String
        }
        if dict.keys.contains("DispositionCode") {
            self.dispositionCode = dict["DispositionCode"] as! String
        }
        if dict.keys.contains("ExceptionCodes") {
            self.exceptionCodes = dict["ExceptionCodes"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class RecordFailureResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RecordFailureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecordFailureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecordFailureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeJobsRequest : Tea.TeaModel {
    public var all: Bool?

    public var instanceId: String?

    public var jobGroupId: String?

    public var jobId: [String]?

    public var jobReferenceId: [String]?

    public var scenarioId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobReferenceId != nil {
            map["JobReferenceId"] = self.jobReferenceId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! [String]
        }
        if dict.keys.contains("JobReferenceId") {
            self.jobReferenceId = dict["JobReferenceId"] as! [String]
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
    }
}

public class ResumeJobsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ResumeJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackScriptRequest : Tea.TeaModel {
    public var instanceId: String?

    public var rollbackVersion: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.rollbackVersion != nil {
            map["RollbackVersion"] = self.rollbackVersion!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RollbackVersion") {
            self.rollbackVersion = dict["RollbackVersion"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class RollbackScriptResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RollbackScriptResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackScriptResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RollbackScriptResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveAfterAnswerDelayPlaybackRequest : Tea.TeaModel {
    public var afterAnswerDelayPlayback: Int32?

    public var entryId: String?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.afterAnswerDelayPlayback != nil {
            map["AfterAnswerDelayPlayback"] = self.afterAnswerDelayPlayback!
        }
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AfterAnswerDelayPlayback") {
            self.afterAnswerDelayPlayback = dict["AfterAnswerDelayPlayback"] as! Int32
        }
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class SaveAfterAnswerDelayPlaybackResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveAfterAnswerDelayPlaybackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveAfterAnswerDelayPlaybackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveAfterAnswerDelayPlaybackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveBaseStrategyPeriodRequest : Tea.TeaModel {
    public var entryId: String?

    public var onlyWeekdays: Bool?

    public var strategyLevel: Int32?

    public var workingTime: [String]?

    public var workingTimeFramesJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.onlyWeekdays != nil {
            map["OnlyWeekdays"] = self.onlyWeekdays!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        if self.workingTime != nil {
            map["WorkingTime"] = self.workingTime!
        }
        if self.workingTimeFramesJson != nil {
            map["WorkingTimeFramesJson"] = self.workingTimeFramesJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("OnlyWeekdays") {
            self.onlyWeekdays = dict["OnlyWeekdays"] as! Bool
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
        if dict.keys.contains("WorkingTime") {
            self.workingTime = dict["WorkingTime"] as! [String]
        }
        if dict.keys.contains("WorkingTimeFramesJson") {
            self.workingTimeFramesJson = dict["WorkingTimeFramesJson"] as! String
        }
    }
}

public class SaveBaseStrategyPeriodResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveBaseStrategyPeriodResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveBaseStrategyPeriodResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveBaseStrategyPeriodResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveContactBlockListRequest : Tea.TeaModel {
    public var contactBlockListList: [String]?

    public var contactBlockListsJson: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactBlockListList != nil {
            map["ContactBlockListList"] = self.contactBlockListList!
        }
        if self.contactBlockListsJson != nil {
            map["ContactBlockListsJson"] = self.contactBlockListsJson!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactBlockListList") {
            self.contactBlockListList = dict["ContactBlockListList"] as! [String]
        }
        if dict.keys.contains("ContactBlockListsJson") {
            self.contactBlockListsJson = dict["ContactBlockListsJson"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class SaveContactBlockListResponseBody : Tea.TeaModel {
    public var affectedRows: Int32?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affectedRows != nil {
            map["AffectedRows"] = self.affectedRows!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AffectedRows") {
            self.affectedRows = dict["AffectedRows"] as! Int32
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveContactBlockListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveContactBlockListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveContactBlockListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveContactWhiteListRequest : Tea.TeaModel {
    public var contactWhiteListList: [String]?

    public var contactWhiteListsJson: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactWhiteListList != nil {
            map["ContactWhiteListList"] = self.contactWhiteListList!
        }
        if self.contactWhiteListsJson != nil {
            map["ContactWhiteListsJson"] = self.contactWhiteListsJson!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactWhiteListList") {
            self.contactWhiteListList = dict["ContactWhiteListList"] as! [String]
        }
        if dict.keys.contains("ContactWhiteListsJson") {
            self.contactWhiteListsJson = dict["ContactWhiteListsJson"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class SaveContactWhiteListResponseBody : Tea.TeaModel {
    public var affectedRows: Int32?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affectedRows != nil {
            map["AffectedRows"] = self.affectedRows!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AffectedRows") {
            self.affectedRows = dict["AffectedRows"] as! Int32
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveContactWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveContactWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveContactWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveEffectiveDaysRequest : Tea.TeaModel {
    public var effectiveDays: Int32?

    public var entryId: String?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.effectiveDays != nil {
            map["EffectiveDays"] = self.effectiveDays!
        }
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EffectiveDays") {
            self.effectiveDays = dict["EffectiveDays"] as! Int32
        }
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class SaveEffectiveDaysResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveEffectiveDaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveEffectiveDaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveEffectiveDaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveMaxAttemptsPerDayRequest : Tea.TeaModel {
    public var entryId: String?

    public var maxAttemptsPerDay: Int32?

    public var strategyLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entryId != nil {
            map["EntryId"] = self.entryId!
        }
        if self.maxAttemptsPerDay != nil {
            map["MaxAttemptsPerDay"] = self.maxAttemptsPerDay!
        }
        if self.strategyLevel != nil {
            map["StrategyLevel"] = self.strategyLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntryId") {
            self.entryId = dict["EntryId"] as! String
        }
        if dict.keys.contains("MaxAttemptsPerDay") {
            self.maxAttemptsPerDay = dict["MaxAttemptsPerDay"] as! Int32
        }
        if dict.keys.contains("StrategyLevel") {
            self.strategyLevel = dict["StrategyLevel"] as! Int32
        }
    }
}

public class SaveMaxAttemptsPerDayResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveMaxAttemptsPerDayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveMaxAttemptsPerDayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveMaxAttemptsPerDayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTaskRequest : Tea.TeaModel {
    public var actualTimeGte: Int64?

    public var actualTimeLte: Int64?

    public var callDurationGte: Int64?

    public var callDurationLte: Int64?

    public var calledNumber: String?

    public var instanceId: String?

    public var jobGroupId: String?

    public var jobGroupNameQuery: String?

    public var jobId: String?

    public var jobStatusStringList: String?

    public var otherId: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var recordingDurationGte: Int64?

    public var recordingDurationLte: Int64?

    public var scriptNameQuery: String?

    public var sortBy: String?

    public var sortOrder: String?

    public var taskCreateTimeGte: Int64?

    public var taskCreateTimeLte: Int64?

    public var taskId: String?

    public var taskStatusStringList: String?

    public var userIdMatch: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actualTimeGte != nil {
            map["ActualTimeGte"] = self.actualTimeGte!
        }
        if self.actualTimeLte != nil {
            map["ActualTimeLte"] = self.actualTimeLte!
        }
        if self.callDurationGte != nil {
            map["CallDurationGte"] = self.callDurationGte!
        }
        if self.callDurationLte != nil {
            map["CallDurationLte"] = self.callDurationLte!
        }
        if self.calledNumber != nil {
            map["CalledNumber"] = self.calledNumber!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobGroupNameQuery != nil {
            map["JobGroupNameQuery"] = self.jobGroupNameQuery!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobStatusStringList != nil {
            map["JobStatusStringList"] = self.jobStatusStringList!
        }
        if self.otherId != nil {
            map["OtherId"] = self.otherId!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordingDurationGte != nil {
            map["RecordingDurationGte"] = self.recordingDurationGte!
        }
        if self.recordingDurationLte != nil {
            map["RecordingDurationLte"] = self.recordingDurationLte!
        }
        if self.scriptNameQuery != nil {
            map["ScriptNameQuery"] = self.scriptNameQuery!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.taskCreateTimeGte != nil {
            map["TaskCreateTimeGte"] = self.taskCreateTimeGte!
        }
        if self.taskCreateTimeLte != nil {
            map["TaskCreateTimeLte"] = self.taskCreateTimeLte!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskStatusStringList != nil {
            map["TaskStatusStringList"] = self.taskStatusStringList!
        }
        if self.userIdMatch != nil {
            map["UserIdMatch"] = self.userIdMatch!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActualTimeGte") {
            self.actualTimeGte = dict["ActualTimeGte"] as! Int64
        }
        if dict.keys.contains("ActualTimeLte") {
            self.actualTimeLte = dict["ActualTimeLte"] as! Int64
        }
        if dict.keys.contains("CallDurationGte") {
            self.callDurationGte = dict["CallDurationGte"] as! Int64
        }
        if dict.keys.contains("CallDurationLte") {
            self.callDurationLte = dict["CallDurationLte"] as! Int64
        }
        if dict.keys.contains("CalledNumber") {
            self.calledNumber = dict["CalledNumber"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobGroupNameQuery") {
            self.jobGroupNameQuery = dict["JobGroupNameQuery"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobStatusStringList") {
            self.jobStatusStringList = dict["JobStatusStringList"] as! String
        }
        if dict.keys.contains("OtherId") {
            self.otherId = dict["OtherId"] as! String
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecordingDurationGte") {
            self.recordingDurationGte = dict["RecordingDurationGte"] as! Int64
        }
        if dict.keys.contains("RecordingDurationLte") {
            self.recordingDurationLte = dict["RecordingDurationLte"] as! Int64
        }
        if dict.keys.contains("ScriptNameQuery") {
            self.scriptNameQuery = dict["ScriptNameQuery"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("TaskCreateTimeGte") {
            self.taskCreateTimeGte = dict["TaskCreateTimeGte"] as! Int64
        }
        if dict.keys.contains("TaskCreateTimeLte") {
            self.taskCreateTimeLte = dict["TaskCreateTimeLte"] as! Int64
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskStatusStringList") {
            self.taskStatusStringList = dict["TaskStatusStringList"] as! String
        }
        if dict.keys.contains("UserIdMatch") {
            self.userIdMatch = dict["UserIdMatch"] as! String
        }
    }
}

public class SearchTaskResponseBody : Tea.TeaModel {
    public class SearchTaskInfoList : Tea.TeaModel {
        public var actualTime: Int64?

        public var callDuration: Int32?

        public var callDurationDisplay: String?

        public var calledNumber: String?

        public var dialException: String?

        public var dialExceptionCodes: [String]?

        public var dialExceptionOld: String?

        public var hasAnswered: Bool?

        public var hasHangUpByRejection: Bool?

        public var hasLastPlaybackCompleted: Bool?

        public var hasReachedEndOfFlow: Bool?

        public var instanceId: String?

        public var jobGroupId: String?

        public var jobGroupName: String?

        public var jobId: String?

        public var jobStatus: Int32?

        public var jobStatusName: String?

        public var jobStatusString: String?

        public var recordingDuration: Int32?

        public var scriptName: String?

        public var taskCreateTime: Int64?

        public var taskEndReason: Int32?

        public var taskId: String?

        public var taskStatus: Int32?

        public var taskStatusName: String?

        public var taskStatusString: String?

        public var userId: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualTime != nil {
                map["ActualTime"] = self.actualTime!
            }
            if self.callDuration != nil {
                map["CallDuration"] = self.callDuration!
            }
            if self.callDurationDisplay != nil {
                map["CallDurationDisplay"] = self.callDurationDisplay!
            }
            if self.calledNumber != nil {
                map["CalledNumber"] = self.calledNumber!
            }
            if self.dialException != nil {
                map["DialException"] = self.dialException!
            }
            if self.dialExceptionCodes != nil {
                map["DialExceptionCodes"] = self.dialExceptionCodes!
            }
            if self.dialExceptionOld != nil {
                map["DialExceptionOld"] = self.dialExceptionOld!
            }
            if self.hasAnswered != nil {
                map["HasAnswered"] = self.hasAnswered!
            }
            if self.hasHangUpByRejection != nil {
                map["HasHangUpByRejection"] = self.hasHangUpByRejection!
            }
            if self.hasLastPlaybackCompleted != nil {
                map["HasLastPlaybackCompleted"] = self.hasLastPlaybackCompleted!
            }
            if self.hasReachedEndOfFlow != nil {
                map["HasReachedEndOfFlow"] = self.hasReachedEndOfFlow!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobGroupId != nil {
                map["JobGroupId"] = self.jobGroupId!
            }
            if self.jobGroupName != nil {
                map["JobGroupName"] = self.jobGroupName!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.jobStatusName != nil {
                map["JobStatusName"] = self.jobStatusName!
            }
            if self.jobStatusString != nil {
                map["JobStatusString"] = self.jobStatusString!
            }
            if self.recordingDuration != nil {
                map["RecordingDuration"] = self.recordingDuration!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.taskCreateTime != nil {
                map["TaskCreateTime"] = self.taskCreateTime!
            }
            if self.taskEndReason != nil {
                map["TaskEndReason"] = self.taskEndReason!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            if self.taskStatusName != nil {
                map["TaskStatusName"] = self.taskStatusName!
            }
            if self.taskStatusString != nil {
                map["TaskStatusString"] = self.taskStatusString!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualTime") {
                self.actualTime = dict["ActualTime"] as! Int64
            }
            if dict.keys.contains("CallDuration") {
                self.callDuration = dict["CallDuration"] as! Int32
            }
            if dict.keys.contains("CallDurationDisplay") {
                self.callDurationDisplay = dict["CallDurationDisplay"] as! String
            }
            if dict.keys.contains("CalledNumber") {
                self.calledNumber = dict["CalledNumber"] as! String
            }
            if dict.keys.contains("DialException") {
                self.dialException = dict["DialException"] as! String
            }
            if dict.keys.contains("DialExceptionCodes") {
                self.dialExceptionCodes = dict["DialExceptionCodes"] as! [String]
            }
            if dict.keys.contains("DialExceptionOld") {
                self.dialExceptionOld = dict["DialExceptionOld"] as! String
            }
            if dict.keys.contains("HasAnswered") {
                self.hasAnswered = dict["HasAnswered"] as! Bool
            }
            if dict.keys.contains("HasHangUpByRejection") {
                self.hasHangUpByRejection = dict["HasHangUpByRejection"] as! Bool
            }
            if dict.keys.contains("HasLastPlaybackCompleted") {
                self.hasLastPlaybackCompleted = dict["HasLastPlaybackCompleted"] as! Bool
            }
            if dict.keys.contains("HasReachedEndOfFlow") {
                self.hasReachedEndOfFlow = dict["HasReachedEndOfFlow"] as! Bool
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobGroupId") {
                self.jobGroupId = dict["JobGroupId"] as! String
            }
            if dict.keys.contains("JobGroupName") {
                self.jobGroupName = dict["JobGroupName"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobStatus") {
                self.jobStatus = dict["JobStatus"] as! Int32
            }
            if dict.keys.contains("JobStatusName") {
                self.jobStatusName = dict["JobStatusName"] as! String
            }
            if dict.keys.contains("JobStatusString") {
                self.jobStatusString = dict["JobStatusString"] as! String
            }
            if dict.keys.contains("RecordingDuration") {
                self.recordingDuration = dict["RecordingDuration"] as! Int32
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("TaskCreateTime") {
                self.taskCreateTime = dict["TaskCreateTime"] as! Int64
            }
            if dict.keys.contains("TaskEndReason") {
                self.taskEndReason = dict["TaskEndReason"] as! Int32
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskStatus") {
                self.taskStatus = dict["TaskStatus"] as! Int32
            }
            if dict.keys.contains("TaskStatusName") {
                self.taskStatusName = dict["TaskStatusName"] as! String
            }
            if dict.keys.contains("TaskStatusString") {
                self.taskStatusString = dict["TaskStatusString"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pageIndex: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var searchTaskInfoList: [SearchTaskResponseBody.SearchTaskInfoList]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageIndex != nil {
            map["PageIndex"] = self.pageIndex!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.searchTaskInfoList != nil {
            var tmp : [Any] = []
            for k in self.searchTaskInfoList! {
                tmp.append(k.toMap())
            }
            map["SearchTaskInfoList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageIndex") {
            self.pageIndex = dict["PageIndex"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SearchTaskInfoList") {
            self.searchTaskInfoList = dict["SearchTaskInfoList"] as! [SearchTaskResponseBody.SearchTaskInfoList]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
    }
}

public class SearchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartJobRequest : Tea.TeaModel {
    public var callingNumber: [String]?

    public var instanceId: String?

    public var jobGroupId: String?

    public var jobJson: String?

    public var scenarioId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobJson != nil {
            map["JobJson"] = self.jobJson!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobJson") {
            self.jobJson = dict["JobJson"] as! String
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class StartJobResponseBody : Tea.TeaModel {
    public class CallIds : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class TaskIds : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var callIds: [StartJobResponseBody.CallIds]?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var taskIds: [StartJobResponseBody.TaskIds]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callIds != nil {
            var tmp : [Any] = []
            for k in self.callIds! {
                tmp.append(k.toMap())
            }
            map["CallIds"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskIds != nil {
            var tmp : [Any] = []
            for k in self.taskIds! {
                tmp.append(k.toMap())
            }
            map["TaskIds"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallIds") {
            self.callIds = dict["CallIds"] as! [StartJobResponseBody.CallIds]
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskIds") {
            self.taskIds = dict["TaskIds"] as! [StartJobResponseBody.TaskIds]
        }
    }
}

public class StartJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitBatchJobsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
    }
}

public class SubmitBatchJobsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitBatchJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitBatchJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitBatchJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitRecordingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var mergedRecording: String?

    public var resourceRecording: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mergedRecording != nil {
            map["MergedRecording"] = self.mergedRecording!
        }
        if self.resourceRecording != nil {
            map["ResourceRecording"] = self.resourceRecording!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MergedRecording") {
            self.mergedRecording = dict["MergedRecording"] as! String
        }
        if dict.keys.contains("ResourceRecording") {
            self.resourceRecording = dict["ResourceRecording"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class SubmitRecordingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitScriptReviewRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class SubmitScriptReviewResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitScriptReviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitScriptReviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitScriptReviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendCallRequest : Tea.TeaModel {
    public var calledNumbers: [String]?

    public var groupId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calledNumbers != nil {
            map["CalledNumbers"] = self.calledNumbers!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalledNumbers") {
            self.calledNumbers = dict["CalledNumbers"] as! [String]
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class SuspendCallResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SuspendCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendCallWithFileRequest : Tea.TeaModel {
    public var filePath: String?

    public var groupId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class SuspendCallWithFileResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SuspendCallWithFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendCallWithFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendCallWithFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendJobsRequest : Tea.TeaModel {
    public var all: Bool?

    public var instanceId: String?

    public var jobGroupId: String?

    public var jobId: [String]?

    public var jobReferenceId: [String]?

    public var scenarioId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobGroupId != nil {
            map["JobGroupId"] = self.jobGroupId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobReferenceId != nil {
            map["JobReferenceId"] = self.jobReferenceId!
        }
        if self.scenarioId != nil {
            map["ScenarioId"] = self.scenarioId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobGroupId") {
            self.jobGroupId = dict["JobGroupId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! [String]
        }
        if dict.keys.contains("JobReferenceId") {
            self.jobReferenceId = dict["JobReferenceId"] as! [String]
        }
        if dict.keys.contains("ScenarioId") {
            self.scenarioId = dict["ScenarioId"] as! String
        }
    }
}

public class SuspendJobsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SuspendJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [TagResourcesRequest.Tag]
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TaskPreparingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceOwnerId: Int64?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceOwnerId != nil {
            map["InstanceOwnerId"] = self.instanceOwnerId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceOwnerId") {
            self.instanceOwnerId = dict["InstanceOwnerId"] as! Int64
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class TaskPreparingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class TaskPreparingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TaskPreparingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TaskPreparingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TerminateCallRequest : Tea.TeaModel {
    public var callId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallId") {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class TerminateCallResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TerminateCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TerminateCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UploadScriptRecordingRequest : Tea.TeaModel {
    public var content: String?

    public var fileId: String?

    public var fileName: String?

    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.fileId != nil {
            map["FileId"] = self.fileId!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("FileId") {
            self.fileId = dict["FileId"] as! String
        }
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class UploadScriptRecordingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class UploadScriptRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UploadScriptRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UploadScriptRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WithdrawScriptReviewRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scriptId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scriptId != nil {
            map["ScriptId"] = self.scriptId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScriptId") {
            self.scriptId = dict["ScriptId"] as! String
        }
    }
}

public class WithdrawScriptReviewResponseBody : Tea.TeaModel {
    public class Script : Tea.TeaModel {
        public var debugStatus: String?

        public var industry: String?

        public var isDebugDrafted: Bool?

        public var isDrafted: Bool?

        public var scene: String?

        public var scriptDescription: String?

        public var scriptId: String?

        public var scriptName: String?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.debugStatus != nil {
                map["DebugStatus"] = self.debugStatus!
            }
            if self.industry != nil {
                map["Industry"] = self.industry!
            }
            if self.isDebugDrafted != nil {
                map["IsDebugDrafted"] = self.isDebugDrafted!
            }
            if self.isDrafted != nil {
                map["IsDrafted"] = self.isDrafted!
            }
            if self.scene != nil {
                map["Scene"] = self.scene!
            }
            if self.scriptDescription != nil {
                map["ScriptDescription"] = self.scriptDescription!
            }
            if self.scriptId != nil {
                map["ScriptId"] = self.scriptId!
            }
            if self.scriptName != nil {
                map["ScriptName"] = self.scriptName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DebugStatus") {
                self.debugStatus = dict["DebugStatus"] as! String
            }
            if dict.keys.contains("Industry") {
                self.industry = dict["Industry"] as! String
            }
            if dict.keys.contains("IsDebugDrafted") {
                self.isDebugDrafted = dict["IsDebugDrafted"] as! Bool
            }
            if dict.keys.contains("IsDrafted") {
                self.isDrafted = dict["IsDrafted"] as! Bool
            }
            if dict.keys.contains("Scene") {
                self.scene = dict["Scene"] as! String
            }
            if dict.keys.contains("ScriptDescription") {
                self.scriptDescription = dict["ScriptDescription"] as! String
            }
            if dict.keys.contains("ScriptId") {
                self.scriptId = dict["ScriptId"] as! String
            }
            if dict.keys.contains("ScriptName") {
                self.scriptName = dict["ScriptName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var script: WithdrawScriptReviewResponseBody.Script?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.script?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.script != nil {
            map["Script"] = self.script?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Script") {
            var model = WithdrawScriptReviewResponseBody.Script()
            model.fromMap(dict["Script"] as! [String: Any])
            self.script = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class WithdrawScriptReviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WithdrawScriptReviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = WithdrawScriptReviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
