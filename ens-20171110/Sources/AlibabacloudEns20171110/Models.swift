import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class BucketInfo : Tea.TeaModel {
    public var bucketAcl: String?

    public var bucketName: String?

    public var comment: String?

    public var createTime: String?

    public var dataRedundancyType: String?

    public var dispatcherType: String?

    public var endpoint: String?

    public var ensRegionId: String?

    public var modifyTime: String?

    public var resourceType: String?

    public var storageClass: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketAcl != nil {
            map["BucketAcl"] = self.bucketAcl!
        }
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dataRedundancyType != nil {
            map["DataRedundancyType"] = self.dataRedundancyType!
        }
        if self.dispatcherType != nil {
            map["DispatcherType"] = self.dispatcherType!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.modifyTime != nil {
            map["ModifyTime"] = self.modifyTime!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.storageClass != nil {
            map["StorageClass"] = self.storageClass!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketAcl") && dict["BucketAcl"] != nil {
            self.bucketAcl = dict["BucketAcl"] as! String
        }
        if dict.keys.contains("BucketName") && dict["BucketName"] != nil {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("DataRedundancyType") && dict["DataRedundancyType"] != nil {
            self.dataRedundancyType = dict["DataRedundancyType"] as! String
        }
        if dict.keys.contains("DispatcherType") && dict["DispatcherType"] != nil {
            self.dispatcherType = dict["DispatcherType"] as! String
        }
        if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
            self.modifyTime = dict["ModifyTime"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("StorageClass") && dict["StorageClass"] != nil {
            self.storageClass = dict["StorageClass"] as! String
        }
    }
}

public class DataDisk : Tea.TeaModel {
    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class HealthCheck : Tea.TeaModel {
    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckType: String?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") && dict["HealthCheckConnectTimeout"] != nil {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") && dict["HealthCheckMethod"] != nil {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") && dict["HealthCheckTimeout"] != nil {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckType") && dict["HealthCheckType"] != nil {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class HttpConfig : Tea.TeaModel {
    public var cookie: String?

    public var cookieTimeout: Int32?

    public var idleTimeout: Int32?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var stickySession: String?

    public var stickySessionType: String?

    public var XForwardedFor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cookie != nil {
            map["Cookie"] = self.cookie!
        }
        if self.cookieTimeout != nil {
            map["CookieTimeout"] = self.cookieTimeout!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.stickySession != nil {
            map["StickySession"] = self.stickySession!
        }
        if self.stickySessionType != nil {
            map["StickySessionType"] = self.stickySessionType!
        }
        if self.XForwardedFor != nil {
            map["XForwardedFor"] = self.XForwardedFor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cookie") && dict["Cookie"] != nil {
            self.cookie = dict["Cookie"] as! String
        }
        if dict.keys.contains("CookieTimeout") && dict["CookieTimeout"] != nil {
            self.cookieTimeout = dict["CookieTimeout"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") && dict["ServerCertificateId"] != nil {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("StickySession") && dict["StickySession"] != nil {
            self.stickySession = dict["StickySession"] as! String
        }
        if dict.keys.contains("StickySessionType") && dict["StickySessionType"] != nil {
            self.stickySessionType = dict["StickySessionType"] as! String
        }
        if dict.keys.contains("XForwardedFor") && dict["XForwardedFor"] != nil {
            self.XForwardedFor = dict["XForwardedFor"] as! String
        }
    }
}

public class InstanceActiveOpsGroup : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class InstanceActiveOpsTask : Tea.TeaModel {
    public var instanceActiveOpsTaskId: String?

    public var instanceActiveOpsTaskStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceActiveOpsTaskId != nil {
            map["InstanceActiveOpsTaskId"] = self.instanceActiveOpsTaskId!
        }
        if self.instanceActiveOpsTaskStatus != nil {
            map["InstanceActiveOpsTaskStatus"] = self.instanceActiveOpsTaskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceActiveOpsTaskId") && dict["InstanceActiveOpsTaskId"] != nil {
            self.instanceActiveOpsTaskId = dict["InstanceActiveOpsTaskId"] as! String
        }
        if dict.keys.contains("InstanceActiveOpsTaskStatus") && dict["InstanceActiveOpsTaskStatus"] != nil {
            self.instanceActiveOpsTaskStatus = dict["InstanceActiveOpsTaskStatus"] as! String
        }
    }
}

public class InstanceOperateResponse : Tea.TeaModel {
    public var code: Int64?

    public var instanceId: String?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
    }
}

public class SecurityGroupRule : Tea.TeaModel {
    public var description_: String?

    public var destCidrIp: String?

    public var direction: String?

    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public var priority: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestCidrIp") && dict["DestCidrIp"] != nil {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("Direction") && dict["Direction"] != nil {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("SourceCidrIp") && dict["SourceCidrIp"] != nil {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") && dict["SourcePortRange"] != nil {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("priority") && dict["priority"] != nil {
            self.priority = dict["priority"] as! Int32
        }
    }
}

public class TcpConfig : Tea.TeaModel {
    public var establishedTimeout: Int32?

    public var persistenceTimeout: Int32?

    public var scheduler: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.persistenceTimeout != nil {
            map["PersistenceTimeout"] = self.persistenceTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EstablishedTimeout") && dict["EstablishedTimeout"] != nil {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("PersistenceTimeout") && dict["PersistenceTimeout"] != nil {
            self.persistenceTimeout = dict["PersistenceTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
    }
}

public class UdpCheck : Tea.TeaModel {
    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckInterval: Int32?

    public var healthyThreshold: Int32?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") && dict["HealthCheckConnectTimeout"] != nil {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class UdpConfig : Tea.TeaModel {
    public var hashKey: String?

    public var scheduler: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hashKey != nil {
            map["HashKey"] = self.hashKey!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HashKey") && dict["HashKey"] != nil {
            self.hashKey = dict["HashKey"] as! String
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
    }
}

public class AccosicateNetworkAclRequest : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var networkAclId: String?

    public var resource: [AccosicateNetworkAclRequest.Resource]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.resource != nil {
            var tmp : [Any] = []
            for k in self.resource! {
                tmp.append(k.toMap())
            }
            map["Resource"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") && dict["NetworkAclId"] != nil {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            var tmp : [AccosicateNetworkAclRequest.Resource] = []
            for v in dict["Resource"] as! [Any] {
                var model = AccosicateNetworkAclRequest.Resource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resource = tmp
        }
    }
}

public class AccosicateNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AccosicateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AccosicateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AccosicateNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddBackendServersRequest : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public var ip: String?

        public var port: Int32?

        public var serverId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var backendServers: [AddBackendServersRequest.BackendServers]?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            var tmp : [Any] = []
            for k in self.backendServers! {
                tmp.append(k.toMap())
            }
            map["BackendServers"] = tmp
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            var tmp : [AddBackendServersRequest.BackendServers] = []
            for v in dict["BackendServers"] as! [Any] {
                var model = AddBackendServersRequest.BackendServers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendServers = tmp
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class AddBackendServersShrinkRequest : Tea.TeaModel {
    public var backendServersShrink: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServersShrink != nil {
            map["BackendServers"] = self.backendServersShrink!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            self.backendServersShrink = dict["BackendServers"] as! String
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class AddBackendServersResponseBody : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public class BackendServer : Tea.TeaModel {
            public var ip: String?

            public var port: Int32?

            public var serverId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
                    self.serverId = dict["ServerId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var backendServer: [AddBackendServersResponseBody.BackendServers.BackendServer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendServer != nil {
                var tmp : [Any] = []
                for k in self.backendServer! {
                    tmp.append(k.toMap())
                }
                map["BackendServer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendServer") && dict["BackendServer"] != nil {
                var tmp : [AddBackendServersResponseBody.BackendServers.BackendServer] = []
                for v in dict["BackendServer"] as! [Any] {
                    var model = AddBackendServersResponseBody.BackendServers.BackendServer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backendServer = tmp
            }
        }
    }
    public var backendServers: AddBackendServersResponseBody.BackendServers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            map["BackendServers"] = self.backendServers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            var model = AddBackendServersResponseBody.BackendServers()
            model.fromMap(dict["BackendServers"] as! [String: Any])
            self.backendServers = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddBackendServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBackendServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddBackendServersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddDeviceInternetPortRequest : Tea.TeaModel {
    public var ISP: String?

    public var instanceId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var natType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ISP") && dict["ISP"] != nil {
            self.ISP = dict["ISP"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InternalIp") && dict["InternalIp"] != nil {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("InternalPort") && dict["InternalPort"] != nil {
            self.internalPort = dict["InternalPort"] as! String
        }
        if dict.keys.contains("NatType") && dict["NatType"] != nil {
            self.natType = dict["NatType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddDeviceInternetPortResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var ruleIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleIds != nil {
            map["RuleIds"] = self.ruleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleIds") && dict["RuleIds"] != nil {
            self.ruleIds = dict["RuleIds"] as! [String]
        }
    }
}

public class AddDeviceInternetPortResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddDeviceInternetPortResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddDeviceInternetPortResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddNetworkInterfaceToInstanceRequest : Tea.TeaModel {
    public var autoStart: Bool?

    public var instanceId: String?

    public var networks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStart != nil {
            map["AutoStart"] = self.autoStart!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networks != nil {
            map["Networks"] = self.networks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoStart") && dict["AutoStart"] != nil {
            self.autoStart = dict["AutoStart"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Networks") && dict["Networks"] != nil {
            self.networks = dict["Networks"] as! String
        }
    }
}

public class AddNetworkInterfaceToInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddNetworkInterfaceToInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddNetworkInterfaceToInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddNetworkInterfaceToInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssignPrivateIpAddressesRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") && dict["NetworkInterfaceId"] != nil {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class AssignPrivateIpAddressesResponseBody : Tea.TeaModel {
    public class AssignedPrivateIpAddressesSet : Tea.TeaModel {
        public var networkInterfaceId: String?

        public var privateIpSet: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.privateIpSet != nil {
                map["PrivateIpSet"] = self.privateIpSet!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceId") && dict["NetworkInterfaceId"] != nil {
                self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
            }
            if dict.keys.contains("PrivateIpSet") && dict["PrivateIpSet"] != nil {
                self.privateIpSet = dict["PrivateIpSet"] as! [String]
            }
        }
    }
    public var assignedPrivateIpAddressesSet: AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.assignedPrivateIpAddressesSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedPrivateIpAddressesSet != nil {
            map["AssignedPrivateIpAddressesSet"] = self.assignedPrivateIpAddressesSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssignedPrivateIpAddressesSet") && dict["AssignedPrivateIpAddressesSet"] != nil {
            var model = AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet()
            model.fromMap(dict["AssignedPrivateIpAddressesSet"] as! [String: Any])
            self.assignedPrivateIpAddressesSet = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssignPrivateIpAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignPrivateIpAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AssignPrivateIpAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateEnsEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var instanceId: String?

    public var instanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") && dict["AllocationId"] != nil {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
    }
}

public class AssociateEnsEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateEnsEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateEnsEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AssociateEnsEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachDiskRequest : Tea.TeaModel {
    public var deleteWithInstance: String?

    public var diskId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteWithInstance") && dict["DeleteWithInstance"] != nil {
            self.deleteWithInstance = dict["DeleteWithInstance"] as! String
        }
        if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AttachDiskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachEnsInstancesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scripts: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scripts != nil {
            map["Scripts"] = self.scripts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Scripts") && dict["Scripts"] != nil {
            self.scripts = dict["Scripts"] as! String
        }
    }
}

public class AttachEnsInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachEnsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachEnsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachEnsInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AuthorizeSecurityGroupRequest : Tea.TeaModel {
    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var securityGroupId: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") && dict["Priority"] != nil {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourceCidrIp") && dict["SourceCidrIp"] != nil {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") && dict["SourcePortRange"] != nil {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class AuthorizeSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AuthorizeSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AuthorizeSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AuthorizeSecurityGroupEgressRequest : Tea.TeaModel {
    public var destCidrIp: String?

    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var securityGroupId: String?

    public var sourcePortRange: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestCidrIp") && dict["DestCidrIp"] != nil {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") && dict["Priority"] != nil {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourcePortRange") && dict["SourcePortRange"] != nil {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class AuthorizeSecurityGroupEgressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AuthorizeSecurityGroupEgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeSecurityGroupEgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AuthorizeSecurityGroupEgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CleanDistDataRequest : Tea.TeaModel {
    public var appId: String?

    public var dataName: String?

    public var dataVersion: String?

    public var ensRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataName != nil {
            map["DataName"] = self.dataName!
        }
        if self.dataVersion != nil {
            map["DataVersion"] = self.dataVersion!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataName") && dict["DataName"] != nil {
            self.dataName = dict["DataName"] as! String
        }
        if dict.keys.contains("DataVersion") && dict["DataVersion"] != nil {
            self.dataVersion = dict["DataVersion"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
    }
}

public class CleanDistDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CleanDistDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CleanDistDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CleanDistDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateARMServerInstancesRequest : Tea.TeaModel {
    public var amount: Int32?

    public var autoRenew: Bool?

    public var ensRegionId: String?

    public var frequency: Int32?

    public var imageId: String?

    public var instanceType: String?

    public var keyPairName: String?

    public var nameSpace: String?

    public var payType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var resolution: String?

    public var serverType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.nameSpace != nil {
            map["NameSpace"] = self.nameSpace!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.resolution != nil {
            map["Resolution"] = self.resolution!
        }
        if self.serverType != nil {
            map["ServerType"] = self.serverType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("Frequency") && dict["Frequency"] != nil {
            self.frequency = dict["Frequency"] as! Int32
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("NameSpace") && dict["NameSpace"] != nil {
            self.nameSpace = dict["NameSpace"] as! String
        }
        if dict.keys.contains("PayType") && dict["PayType"] != nil {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Resolution") && dict["Resolution"] != nil {
            self.resolution = dict["Resolution"] as! String
        }
        if dict.keys.contains("ServerType") && dict["ServerType"] != nil {
            self.serverType = dict["ServerType"] as! String
        }
    }
}

public class CreateARMServerInstancesResponseBody : Tea.TeaModel {
    public var instanceIds: [String]?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateARMServerInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateARMServerInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateARMServerInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApplicationRequest : Tea.TeaModel {
    public var template: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Template") && dict["Template"] != nil {
            self.template = dict["Template"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class CreateApplicationResponseBody : Tea.TeaModel {
    public var appId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClassicNetworkRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var ensRegionId: String?

    public var networkName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("NetworkName") && dict["NetworkName"] != nil {
            self.networkName = dict["NetworkName"] as! String
        }
    }
}

public class CreateClassicNetworkResponseBody : Tea.TeaModel {
    public var networkId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateClassicNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClassicNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateClassicNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiskRequest : Tea.TeaModel {
    public var category: String?

    public var ensRegionId: String?

    public var instanceChargeType: String?

    public var size: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("Size") && dict["Size"] != nil {
            self.size = dict["Size"] as! String
        }
        if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class CreateDiskResponseBody : Tea.TeaModel {
    public var instanceIds: [String]?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEipInstanceRequest : Tea.TeaModel {
    public var bandwidth: Int64?

    public var ensRegionId: String?

    public var instanceChargeType: String?

    public var internetChargeType: String?

    public var isp: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int64
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Isp") && dict["Isp"] != nil {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class CreateEipInstanceResponseBody : Tea.TeaModel {
    public var allocationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") && dict["AllocationId"] != nil {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEipInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEipInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEipInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnsRouteEntryRequest : Tea.TeaModel {
    public var description_: String?

    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopType: String?

    public var routeEntryName: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationCidrBlock") && dict["DestinationCidrBlock"] != nil {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("NextHopId") && dict["NextHopId"] != nil {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopType") && dict["NextHopType"] != nil {
            self.nextHopType = dict["NextHopType"] as! String
        }
        if dict.keys.contains("RouteEntryName") && dict["RouteEntryName"] != nil {
            self.routeEntryName = dict["RouteEntryName"] as! String
        }
        if dict.keys.contains("RouteTableId") && dict["RouteTableId"] != nil {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class CreateEnsRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntryId") && dict["RouteEntryId"] != nil {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
    }
}

public class CreateEnsRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnsRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEnsRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnsServiceRequest : Tea.TeaModel {
    public var ensServiceId: String?

    public var orderType: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensServiceId != nil {
            map["EnsServiceId"] = self.ensServiceId!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsServiceId") && dict["EnsServiceId"] != nil {
            self.ensServiceId = dict["EnsServiceId"] as! String
        }
        if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class CreateEnsServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnsServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnsServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEnsServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceName: String?

    public var EPNInstanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var networkingModel: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceName != nil {
            map["EPNInstanceName"] = self.EPNInstanceName!
        }
        if self.EPNInstanceType != nil {
            map["EPNInstanceType"] = self.EPNInstanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceName") && dict["EPNInstanceName"] != nil {
            self.EPNInstanceName = dict["EPNInstanceName"] as! String
        }
        if dict.keys.contains("EPNInstanceType") && dict["EPNInstanceType"] != nil {
            self.EPNInstanceType = dict["EPNInstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("NetworkingModel") && dict["NetworkingModel"] != nil {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
    }
}

public class CreateEpnInstanceResponseBody : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFileSystemRequest : Tea.TeaModel {
    public class OrderDetails : Tea.TeaModel {
        public var chargeType: String?

        public var ensRegionId: String?

        public var fileSystemName: String?

        public var mountTargetDomain: String?

        public var networkId: String?

        public var orderType: String?

        public var protocolType: String?

        public var storgeType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.fileSystemName != nil {
                map["FileSystemName"] = self.fileSystemName!
            }
            if self.mountTargetDomain != nil {
                map["MountTargetDomain"] = self.mountTargetDomain!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.storgeType != nil {
                map["StorgeType"] = self.storgeType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("FileSystemName") && dict["FileSystemName"] != nil {
                self.fileSystemName = dict["FileSystemName"] as! String
            }
            if dict.keys.contains("MountTargetDomain") && dict["MountTargetDomain"] != nil {
                self.mountTargetDomain = dict["MountTargetDomain"] as! String
            }
            if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
                self.orderType = dict["OrderType"] as! String
            }
            if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("StorgeType") && dict["StorgeType"] != nil {
                self.storgeType = dict["StorgeType"] as! String
            }
        }
    }
    public var orderDetails: [CreateFileSystemRequest.OrderDetails]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderDetails != nil {
            var tmp : [Any] = []
            for k in self.orderDetails! {
                tmp.append(k.toMap())
            }
            map["OrderDetails"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderDetails") && dict["OrderDetails"] != nil {
            var tmp : [CreateFileSystemRequest.OrderDetails] = []
            for v in dict["OrderDetails"] as! [Any] {
                var model = CreateFileSystemRequest.OrderDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orderDetails = tmp
        }
    }
}

public class CreateFileSystemShrinkRequest : Tea.TeaModel {
    public var orderDetailsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderDetailsShrink != nil {
            map["OrderDetails"] = self.orderDetailsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderDetails") && dict["OrderDetails"] != nil {
            self.orderDetailsShrink = dict["OrderDetails"] as! String
        }
    }
}

public class CreateFileSystemResponseBody : Tea.TeaModel {
    public var allocationId: [String]?

    public var bizStatusCode: String?

    public var requestId: String?

    public var unAllocationId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.bizStatusCode != nil {
            map["BizStatusCode"] = self.bizStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.unAllocationId != nil {
            map["UnAllocationId"] = self.unAllocationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") && dict["AllocationId"] != nil {
            self.allocationId = dict["AllocationId"] as! [String]
        }
        if dict.keys.contains("BizStatusCode") && dict["BizStatusCode"] != nil {
            self.bizStatusCode = dict["BizStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UnAllocationId") && dict["UnAllocationId"] != nil {
            self.unAllocationId = dict["UnAllocationId"] as! [String]
        }
    }
}

public class CreateFileSystemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFileSystemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFileSystemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateForwardEntryRequest : Tea.TeaModel {
    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryName: String?

    public var healthCheckPort: Int32?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var natGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.healthCheckPort != nil {
            map["HealthCheckPort"] = self.healthCheckPort!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExternalIp") && dict["ExternalIp"] != nil {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ExternalPort") && dict["ExternalPort"] != nil {
            self.externalPort = dict["ExternalPort"] as! String
        }
        if dict.keys.contains("ForwardEntryName") && dict["ForwardEntryName"] != nil {
            self.forwardEntryName = dict["ForwardEntryName"] as! String
        }
        if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
            self.healthCheckPort = dict["HealthCheckPort"] as! Int32
        }
        if dict.keys.contains("InternalIp") && dict["InternalIp"] != nil {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("InternalPort") && dict["InternalPort"] != nil {
            self.internalPort = dict["InternalPort"] as! String
        }
        if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
    }
}

public class CreateForwardEntryResponseBody : Tea.TeaModel {
    public var forwardEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardEntryId") && dict["ForwardEntryId"] != nil {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateImageRequest : Tea.TeaModel {
    public var deleteAfterImageUpload: String?

    public var imageName: String?

    public var instanceId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteAfterImageUpload != nil {
            map["DeleteAfterImageUpload"] = self.deleteAfterImageUpload!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteAfterImageUpload") && dict["DeleteAfterImageUpload"] != nil {
            self.deleteAfterImageUpload = dict["DeleteAfterImageUpload"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class CreateImageResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var size: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var size: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! String
            }
        }
    }
    public var dataDisk: [CreateInstanceRequest.DataDisk]?

    public var systemDisk: CreateInstanceRequest.SystemDisk?

    public var autoRenew: String?

    public var autoRenewPeriod: String?

    public var ensRegionId: String?

    public var hostName: String?

    public var imageId: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var ipType: String?

    public var keyPairName: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var paymentType: String?

    public var period: String?

    public var privateIpAddress: String?

    public var publicIpIdentification: Bool?

    public var quantity: String?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.publicIpIdentification != nil {
            map["PublicIpIdentification"] = self.publicIpIdentification!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDisk") && dict["DataDisk"] != nil {
            var tmp : [CreateInstanceRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = CreateInstanceRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
            var model = CreateInstanceRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! String
        }
        if dict.keys.contains("AutoRenewPeriod") && dict["AutoRenewPeriod"] != nil {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("IpType") && dict["IpType"] != nil {
            self.ipType = dict["IpType"] as! String
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") && dict["PasswordInherit"] != nil {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("PaymentType") && dict["PaymentType"] != nil {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") && dict["PrivateIpAddress"] != nil {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("PublicIpIdentification") && dict["PublicIpIdentification"] != nil {
            self.publicIpIdentification = dict["PublicIpIdentification"] as! Bool
        }
        if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
            self.quantity = dict["Quantity"] as! String
        }
        if dict.keys.contains("UniqueSuffix") && dict["UniqueSuffix"] != nil {
            self.uniqueSuffix = dict["UniqueSuffix"] as! Bool
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public class InstanceIds : Tea.TeaModel {
        public var instanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! [String]
            }
        }
    }
    public var code: Int32?

    public var instanceIds: CreateInstanceResponseBody.InstanceIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            var model = CreateInstanceResponseBody.InstanceIds()
            model.fromMap(dict["InstanceIds"] as! [String: Any])
            self.instanceIds = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceActiveOpsTaskRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class CreateInstanceActiveOpsTaskShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class CreateInstanceActiveOpsTaskResponseBody : Tea.TeaModel {
    public var instanceActiveOpsTask: InstanceActiveOpsTask?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceActiveOpsTask?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceActiveOpsTask != nil {
            map["InstanceActiveOpsTask"] = self.instanceActiveOpsTask?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceActiveOpsTask") && dict["InstanceActiveOpsTask"] != nil {
            var model = InstanceActiveOpsTask()
            model.fromMap(dict["InstanceActiveOpsTask"] as! [String: Any])
            self.instanceActiveOpsTask = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateInstanceActiveOpsTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceActiveOpsTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateInstanceActiveOpsTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateKeyPairRequest : Tea.TeaModel {
    public var keyPairName: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class CreateKeyPairResponseBody : Tea.TeaModel {
    public var keyPairFingerPrint: String?

    public var keyPairId: String?

    public var keyPairName: String?

    public var privateKeyBody: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairId != nil {
            map["KeyPairId"] = self.keyPairId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.privateKeyBody != nil {
            map["PrivateKeyBody"] = self.privateKeyBody!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairFingerPrint") && dict["KeyPairFingerPrint"] != nil {
            self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
        }
        if dict.keys.contains("KeyPairId") && dict["KeyPairId"] != nil {
            self.keyPairId = dict["KeyPairId"] as! String
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("PrivateKeyBody") && dict["PrivateKeyBody"] != nil {
            self.privateKeyBody = dict["PrivateKeyBody"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateKeyPairResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var loadBalancerName: String?

    public var loadBalancerSpec: String?

    public var networkId: String?

    public var payType: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        if self.loadBalancerSpec != nil {
            map["LoadBalancerSpec"] = self.loadBalancerSpec!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") && dict["LoadBalancerName"] != nil {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
        if dict.keys.contains("LoadBalancerSpec") && dict["LoadBalancerSpec"] != nil {
            self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PayType") && dict["PayType"] != nil {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateLoadBalancerResponseBody : Tea.TeaModel {
    public var loadBalancerId: String?

    public var loadBalancerName: String?

    public var networkId: String?

    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") && dict["LoadBalancerName"] != nil {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateLoadBalancerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLoadBalancerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerHTTPListenerRequest : Tea.TeaModel {
    public var description_: String?

    public var forwardPort: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerForward: String?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public var XForwardedFor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.forwardPort != nil {
            map["ForwardPort"] = self.forwardPort!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerForward != nil {
            map["ListenerForward"] = self.listenerForward!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        if self.XForwardedFor != nil {
            map["XForwardedFor"] = self.XForwardedFor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ForwardPort") && dict["ForwardPort"] != nil {
            self.forwardPort = dict["ForwardPort"] as! Int32
        }
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") && dict["HealthCheckMethod"] != nil {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") && dict["HealthCheckTimeout"] != nil {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerForward") && dict["ListenerForward"] != nil {
            self.listenerForward = dict["ListenerForward"] as! String
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
        if dict.keys.contains("XForwardedFor") && dict["XForwardedFor"] != nil {
            self.XForwardedFor = dict["XForwardedFor"] as! String
        }
    }
}

public class CreateLoadBalancerHTTPListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLoadBalancerHTTPListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerHTTPListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLoadBalancerHTTPListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerHTTPSListenerRequest : Tea.TeaModel {
    public var cookie: String?

    public var cookieTimeout: Int32?

    public var description_: String?

    public var forwardPort: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerForward: String?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var stickySessionType: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cookie != nil {
            map["Cookie"] = self.cookie!
        }
        if self.cookieTimeout != nil {
            map["CookieTimeout"] = self.cookieTimeout!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.forwardPort != nil {
            map["ForwardPort"] = self.forwardPort!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerForward != nil {
            map["ListenerForward"] = self.listenerForward!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.stickySessionType != nil {
            map["StickySessionType"] = self.stickySessionType!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cookie") && dict["Cookie"] != nil {
            self.cookie = dict["Cookie"] as! String
        }
        if dict.keys.contains("CookieTimeout") && dict["CookieTimeout"] != nil {
            self.cookieTimeout = dict["CookieTimeout"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ForwardPort") && dict["ForwardPort"] != nil {
            self.forwardPort = dict["ForwardPort"] as! Int32
        }
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") && dict["HealthCheckMethod"] != nil {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") && dict["HealthCheckTimeout"] != nil {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerForward") && dict["ListenerForward"] != nil {
            self.listenerForward = dict["ListenerForward"] as! String
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") && dict["ServerCertificateId"] != nil {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("StickySessionType") && dict["StickySessionType"] != nil {
            self.stickySessionType = dict["StickySessionType"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class CreateLoadBalancerHTTPSListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLoadBalancerHTTPSListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerHTTPSListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLoadBalancerHTTPSListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerTCPListenerRequest : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var description_: String?

    public var eipTransmit: String?

    public var establishedTimeout: Int32?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckType: String?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var persistenceTimeout: Int32?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.persistenceTimeout != nil {
            map["PersistenceTimeout"] = self.persistenceTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") && dict["BackendServerPort"] != nil {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") && dict["EipTransmit"] != nil {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("EstablishedTimeout") && dict["EstablishedTimeout"] != nil {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") && dict["HealthCheckConnectTimeout"] != nil {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckType") && dict["HealthCheckType"] != nil {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("PersistenceTimeout") && dict["PersistenceTimeout"] != nil {
            self.persistenceTimeout = dict["PersistenceTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class CreateLoadBalancerTCPListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLoadBalancerTCPListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerTCPListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLoadBalancerTCPListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerUDPListenerRequest : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var description_: String?

    public var eipTransmit: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckExp: String?

    public var healthCheckInterval: Int32?

    public var healthCheckReq: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckExp != nil {
            map["HealthCheckExp"] = self.healthCheckExp!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckReq != nil {
            map["HealthCheckReq"] = self.healthCheckReq!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") && dict["BackendServerPort"] != nil {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") && dict["EipTransmit"] != nil {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") && dict["HealthCheckConnectTimeout"] != nil {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckExp") && dict["HealthCheckExp"] != nil {
            self.healthCheckExp = dict["HealthCheckExp"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckReq") && dict["HealthCheckReq"] != nil {
            self.healthCheckReq = dict["HealthCheckReq"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class CreateLoadBalancerUDPListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLoadBalancerUDPListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerUDPListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateLoadBalancerUDPListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMountTargetRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public var mountTargetName: String?

    public var netWorkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.mountTargetName != nil {
            map["MountTargetName"] = self.mountTargetName!
        }
        if self.netWorkId != nil {
            map["NetWorkId"] = self.netWorkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") && dict["FileSystemId"] != nil {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("MountTargetName") && dict["MountTargetName"] != nil {
            self.mountTargetName = dict["MountTargetName"] as! String
        }
        if dict.keys.contains("NetWorkId") && dict["NetWorkId"] != nil {
            self.netWorkId = dict["NetWorkId"] as! String
        }
    }
}

public class CreateMountTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class CreateMountTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMountTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMountTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNatGatewayRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var instanceType: String?

    public var name: String?

    public var networkId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateNatGatewayResponseBody : Tea.TeaModel {
    public var natGatewayId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateNatGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var ensRegionId: String?

    public var networkName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("NetworkName") && dict["NetworkName"] != nil {
            self.networkName = dict["NetworkName"] as! String
        }
    }
}

public class CreateNetworkResponseBody : Tea.TeaModel {
    public var networkId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkAclRequest : Tea.TeaModel {
    public var description_: String?

    public var networkAclName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NetworkAclName") && dict["NetworkAclName"] != nil {
            self.networkAclName = dict["NetworkAclName"] as! String
        }
    }
}

public class CreateNetworkAclResponseBody : Tea.TeaModel {
    public var networkAclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") && dict["NetworkAclId"] != nil {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkAclEntryRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var direction: String?

    public var networkAclEntryName: String?

    public var networkAclId: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.networkAclEntryName != nil {
            map["NetworkAclEntryName"] = self.networkAclEntryName!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Direction") && dict["Direction"] != nil {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("NetworkAclEntryName") && dict["NetworkAclEntryName"] != nil {
            self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
        }
        if dict.keys.contains("NetworkAclId") && dict["NetworkAclId"] != nil {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") && dict["Priority"] != nil {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class CreateNetworkAclEntryResponseBody : Tea.TeaModel {
    public var networkAclEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclEntryId != nil {
            map["NetworkAclEntryId"] = self.networkAclEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclEntryId") && dict["NetworkAclEntryId"] != nil {
            self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkAclEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkAclEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateNetworkAclEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSecurityGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var securityGroupName: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class CreateSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class CreateSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSnatEntryRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public var sourceCIDR: String?

    public var sourceNetworkId: String?

    public var sourceVSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.sourceCIDR != nil {
            map["SourceCIDR"] = self.sourceCIDR!
        }
        if self.sourceNetworkId != nil {
            map["SourceNetworkId"] = self.sourceNetworkId!
        }
        if self.sourceVSwitchId != nil {
            map["SourceVSwitchId"] = self.sourceVSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("SnatEntryName") && dict["SnatEntryName"] != nil {
            self.snatEntryName = dict["SnatEntryName"] as! String
        }
        if dict.keys.contains("SnatIp") && dict["SnatIp"] != nil {
            self.snatIp = dict["SnatIp"] as! String
        }
        if dict.keys.contains("SourceCIDR") && dict["SourceCIDR"] != nil {
            self.sourceCIDR = dict["SourceCIDR"] as! String
        }
        if dict.keys.contains("SourceNetworkId") && dict["SourceNetworkId"] != nil {
            self.sourceNetworkId = dict["SourceNetworkId"] as! String
        }
        if dict.keys.contains("SourceVSwitchId") && dict["SourceVSwitchId"] != nil {
            self.sourceVSwitchId = dict["SourceVSwitchId"] as! String
        }
    }
}

public class CreateSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snatEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnatEntryId") && dict["SnatEntryId"] != nil {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
    }
}

public class CreateSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVSwitchRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var ensRegionId: String?

    public var networkId: String?

    public var vSwitchName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("VSwitchName") && dict["VSwitchName"] != nil {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
    }
}

public class CreateVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class DeleteApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDeviceInternetPortRequest : Tea.TeaModel {
    public var instanceId: String?

    public var natType: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NatType") && dict["NatType"] != nil {
            self.natType = dict["NatType"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class DeleteDeviceInternetPortResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var ruleIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleIds != nil {
            map["RuleIds"] = self.ruleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleIds") && dict["RuleIds"] != nil {
            self.ruleIds = dict["RuleIds"] as! [String]
        }
    }
}

public class DeleteDeviceInternetPortResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDeviceInternetPortResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDeviceInternetPortResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
            self.diskId = dict["DiskId"] as! String
        }
    }
}

public class DeleteDiskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnsRouteEntryRequest : Tea.TeaModel {
    public var routeEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RouteEntryId") && dict["RouteEntryId"] != nil {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
    }
}

public class DeleteEnsRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnsRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnsRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEnsRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
    }
}

public class DeleteEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFileSystemRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") && dict["FileSystemId"] != nil {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
    }
}

public class DeleteFileSystemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFileSystemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFileSystemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFileSystemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteForwardEntryRequest : Tea.TeaModel {
    public var forwardEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardEntryId") && dict["ForwardEntryId"] != nil {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
    }
}

public class DeleteForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImageRequest : Tea.TeaModel {
    public var imageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
    }
}

public class DeleteImageResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteKeyPairsRequest : Tea.TeaModel {
    public var keyPairName: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DeleteKeyPairsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteKeyPairsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteKeyPairsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteKeyPairsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLoadBalancerListenerRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("ListenerProtocol") && dict["ListenerProtocol"] != nil {
            self.listenerProtocol = dict["ListenerProtocol"] as! String
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DeleteLoadBalancerListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLoadBalancerListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLoadBalancerListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLoadBalancerListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMountTargetRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public var mountTargetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.mountTargetName != nil {
            map["MountTargetName"] = self.mountTargetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") && dict["FileSystemId"] != nil {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("MountTargetName") && dict["MountTargetName"] != nil {
            self.mountTargetName = dict["MountTargetName"] as! String
        }
    }
}

public class DeleteMountTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMountTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMountTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMountTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNatGatewayRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
    }
}

public class DeleteNatGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNatGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkRequest : Tea.TeaModel {
    public var networkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
    }
}

public class DeleteNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkAclRequest : Tea.TeaModel {
    public var networkAclId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") && dict["NetworkAclId"] != nil {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
    }
}

public class DeleteNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkAclEntryRequest : Tea.TeaModel {
    public var networkAclEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclEntryId != nil {
            map["NetworkAclEntryId"] = self.networkAclEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclEntryId") && dict["NetworkAclEntryId"] != nil {
            self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
        }
    }
}

public class DeleteNetworkAclEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkAclEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkAclEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteNetworkAclEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSecurityGroupRequest : Tea.TeaModel {
    public var securityGroupId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DeleteSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnatEntryRequest : Tea.TeaModel {
    public var snatEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SnatEntryId") && dict["SnatEntryId"] != nil {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
    }
}

public class DeleteSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVSwitchRequest : Tea.TeaModel {
    public var vSwitchId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DeleteVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAICImagesRequest : Tea.TeaModel {
    public var imageId: String?

    public var imageUrl: String?

    public var pageNumber: String?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageUrl") && dict["ImageUrl"] != nil {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
    }
}

public class DescribeAICImagesResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public var creationTime: String?

        public var imageId: String?

        public var imageUrl: String?

        public var status: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageUrl") && dict["ImageUrl"] != nil {
                self.imageUrl = dict["ImageUrl"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("User") && dict["User"] != nil {
                self.user = dict["User"] as! String
            }
        }
    }
    public var images: [DescribeAICImagesResponseBody.Images]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            var tmp : [Any] = []
            for k in self.images! {
                tmp.append(k.toMap())
            }
            map["Images"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Images") && dict["Images"] != nil {
            var tmp : [DescribeAICImagesResponseBody.Images] = []
            for v in dict["Images"] as! [Any] {
                var model = DescribeAICImagesResponseBody.Images()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.images = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAICImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAICImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAICImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeARMServerInstancesRequest : Tea.TeaModel {
    public var ensRegionIds: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var serverIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serverIds != nil {
            map["ServerIds"] = self.serverIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionIds") && dict["EnsRegionIds"] != nil {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServerIds") && dict["ServerIds"] != nil {
            self.serverIds = dict["ServerIds"] as! [String]
        }
    }
}

public class DescribeARMServerInstancesShrinkRequest : Tea.TeaModel {
    public var ensRegionIdsShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var serverIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionIdsShrink != nil {
            map["EnsRegionIds"] = self.ensRegionIdsShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serverIdsShrink != nil {
            map["ServerIds"] = self.serverIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionIds") && dict["EnsRegionIds"] != nil {
            self.ensRegionIdsShrink = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServerIds") && dict["ServerIds"] != nil {
            self.serverIdsShrink = dict["ServerIds"] as! String
        }
    }
}

public class DescribeARMServerInstancesResponseBody : Tea.TeaModel {
    public class Servers : Tea.TeaModel {
        public class AICInstances : Tea.TeaModel {
            public class NetworkAttributes : Tea.TeaModel {
                public var ipAddress: String?

                public var networkId: String?

                public var vSwitchId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    if self.networkId != nil {
                        map["NetworkId"] = self.networkId!
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
                        self.ipAddress = dict["IpAddress"] as! String
                    }
                    if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
                        self.networkId = dict["NetworkId"] as! String
                    }
                    if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                        self.vSwitchId = dict["VSwitchId"] as! String
                    }
                }
            }
            public var frequency: Int64?

            public var imageId: String?

            public var instanceId: String?

            public var networkAttributes: DescribeARMServerInstancesResponseBody.Servers.AICInstances.NetworkAttributes?

            public var resolution: String?

            public var spec: String?

            public var state: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.networkAttributes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.frequency != nil {
                    map["Frequency"] = self.frequency!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.networkAttributes != nil {
                    map["NetworkAttributes"] = self.networkAttributes?.toMap()
                }
                if self.resolution != nil {
                    map["Resolution"] = self.resolution!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Frequency") && dict["Frequency"] != nil {
                    self.frequency = dict["Frequency"] as! Int64
                }
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("NetworkAttributes") && dict["NetworkAttributes"] != nil {
                    var model = DescribeARMServerInstancesResponseBody.Servers.AICInstances.NetworkAttributes()
                    model.fromMap(dict["NetworkAttributes"] as! [String: Any])
                    self.networkAttributes = model
                }
                if dict.keys.contains("Resolution") && dict["Resolution"] != nil {
                    self.resolution = dict["Resolution"] as! String
                }
                if dict.keys.contains("Spec") && dict["Spec"] != nil {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var AICInstances: [DescribeARMServerInstancesResponseBody.Servers.AICInstances]?

        public var creationTime: String?

        public var ensRegionId: String?

        public var expiredTime: String?

        public var namespace: String?

        public var serverId: String?

        public var specName: String?

        public var state: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AICInstances != nil {
                var tmp : [Any] = []
                for k in self.AICInstances! {
                    tmp.append(k.toMap())
                }
                map["AICInstances"] = tmp
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.specName != nil {
                map["SpecName"] = self.specName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AICInstances") && dict["AICInstances"] != nil {
                var tmp : [DescribeARMServerInstancesResponseBody.Servers.AICInstances] = []
                for v in dict["AICInstances"] as! [Any] {
                    var model = DescribeARMServerInstancesResponseBody.Servers.AICInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.AICInstances = tmp
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("SpecName") && dict["SpecName"] != nil {
                self.specName = dict["SpecName"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var servers: [DescribeARMServerInstancesResponseBody.Servers]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.servers != nil {
            var tmp : [Any] = []
            for k in self.servers! {
                tmp.append(k.toMap())
            }
            map["Servers"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Servers") && dict["Servers"] != nil {
            var tmp : [DescribeARMServerInstancesResponseBody.Servers] = []
            for v in dict["Servers"] as! [Any] {
                var model = DescribeARMServerInstancesResponseBody.Servers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.servers = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeARMServerInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeARMServerInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeARMServerInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var appVersions: String?

    public var level: String?

    public var outDetailStatParams: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appVersions != nil {
            map["AppVersions"] = self.appVersions!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.outDetailStatParams != nil {
            map["OutDetailStatParams"] = self.outDetailStatParams!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppVersions") && dict["AppVersions"] != nil {
            self.appVersions = dict["AppVersions"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("OutDetailStatParams") && dict["OutDetailStatParams"] != nil {
            self.outDetailStatParams = dict["OutDetailStatParams"] as! String
        }
    }
}

public class DescribeApplicationResponseBody : Tea.TeaModel {
    public var application: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.application != nil {
            map["Application"] = self.application!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Application") && dict["Application"] != nil {
            self.application = dict["Application"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationResourceSummaryRequest : Tea.TeaModel {
    public var level: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeApplicationResourceSummaryResponseBody : Tea.TeaModel {
    public var applicationResource: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationResource != nil {
            map["ApplicationResource"] = self.applicationResource!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationResource") && dict["ApplicationResource"] != nil {
            self.applicationResource = dict["ApplicationResource"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApplicationResourceSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationResourceSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApplicationResourceSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvailableResourceRequest : Tea.TeaModel {
    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeAvailableResourceResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var imageId: String?

            public var imageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                    self.imageName = dict["ImageName"] as! String
                }
            }
        }
        public var image: [DescribeAvailableResourceResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") && dict["Image"] != nil {
                var tmp : [DescribeAvailableResourceResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeAvailableResourceResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public var dataDiskSize: String?

            public var ensRegionId: String?

            public var instanceSpec: String?

            public var supportResourcesCount: String?

            public var systemDiskSize: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataDiskSize != nil {
                    map["DataDiskSize"] = self.dataDiskSize!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceSpec != nil {
                    map["InstanceSpec"] = self.instanceSpec!
                }
                if self.supportResourcesCount != nil {
                    map["SupportResourcesCount"] = self.supportResourcesCount!
                }
                if self.systemDiskSize != nil {
                    map["SystemDiskSize"] = self.systemDiskSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataDiskSize") && dict["DataDiskSize"] != nil {
                    self.dataDiskSize = dict["DataDiskSize"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceSpec") && dict["InstanceSpec"] != nil {
                    self.instanceSpec = dict["InstanceSpec"] as! String
                }
                if dict.keys.contains("SupportResourcesCount") && dict["SupportResourcesCount"] != nil {
                    self.supportResourcesCount = dict["SupportResourcesCount"] as! String
                }
                if dict.keys.contains("SystemDiskSize") && dict["SystemDiskSize"] != nil {
                    self.systemDiskSize = dict["SystemDiskSize"] as! String
                }
            }
        }
        public var supportResource: [DescribeAvailableResourceResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") && dict["SupportResource"] != nil {
                var tmp : [DescribeAvailableResourceResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeAvailableResourceResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeAvailableResourceResponseBody.Images?

    public var requestId: String?

    public var supportResources: DescribeAvailableResourceResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") && dict["Images"] != nil {
            var model = DescribeAvailableResourceResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") && dict["SupportResources"] != nil {
            var model = DescribeAvailableResourceResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeAvailableResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAvailableResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvailableResourceInfoResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var imageId: String?

            public var imageName: String?

            public var imageSize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageSize != nil {
                    map["ImageSize"] = self.imageSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImageSize") && dict["ImageSize"] != nil {
                    self.imageSize = dict["ImageSize"] as! Int32
                }
            }
        }
        public var image: [DescribeAvailableResourceInfoResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") && dict["Image"] != nil {
                var tmp : [DescribeAvailableResourceInfoResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeAvailableResourceInfoResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public class BandwidthTypes : Tea.TeaModel {
                public var bandwidthType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandwidthType != nil {
                        map["BandwidthType"] = self.bandwidthType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BandwidthType") && dict["BandwidthType"] != nil {
                        self.bandwidthType = dict["BandwidthType"] as! [String]
                    }
                }
            }
            public class EnsRegionIds : Tea.TeaModel {
                public var ensRegionId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ensRegionId != nil {
                        map["EnsRegionId"] = self.ensRegionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                        self.ensRegionId = dict["EnsRegionId"] as! [String]
                    }
                }
            }
            public class EnsRegionIdsExtends : Tea.TeaModel {
                public class EnsRegionId : Tea.TeaModel {
                    public var area: String?

                    public var enName: String?

                    public var ensRegionId: String?

                    public var name: String?

                    public var province: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.area != nil {
                            map["Area"] = self.area!
                        }
                        if self.enName != nil {
                            map["EnName"] = self.enName!
                        }
                        if self.ensRegionId != nil {
                            map["EnsRegionId"] = self.ensRegionId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.province != nil {
                            map["Province"] = self.province!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Area") && dict["Area"] != nil {
                            self.area = dict["Area"] as! String
                        }
                        if dict.keys.contains("EnName") && dict["EnName"] != nil {
                            self.enName = dict["EnName"] as! String
                        }
                        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                            self.ensRegionId = dict["EnsRegionId"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Province") && dict["Province"] != nil {
                            self.province = dict["Province"] as! String
                        }
                    }
                }
                public var ensRegionId: [DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends.EnsRegionId]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ensRegionId != nil {
                        var tmp : [Any] = []
                        for k in self.ensRegionId! {
                            tmp.append(k.toMap())
                        }
                        map["EnsRegionId"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                        var tmp : [DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends.EnsRegionId] = []
                        for v in dict["EnsRegionId"] as! [Any] {
                            var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends.EnsRegionId()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ensRegionId = tmp
                    }
                }
            }
            public class InstanceSpeces : Tea.TeaModel {
                public var instanceSpec: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceSpec != nil {
                        map["InstanceSpec"] = self.instanceSpec!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceSpec") && dict["InstanceSpec"] != nil {
                        self.instanceSpec = dict["InstanceSpec"] as! [String]
                    }
                }
            }
            public var bandwidthTypes: DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.BandwidthTypes?

            public var dataDiskMaxSize: Int32?

            public var dataDiskMinSize: Int32?

            public var ensRegionIds: DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIds?

            public var ensRegionIdsExtends: DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends?

            public var instanceSpeces: DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.InstanceSpeces?

            public var systemDiskMaxSize: Int32?

            public var systemDiskMinSize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bandwidthTypes?.validate()
                try self.ensRegionIds?.validate()
                try self.ensRegionIdsExtends?.validate()
                try self.instanceSpeces?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidthTypes != nil {
                    map["BandwidthTypes"] = self.bandwidthTypes?.toMap()
                }
                if self.dataDiskMaxSize != nil {
                    map["DataDiskMaxSize"] = self.dataDiskMaxSize!
                }
                if self.dataDiskMinSize != nil {
                    map["DataDiskMinSize"] = self.dataDiskMinSize!
                }
                if self.ensRegionIds != nil {
                    map["EnsRegionIds"] = self.ensRegionIds?.toMap()
                }
                if self.ensRegionIdsExtends != nil {
                    map["EnsRegionIdsExtends"] = self.ensRegionIdsExtends?.toMap()
                }
                if self.instanceSpeces != nil {
                    map["InstanceSpeces"] = self.instanceSpeces?.toMap()
                }
                if self.systemDiskMaxSize != nil {
                    map["SystemDiskMaxSize"] = self.systemDiskMaxSize!
                }
                if self.systemDiskMinSize != nil {
                    map["SystemDiskMinSize"] = self.systemDiskMinSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandwidthTypes") && dict["BandwidthTypes"] != nil {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.BandwidthTypes()
                    model.fromMap(dict["BandwidthTypes"] as! [String: Any])
                    self.bandwidthTypes = model
                }
                if dict.keys.contains("DataDiskMaxSize") && dict["DataDiskMaxSize"] != nil {
                    self.dataDiskMaxSize = dict["DataDiskMaxSize"] as! Int32
                }
                if dict.keys.contains("DataDiskMinSize") && dict["DataDiskMinSize"] != nil {
                    self.dataDiskMinSize = dict["DataDiskMinSize"] as! Int32
                }
                if dict.keys.contains("EnsRegionIds") && dict["EnsRegionIds"] != nil {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIds()
                    model.fromMap(dict["EnsRegionIds"] as! [String: Any])
                    self.ensRegionIds = model
                }
                if dict.keys.contains("EnsRegionIdsExtends") && dict["EnsRegionIdsExtends"] != nil {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends()
                    model.fromMap(dict["EnsRegionIdsExtends"] as! [String: Any])
                    self.ensRegionIdsExtends = model
                }
                if dict.keys.contains("InstanceSpeces") && dict["InstanceSpeces"] != nil {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.InstanceSpeces()
                    model.fromMap(dict["InstanceSpeces"] as! [String: Any])
                    self.instanceSpeces = model
                }
                if dict.keys.contains("SystemDiskMaxSize") && dict["SystemDiskMaxSize"] != nil {
                    self.systemDiskMaxSize = dict["SystemDiskMaxSize"] as! Int32
                }
                if dict.keys.contains("SystemDiskMinSize") && dict["SystemDiskMinSize"] != nil {
                    self.systemDiskMinSize = dict["SystemDiskMinSize"] as! Int32
                }
            }
        }
        public var supportResource: [DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") && dict["SupportResource"] != nil {
                var tmp : [DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var images: DescribeAvailableResourceInfoResponseBody.Images?

    public var requestId: String?

    public var supportResources: DescribeAvailableResourceInfoResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Images") && dict["Images"] != nil {
            var model = DescribeAvailableResourceInfoResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") && dict["SupportResources"] != nil {
            var model = DescribeAvailableResourceInfoResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeAvailableResourceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableResourceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAvailableResourceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBandWithdChargeTypeRequest : Tea.TeaModel {
    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeBandWithdChargeTypeResponseBody : Tea.TeaModel {
    public var bandWithTypeInfo: String?

    public var chargeContractType: String?

    public var chargeCycleInfo: String?

    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandWithTypeInfo != nil {
            map["BandWithTypeInfo"] = self.bandWithTypeInfo!
        }
        if self.chargeContractType != nil {
            map["ChargeContractType"] = self.chargeContractType!
        }
        if self.chargeCycleInfo != nil {
            map["ChargeCycleInfo"] = self.chargeCycleInfo!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandWithTypeInfo") && dict["BandWithTypeInfo"] != nil {
            self.bandWithTypeInfo = dict["BandWithTypeInfo"] as! String
        }
        if dict.keys.contains("ChargeContractType") && dict["ChargeContractType"] != nil {
            self.chargeContractType = dict["ChargeContractType"] as! String
        }
        if dict.keys.contains("ChargeCycleInfo") && dict["ChargeCycleInfo"] != nil {
            self.chargeCycleInfo = dict["ChargeCycleInfo"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBandWithdChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandWithdChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBandWithdChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBandwitdhByInternetChargeTypeRequest : Tea.TeaModel {
    public var endTime: String?

    public var ensRegionId: String?

    public var isp: String?

    public var startTime: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("Isp") && dict["Isp"] != nil {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeBandwitdhByInternetChargeTypeResponseBody : Tea.TeaModel {
    public var bandwidthValue: Int64?

    public var internetChargeType: String?

    public var requestId: String?

    public var timeStamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthValue != nil {
            map["BandwidthValue"] = self.bandwidthValue!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthValue") && dict["BandwidthValue"] != nil {
            self.bandwidthValue = dict["BandwidthValue"] as! Int64
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
            self.timeStamp = dict["TimeStamp"] as! String
        }
    }
}

public class DescribeBandwitdhByInternetChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandwitdhByInternetChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBandwitdhByInternetChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudDiskAvailableResourceInfoResponseBody : Tea.TeaModel {
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public var canBuyCount: Int64?

            public var category: String?

            public var defaultDiskSize: Int64?

            public var diskMaxSize: Int64?

            public var diskMinSize: Int64?

            public var ensRegionId: String?

            public var ensRegionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.canBuyCount != nil {
                    map["CanBuyCount"] = self.canBuyCount!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.defaultDiskSize != nil {
                    map["DefaultDiskSize"] = self.defaultDiskSize!
                }
                if self.diskMaxSize != nil {
                    map["DiskMaxSize"] = self.diskMaxSize!
                }
                if self.diskMinSize != nil {
                    map["DiskMinSize"] = self.diskMinSize!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.ensRegionName != nil {
                    map["EnsRegionName"] = self.ensRegionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CanBuyCount") && dict["CanBuyCount"] != nil {
                    self.canBuyCount = dict["CanBuyCount"] as! Int64
                }
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("DefaultDiskSize") && dict["DefaultDiskSize"] != nil {
                    self.defaultDiskSize = dict["DefaultDiskSize"] as! Int64
                }
                if dict.keys.contains("DiskMaxSize") && dict["DiskMaxSize"] != nil {
                    self.diskMaxSize = dict["DiskMaxSize"] as! Int64
                }
                if dict.keys.contains("DiskMinSize") && dict["DiskMinSize"] != nil {
                    self.diskMinSize = dict["DiskMinSize"] as! Int64
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("EnsRegionName") && dict["EnsRegionName"] != nil {
                    self.ensRegionName = dict["EnsRegionName"] as! String
                }
            }
        }
        public var supportResource: [DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") && dict["SupportResource"] != nil {
                var tmp : [DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var requestId: String?

    public var supportResources: DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") && dict["SupportResources"] != nil {
            var model = DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeCloudDiskAvailableResourceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudDiskAvailableResourceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCloudDiskAvailableResourceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudDiskTypesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
    }
}

public class DescribeCloudDiskTypesResponseBody : Tea.TeaModel {
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public var category: String?

            public var ensRegionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
            }
        }
        public var supportResource: [DescribeCloudDiskTypesResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") && dict["SupportResource"] != nil {
                var tmp : [DescribeCloudDiskTypesResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeCloudDiskTypesResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var requestId: String?

    public var supportResources: DescribeCloudDiskTypesResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") && dict["SupportResources"] != nil {
            var model = DescribeCloudDiskTypesResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeCloudDiskTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudDiskTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCloudDiskTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCreatePrePaidInstanceResultRequest : Tea.TeaModel {
    public var instanceId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeCreatePrePaidInstanceResultResponseBody : Tea.TeaModel {
    public class InstanceCreateResult : Tea.TeaModel {
        public var instanceCreateStatus: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceCreateStatus != nil {
                map["InstanceCreateStatus"] = self.instanceCreateStatus!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceCreateStatus") && dict["InstanceCreateStatus"] != nil {
                self.instanceCreateStatus = dict["InstanceCreateStatus"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public var instanceCreateResult: DescribeCreatePrePaidInstanceResultResponseBody.InstanceCreateResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceCreateResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCreateResult != nil {
            map["InstanceCreateResult"] = self.instanceCreateResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceCreateResult") && dict["InstanceCreateResult"] != nil {
            var model = DescribeCreatePrePaidInstanceResultResponseBody.InstanceCreateResult()
            model.fromMap(dict["InstanceCreateResult"] as! [String: Any])
            self.instanceCreateResult = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCreatePrePaidInstanceResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCreatePrePaidInstanceResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCreatePrePaidInstanceResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataDistResultRequest : Tea.TeaModel {
    public var appId: String?

    public var dataNames: String?

    public var dataVersions: String?

    public var ensRegionIds: [String]?

    public var instanceIds: String?

    public var maxDate: String?

    public var minDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataNames != nil {
            map["DataNames"] = self.dataNames!
        }
        if self.dataVersions != nil {
            map["DataVersions"] = self.dataVersions!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataNames") && dict["DataNames"] != nil {
            self.dataNames = dict["DataNames"] as! String
        }
        if dict.keys.contains("DataVersions") && dict["DataVersions"] != nil {
            self.dataVersions = dict["DataVersions"] as! String
        }
        if dict.keys.contains("EnsRegionIds") && dict["EnsRegionIds"] != nil {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("MaxDate") && dict["MaxDate"] != nil {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") && dict["MinDate"] != nil {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeDataDistResultShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var dataNames: String?

    public var dataVersions: String?

    public var ensRegionIdsShrink: String?

    public var instanceIds: String?

    public var maxDate: String?

    public var minDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataNames != nil {
            map["DataNames"] = self.dataNames!
        }
        if self.dataVersions != nil {
            map["DataVersions"] = self.dataVersions!
        }
        if self.ensRegionIdsShrink != nil {
            map["EnsRegionIds"] = self.ensRegionIdsShrink!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataNames") && dict["DataNames"] != nil {
            self.dataNames = dict["DataNames"] as! String
        }
        if dict.keys.contains("DataVersions") && dict["DataVersions"] != nil {
            self.dataVersions = dict["DataVersions"] as! String
        }
        if dict.keys.contains("EnsRegionIds") && dict["EnsRegionIds"] != nil {
            self.ensRegionIdsShrink = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("MaxDate") && dict["MaxDate"] != nil {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") && dict["MinDate"] != nil {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeDataDistResultResponseBody : Tea.TeaModel {
    public class DistResults : Tea.TeaModel {
        public class DistResult : Tea.TeaModel {
            public class StatusStats : Tea.TeaModel {
                public class StatusStat : Tea.TeaModel {
                    public class Instances : Tea.TeaModel {
                        public class Instance : Tea.TeaModel {
                            public var instanceId: String?

                            public var startTime: String?

                            public var statusDescrip: String?

                            public var updateTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.instanceId != nil {
                                    map["InstanceId"] = self.instanceId!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.statusDescrip != nil {
                                    map["StatusDescrip"] = self.statusDescrip!
                                }
                                if self.updateTime != nil {
                                    map["UpdateTime"] = self.updateTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                                    self.instanceId = dict["InstanceId"] as! String
                                }
                                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("StatusDescrip") && dict["StatusDescrip"] != nil {
                                    self.statusDescrip = dict["StatusDescrip"] as! String
                                }
                                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                                    self.updateTime = dict["UpdateTime"] as! String
                                }
                            }
                        }
                        public var instance: [DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances.Instance]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.instance != nil {
                                var tmp : [Any] = []
                                for k in self.instance! {
                                    tmp.append(k.toMap())
                                }
                                map["Instance"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Instance") && dict["Instance"] != nil {
                                var tmp : [DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances.Instance] = []
                                for v in dict["Instance"] as! [Any] {
                                    var model = DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances.Instance()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.instance = tmp
                            }
                        }
                    }
                    public var instanceCount: String?

                    public var instances: DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.instances?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceCount != nil {
                            map["InstanceCount"] = self.instanceCount!
                        }
                        if self.instances != nil {
                            map["Instances"] = self.instances?.toMap()
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                            self.instanceCount = dict["InstanceCount"] as! String
                        }
                        if dict.keys.contains("Instances") && dict["Instances"] != nil {
                            var model = DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances()
                            model.fromMap(dict["Instances"] as! [String: Any])
                            self.instances = model
                        }
                        if dict.keys.contains("Status") && dict["Status"] != nil {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var statusStat: [DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.statusStat != nil {
                        var tmp : [Any] = []
                        for k in self.statusStat! {
                            tmp.append(k.toMap())
                        }
                        map["StatusStat"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StatusStat") && dict["StatusStat"] != nil {
                        var tmp : [DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat] = []
                        for v in dict["StatusStat"] as! [Any] {
                            var model = DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.statusStat = tmp
                    }
                }
            }
            public var name: String?

            public var statusStats: DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.statusStats?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.statusStats != nil {
                    map["StatusStats"] = self.statusStats?.toMap()
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("StatusStats") && dict["StatusStats"] != nil {
                    var model = DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats()
                    model.fromMap(dict["StatusStats"] as! [String: Any])
                    self.statusStats = model
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var distResult: [DescribeDataDistResultResponseBody.DistResults.DistResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.distResult != nil {
                var tmp : [Any] = []
                for k in self.distResult! {
                    tmp.append(k.toMap())
                }
                map["DistResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DistResult") && dict["DistResult"] != nil {
                var tmp : [DescribeDataDistResultResponseBody.DistResults.DistResult] = []
                for v in dict["DistResult"] as! [Any] {
                    var model = DescribeDataDistResultResponseBody.DistResults.DistResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.distResult = tmp
            }
        }
    }
    public var distResults: DescribeDataDistResultResponseBody.DistResults?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.distResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.distResults != nil {
            map["DistResults"] = self.distResults?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DistResults") && dict["DistResults"] != nil {
            var model = DescribeDataDistResultResponseBody.DistResults()
            model.fromMap(dict["DistResults"] as! [String: Any])
            self.distResults = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDataDistResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataDistResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDataDistResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataDownloadURLRequest : Tea.TeaModel {
    public var appId: String?

    public var dataName: String?

    public var dataVersion: String?

    public var expireTimeout: Int64?

    public var serverFilterStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataName != nil {
            map["DataName"] = self.dataName!
        }
        if self.dataVersion != nil {
            map["DataVersion"] = self.dataVersion!
        }
        if self.expireTimeout != nil {
            map["ExpireTimeout"] = self.expireTimeout!
        }
        if self.serverFilterStrategy != nil {
            map["ServerFilterStrategy"] = self.serverFilterStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataName") && dict["DataName"] != nil {
            self.dataName = dict["DataName"] as! String
        }
        if dict.keys.contains("DataVersion") && dict["DataVersion"] != nil {
            self.dataVersion = dict["DataVersion"] as! String
        }
        if dict.keys.contains("ExpireTimeout") && dict["ExpireTimeout"] != nil {
            self.expireTimeout = dict["ExpireTimeout"] as! Int64
        }
        if dict.keys.contains("ServerFilterStrategy") && dict["ServerFilterStrategy"] != nil {
            self.serverFilterStrategy = dict["ServerFilterStrategy"] as! String
        }
    }
}

public class DescribeDataDownloadURLResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ServerList : Tea.TeaModel {
            public var host: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") && dict["Host"] != nil {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var expireTime: String?

        public var serverList: [DescribeDataDownloadURLResponseBody.Data.ServerList]?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.serverList != nil {
                var tmp : [Any] = []
                for k in self.serverList! {
                    tmp.append(k.toMap())
                }
                map["ServerList"] = tmp
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("ServerList") && dict["ServerList"] != nil {
                var tmp : [DescribeDataDownloadURLResponseBody.Data.ServerList] = []
                for v in dict["ServerList"] as! [Any] {
                    var model = DescribeDataDownloadURLResponseBody.Data.ServerList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serverList = tmp
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: DescribeDataDownloadURLResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeDataDownloadURLResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDataDownloadURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataDownloadURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDataDownloadURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataPushResultRequest : Tea.TeaModel {
    public var appId: String?

    public var dataNames: String?

    public var dataVersions: String?

    public var maxDate: String?

    public var minDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataNames != nil {
            map["DataNames"] = self.dataNames!
        }
        if self.dataVersions != nil {
            map["DataVersions"] = self.dataVersions!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionIds != nil {
            map["RegionIds"] = self.regionIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataNames") && dict["DataNames"] != nil {
            self.dataNames = dict["DataNames"] as! String
        }
        if dict.keys.contains("DataVersions") && dict["DataVersions"] != nil {
            self.dataVersions = dict["DataVersions"] as! String
        }
        if dict.keys.contains("MaxDate") && dict["MaxDate"] != nil {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") && dict["MinDate"] != nil {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionIds") && dict["RegionIds"] != nil {
            self.regionIds = dict["RegionIds"] as! String
        }
    }
}

public class DescribeDataPushResultResponseBody : Tea.TeaModel {
    public class PushResults : Tea.TeaModel {
        public class PushResult : Tea.TeaModel {
            public class StatusStatS : Tea.TeaModel {
                public class StatusStat : Tea.TeaModel {
                    public class RegionIds : Tea.TeaModel {
                        public class RegionId : Tea.TeaModel {
                            public var regionId: String?

                            public var startTime: String?

                            public var statusDescrip: String?

                            public var updateTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.regionId != nil {
                                    map["RegionId"] = self.regionId!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.statusDescrip != nil {
                                    map["StatusDescrip"] = self.statusDescrip!
                                }
                                if self.updateTime != nil {
                                    map["UpdateTime"] = self.updateTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                                    self.regionId = dict["RegionId"] as! String
                                }
                                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("StatusDescrip") && dict["StatusDescrip"] != nil {
                                    self.statusDescrip = dict["StatusDescrip"] as! String
                                }
                                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                                    self.updateTime = dict["UpdateTime"] as! String
                                }
                            }
                        }
                        public var regionId: [DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds.RegionId]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.regionId != nil {
                                var tmp : [Any] = []
                                for k in self.regionId! {
                                    tmp.append(k.toMap())
                                }
                                map["RegionId"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                                var tmp : [DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds.RegionId] = []
                                for v in dict["RegionId"] as! [Any] {
                                    var model = DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds.RegionId()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.regionId = tmp
                            }
                        }
                    }
                    public var regionIdCount: Int32?

                    public var regionIds: DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.regionIds?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.regionIdCount != nil {
                            map["RegionIdCount"] = self.regionIdCount!
                        }
                        if self.regionIds != nil {
                            map["RegionIds"] = self.regionIds?.toMap()
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("RegionIdCount") && dict["RegionIdCount"] != nil {
                            self.regionIdCount = dict["RegionIdCount"] as! Int32
                        }
                        if dict.keys.contains("RegionIds") && dict["RegionIds"] != nil {
                            var model = DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds()
                            model.fromMap(dict["RegionIds"] as! [String: Any])
                            self.regionIds = model
                        }
                        if dict.keys.contains("Status") && dict["Status"] != nil {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var statusStat: [DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.statusStat != nil {
                        var tmp : [Any] = []
                        for k in self.statusStat! {
                            tmp.append(k.toMap())
                        }
                        map["StatusStat"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StatusStat") && dict["StatusStat"] != nil {
                        var tmp : [DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat] = []
                        for v in dict["StatusStat"] as! [Any] {
                            var model = DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.statusStat = tmp
                    }
                }
            }
            public var name: String?

            public var statusStatS: DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.statusStatS?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.statusStatS != nil {
                    map["StatusStatS"] = self.statusStatS?.toMap()
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("StatusStatS") && dict["StatusStatS"] != nil {
                    var model = DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS()
                    model.fromMap(dict["StatusStatS"] as! [String: Any])
                    self.statusStatS = model
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var pushResult: [DescribeDataPushResultResponseBody.PushResults.PushResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pushResult != nil {
                var tmp : [Any] = []
                for k in self.pushResult! {
                    tmp.append(k.toMap())
                }
                map["PushResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
                var tmp : [DescribeDataPushResultResponseBody.PushResults.PushResult] = []
                for v in dict["PushResult"] as! [Any] {
                    var model = DescribeDataPushResultResponseBody.PushResults.PushResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pushResult = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pushResults: DescribeDataPushResultResponseBody.PushResults?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pushResults != nil {
            map["PushResults"] = self.pushResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PushResults") && dict["PushResults"] != nil {
            var model = DescribeDataPushResultResponseBody.PushResults()
            model.fromMap(dict["PushResults"] as! [String: Any])
            self.pushResults = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDataPushResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataPushResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDataPushResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeviceServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var ensRegionId: String?

    public var instanceId: String?

    public var orderId: String?

    public var regionId: String?

    public var serviceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
    }
}

public class DescribeDeviceServiceResponseBody : Tea.TeaModel {
    public class AppMetaData : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var appStableVersion: String?

        public var appType: String?

        public var clusterName: String?

        public var createTime: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.appStableVersion != nil {
                map["AppStableVersion"] = self.appStableVersion!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") && dict["AppId"] != nil {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("AppStableVersion") && dict["AppStableVersion"] != nil {
                self.appStableVersion = dict["AppStableVersion"] as! String
            }
            if dict.keys.contains("AppType") && dict["AppType"] != nil {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class AppStatus : Tea.TeaModel {
        public var phase: String?

        public var statusDescrip: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.statusDescrip != nil {
                map["StatusDescrip"] = self.statusDescrip!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Phase") && dict["Phase"] != nil {
                self.phase = dict["Phase"] as! String
            }
            if dict.keys.contains("StatusDescrip") && dict["StatusDescrip"] != nil {
                self.statusDescrip = dict["StatusDescrip"] as! String
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public class ResourceDetailInfos : Tea.TeaModel {
        public var deviceName: String?

        public var ID: String?

        public var IP: String?

        public var ISP: String?

        public var imageID: String?

        public var mac: String?

        public var regionID: String?

        public var server: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceName != nil {
                map["DeviceName"] = self.deviceName!
            }
            if self.ID != nil {
                map["ID"] = self.ID!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.ISP != nil {
                map["ISP"] = self.ISP!
            }
            if self.imageID != nil {
                map["ImageID"] = self.imageID!
            }
            if self.mac != nil {
                map["Mac"] = self.mac!
            }
            if self.regionID != nil {
                map["RegionID"] = self.regionID!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceName") && dict["DeviceName"] != nil {
                self.deviceName = dict["DeviceName"] as! String
            }
            if dict.keys.contains("ID") && dict["ID"] != nil {
                self.ID = dict["ID"] as! String
            }
            if dict.keys.contains("IP") && dict["IP"] != nil {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("ISP") && dict["ISP"] != nil {
                self.ISP = dict["ISP"] as! String
            }
            if dict.keys.contains("ImageID") && dict["ImageID"] != nil {
                self.imageID = dict["ImageID"] as! String
            }
            if dict.keys.contains("Mac") && dict["Mac"] != nil {
                self.mac = dict["Mac"] as! String
            }
            if dict.keys.contains("RegionID") && dict["RegionID"] != nil {
                self.regionID = dict["RegionID"] as! String
            }
            if dict.keys.contains("Server") && dict["Server"] != nil {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ResourceInfos : Tea.TeaModel {
        public class DeviceInfos : Tea.TeaModel {
            public class Network : Tea.TeaModel {
                public var containerPorts: String?

                public var externalIp: String?

                public var hostPorts: String?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.containerPorts != nil {
                        map["ContainerPorts"] = self.containerPorts!
                    }
                    if self.externalIp != nil {
                        map["ExternalIp"] = self.externalIp!
                    }
                    if self.hostPorts != nil {
                        map["HostPorts"] = self.hostPorts!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContainerPorts") && dict["ContainerPorts"] != nil {
                        self.containerPorts = dict["ContainerPorts"] as! String
                    }
                    if dict.keys.contains("ExternalIp") && dict["ExternalIp"] != nil {
                        self.externalIp = dict["ExternalIp"] as! String
                    }
                    if dict.keys.contains("HostPorts") && dict["HostPorts"] != nil {
                        self.hostPorts = dict["HostPorts"] as! String
                    }
                    if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public var name: String?

            public var network: [DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos.Network]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.network != nil {
                    var tmp : [Any] = []
                    for k in self.network! {
                        tmp.append(k.toMap())
                    }
                    map["Network"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Network") && dict["Network"] != nil {
                    var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos.Network] = []
                    for v in dict["Network"] as! [Any] {
                        var model = DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos.Network()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.network = tmp
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class InternalIps : Tea.TeaModel {
            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
            }
        }
        public class PublicIps : Tea.TeaModel {
            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
            }
        }
        public var appVersion: String?

        public var areaCode: String?

        public var areaName: String?

        public var createTime: String?

        public var deviceInfos: [DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos]?

        public var instanceId: String?

        public var instanceStatus: String?

        public var internalIps: [DescribeDeviceServiceResponseBody.ResourceInfos.InternalIps]?

        public var publicIps: [DescribeDeviceServiceResponseBody.ResourceInfos.PublicIps]?

        public var regionCode: String?

        public var regionId: String?

        public var regionName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.areaCode != nil {
                map["AreaCode"] = self.areaCode!
            }
            if self.areaName != nil {
                map["AreaName"] = self.areaName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deviceInfos != nil {
                var tmp : [Any] = []
                for k in self.deviceInfos! {
                    tmp.append(k.toMap())
                }
                map["DeviceInfos"] = tmp
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceStatus != nil {
                map["InstanceStatus"] = self.instanceStatus!
            }
            if self.internalIps != nil {
                var tmp : [Any] = []
                for k in self.internalIps! {
                    tmp.append(k.toMap())
                }
                map["InternalIps"] = tmp
            }
            if self.publicIps != nil {
                var tmp : [Any] = []
                for k in self.publicIps! {
                    tmp.append(k.toMap())
                }
                map["PublicIps"] = tmp
            }
            if self.regionCode != nil {
                map["RegionCode"] = self.regionCode!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppVersion") && dict["AppVersion"] != nil {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("AreaCode") && dict["AreaCode"] != nil {
                self.areaCode = dict["AreaCode"] as! String
            }
            if dict.keys.contains("AreaName") && dict["AreaName"] != nil {
                self.areaName = dict["AreaName"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeviceInfos") && dict["DeviceInfos"] != nil {
                var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos] = []
                for v in dict["DeviceInfos"] as! [Any] {
                    var model = DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deviceInfos = tmp
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceStatus") && dict["InstanceStatus"] != nil {
                self.instanceStatus = dict["InstanceStatus"] as! String
            }
            if dict.keys.contains("InternalIps") && dict["InternalIps"] != nil {
                var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos.InternalIps] = []
                for v in dict["InternalIps"] as! [Any] {
                    var model = DescribeDeviceServiceResponseBody.ResourceInfos.InternalIps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.internalIps = tmp
            }
            if dict.keys.contains("PublicIps") && dict["PublicIps"] != nil {
                var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos.PublicIps] = []
                for v in dict["PublicIps"] as! [Any] {
                    var model = DescribeDeviceServiceResponseBody.ResourceInfos.PublicIps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.publicIps = tmp
            }
            if dict.keys.contains("RegionCode") && dict["RegionCode"] != nil {
                self.regionCode = dict["RegionCode"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
        }
    }
    public var appMetaData: DescribeDeviceServiceResponseBody.AppMetaData?

    public var appStatus: DescribeDeviceServiceResponseBody.AppStatus?

    public var requestId: String?

    public var resourceDetailInfos: [DescribeDeviceServiceResponseBody.ResourceDetailInfos]?

    public var resourceInfos: [DescribeDeviceServiceResponseBody.ResourceInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appMetaData?.validate()
        try self.appStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appMetaData != nil {
            map["AppMetaData"] = self.appMetaData?.toMap()
        }
        if self.appStatus != nil {
            map["AppStatus"] = self.appStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceDetailInfos != nil {
            var tmp : [Any] = []
            for k in self.resourceDetailInfos! {
                tmp.append(k.toMap())
            }
            map["ResourceDetailInfos"] = tmp
        }
        if self.resourceInfos != nil {
            var tmp : [Any] = []
            for k in self.resourceInfos! {
                tmp.append(k.toMap())
            }
            map["ResourceInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppMetaData") && dict["AppMetaData"] != nil {
            var model = DescribeDeviceServiceResponseBody.AppMetaData()
            model.fromMap(dict["AppMetaData"] as! [String: Any])
            self.appMetaData = model
        }
        if dict.keys.contains("AppStatus") && dict["AppStatus"] != nil {
            var model = DescribeDeviceServiceResponseBody.AppStatus()
            model.fromMap(dict["AppStatus"] as! [String: Any])
            self.appStatus = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceDetailInfos") && dict["ResourceDetailInfos"] != nil {
            var tmp : [DescribeDeviceServiceResponseBody.ResourceDetailInfos] = []
            for v in dict["ResourceDetailInfos"] as! [Any] {
                var model = DescribeDeviceServiceResponseBody.ResourceDetailInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceDetailInfos = tmp
        }
        if dict.keys.contains("ResourceInfos") && dict["ResourceInfos"] != nil {
            var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos] = []
            for v in dict["ResourceInfos"] as! [Any] {
                var model = DescribeDeviceServiceResponseBody.ResourceInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceInfos = tmp
        }
    }
}

public class DescribeDeviceServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeviceServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDeviceServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDisksRequest : Tea.TeaModel {
    public var category: String?

    public var diskChargeType: String?

    public var diskId: String?

    public var diskIds: String?

    public var diskName: String?

    public var diskType: String?

    public var ensRegionId: String?

    public var ensRegionIds: String?

    public var instanceId: String?

    public var orderByParams: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var snapshotId: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.diskChargeType != nil {
            map["DiskChargeType"] = self.diskChargeType!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") && dict["Category"] != nil {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("DiskChargeType") && dict["DiskChargeType"] != nil {
            self.diskChargeType = dict["DiskChargeType"] as! String
        }
        if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("DiskIds") && dict["DiskIds"] != nil {
            self.diskIds = dict["DiskIds"] as! String
        }
        if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
            self.diskName = dict["DiskName"] as! String
        }
        if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
            self.diskType = dict["DiskType"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") && dict["EnsRegionIds"] != nil {
            self.ensRegionIds = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderByParams") && dict["OrderByParams"] != nil {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeDisksResponseBody : Tea.TeaModel {
    public class Disks : Tea.TeaModel {
        public class Disks : Tea.TeaModel {
            public var category: String?

            public var creationTime: String?

            public var diskChargeType: String?

            public var diskId: String?

            public var diskName: String?

            public var ensRegionId: String?

            public var instanceId: String?

            public var instanceName: String?

            public var portable: Bool?

            public var size: Int32?

            public var snapshotId: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diskChargeType != nil {
                    map["DiskChargeType"] = self.diskChargeType!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.portable != nil {
                    map["Portable"] = self.portable!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") && dict["Category"] != nil {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DiskChargeType") && dict["DiskChargeType"] != nil {
                    self.diskChargeType = dict["DiskChargeType"] as! String
                }
                if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Portable") && dict["Portable"] != nil {
                    self.portable = dict["Portable"] as! Bool
                }
                if dict.keys.contains("Size") && dict["Size"] != nil {
                    self.size = dict["Size"] as! Int32
                }
                if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var disks: [DescribeDisksResponseBody.Disks.Disks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disks != nil {
                var tmp : [Any] = []
                for k in self.disks! {
                    tmp.append(k.toMap())
                }
                map["Disks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Disks") && dict["Disks"] != nil {
                var tmp : [DescribeDisksResponseBody.Disks.Disks] = []
                for v in dict["Disks"] as! [Any] {
                    var model = DescribeDisksResponseBody.Disks.Disks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.disks = tmp
            }
        }
    }
    public var code: Int32?

    public var disks: DescribeDisksResponseBody.Disks?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.disks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.disks != nil {
            map["Disks"] = self.disks?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Disks") && dict["Disks"] != nil {
            var model = DescribeDisksResponseBody.Disks()
            model.fromMap(dict["Disks"] as! [String: Any])
            self.disks = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDisksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDisksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDisksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEipAddressesRequest : Tea.TeaModel {
    public var eips: String?

    public var ensRegionId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eips != nil {
            map["Eips"] = self.eips!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Eips") && dict["Eips"] != nil {
            self.eips = dict["Eips"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeEipAddressesResponseBody : Tea.TeaModel {
    public class EipAddresses : Tea.TeaModel {
        public class EipAddress : Tea.TeaModel {
            public var eip: String?

            public var instanceIdInternetIp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eip != nil {
                    map["Eip"] = self.eip!
                }
                if self.instanceIdInternetIp != nil {
                    map["InstanceIdInternetIp"] = self.instanceIdInternetIp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Eip") && dict["Eip"] != nil {
                    self.eip = dict["Eip"] as! String
                }
                if dict.keys.contains("InstanceIdInternetIp") && dict["InstanceIdInternetIp"] != nil {
                    self.instanceIdInternetIp = dict["InstanceIdInternetIp"] as! String
                }
            }
        }
        public var eipAddress: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipAddress != nil {
                var tmp : [Any] = []
                for k in self.eipAddress! {
                    tmp.append(k.toMap())
                }
                map["EipAddress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipAddress") && dict["EipAddress"] != nil {
                var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress] = []
                for v in dict["EipAddress"] as! [Any] {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipAddress = tmp
            }
        }
    }
    public var eipAddresses: DescribeEipAddressesResponseBody.EipAddresses?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipAddresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipAddresses != nil {
            map["EipAddresses"] = self.eipAddresses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipAddresses") && dict["EipAddresses"] != nil {
            var model = DescribeEipAddressesResponseBody.EipAddresses()
            model.fromMap(dict["EipAddresses"] as! [String: Any])
            self.eipAddresses = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEipAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEipAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeElbAvailableResourceInfoResponseBody : Tea.TeaModel {
    public class ElbAvailableResourceInfo : Tea.TeaModel {
        public var area: String?

        public var canBuyCount: String?

        public var enName: String?

        public var ensRegionId: String?

        public var loadBalancerSpec: [String]?

        public var name: String?

        public var province: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.area != nil {
                map["Area"] = self.area!
            }
            if self.canBuyCount != nil {
                map["CanBuyCount"] = self.canBuyCount!
            }
            if self.enName != nil {
                map["EnName"] = self.enName!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.loadBalancerSpec != nil {
                map["LoadBalancerSpec"] = self.loadBalancerSpec!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Area") && dict["Area"] != nil {
                self.area = dict["Area"] as! String
            }
            if dict.keys.contains("CanBuyCount") && dict["CanBuyCount"] != nil {
                self.canBuyCount = dict["CanBuyCount"] as! String
            }
            if dict.keys.contains("EnName") && dict["EnName"] != nil {
                self.enName = dict["EnName"] as! String
            }
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("LoadBalancerSpec") && dict["LoadBalancerSpec"] != nil {
                self.loadBalancerSpec = dict["LoadBalancerSpec"] as! [String]
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Province") && dict["Province"] != nil {
                self.province = dict["Province"] as! String
            }
        }
    }
    public var elbAvailableResourceInfo: [DescribeElbAvailableResourceInfoResponseBody.ElbAvailableResourceInfo]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elbAvailableResourceInfo != nil {
            var tmp : [Any] = []
            for k in self.elbAvailableResourceInfo! {
                tmp.append(k.toMap())
            }
            map["ElbAvailableResourceInfo"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ElbAvailableResourceInfo") && dict["ElbAvailableResourceInfo"] != nil {
            var tmp : [DescribeElbAvailableResourceInfoResponseBody.ElbAvailableResourceInfo] = []
            for v in dict["ElbAvailableResourceInfo"] as! [Any] {
                var model = DescribeElbAvailableResourceInfoResponseBody.ElbAvailableResourceInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.elbAvailableResourceInfo = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeElbAvailableResourceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElbAvailableResourceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeElbAvailableResourceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsEipAddressesRequest : Tea.TeaModel {
    public var allocationId: String?

    public var associatedInstanceId: String?

    public var associatedInstanceType: String?

    public var eipAddress: String?

    public var eipName: String?

    public var ensRegionId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.associatedInstanceId != nil {
            map["AssociatedInstanceId"] = self.associatedInstanceId!
        }
        if self.associatedInstanceType != nil {
            map["AssociatedInstanceType"] = self.associatedInstanceType!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.eipName != nil {
            map["EipName"] = self.eipName!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") && dict["AllocationId"] != nil {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("AssociatedInstanceId") && dict["AssociatedInstanceId"] != nil {
            self.associatedInstanceId = dict["AssociatedInstanceId"] as! String
        }
        if dict.keys.contains("AssociatedInstanceType") && dict["AssociatedInstanceType"] != nil {
            self.associatedInstanceType = dict["AssociatedInstanceType"] as! String
        }
        if dict.keys.contains("EipAddress") && dict["EipAddress"] != nil {
            self.eipAddress = dict["EipAddress"] as! String
        }
        if dict.keys.contains("EipName") && dict["EipName"] != nil {
            self.eipName = dict["EipName"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeEnsEipAddressesResponseBody : Tea.TeaModel {
    public class EipAddresses : Tea.TeaModel {
        public class EipAddress : Tea.TeaModel {
            public var allocationId: String?

            public var allocationTime: String?

            public var bandwidth: Int32?

            public var chargeType: String?

            public var description_: String?

            public var ensRegionId: String?

            public var instanceId: String?

            public var instanceType: String?

            public var internetChargeType: String?

            public var ipAddress: String?

            public var isp: String?

            public var name: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationId != nil {
                    map["AllocationId"] = self.allocationId!
                }
                if self.allocationTime != nil {
                    map["AllocationTime"] = self.allocationTime!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocationId") && dict["AllocationId"] != nil {
                    self.allocationId = dict["AllocationId"] as! String
                }
                if dict.keys.contains("AllocationTime") && dict["AllocationTime"] != nil {
                    self.allocationTime = dict["AllocationTime"] as! String
                }
                if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("Isp") && dict["Isp"] != nil {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var eipAddress: [DescribeEnsEipAddressesResponseBody.EipAddresses.EipAddress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipAddress != nil {
                var tmp : [Any] = []
                for k in self.eipAddress! {
                    tmp.append(k.toMap())
                }
                map["EipAddress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipAddress") && dict["EipAddress"] != nil {
                var tmp : [DescribeEnsEipAddressesResponseBody.EipAddresses.EipAddress] = []
                for v in dict["EipAddress"] as! [Any] {
                    var model = DescribeEnsEipAddressesResponseBody.EipAddresses.EipAddress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipAddress = tmp
            }
        }
    }
    public var eipAddresses: DescribeEnsEipAddressesResponseBody.EipAddresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipAddresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipAddresses != nil {
            map["EipAddresses"] = self.eipAddresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipAddresses") && dict["EipAddresses"] != nil {
            var model = DescribeEnsEipAddressesResponseBody.EipAddresses()
            model.fromMap(dict["EipAddresses"] as! [String: Any])
            self.eipAddresses = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEnsEipAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsEipAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnsEipAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsNetDistrictRequest : Tea.TeaModel {
    public var netDistrictCode: String?

    public var netLevelCode: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.netDistrictCode != nil {
            map["NetDistrictCode"] = self.netDistrictCode!
        }
        if self.netLevelCode != nil {
            map["NetLevelCode"] = self.netLevelCode!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetDistrictCode") && dict["NetDistrictCode"] != nil {
            self.netDistrictCode = dict["NetDistrictCode"] as! String
        }
        if dict.keys.contains("NetLevelCode") && dict["NetLevelCode"] != nil {
            self.netLevelCode = dict["NetLevelCode"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeEnsNetDistrictResponseBody : Tea.TeaModel {
    public class EnsNetDistricts : Tea.TeaModel {
        public class EnsNetDistrict : Tea.TeaModel {
            public var ensRegionIdCount: String?

            public var netDistrictCode: String?

            public var netDistrictEnName: String?

            public var netDistrictFatherCode: String?

            public var netDistrictLevel: String?

            public var netDistrictName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ensRegionIdCount != nil {
                    map["EnsRegionIdCount"] = self.ensRegionIdCount!
                }
                if self.netDistrictCode != nil {
                    map["NetDistrictCode"] = self.netDistrictCode!
                }
                if self.netDistrictEnName != nil {
                    map["NetDistrictEnName"] = self.netDistrictEnName!
                }
                if self.netDistrictFatherCode != nil {
                    map["NetDistrictFatherCode"] = self.netDistrictFatherCode!
                }
                if self.netDistrictLevel != nil {
                    map["NetDistrictLevel"] = self.netDistrictLevel!
                }
                if self.netDistrictName != nil {
                    map["NetDistrictName"] = self.netDistrictName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnsRegionIdCount") && dict["EnsRegionIdCount"] != nil {
                    self.ensRegionIdCount = dict["EnsRegionIdCount"] as! String
                }
                if dict.keys.contains("NetDistrictCode") && dict["NetDistrictCode"] != nil {
                    self.netDistrictCode = dict["NetDistrictCode"] as! String
                }
                if dict.keys.contains("NetDistrictEnName") && dict["NetDistrictEnName"] != nil {
                    self.netDistrictEnName = dict["NetDistrictEnName"] as! String
                }
                if dict.keys.contains("NetDistrictFatherCode") && dict["NetDistrictFatherCode"] != nil {
                    self.netDistrictFatherCode = dict["NetDistrictFatherCode"] as! String
                }
                if dict.keys.contains("NetDistrictLevel") && dict["NetDistrictLevel"] != nil {
                    self.netDistrictLevel = dict["NetDistrictLevel"] as! String
                }
                if dict.keys.contains("NetDistrictName") && dict["NetDistrictName"] != nil {
                    self.netDistrictName = dict["NetDistrictName"] as! String
                }
            }
        }
        public var ensNetDistrict: [DescribeEnsNetDistrictResponseBody.EnsNetDistricts.EnsNetDistrict]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensNetDistrict != nil {
                var tmp : [Any] = []
                for k in self.ensNetDistrict! {
                    tmp.append(k.toMap())
                }
                map["EnsNetDistrict"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsNetDistrict") && dict["EnsNetDistrict"] != nil {
                var tmp : [DescribeEnsNetDistrictResponseBody.EnsNetDistricts.EnsNetDistrict] = []
                for v in dict["EnsNetDistrict"] as! [Any] {
                    var model = DescribeEnsNetDistrictResponseBody.EnsNetDistricts.EnsNetDistrict()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensNetDistrict = tmp
            }
        }
    }
    public var code: Int32?

    public var ensNetDistricts: DescribeEnsNetDistrictResponseBody.EnsNetDistricts?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensNetDistricts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ensNetDistricts != nil {
            map["EnsNetDistricts"] = self.ensNetDistricts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EnsNetDistricts") && dict["EnsNetDistricts"] != nil {
            var model = DescribeEnsNetDistrictResponseBody.EnsNetDistricts()
            model.fromMap(dict["EnsNetDistricts"] as! [String: Any])
            self.ensNetDistricts = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsNetDistrictResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsNetDistrictResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnsNetDistrictResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsNetLevelRequest : Tea.TeaModel {
    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeEnsNetLevelResponseBody : Tea.TeaModel {
    public class EnsNetLevels : Tea.TeaModel {
        public class EnsNetLevel : Tea.TeaModel {
            public var ensNetLevelCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ensNetLevelCode != nil {
                    map["EnsNetLevelCode"] = self.ensNetLevelCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnsNetLevelCode") && dict["EnsNetLevelCode"] != nil {
                    self.ensNetLevelCode = dict["EnsNetLevelCode"] as! String
                }
            }
        }
        public var ensNetLevel: [DescribeEnsNetLevelResponseBody.EnsNetLevels.EnsNetLevel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensNetLevel != nil {
                var tmp : [Any] = []
                for k in self.ensNetLevel! {
                    tmp.append(k.toMap())
                }
                map["EnsNetLevel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsNetLevel") && dict["EnsNetLevel"] != nil {
                var tmp : [DescribeEnsNetLevelResponseBody.EnsNetLevels.EnsNetLevel] = []
                for v in dict["EnsNetLevel"] as! [Any] {
                    var model = DescribeEnsNetLevelResponseBody.EnsNetLevels.EnsNetLevel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensNetLevel = tmp
            }
        }
    }
    public var code: Int32?

    public var ensNetLevels: DescribeEnsNetLevelResponseBody.EnsNetLevels?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensNetLevels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ensNetLevels != nil {
            map["EnsNetLevels"] = self.ensNetLevels?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EnsNetLevels") && dict["EnsNetLevels"] != nil {
            var model = DescribeEnsNetLevelResponseBody.EnsNetLevels()
            model.fromMap(dict["EnsNetLevels"] as! [String: Any])
            self.ensNetLevels = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsNetLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsNetLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnsNetLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsNetSaleDistrictRequest : Tea.TeaModel {
    public var netDistrictCode: String?

    public var netLevelCode: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.netDistrictCode != nil {
            map["NetDistrictCode"] = self.netDistrictCode!
        }
        if self.netLevelCode != nil {
            map["NetLevelCode"] = self.netLevelCode!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetDistrictCode") && dict["NetDistrictCode"] != nil {
            self.netDistrictCode = dict["NetDistrictCode"] as! String
        }
        if dict.keys.contains("NetLevelCode") && dict["NetLevelCode"] != nil {
            self.netLevelCode = dict["NetLevelCode"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeEnsNetSaleDistrictResponseBody : Tea.TeaModel {
    public class EnsNetDistricts : Tea.TeaModel {
        public class EnsNetDistrict : Tea.TeaModel {
            public var ensRegionIdCount: String?

            public var instanceCount: String?

            public var netDistrictCode: String?

            public var netDistrictEnName: String?

            public var netDistrictFatherCode: String?

            public var netDistrictLevel: String?

            public var netDistrictName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ensRegionIdCount != nil {
                    map["EnsRegionIdCount"] = self.ensRegionIdCount!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.netDistrictCode != nil {
                    map["NetDistrictCode"] = self.netDistrictCode!
                }
                if self.netDistrictEnName != nil {
                    map["NetDistrictEnName"] = self.netDistrictEnName!
                }
                if self.netDistrictFatherCode != nil {
                    map["NetDistrictFatherCode"] = self.netDistrictFatherCode!
                }
                if self.netDistrictLevel != nil {
                    map["NetDistrictLevel"] = self.netDistrictLevel!
                }
                if self.netDistrictName != nil {
                    map["NetDistrictName"] = self.netDistrictName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnsRegionIdCount") && dict["EnsRegionIdCount"] != nil {
                    self.ensRegionIdCount = dict["EnsRegionIdCount"] as! String
                }
                if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                    self.instanceCount = dict["InstanceCount"] as! String
                }
                if dict.keys.contains("NetDistrictCode") && dict["NetDistrictCode"] != nil {
                    self.netDistrictCode = dict["NetDistrictCode"] as! String
                }
                if dict.keys.contains("NetDistrictEnName") && dict["NetDistrictEnName"] != nil {
                    self.netDistrictEnName = dict["NetDistrictEnName"] as! String
                }
                if dict.keys.contains("NetDistrictFatherCode") && dict["NetDistrictFatherCode"] != nil {
                    self.netDistrictFatherCode = dict["NetDistrictFatherCode"] as! String
                }
                if dict.keys.contains("NetDistrictLevel") && dict["NetDistrictLevel"] != nil {
                    self.netDistrictLevel = dict["NetDistrictLevel"] as! String
                }
                if dict.keys.contains("NetDistrictName") && dict["NetDistrictName"] != nil {
                    self.netDistrictName = dict["NetDistrictName"] as! String
                }
            }
        }
        public var ensNetDistrict: [DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts.EnsNetDistrict]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensNetDistrict != nil {
                var tmp : [Any] = []
                for k in self.ensNetDistrict! {
                    tmp.append(k.toMap())
                }
                map["EnsNetDistrict"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsNetDistrict") && dict["EnsNetDistrict"] != nil {
                var tmp : [DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts.EnsNetDistrict] = []
                for v in dict["EnsNetDistrict"] as! [Any] {
                    var model = DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts.EnsNetDistrict()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensNetDistrict = tmp
            }
        }
    }
    public var code: Int32?

    public var ensNetDistricts: DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensNetDistricts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ensNetDistricts != nil {
            map["EnsNetDistricts"] = self.ensNetDistricts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EnsNetDistricts") && dict["EnsNetDistricts"] != nil {
            var model = DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts()
            model.fromMap(dict["EnsNetDistricts"] as! [String: Any])
            self.ensNetDistricts = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsNetSaleDistrictResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsNetSaleDistrictResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnsNetSaleDistrictResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsRegionIdIpv6InfoRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeEnsRegionIdIpv6InfoResponseBody : Tea.TeaModel {
    public class SupportIpv6Info : Tea.TeaModel {
        public var ensRegionId: String?

        public var supportIpv6: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.supportIpv6 != nil {
                map["SupportIpv6"] = self.supportIpv6!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("SupportIpv6") && dict["SupportIpv6"] != nil {
                self.supportIpv6 = dict["SupportIpv6"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var supportIpv6Info: DescribeEnsRegionIdIpv6InfoResponseBody.SupportIpv6Info?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.supportIpv6Info?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportIpv6Info != nil {
            map["SupportIpv6Info"] = self.supportIpv6Info?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportIpv6Info") && dict["SupportIpv6Info"] != nil {
            var model = DescribeEnsRegionIdIpv6InfoResponseBody.SupportIpv6Info()
            model.fromMap(dict["SupportIpv6Info"] as! [String: Any])
            self.supportIpv6Info = model
        }
    }
}

public class DescribeEnsRegionIdIpv6InfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsRegionIdIpv6InfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnsRegionIdIpv6InfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsRegionIdResourceRequest : Tea.TeaModel {
    public var endTime: String?

    public var isp: String?

    public var orderByParams: String?

    public var pageNumber: Int32?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Isp") && dict["Isp"] != nil {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("OrderByParams") && dict["OrderByParams"] != nil {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeEnsRegionIdResourceResponseBody : Tea.TeaModel {
    public class EnsRegionIdResources : Tea.TeaModel {
        public class EnsRegionIdResource : Tea.TeaModel {
            public var area: String?

            public var areaCode: String?

            public var bizDate: String?

            public var ensRegionId: String?

            public var ensRegionIdName: String?

            public var instanceCount: Int32?

            public var internetBandwidth: Int64?

            public var isp: String?

            public var VCpu: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area != nil {
                    map["Area"] = self.area!
                }
                if self.areaCode != nil {
                    map["AreaCode"] = self.areaCode!
                }
                if self.bizDate != nil {
                    map["BizDate"] = self.bizDate!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.ensRegionIdName != nil {
                    map["EnsRegionIdName"] = self.ensRegionIdName!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.internetBandwidth != nil {
                    map["InternetBandwidth"] = self.internetBandwidth!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.VCpu != nil {
                    map["VCpu"] = self.VCpu!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Area") && dict["Area"] != nil {
                    self.area = dict["Area"] as! String
                }
                if dict.keys.contains("AreaCode") && dict["AreaCode"] != nil {
                    self.areaCode = dict["AreaCode"] as! String
                }
                if dict.keys.contains("BizDate") && dict["BizDate"] != nil {
                    self.bizDate = dict["BizDate"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("EnsRegionIdName") && dict["EnsRegionIdName"] != nil {
                    self.ensRegionIdName = dict["EnsRegionIdName"] as! String
                }
                if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                    self.instanceCount = dict["InstanceCount"] as! Int32
                }
                if dict.keys.contains("InternetBandwidth") && dict["InternetBandwidth"] != nil {
                    self.internetBandwidth = dict["InternetBandwidth"] as! Int64
                }
                if dict.keys.contains("Isp") && dict["Isp"] != nil {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("VCpu") && dict["VCpu"] != nil {
                    self.VCpu = dict["VCpu"] as! Int32
                }
            }
        }
        public var ensRegionIdResource: [DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources.EnsRegionIdResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionIdResource != nil {
                var tmp : [Any] = []
                for k in self.ensRegionIdResource! {
                    tmp.append(k.toMap())
                }
                map["EnsRegionIdResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionIdResource") && dict["EnsRegionIdResource"] != nil {
                var tmp : [DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources.EnsRegionIdResource] = []
                for v in dict["EnsRegionIdResource"] as! [Any] {
                    var model = DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources.EnsRegionIdResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensRegionIdResource = tmp
            }
        }
    }
    public var ensRegionIdResources: DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensRegionIdResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionIdResources != nil {
            map["EnsRegionIdResources"] = self.ensRegionIdResources?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionIdResources") && dict["EnsRegionIdResources"] != nil {
            var model = DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources()
            model.fromMap(dict["EnsRegionIdResources"] as! [String: Any])
            self.ensRegionIdResources = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEnsRegionIdResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsRegionIdResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnsRegionIdResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsRegionsRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
    }
}

public class DescribeEnsRegionsResponseBody : Tea.TeaModel {
    public class EnsRegions : Tea.TeaModel {
        public class EnsRegions : Tea.TeaModel {
            public var area: String?

            public var enName: String?

            public var ensRegionId: String?

            public var name: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area != nil {
                    map["Area"] = self.area!
                }
                if self.enName != nil {
                    map["EnName"] = self.enName!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Area") && dict["Area"] != nil {
                    self.area = dict["Area"] as! String
                }
                if dict.keys.contains("EnName") && dict["EnName"] != nil {
                    self.enName = dict["EnName"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var ensRegions: [DescribeEnsRegionsResponseBody.EnsRegions.EnsRegions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegions != nil {
                var tmp : [Any] = []
                for k in self.ensRegions! {
                    tmp.append(k.toMap())
                }
                map["EnsRegions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegions") && dict["EnsRegions"] != nil {
                var tmp : [DescribeEnsRegionsResponseBody.EnsRegions.EnsRegions] = []
                for v in dict["EnsRegions"] as! [Any] {
                    var model = DescribeEnsRegionsResponseBody.EnsRegions.EnsRegions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensRegions = tmp
            }
        }
    }
    public var code: Int32?

    public var ensRegions: DescribeEnsRegionsResponseBody.EnsRegions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensRegions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ensRegions != nil {
            map["EnsRegions"] = self.ensRegions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EnsRegions") && dict["EnsRegions"] != nil {
            var model = DescribeEnsRegionsResponseBody.EnsRegions()
            model.fromMap(dict["EnsRegions"] as! [String: Any])
            self.ensRegions = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnsRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsResourceUsageRequest : Tea.TeaModel {
    public var expiredEndTime: String?

    public var expiredStartTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.expiredEndTime != nil {
            map["ExpiredEndTime"] = self.expiredEndTime!
        }
        if self.expiredStartTime != nil {
            map["ExpiredStartTime"] = self.expiredStartTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExpiredEndTime") && dict["ExpiredEndTime"] != nil {
            self.expiredEndTime = dict["ExpiredEndTime"] as! String
        }
        if dict.keys.contains("ExpiredStartTime") && dict["ExpiredStartTime"] != nil {
            self.expiredStartTime = dict["ExpiredStartTime"] as! String
        }
    }
}

public class DescribeEnsResourceUsageResponseBody : Tea.TeaModel {
    public class EnsResourceUsage : Tea.TeaModel {
        public var computeResourceCount: Int32?

        public var cpuSum: Int64?

        public var diskCount: Int32?

        public var downCount: Int32?

        public var expiredCount: Int32?

        public var expiringCount: Int32?

        public var gpuSum: Int64?

        public var instanceCount: Int32?

        public var runningCount: Int32?

        public var serviceType: String?

        public var storageSum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.computeResourceCount != nil {
                map["ComputeResourceCount"] = self.computeResourceCount!
            }
            if self.cpuSum != nil {
                map["CpuSum"] = self.cpuSum!
            }
            if self.diskCount != nil {
                map["DiskCount"] = self.diskCount!
            }
            if self.downCount != nil {
                map["DownCount"] = self.downCount!
            }
            if self.expiredCount != nil {
                map["ExpiredCount"] = self.expiredCount!
            }
            if self.expiringCount != nil {
                map["ExpiringCount"] = self.expiringCount!
            }
            if self.gpuSum != nil {
                map["GpuSum"] = self.gpuSum!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.runningCount != nil {
                map["RunningCount"] = self.runningCount!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.storageSum != nil {
                map["StorageSum"] = self.storageSum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComputeResourceCount") && dict["ComputeResourceCount"] != nil {
                self.computeResourceCount = dict["ComputeResourceCount"] as! Int32
            }
            if dict.keys.contains("CpuSum") && dict["CpuSum"] != nil {
                self.cpuSum = dict["CpuSum"] as! Int64
            }
            if dict.keys.contains("DiskCount") && dict["DiskCount"] != nil {
                self.diskCount = dict["DiskCount"] as! Int32
            }
            if dict.keys.contains("DownCount") && dict["DownCount"] != nil {
                self.downCount = dict["DownCount"] as! Int32
            }
            if dict.keys.contains("ExpiredCount") && dict["ExpiredCount"] != nil {
                self.expiredCount = dict["ExpiredCount"] as! Int32
            }
            if dict.keys.contains("ExpiringCount") && dict["ExpiringCount"] != nil {
                self.expiringCount = dict["ExpiringCount"] as! Int32
            }
            if dict.keys.contains("GpuSum") && dict["GpuSum"] != nil {
                self.gpuSum = dict["GpuSum"] as! Int64
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("RunningCount") && dict["RunningCount"] != nil {
                self.runningCount = dict["RunningCount"] as! Int32
            }
            if dict.keys.contains("ServiceType") && dict["ServiceType"] != nil {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("StorageSum") && dict["StorageSum"] != nil {
                self.storageSum = dict["StorageSum"] as! Int64
            }
        }
    }
    public var ensResourceUsage: [DescribeEnsResourceUsageResponseBody.EnsResourceUsage]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensResourceUsage != nil {
            var tmp : [Any] = []
            for k in self.ensResourceUsage! {
                tmp.append(k.toMap())
            }
            map["EnsResourceUsage"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsResourceUsage") && dict["EnsResourceUsage"] != nil {
            var tmp : [DescribeEnsResourceUsageResponseBody.EnsResourceUsage] = []
            for v in dict["EnsResourceUsage"] as! [Any] {
                var model = DescribeEnsResourceUsageResponseBody.EnsResourceUsage()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ensResourceUsage = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsResourceUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsResourceUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnsResourceUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsRouteEntryListRequest : Tea.TeaModel {
    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var routeEntryId: String?

    public var routeEntryName: String?

    public var routeEntryType: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationCidrBlock") && dict["DestinationCidrBlock"] != nil {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("NextHopId") && dict["NextHopId"] != nil {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopType") && dict["NextHopType"] != nil {
            self.nextHopType = dict["NextHopType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RouteEntryId") && dict["RouteEntryId"] != nil {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
        if dict.keys.contains("RouteEntryName") && dict["RouteEntryName"] != nil {
            self.routeEntryName = dict["RouteEntryName"] as! String
        }
        if dict.keys.contains("RouteEntryType") && dict["RouteEntryType"] != nil {
            self.routeEntryType = dict["RouteEntryType"] as! String
        }
        if dict.keys.contains("RouteTableId") && dict["RouteTableId"] != nil {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class DescribeEnsRouteEntryListResponseBody : Tea.TeaModel {
    public class RouteEntrys : Tea.TeaModel {
        public class NextHops : Tea.TeaModel {
            public var nextHopId: String?

            public var nextHopType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nextHopId != nil {
                    map["NextHopId"] = self.nextHopId!
                }
                if self.nextHopType != nil {
                    map["NextHopType"] = self.nextHopType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NextHopId") && dict["NextHopId"] != nil {
                    self.nextHopId = dict["NextHopId"] as! String
                }
                if dict.keys.contains("NextHopType") && dict["NextHopType"] != nil {
                    self.nextHopType = dict["NextHopType"] as! String
                }
            }
        }
        public var description_: String?

        public var destinationCidrBlock: String?

        public var nextHops: [DescribeEnsRouteEntryListResponseBody.RouteEntrys.NextHops]?

        public var routeEntryId: String?

        public var routeEntryName: String?

        public var routeTableId: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.nextHops != nil {
                var tmp : [Any] = []
                for k in self.nextHops! {
                    tmp.append(k.toMap())
                }
                map["NextHops"] = tmp
            }
            if self.routeEntryId != nil {
                map["RouteEntryId"] = self.routeEntryId!
            }
            if self.routeEntryName != nil {
                map["RouteEntryName"] = self.routeEntryName!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationCidrBlock") && dict["DestinationCidrBlock"] != nil {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("NextHops") && dict["NextHops"] != nil {
                var tmp : [DescribeEnsRouteEntryListResponseBody.RouteEntrys.NextHops] = []
                for v in dict["NextHops"] as! [Any] {
                    var model = DescribeEnsRouteEntryListResponseBody.RouteEntrys.NextHops()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nextHops = tmp
            }
            if dict.keys.contains("RouteEntryId") && dict["RouteEntryId"] != nil {
                self.routeEntryId = dict["RouteEntryId"] as! String
            }
            if dict.keys.contains("RouteEntryName") && dict["RouteEntryName"] != nil {
                self.routeEntryName = dict["RouteEntryName"] as! String
            }
            if dict.keys.contains("RouteTableId") && dict["RouteTableId"] != nil {
                self.routeTableId = dict["RouteTableId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routeEntrys: [DescribeEnsRouteEntryListResponseBody.RouteEntrys]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntrys != nil {
            var tmp : [Any] = []
            for k in self.routeEntrys! {
                tmp.append(k.toMap())
            }
            map["RouteEntrys"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntrys") && dict["RouteEntrys"] != nil {
            var tmp : [DescribeEnsRouteEntryListResponseBody.RouteEntrys] = []
            for v in dict["RouteEntrys"] as! [Any] {
                var model = DescribeEnsRouteEntryListResponseBody.RouteEntrys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeEntrys = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEnsRouteEntryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsRouteEntryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEnsRouteEntryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnBandWidthDataRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var endTime: String?

    public var ensRegionId: String?

    public var instanceId: String?

    public var isp: String?

    public var networkingModel: String?

    public var period: String?

    public var startTime: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Isp") && dict["Isp"] != nil {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("NetworkingModel") && dict["NetworkingModel"] != nil {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeEpnBandWidthDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class BandWidthMonitorData : Tea.TeaModel {
            public var downBandWidth: Int64?

            public var internetRX: Int64?

            public var internetTX: Int64?

            public var timeStamp: String?

            public var upBandWidth: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downBandWidth != nil {
                    map["DownBandWidth"] = self.downBandWidth!
                }
                if self.internetRX != nil {
                    map["InternetRX"] = self.internetRX!
                }
                if self.internetTX != nil {
                    map["InternetTX"] = self.internetTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.upBandWidth != nil {
                    map["UpBandWidth"] = self.upBandWidth!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DownBandWidth") && dict["DownBandWidth"] != nil {
                    self.downBandWidth = dict["DownBandWidth"] as! Int64
                }
                if dict.keys.contains("InternetRX") && dict["InternetRX"] != nil {
                    self.internetRX = dict["InternetRX"] as! Int64
                }
                if dict.keys.contains("InternetTX") && dict["InternetTX"] != nil {
                    self.internetTX = dict["InternetTX"] as! Int64
                }
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("UpBandWidth") && dict["UpBandWidth"] != nil {
                    self.upBandWidth = dict["UpBandWidth"] as! Int64
                }
            }
        }
        public var bandWidthMonitorData: [DescribeEpnBandWidthDataResponseBody.MonitorData.BandWidthMonitorData]?

        public var maxDownBandWidth: Int64?

        public var maxUpBandWidth: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandWidthMonitorData != nil {
                var tmp : [Any] = []
                for k in self.bandWidthMonitorData! {
                    tmp.append(k.toMap())
                }
                map["BandWidthMonitorData"] = tmp
            }
            if self.maxDownBandWidth != nil {
                map["MaxDownBandWidth"] = self.maxDownBandWidth!
            }
            if self.maxUpBandWidth != nil {
                map["MaxUpBandWidth"] = self.maxUpBandWidth!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BandWidthMonitorData") && dict["BandWidthMonitorData"] != nil {
                var tmp : [DescribeEpnBandWidthDataResponseBody.MonitorData.BandWidthMonitorData] = []
                for v in dict["BandWidthMonitorData"] as! [Any] {
                    var model = DescribeEpnBandWidthDataResponseBody.MonitorData.BandWidthMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bandWidthMonitorData = tmp
            }
            if dict.keys.contains("MaxDownBandWidth") && dict["MaxDownBandWidth"] != nil {
                self.maxDownBandWidth = dict["MaxDownBandWidth"] as! Int64
            }
            if dict.keys.contains("MaxUpBandWidth") && dict["MaxUpBandWidth"] != nil {
                self.maxUpBandWidth = dict["MaxUpBandWidth"] as! Int64
            }
        }
    }
    public var monitorData: DescribeEpnBandWidthDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorData") && dict["MonitorData"] != nil {
            var model = DescribeEpnBandWidthDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEpnBandWidthDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnBandWidthDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEpnBandWidthDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnBandwitdhByInternetChargeTypeRequest : Tea.TeaModel {
    public var endTime: String?

    public var ensRegionId: String?

    public var isp: String?

    public var networkingModel: String?

    public var startTime: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("Isp") && dict["Isp"] != nil {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("NetworkingModel") && dict["NetworkingModel"] != nil {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeEpnBandwitdhByInternetChargeTypeResponseBody : Tea.TeaModel {
    public var bandwidthValue: Int64?

    public var internetChargeType: String?

    public var requestId: String?

    public var timeStamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthValue != nil {
            map["BandwidthValue"] = self.bandwidthValue!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthValue") && dict["BandwidthValue"] != nil {
            self.bandwidthValue = dict["BandwidthValue"] as! Int64
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
            self.timeStamp = dict["TimeStamp"] as! String
        }
    }
}

public class DescribeEpnBandwitdhByInternetChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnBandwitdhByInternetChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEpnBandwitdhByInternetChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnInstanceAttributeRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
    }
}

public class DescribeEpnInstanceAttributeResponseBody : Tea.TeaModel {
    public class ConfVersions : Tea.TeaModel {
        public var confVersion: String?

        public var ensRegionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confVersion != nil {
                map["ConfVersion"] = self.confVersion!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfVersion") && dict["ConfVersion"] != nil {
                self.confVersion = dict["ConfVersion"] as! String
            }
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
        }
    }
    public class Instances : Tea.TeaModel {
        public var ensRegionId: String?

        public var instanceId: String?

        public var instanceName: String?

        public var isp: String?

        public var privateIpAddress: String?

        public var publicIpAddress: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress!
            }
            if self.publicIpAddress != nil {
                map["PublicIpAddress"] = self.publicIpAddress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("Isp") && dict["Isp"] != nil {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("PrivateIpAddress") && dict["PrivateIpAddress"] != nil {
                self.privateIpAddress = dict["PrivateIpAddress"] as! String
            }
            if dict.keys.contains("PublicIpAddress") && dict["PublicIpAddress"] != nil {
                self.publicIpAddress = dict["PublicIpAddress"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class VSwitches : Tea.TeaModel {
        public var cidrBlock: String?

        public var ensRegionId: String?

        public var vSwitchId: String?

        public var vSwitchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchName != nil {
                map["VSwitchName"] = self.vSwitchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                self.cidrBlock = dict["CidrBlock"] as! String
            }
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VSwitchName") && dict["VSwitchName"] != nil {
                self.vSwitchName = dict["VSwitchName"] as! String
            }
        }
    }
    public var confVersions: [DescribeEpnInstanceAttributeResponseBody.ConfVersions]?

    public var EPNInstanceId: String?

    public var EPNInstanceName: String?

    public var instances: [DescribeEpnInstanceAttributeResponseBody.Instances]?

    public var networkingModel: String?

    public var requestId: String?

    public var vSwitches: [DescribeEpnInstanceAttributeResponseBody.VSwitches]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confVersions != nil {
            var tmp : [Any] = []
            for k in self.confVersions! {
                tmp.append(k.toMap())
            }
            map["ConfVersions"] = tmp
        }
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.EPNInstanceName != nil {
            map["EPNInstanceName"] = self.EPNInstanceName!
        }
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitches != nil {
            var tmp : [Any] = []
            for k in self.vSwitches! {
                tmp.append(k.toMap())
            }
            map["VSwitches"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfVersions") && dict["ConfVersions"] != nil {
            var tmp : [DescribeEpnInstanceAttributeResponseBody.ConfVersions] = []
            for v in dict["ConfVersions"] as! [Any] {
                var model = DescribeEpnInstanceAttributeResponseBody.ConfVersions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.confVersions = tmp
        }
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("EPNInstanceName") && dict["EPNInstanceName"] != nil {
            self.EPNInstanceName = dict["EPNInstanceName"] as! String
        }
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            var tmp : [DescribeEpnInstanceAttributeResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = DescribeEpnInstanceAttributeResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("NetworkingModel") && dict["NetworkingModel"] != nil {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitches") && dict["VSwitches"] != nil {
            var tmp : [DescribeEpnInstanceAttributeResponseBody.VSwitches] = []
            for v in dict["VSwitches"] as! [Any] {
                var model = DescribeEpnInstanceAttributeResponseBody.VSwitches()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vSwitches = tmp
        }
    }
}

public class DescribeEpnInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEpnInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnInstancesRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var EPNInstanceName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.EPNInstanceName != nil {
            map["EPNInstanceName"] = self.EPNInstanceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("EPNInstanceName") && dict["EPNInstanceName"] != nil {
            self.EPNInstanceName = dict["EPNInstanceName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeEpnInstancesResponseBody : Tea.TeaModel {
    public class EPNInstances : Tea.TeaModel {
        public class EPNInstance : Tea.TeaModel {
            public var creationTime: String?

            public var EPNInstanceId: String?

            public var EPNInstanceName: String?

            public var EPNInstanceType: String?

            public var endTime: String?

            public var internetMaxBandwidthOut: Int32?

            public var modifyTime: String?

            public var networkingModel: String?

            public var startTime: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.EPNInstanceId != nil {
                    map["EPNInstanceId"] = self.EPNInstanceId!
                }
                if self.EPNInstanceName != nil {
                    map["EPNInstanceName"] = self.EPNInstanceName!
                }
                if self.EPNInstanceType != nil {
                    map["EPNInstanceType"] = self.EPNInstanceType!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.internetMaxBandwidthOut != nil {
                    map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.networkingModel != nil {
                    map["NetworkingModel"] = self.networkingModel!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
                    self.EPNInstanceId = dict["EPNInstanceId"] as! String
                }
                if dict.keys.contains("EPNInstanceName") && dict["EPNInstanceName"] != nil {
                    self.EPNInstanceName = dict["EPNInstanceName"] as! String
                }
                if dict.keys.contains("EPNInstanceType") && dict["EPNInstanceType"] != nil {
                    self.EPNInstanceType = dict["EPNInstanceType"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
                    self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
                }
                if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                    self.modifyTime = dict["ModifyTime"] as! String
                }
                if dict.keys.contains("NetworkingModel") && dict["NetworkingModel"] != nil {
                    self.networkingModel = dict["NetworkingModel"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var EPNInstance: [DescribeEpnInstancesResponseBody.EPNInstances.EPNInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.EPNInstance != nil {
                var tmp : [Any] = []
                for k in self.EPNInstance! {
                    tmp.append(k.toMap())
                }
                map["EPNInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EPNInstance") && dict["EPNInstance"] != nil {
                var tmp : [DescribeEpnInstancesResponseBody.EPNInstances.EPNInstance] = []
                for v in dict["EPNInstance"] as! [Any] {
                    var model = DescribeEpnInstancesResponseBody.EPNInstances.EPNInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.EPNInstance = tmp
            }
        }
    }
    public var EPNInstances: DescribeEpnInstancesResponseBody.EPNInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.EPNInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstances != nil {
            map["EPNInstances"] = self.EPNInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstances") && dict["EPNInstances"] != nil {
            var model = DescribeEpnInstancesResponseBody.EPNInstances()
            model.fromMap(dict["EPNInstances"] as! [String: Any])
            self.EPNInstances = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEpnInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEpnInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnMeasurementDataRequest : Tea.TeaModel {
    public var endDate: String?

    public var startDate: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeEpnMeasurementDataResponseBody : Tea.TeaModel {
    public class MeasurementDatas : Tea.TeaModel {
        public class MeasurementData : Tea.TeaModel {
            public class BandWidthFeeDatas : Tea.TeaModel {
                public class BandWidthFeeData : Tea.TeaModel {
                    public var costCode: String?

                    public var costName: String?

                    public var costType: String?

                    public var costVal: Int32?

                    public var ispLine: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.costCode != nil {
                            map["CostCode"] = self.costCode!
                        }
                        if self.costName != nil {
                            map["CostName"] = self.costName!
                        }
                        if self.costType != nil {
                            map["CostType"] = self.costType!
                        }
                        if self.costVal != nil {
                            map["CostVal"] = self.costVal!
                        }
                        if self.ispLine != nil {
                            map["IspLine"] = self.ispLine!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CostCode") && dict["CostCode"] != nil {
                            self.costCode = dict["CostCode"] as! String
                        }
                        if dict.keys.contains("CostName") && dict["CostName"] != nil {
                            self.costName = dict["CostName"] as! String
                        }
                        if dict.keys.contains("CostType") && dict["CostType"] != nil {
                            self.costType = dict["CostType"] as! String
                        }
                        if dict.keys.contains("CostVal") && dict["CostVal"] != nil {
                            self.costVal = dict["CostVal"] as! Int32
                        }
                        if dict.keys.contains("IspLine") && dict["IspLine"] != nil {
                            self.ispLine = dict["IspLine"] as! String
                        }
                    }
                }
                public var bandWidthFeeData: [DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandWidthFeeData != nil {
                        var tmp : [Any] = []
                        for k in self.bandWidthFeeData! {
                            tmp.append(k.toMap())
                        }
                        map["BandWidthFeeData"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BandWidthFeeData") && dict["BandWidthFeeData"] != nil {
                        var tmp : [DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData] = []
                        for v in dict["BandWidthFeeData"] as! [Any] {
                            var model = DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.bandWidthFeeData = tmp
                    }
                }
            }
            public var bandWidthFeeDatas: DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas?

            public var chargeModel: String?

            public var costCycle: String?

            public var costEndTime: String?

            public var costStartTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bandWidthFeeDatas?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidthFeeDatas != nil {
                    map["BandWidthFeeDatas"] = self.bandWidthFeeDatas?.toMap()
                }
                if self.chargeModel != nil {
                    map["ChargeModel"] = self.chargeModel!
                }
                if self.costCycle != nil {
                    map["CostCycle"] = self.costCycle!
                }
                if self.costEndTime != nil {
                    map["CostEndTime"] = self.costEndTime!
                }
                if self.costStartTime != nil {
                    map["CostStartTime"] = self.costStartTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandWidthFeeDatas") && dict["BandWidthFeeDatas"] != nil {
                    var model = DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas()
                    model.fromMap(dict["BandWidthFeeDatas"] as! [String: Any])
                    self.bandWidthFeeDatas = model
                }
                if dict.keys.contains("ChargeModel") && dict["ChargeModel"] != nil {
                    self.chargeModel = dict["ChargeModel"] as! String
                }
                if dict.keys.contains("CostCycle") && dict["CostCycle"] != nil {
                    self.costCycle = dict["CostCycle"] as! String
                }
                if dict.keys.contains("CostEndTime") && dict["CostEndTime"] != nil {
                    self.costEndTime = dict["CostEndTime"] as! String
                }
                if dict.keys.contains("CostStartTime") && dict["CostStartTime"] != nil {
                    self.costStartTime = dict["CostStartTime"] as! String
                }
            }
        }
        public var measurementData: [DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.measurementData != nil {
                var tmp : [Any] = []
                for k in self.measurementData! {
                    tmp.append(k.toMap())
                }
                map["MeasurementData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MeasurementData") && dict["MeasurementData"] != nil {
                var tmp : [DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData] = []
                for v in dict["MeasurementData"] as! [Any] {
                    var model = DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.measurementData = tmp
            }
        }
    }
    public var measurementDatas: DescribeEpnMeasurementDataResponseBody.MeasurementDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.measurementDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.measurementDatas != nil {
            map["MeasurementDatas"] = self.measurementDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MeasurementDatas") && dict["MeasurementDatas"] != nil {
            var model = DescribeEpnMeasurementDataResponseBody.MeasurementDatas()
            model.fromMap(dict["MeasurementDatas"] as! [String: Any])
            self.measurementDatas = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEpnMeasurementDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnMeasurementDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEpnMeasurementDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExportImageInfoRequest : Tea.TeaModel {
    public var imageId: String?

    public var imageName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeExportImageInfoResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var architecture: String?

            public var creationTime: String?

            public var exportedImageURL: String?

            public var imageExportStatus: String?

            public var imageId: String?

            public var imageName: String?

            public var imageOwnerAlias: String?

            public var platform: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architecture != nil {
                    map["Architecture"] = self.architecture!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.exportedImageURL != nil {
                    map["ExportedImageURL"] = self.exportedImageURL!
                }
                if self.imageExportStatus != nil {
                    map["ImageExportStatus"] = self.imageExportStatus!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageOwnerAlias != nil {
                    map["ImageOwnerAlias"] = self.imageOwnerAlias!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Architecture") && dict["Architecture"] != nil {
                    self.architecture = dict["Architecture"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("ExportedImageURL") && dict["ExportedImageURL"] != nil {
                    self.exportedImageURL = dict["ExportedImageURL"] as! String
                }
                if dict.keys.contains("ImageExportStatus") && dict["ImageExportStatus"] != nil {
                    self.imageExportStatus = dict["ImageExportStatus"] as! String
                }
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImageOwnerAlias") && dict["ImageOwnerAlias"] != nil {
                    self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
            }
        }
        public var image: [DescribeExportImageInfoResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") && dict["Image"] != nil {
                var tmp : [DescribeExportImageInfoResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeExportImageInfoResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public var images: DescribeExportImageInfoResponseBody.Images?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Images") && dict["Images"] != nil {
            var model = DescribeExportImageInfoResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeExportImageInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExportImageInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExportImageInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExportImageStatusRequest : Tea.TeaModel {
    public var imageId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeExportImageStatusResponseBody : Tea.TeaModel {
    public var imageExportStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageExportStatus != nil {
            map["ImageExportStatus"] = self.imageExportStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageExportStatus") && dict["ImageExportStatus"] != nil {
            self.imageExportStatus = dict["ImageExportStatus"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeExportImageStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExportImageStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExportImageStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFileSystemsRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public var fileSystemName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.fileSystemName != nil {
            map["FileSystemName"] = self.fileSystemName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") && dict["FileSystemId"] != nil {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("FileSystemName") && dict["FileSystemName"] != nil {
            self.fileSystemName = dict["FileSystemName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeFileSystemsResponseBody : Tea.TeaModel {
    public class FileSystems : Tea.TeaModel {
        public class MountTargets : Tea.TeaModel {
            public var mountTargetDomain: String?

            public var mountTargetName: String?

            public var netWorkId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountTargetDomain != nil {
                    map["MountTargetDomain"] = self.mountTargetDomain!
                }
                if self.mountTargetName != nil {
                    map["MountTargetName"] = self.mountTargetName!
                }
                if self.netWorkId != nil {
                    map["NetWorkId"] = self.netWorkId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountTargetDomain") && dict["MountTargetDomain"] != nil {
                    self.mountTargetDomain = dict["MountTargetDomain"] as! String
                }
                if dict.keys.contains("MountTargetName") && dict["MountTargetName"] != nil {
                    self.mountTargetName = dict["MountTargetName"] as! String
                }
                if dict.keys.contains("NetWorkId") && dict["NetWorkId"] != nil {
                    self.netWorkId = dict["NetWorkId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var capacity: Int64?

        public var creationTime: String?

        public var ensRegionId: String?

        public var fileSystemId: String?

        public var fileSystemName: String?

        public var meteredSize: Int64?

        public var mountTargets: [DescribeFileSystemsResponseBody.FileSystems.MountTargets]?

        public var payType: String?

        public var protocolType: String?

        public var status: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacity != nil {
                map["Capacity"] = self.capacity!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.fileSystemId != nil {
                map["FileSystemId"] = self.fileSystemId!
            }
            if self.fileSystemName != nil {
                map["FileSystemName"] = self.fileSystemName!
            }
            if self.meteredSize != nil {
                map["MeteredSize"] = self.meteredSize!
            }
            if self.mountTargets != nil {
                var tmp : [Any] = []
                for k in self.mountTargets! {
                    tmp.append(k.toMap())
                }
                map["MountTargets"] = tmp
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Capacity") && dict["Capacity"] != nil {
                self.capacity = dict["Capacity"] as! Int64
            }
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("FileSystemId") && dict["FileSystemId"] != nil {
                self.fileSystemId = dict["FileSystemId"] as! String
            }
            if dict.keys.contains("FileSystemName") && dict["FileSystemName"] != nil {
                self.fileSystemName = dict["FileSystemName"] as! String
            }
            if dict.keys.contains("MeteredSize") && dict["MeteredSize"] != nil {
                self.meteredSize = dict["MeteredSize"] as! Int64
            }
            if dict.keys.contains("MountTargets") && dict["MountTargets"] != nil {
                var tmp : [DescribeFileSystemsResponseBody.FileSystems.MountTargets] = []
                for v in dict["MountTargets"] as! [Any] {
                    var model = DescribeFileSystemsResponseBody.FileSystems.MountTargets()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mountTargets = tmp
            }
            if dict.keys.contains("PayType") && dict["PayType"] != nil {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public var fileSystems: [DescribeFileSystemsResponseBody.FileSystems]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSystems != nil {
            var tmp : [Any] = []
            for k in self.fileSystems! {
                tmp.append(k.toMap())
            }
            map["FileSystems"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileSystems") && dict["FileSystems"] != nil {
            var tmp : [DescribeFileSystemsResponseBody.FileSystems] = []
            for v in dict["FileSystems"] as! [Any] {
                var model = DescribeFileSystemsResponseBody.FileSystems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileSystems = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeFileSystemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFileSystemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFileSystemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeForwardTableEntriesRequest : Tea.TeaModel {
    public var externalIp: String?

    public var forwardEntryId: String?

    public var forwardEntryName: String?

    public var internalIp: String?

    public var ipProtocol: String?

    public var natGatewayId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExternalIp") && dict["ExternalIp"] != nil {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ForwardEntryId") && dict["ForwardEntryId"] != nil {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardEntryName") && dict["ForwardEntryName"] != nil {
            self.forwardEntryName = dict["ForwardEntryName"] as! String
        }
        if dict.keys.contains("InternalIp") && dict["InternalIp"] != nil {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeForwardTableEntriesResponseBody : Tea.TeaModel {
    public class ForwardTableEntries : Tea.TeaModel {
        public var externalIp: String?

        public var externalPort: String?

        public var forwardEntryId: String?

        public var forwardEntryName: String?

        public var healthCheckPort: String?

        public var internalIp: String?

        public var internalPort: String?

        public var ipProtocol: String?

        public var natGatewayId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.externalIp != nil {
                map["ExternalIp"] = self.externalIp!
            }
            if self.externalPort != nil {
                map["ExternalPort"] = self.externalPort!
            }
            if self.forwardEntryId != nil {
                map["ForwardEntryId"] = self.forwardEntryId!
            }
            if self.forwardEntryName != nil {
                map["ForwardEntryName"] = self.forwardEntryName!
            }
            if self.healthCheckPort != nil {
                map["HealthCheckPort"] = self.healthCheckPort!
            }
            if self.internalIp != nil {
                map["InternalIp"] = self.internalIp!
            }
            if self.internalPort != nil {
                map["InternalPort"] = self.internalPort!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExternalIp") && dict["ExternalIp"] != nil {
                self.externalIp = dict["ExternalIp"] as! String
            }
            if dict.keys.contains("ExternalPort") && dict["ExternalPort"] != nil {
                self.externalPort = dict["ExternalPort"] as! String
            }
            if dict.keys.contains("ForwardEntryId") && dict["ForwardEntryId"] != nil {
                self.forwardEntryId = dict["ForwardEntryId"] as! String
            }
            if dict.keys.contains("ForwardEntryName") && dict["ForwardEntryName"] != nil {
                self.forwardEntryName = dict["ForwardEntryName"] as! String
            }
            if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
                self.healthCheckPort = dict["HealthCheckPort"] as! String
            }
            if dict.keys.contains("InternalIp") && dict["InternalIp"] != nil {
                self.internalIp = dict["InternalIp"] as! String
            }
            if dict.keys.contains("InternalPort") && dict["InternalPort"] != nil {
                self.internalPort = dict["InternalPort"] as! String
            }
            if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
                self.natGatewayId = dict["NatGatewayId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var forwardTableEntries: [DescribeForwardTableEntriesResponseBody.ForwardTableEntries]?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardTableEntries != nil {
            var tmp : [Any] = []
            for k in self.forwardTableEntries! {
                tmp.append(k.toMap())
            }
            map["ForwardTableEntries"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardTableEntries") && dict["ForwardTableEntries"] != nil {
            var tmp : [DescribeForwardTableEntriesResponseBody.ForwardTableEntries] = []
            for v in dict["ForwardTableEntries"] as! [Any] {
                var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.forwardTableEntries = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeForwardTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeForwardTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeForwardTableEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageInfosRequest : Tea.TeaModel {
    public var osType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OsType") && dict["OsType"] != nil {
            self.osType = dict["OsType"] as! String
        }
    }
}

public class DescribeImageInfosResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var computeType: String?

            public var description_: String?

            public var imageId: String?

            public var imageSize: String?

            public var imageVersion: String?

            public var OSName: String?

            public var OSType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.computeType != nil {
                    map["ComputeType"] = self.computeType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageSize != nil {
                    map["ImageSize"] = self.imageSize!
                }
                if self.imageVersion != nil {
                    map["ImageVersion"] = self.imageVersion!
                }
                if self.OSName != nil {
                    map["OSName"] = self.OSName!
                }
                if self.OSType != nil {
                    map["OSType"] = self.OSType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComputeType") && dict["ComputeType"] != nil {
                    self.computeType = dict["ComputeType"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageSize") && dict["ImageSize"] != nil {
                    self.imageSize = dict["ImageSize"] as! String
                }
                if dict.keys.contains("ImageVersion") && dict["ImageVersion"] != nil {
                    self.imageVersion = dict["ImageVersion"] as! String
                }
                if dict.keys.contains("OSName") && dict["OSName"] != nil {
                    self.OSName = dict["OSName"] as! String
                }
                if dict.keys.contains("OSType") && dict["OSType"] != nil {
                    self.OSType = dict["OSType"] as! String
                }
            }
        }
        public var image: [DescribeImageInfosResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") && dict["Image"] != nil {
                var tmp : [DescribeImageInfosResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeImageInfosResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeImageInfosResponseBody.Images?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") && dict["Images"] != nil {
            var model = DescribeImageInfosResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageSharePermissionRequest : Tea.TeaModel {
    public var aliyunId: Int64?

    public var imageId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunId != nil {
            map["AliyunId"] = self.aliyunId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunId") && dict["AliyunId"] != nil {
            self.aliyunId = dict["AliyunId"] as! Int64
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
    }
}

public class DescribeImageSharePermissionResponseBody : Tea.TeaModel {
    public class Accounts : Tea.TeaModel {
        public var account: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                map["Account"] = self.account!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Account") && dict["Account"] != nil {
                self.account = dict["Account"] as! [String]
            }
        }
    }
    public var accounts: DescribeImageSharePermissionResponseBody.Accounts?

    public var imageId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accounts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accounts != nil {
            map["Accounts"] = self.accounts?.toMap()
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Accounts") && dict["Accounts"] != nil {
            var model = DescribeImageSharePermissionResponseBody.Accounts()
            model.fromMap(dict["Accounts"] as! [String: Any])
            self.accounts = model
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImageSharePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageSharePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageSharePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImagesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var imageId: String?

    public var imageName: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var snapshotId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeImagesResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var architecture: String?

            public var creationTime: String?

            public var imageId: String?

            public var imageName: String?

            public var imageOwnerAlias: String?

            public var imageSize: String?

            public var platform: String?

            public var snapshotId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architecture != nil {
                    map["Architecture"] = self.architecture!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageOwnerAlias != nil {
                    map["ImageOwnerAlias"] = self.imageOwnerAlias!
                }
                if self.imageSize != nil {
                    map["ImageSize"] = self.imageSize!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Architecture") && dict["Architecture"] != nil {
                    self.architecture = dict["Architecture"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImageOwnerAlias") && dict["ImageOwnerAlias"] != nil {
                    self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
                }
                if dict.keys.contains("ImageSize") && dict["ImageSize"] != nil {
                    self.imageSize = dict["ImageSize"] as! String
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
            }
        }
        public var image: [DescribeImagesResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") && dict["Image"] != nil {
                var tmp : [DescribeImagesResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeImagesResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeImagesResponseBody.Images?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") && dict["Images"] != nil {
            var model = DescribeImagesResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public class InstanceRenewAttributes : Tea.TeaModel {
        public class InstanceRenewAttribute : Tea.TeaModel {
            public var autoRenewal: Bool?

            public var duration: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewal != nil {
                    map["AutoRenewal"] = self.autoRenewal!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoRenewal") && dict["AutoRenewal"] != nil {
                    self.autoRenewal = dict["AutoRenewal"] as! Bool
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var instanceRenewAttribute: [DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.instanceRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["InstanceRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceRenewAttribute") && dict["InstanceRenewAttribute"] != nil {
                var tmp : [DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute] = []
                for v in dict["InstanceRenewAttribute"] as! [Any] {
                    var model = DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceRenewAttribute = tmp
            }
        }
    }
    public var code: Int32?

    public var instanceRenewAttributes: DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceRenewAttributes != nil {
            map["InstanceRenewAttributes"] = self.instanceRenewAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("InstanceRenewAttributes") && dict["InstanceRenewAttributes"] != nil {
            var model = DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes()
            model.fromMap(dict["InstanceRenewAttributes"] as! [String: Any])
            self.instanceRenewAttributes = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceMonitorDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var period: String?

    public var startTime: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeInstanceMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class InstanceMonitorData : Tea.TeaModel {
            public var CPU: String?

            public var instanceId: String?

            public var memory: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.CPU != nil {
                    map["CPU"] = self.CPU!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CPU") && dict["CPU"] != nil {
                    self.CPU = dict["CPU"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! String
                }
            }
        }
        public var instanceMonitorData: [DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceMonitorData != nil {
                var tmp : [Any] = []
                for k in self.instanceMonitorData! {
                    tmp.append(k.toMap())
                }
                map["InstanceMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceMonitorData") && dict["InstanceMonitorData"] != nil {
                var tmp : [DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData] = []
                for v in dict["InstanceMonitorData"] as! [Any] {
                    var model = DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceMonitorData = tmp
            }
        }
    }
    public var code: Int32?

    public var monitorData: DescribeInstanceMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("MonitorData") && dict["MonitorData"] != nil {
            var model = DescribeInstanceMonitorDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceSpecRequest : Tea.TeaModel {
    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeInstanceSpecResponseBody : Tea.TeaModel {
    public class InstanceSpecs : Tea.TeaModel {
        public class InstanceSpec : Tea.TeaModel {
            public var core: String?

            public var displayName: String?

            public var instanceType: String?

            public var memory: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.core != nil {
                    map["Core"] = self.core!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Core") && dict["Core"] != nil {
                    self.core = dict["Core"] as! String
                }
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! String
                }
            }
        }
        public var instanceSpec: [DescribeInstanceSpecResponseBody.InstanceSpecs.InstanceSpec]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceSpec != nil {
                var tmp : [Any] = []
                for k in self.instanceSpec! {
                    tmp.append(k.toMap())
                }
                map["InstanceSpec"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceSpec") && dict["InstanceSpec"] != nil {
                var tmp : [DescribeInstanceSpecResponseBody.InstanceSpecs.InstanceSpec] = []
                for v in dict["InstanceSpec"] as! [Any] {
                    var model = DescribeInstanceSpecResponseBody.InstanceSpecs.InstanceSpec()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceSpec = tmp
            }
        }
    }
    public var bandwidthLimit: Int32?

    public var code: Int32?

    public var dataDiskMaxSize: Int32?

    public var dataDiskMinSize: Int32?

    public var instanceSpecs: DescribeInstanceSpecResponseBody.InstanceSpecs?

    public var requestId: String?

    public var systemDiskMaxSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceSpecs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthLimit != nil {
            map["BandwidthLimit"] = self.bandwidthLimit!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dataDiskMaxSize != nil {
            map["DataDiskMaxSize"] = self.dataDiskMaxSize!
        }
        if self.dataDiskMinSize != nil {
            map["DataDiskMinSize"] = self.dataDiskMinSize!
        }
        if self.instanceSpecs != nil {
            map["InstanceSpecs"] = self.instanceSpecs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemDiskMaxSize != nil {
            map["SystemDiskMaxSize"] = self.systemDiskMaxSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthLimit") && dict["BandwidthLimit"] != nil {
            self.bandwidthLimit = dict["BandwidthLimit"] as! Int32
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("DataDiskMaxSize") && dict["DataDiskMaxSize"] != nil {
            self.dataDiskMaxSize = dict["DataDiskMaxSize"] as! Int32
        }
        if dict.keys.contains("DataDiskMinSize") && dict["DataDiskMinSize"] != nil {
            self.dataDiskMinSize = dict["DataDiskMinSize"] as! Int32
        }
        if dict.keys.contains("InstanceSpecs") && dict["InstanceSpecs"] != nil {
            var model = DescribeInstanceSpecResponseBody.InstanceSpecs()
            model.fromMap(dict["InstanceSpecs"] as! [String: Any])
            self.instanceSpecs = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemDiskMaxSize") && dict["SystemDiskMaxSize"] != nil {
            self.systemDiskMaxSize = dict["SystemDiskMaxSize"] as! Int32
        }
    }
}

public class DescribeInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTypesRequest : Tea.TeaModel {
    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeInstanceTypesResponseBody : Tea.TeaModel {
    public class InstanceTypes : Tea.TeaModel {
        public class InstanceType : Tea.TeaModel {
            public var cpuCoreCount: Int32?

            public var instanceTypeId: String?

            public var instanceTypeName: String?

            public var memorySize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCoreCount != nil {
                    map["CpuCoreCount"] = self.cpuCoreCount!
                }
                if self.instanceTypeId != nil {
                    map["InstanceTypeId"] = self.instanceTypeId!
                }
                if self.instanceTypeName != nil {
                    map["InstanceTypeName"] = self.instanceTypeName!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CpuCoreCount") && dict["CpuCoreCount"] != nil {
                    self.cpuCoreCount = dict["CpuCoreCount"] as! Int32
                }
                if dict.keys.contains("InstanceTypeId") && dict["InstanceTypeId"] != nil {
                    self.instanceTypeId = dict["InstanceTypeId"] as! String
                }
                if dict.keys.contains("InstanceTypeName") && dict["InstanceTypeName"] != nil {
                    self.instanceTypeName = dict["InstanceTypeName"] as! String
                }
                if dict.keys.contains("MemorySize") && dict["MemorySize"] != nil {
                    self.memorySize = dict["MemorySize"] as! Int32
                }
            }
        }
        public var instanceType: [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                var tmp : [Any] = []
                for k in self.instanceType! {
                    tmp.append(k.toMap())
                }
                map["InstanceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                var tmp : [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType] = []
                for v in dict["InstanceType"] as! [Any] {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceType = tmp
            }
        }
    }
    public var code: Int32?

    public var instanceTypes: DescribeInstanceTypesResponseBody.InstanceTypes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
            var model = DescribeInstanceTypesResponseBody.InstanceTypes()
            model.fromMap(dict["InstanceTypes"] as! [String: Any])
            self.instanceTypes = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceVncUrlRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceVncUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vncUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vncUrl != nil {
            map["VncUrl"] = self.vncUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VncUrl") && dict["VncUrl"] != nil {
            self.vncUrl = dict["VncUrl"] as! String
        }
    }
}

public class DescribeInstanceVncUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceVncUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceVncUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstancesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIds: String?

    public var ensServiceId: String?

    public var imageId: String?

    public var instanceId: String?

    public var instanceIds: String?

    public var instanceName: String?

    public var instanceResourceType: String?

    public var intranetIp: String?

    public var networkId: String?

    public var orderByParams: String?

    public var pageNumber: Int32?

    public var pageSize: String?

    public var searchKey: String?

    public var securityGroupId: String?

    public var status: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.ensServiceId != nil {
            map["EnsServiceId"] = self.ensServiceId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceResourceType != nil {
            map["InstanceResourceType"] = self.instanceResourceType!
        }
        if self.intranetIp != nil {
            map["IntranetIp"] = self.intranetIp!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") && dict["EnsRegionIds"] != nil {
            self.ensRegionIds = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("EnsServiceId") && dict["EnsServiceId"] != nil {
            self.ensServiceId = dict["EnsServiceId"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceResourceType") && dict["InstanceResourceType"] != nil {
            self.instanceResourceType = dict["InstanceResourceType"] as! String
        }
        if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
            self.intranetIp = dict["IntranetIp"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("OrderByParams") && dict["OrderByParams"] != nil {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public class DataDisk : Tea.TeaModel {
                public class DataDisk : Tea.TeaModel {
                    public var category: String?

                    public var diskId: String?

                    public var diskName: String?

                    public var size: Int32?

                    public var deviceType: String?

                    public var diskType: String?

                    public var name: String?

                    public var storage: Int32?

                    public var uuid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.category != nil {
                            map["Category"] = self.category!
                        }
                        if self.diskId != nil {
                            map["DiskId"] = self.diskId!
                        }
                        if self.diskName != nil {
                            map["DiskName"] = self.diskName!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.deviceType != nil {
                            map["device_type"] = self.deviceType!
                        }
                        if self.diskType != nil {
                            map["disk_type"] = self.diskType!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.storage != nil {
                            map["storage"] = self.storage!
                        }
                        if self.uuid != nil {
                            map["uuid"] = self.uuid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Category") && dict["Category"] != nil {
                            self.category = dict["Category"] as! String
                        }
                        if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
                            self.diskId = dict["DiskId"] as! String
                        }
                        if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                            self.diskName = dict["DiskName"] as! String
                        }
                        if dict.keys.contains("Size") && dict["Size"] != nil {
                            self.size = dict["Size"] as! Int32
                        }
                        if dict.keys.contains("device_type") && dict["device_type"] != nil {
                            self.deviceType = dict["device_type"] as! String
                        }
                        if dict.keys.contains("disk_type") && dict["disk_type"] != nil {
                            self.diskType = dict["disk_type"] as! String
                        }
                        if dict.keys.contains("name") && dict["name"] != nil {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("storage") && dict["storage"] != nil {
                            self.storage = dict["storage"] as! Int32
                        }
                        if dict.keys.contains("uuid") && dict["uuid"] != nil {
                            self.uuid = dict["uuid"] as! String
                        }
                    }
                }
                public var dataDisk: [DescribeInstancesResponseBody.Instances.Instance.DataDisk.DataDisk]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataDisk != nil {
                        var tmp : [Any] = []
                        for k in self.dataDisk! {
                            tmp.append(k.toMap())
                        }
                        map["DataDisk"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataDisk") && dict["DataDisk"] != nil {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.DataDisk.DataDisk] = []
                        for v in dict["DataDisk"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.DataDisk.DataDisk()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataDisk = tmp
                    }
                }
            }
            public class InnerIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
                        self.ipAddress = dict["IpAddress"] as! [String]
                    }
                }
            }
            public class NetworkAttributes : Tea.TeaModel {
                public class PrivateIpAddress : Tea.TeaModel {
                    public var ipAddress: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
                            self.ipAddress = dict["IpAddress"] as! [String]
                        }
                    }
                }
                public var networkId: String?

                public var privateIpAddress: DescribeInstancesResponseBody.Instances.Instance.NetworkAttributes.PrivateIpAddress?

                public var vSwitchId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.privateIpAddress?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkId != nil {
                        map["NetworkId"] = self.networkId!
                    }
                    if self.privateIpAddress != nil {
                        map["PrivateIpAddress"] = self.privateIpAddress?.toMap()
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
                        self.networkId = dict["NetworkId"] as! String
                    }
                    if dict.keys.contains("PrivateIpAddress") && dict["PrivateIpAddress"] != nil {
                        var model = DescribeInstancesResponseBody.Instances.Instance.NetworkAttributes.PrivateIpAddress()
                        model.fromMap(dict["PrivateIpAddress"] as! [String: Any])
                        self.privateIpAddress = model
                    }
                    if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                        self.vSwitchId = dict["VSwitchId"] as! String
                    }
                }
            }
            public class PrivateIpAddresses : Tea.TeaModel {
                public class PrivateIpAddress : Tea.TeaModel {
                    public var gateWay: String?

                    public var ip: String?

                    public var isp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gateWay != nil {
                            map["GateWay"] = self.gateWay!
                        }
                        if self.ip != nil {
                            map["Ip"] = self.ip!
                        }
                        if self.isp != nil {
                            map["Isp"] = self.isp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("GateWay") && dict["GateWay"] != nil {
                            self.gateWay = dict["GateWay"] as! String
                        }
                        if dict.keys.contains("Ip") && dict["Ip"] != nil {
                            self.ip = dict["Ip"] as! String
                        }
                        if dict.keys.contains("Isp") && dict["Isp"] != nil {
                            self.isp = dict["Isp"] as! String
                        }
                    }
                }
                public var privateIpAddress: [DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses.PrivateIpAddress]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateIpAddress != nil {
                        var tmp : [Any] = []
                        for k in self.privateIpAddress! {
                            tmp.append(k.toMap())
                        }
                        map["PrivateIpAddress"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateIpAddress") && dict["PrivateIpAddress"] != nil {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses.PrivateIpAddress] = []
                        for v in dict["PrivateIpAddress"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses.PrivateIpAddress()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.privateIpAddress = tmp
                    }
                }
            }
            public class PublicIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
                        self.ipAddress = dict["IpAddress"] as! [String]
                    }
                }
            }
            public class PublicIpAddresses : Tea.TeaModel {
                public class PublicIpAddress : Tea.TeaModel {
                    public var gateWay: String?

                    public var ip: String?

                    public var isp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gateWay != nil {
                            map["GateWay"] = self.gateWay!
                        }
                        if self.ip != nil {
                            map["Ip"] = self.ip!
                        }
                        if self.isp != nil {
                            map["Isp"] = self.isp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("GateWay") && dict["GateWay"] != nil {
                            self.gateWay = dict["GateWay"] as! String
                        }
                        if dict.keys.contains("Ip") && dict["Ip"] != nil {
                            self.ip = dict["Ip"] as! String
                        }
                        if dict.keys.contains("Isp") && dict["Isp"] != nil {
                            self.isp = dict["Isp"] as! String
                        }
                    }
                }
                public var publicIpAddress: [DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses.PublicIpAddress]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.publicIpAddress != nil {
                        var tmp : [Any] = []
                        for k in self.publicIpAddress! {
                            tmp.append(k.toMap())
                        }
                        map["PublicIpAddress"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PublicIpAddress") && dict["PublicIpAddress"] != nil {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses.PublicIpAddress] = []
                        for v in dict["PublicIpAddress"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses.PublicIpAddress()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.publicIpAddress = tmp
                    }
                }
            }
            public class SecurityGroupIds : Tea.TeaModel {
                public var securityGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                        self.securityGroupId = dict["SecurityGroupId"] as! [String]
                    }
                }
            }
            public class SystemDisk : Tea.TeaModel {
                public var category: String?

                public var diskId: String?

                public var diskName: String?

                public var size: Int32?

                public var deviceType: String?

                public var diskType: String?

                public var name: String?

                public var storage: Int32?

                public var uuid: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.diskId != nil {
                        map["DiskId"] = self.diskId!
                    }
                    if self.diskName != nil {
                        map["DiskName"] = self.diskName!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.deviceType != nil {
                        map["device_type"] = self.deviceType!
                    }
                    if self.diskType != nil {
                        map["disk_type"] = self.diskType!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.storage != nil {
                        map["storage"] = self.storage!
                    }
                    if self.uuid != nil {
                        map["uuid"] = self.uuid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") && dict["Category"] != nil {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
                        self.diskId = dict["DiskId"] as! String
                    }
                    if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                        self.diskName = dict["DiskName"] as! String
                    }
                    if dict.keys.contains("Size") && dict["Size"] != nil {
                        self.size = dict["Size"] as! Int32
                    }
                    if dict.keys.contains("device_type") && dict["device_type"] != nil {
                        self.deviceType = dict["device_type"] as! String
                    }
                    if dict.keys.contains("disk_type") && dict["disk_type"] != nil {
                        self.diskType = dict["disk_type"] as! String
                    }
                    if dict.keys.contains("name") && dict["name"] != nil {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("storage") && dict["storage"] != nil {
                        self.storage = dict["storage"] as! Int32
                    }
                    if dict.keys.contains("uuid") && dict["uuid"] != nil {
                        self.uuid = dict["uuid"] as! String
                    }
                }
            }
            public var cpu: String?

            public var creationTime: String?

            public var dataDisk: DescribeInstancesResponseBody.Instances.Instance.DataDisk?

            public var disk: Int32?

            public var ensRegionId: String?

            public var expiredTime: String?

            public var hostName: String?

            public var imageId: String?

            public var innerIpAddress: DescribeInstancesResponseBody.Instances.Instance.InnerIpAddress?

            public var instanceId: String?

            public var instanceName: String?

            public var instanceResourceType: String?

            public var instanceTypeFamily: String?

            public var internetMaxBandwidthIn: Int32?

            public var internetMaxBandwidthOut: Int32?

            public var memory: Int32?

            public var networkAttributes: DescribeInstancesResponseBody.Instances.Instance.NetworkAttributes?

            public var OSName: String?

            public var privateIpAddresses: DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses?

            public var publicIpAddress: DescribeInstancesResponseBody.Instances.Instance.PublicIpAddress?

            public var publicIpAddresses: DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses?

            public var securityGroupIds: DescribeInstancesResponseBody.Instances.Instance.SecurityGroupIds?

            public var specName: String?

            public var status: String?

            public var systemDisk: DescribeInstancesResponseBody.Instances.Instance.SystemDisk?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataDisk?.validate()
                try self.innerIpAddress?.validate()
                try self.networkAttributes?.validate()
                try self.privateIpAddresses?.validate()
                try self.publicIpAddress?.validate()
                try self.publicIpAddresses?.validate()
                try self.securityGroupIds?.validate()
                try self.systemDisk?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.dataDisk != nil {
                    map["DataDisk"] = self.dataDisk?.toMap()
                }
                if self.disk != nil {
                    map["Disk"] = self.disk!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.innerIpAddress != nil {
                    map["InnerIpAddress"] = self.innerIpAddress?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instanceResourceType != nil {
                    map["InstanceResourceType"] = self.instanceResourceType!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.internetMaxBandwidthIn != nil {
                    map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
                }
                if self.internetMaxBandwidthOut != nil {
                    map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.networkAttributes != nil {
                    map["NetworkAttributes"] = self.networkAttributes?.toMap()
                }
                if self.OSName != nil {
                    map["OSName"] = self.OSName!
                }
                if self.privateIpAddresses != nil {
                    map["PrivateIpAddresses"] = self.privateIpAddresses?.toMap()
                }
                if self.publicIpAddress != nil {
                    map["PublicIpAddress"] = self.publicIpAddress?.toMap()
                }
                if self.publicIpAddresses != nil {
                    map["PublicIpAddresses"] = self.publicIpAddresses?.toMap()
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                }
                if self.specName != nil {
                    map["SpecName"] = self.specName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.systemDisk != nil {
                    map["SystemDisk"] = self.systemDisk?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DataDisk") && dict["DataDisk"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.Instance.DataDisk()
                    model.fromMap(dict["DataDisk"] as! [String: Any])
                    self.dataDisk = model
                }
                if dict.keys.contains("Disk") && dict["Disk"] != nil {
                    self.disk = dict["Disk"] as! Int32
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("InnerIpAddress") && dict["InnerIpAddress"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.Instance.InnerIpAddress()
                    model.fromMap(dict["InnerIpAddress"] as! [String: Any])
                    self.innerIpAddress = model
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("InstanceResourceType") && dict["InstanceResourceType"] != nil {
                    self.instanceResourceType = dict["InstanceResourceType"] as! String
                }
                if dict.keys.contains("InstanceTypeFamily") && dict["InstanceTypeFamily"] != nil {
                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                }
                if dict.keys.contains("InternetMaxBandwidthIn") && dict["InternetMaxBandwidthIn"] != nil {
                    self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
                }
                if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
                    self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("NetworkAttributes") && dict["NetworkAttributes"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkAttributes()
                    model.fromMap(dict["NetworkAttributes"] as! [String: Any])
                    self.networkAttributes = model
                }
                if dict.keys.contains("OSName") && dict["OSName"] != nil {
                    self.OSName = dict["OSName"] as! String
                }
                if dict.keys.contains("PrivateIpAddresses") && dict["PrivateIpAddresses"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses()
                    model.fromMap(dict["PrivateIpAddresses"] as! [String: Any])
                    self.privateIpAddresses = model
                }
                if dict.keys.contains("PublicIpAddress") && dict["PublicIpAddress"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PublicIpAddress()
                    model.fromMap(dict["PublicIpAddress"] as! [String: Any])
                    self.publicIpAddress = model
                }
                if dict.keys.contains("PublicIpAddresses") && dict["PublicIpAddresses"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses()
                    model.fromMap(dict["PublicIpAddresses"] as! [String: Any])
                    self.publicIpAddresses = model
                }
                if dict.keys.contains("SecurityGroupIds") && dict["SecurityGroupIds"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.Instance.SecurityGroupIds()
                    model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
                    self.securityGroupIds = model
                }
                if dict.keys.contains("SpecName") && dict["SpecName"] != nil {
                    self.specName = dict["SpecName"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
                    var model = DescribeInstancesResponseBody.Instances.Instance.SystemDisk()
                    model.fromMap(dict["SystemDisk"] as! [String: Any])
                    self.systemDisk = model
                }
            }
        }
        public var instance: [DescribeInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") && dict["Instance"] != nil {
                var tmp : [DescribeInstancesResponseBody.Instances.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = DescribeInstancesResponseBody.Instances.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var code: Int32?

    public var instances: DescribeInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            var model = DescribeInstancesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeKeyPairsRequest : Tea.TeaModel {
    public var keyPairName: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeKeyPairsResponseBody : Tea.TeaModel {
    public class KeyPairs : Tea.TeaModel {
        public class KeyPair : Tea.TeaModel {
            public var creationTime: String?

            public var keyPairFingerPrint: String?

            public var keyPairName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.keyPairFingerPrint != nil {
                    map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
                }
                if self.keyPairName != nil {
                    map["KeyPairName"] = self.keyPairName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("KeyPairFingerPrint") && dict["KeyPairFingerPrint"] != nil {
                    self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
                }
                if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
                    self.keyPairName = dict["KeyPairName"] as! String
                }
            }
        }
        public var keyPair: [DescribeKeyPairsResponseBody.KeyPairs.KeyPair]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keyPair != nil {
                var tmp : [Any] = []
                for k in self.keyPair! {
                    tmp.append(k.toMap())
                }
                map["KeyPair"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("KeyPair") && dict["KeyPair"] != nil {
                var tmp : [DescribeKeyPairsResponseBody.KeyPairs.KeyPair] = []
                for v in dict["KeyPair"] as! [Any] {
                    var model = DescribeKeyPairsResponseBody.KeyPairs.KeyPair()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.keyPair = tmp
            }
        }
    }
    public var keyPairs: DescribeKeyPairsResponseBody.KeyPairs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.keyPairs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairs != nil {
            map["KeyPairs"] = self.keyPairs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairs") && dict["KeyPairs"] != nil {
            var model = DescribeKeyPairsResponseBody.KeyPairs()
            model.fromMap(dict["KeyPairs"] as! [String: Any])
            self.keyPairs = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeKeyPairsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKeyPairsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeKeyPairsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerAttributeRequest : Tea.TeaModel {
    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerAttributeResponseBody : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public var ip: String?

        public var port: String?

        public var serverId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class ListenerPortsAndProtocols : Tea.TeaModel {
        public var description_: String?

        public var forwardPort: Int32?

        public var listenerForward: String?

        public var listenerPort: Int32?

        public var listenerProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.forwardPort != nil {
                map["ForwardPort"] = self.forwardPort!
            }
            if self.listenerForward != nil {
                map["ListenerForward"] = self.listenerForward!
            }
            if self.listenerPort != nil {
                map["ListenerPort"] = self.listenerPort!
            }
            if self.listenerProtocol != nil {
                map["ListenerProtocol"] = self.listenerProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ForwardPort") && dict["ForwardPort"] != nil {
                self.forwardPort = dict["ForwardPort"] as! Int32
            }
            if dict.keys.contains("ListenerForward") && dict["ListenerForward"] != nil {
                self.listenerForward = dict["ListenerForward"] as! String
            }
            if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
                self.listenerPort = dict["ListenerPort"] as! Int32
            }
            if dict.keys.contains("ListenerProtocol") && dict["ListenerProtocol"] != nil {
                self.listenerProtocol = dict["ListenerProtocol"] as! String
            }
        }
    }
    public var address: String?

    public var addressIPVersion: String?

    public var backendServers: [DescribeLoadBalancerAttributeResponseBody.BackendServers]?

    public var bandwidth: Int32?

    public var createTime: String?

    public var endTime: String?

    public var ensRegionId: String?

    public var listenerPorts: [String]?

    public var listenerPortsAndProtocols: [DescribeLoadBalancerAttributeResponseBody.ListenerPortsAndProtocols]?

    public var loadBalancerId: String?

    public var loadBalancerName: String?

    public var loadBalancerSpec: String?

    public var loadBalancerStatus: String?

    public var networkId: String?

    public var payType: String?

    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.backendServers != nil {
            var tmp : [Any] = []
            for k in self.backendServers! {
                tmp.append(k.toMap())
            }
            map["BackendServers"] = tmp
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.listenerPorts != nil {
            map["ListenerPorts"] = self.listenerPorts!
        }
        if self.listenerPortsAndProtocols != nil {
            var tmp : [Any] = []
            for k in self.listenerPortsAndProtocols! {
                tmp.append(k.toMap())
            }
            map["ListenerPortsAndProtocols"] = tmp
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        if self.loadBalancerSpec != nil {
            map["LoadBalancerSpec"] = self.loadBalancerSpec!
        }
        if self.loadBalancerStatus != nil {
            map["LoadBalancerStatus"] = self.loadBalancerStatus!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            var tmp : [DescribeLoadBalancerAttributeResponseBody.BackendServers] = []
            for v in dict["BackendServers"] as! [Any] {
                var model = DescribeLoadBalancerAttributeResponseBody.BackendServers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendServers = tmp
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("ListenerPorts") && dict["ListenerPorts"] != nil {
            self.listenerPorts = dict["ListenerPorts"] as! [String]
        }
        if dict.keys.contains("ListenerPortsAndProtocols") && dict["ListenerPortsAndProtocols"] != nil {
            var tmp : [DescribeLoadBalancerAttributeResponseBody.ListenerPortsAndProtocols] = []
            for v in dict["ListenerPortsAndProtocols"] as! [Any] {
                var model = DescribeLoadBalancerAttributeResponseBody.ListenerPortsAndProtocols()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.listenerPortsAndProtocols = tmp
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") && dict["LoadBalancerName"] != nil {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
        if dict.keys.contains("LoadBalancerSpec") && dict["LoadBalancerSpec"] != nil {
            self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
        }
        if dict.keys.contains("LoadBalancerStatus") && dict["LoadBalancerStatus"] != nil {
            self.loadBalancerStatus = dict["LoadBalancerStatus"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PayType") && dict["PayType"] != nil {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeLoadBalancerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLoadBalancerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerHTTPListenerAttributeRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerHTTPListenerAttributeResponseBody : Tea.TeaModel {
    public var bandwidth: Int32?

    public var description_: String?

    public var forwardPort: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerForward: String?

    public var listenerPort: Int32?

    public var requestId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var status: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.forwardPort != nil {
            map["ForwardPort"] = self.forwardPort!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerForward != nil {
            map["ListenerForward"] = self.listenerForward!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ForwardPort") && dict["ForwardPort"] != nil {
            self.forwardPort = dict["ForwardPort"] as! Int32
        }
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") && dict["HealthCheckMethod"] != nil {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") && dict["HealthCheckTimeout"] != nil {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerForward") && dict["ListenerForward"] != nil {
            self.listenerForward = dict["ListenerForward"] as! String
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") && dict["ServerCertificateId"] != nil {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class DescribeLoadBalancerHTTPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerHTTPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLoadBalancerHTTPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerHTTPSListenerAttributeRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerHTTPSListenerAttributeResponseBody : Tea.TeaModel {
    public var bandwidth: Int32?

    public var description_: String?

    public var forwardPort: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerForward: String?

    public var listenerPort: Int32?

    public var requestId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var status: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.forwardPort != nil {
            map["ForwardPort"] = self.forwardPort!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerForward != nil {
            map["ListenerForward"] = self.listenerForward!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ForwardPort") && dict["ForwardPort"] != nil {
            self.forwardPort = dict["ForwardPort"] as! Int32
        }
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") && dict["HealthCheckMethod"] != nil {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") && dict["HealthCheckTimeout"] != nil {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerForward") && dict["ListenerForward"] != nil {
            self.listenerForward = dict["ListenerForward"] as! String
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") && dict["ServerCertificateId"] != nil {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class DescribeLoadBalancerHTTPSListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerHTTPSListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLoadBalancerHTTPSListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerSpecRequest : Tea.TeaModel {
    public var loadBalancerSpec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerSpec != nil {
            map["LoadBalancerSpec"] = self.loadBalancerSpec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerSpec") && dict["LoadBalancerSpec"] != nil {
            self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
        }
    }
}

public class DescribeLoadBalancerSpecResponseBody : Tea.TeaModel {
    public class LoadBalancerSpecs : Tea.TeaModel {
        public var displayName: String?

        public var loadBalancerSpec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.loadBalancerSpec != nil {
                map["LoadBalancerSpec"] = self.loadBalancerSpec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("LoadBalancerSpec") && dict["LoadBalancerSpec"] != nil {
                self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
            }
        }
    }
    public var loadBalancerSpecs: [DescribeLoadBalancerSpecResponseBody.LoadBalancerSpecs]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerSpecs != nil {
            var tmp : [Any] = []
            for k in self.loadBalancerSpecs! {
                tmp.append(k.toMap())
            }
            map["LoadBalancerSpecs"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerSpecs") && dict["LoadBalancerSpecs"] != nil {
            var tmp : [DescribeLoadBalancerSpecResponseBody.LoadBalancerSpecs] = []
            for v in dict["LoadBalancerSpecs"] as! [Any] {
                var model = DescribeLoadBalancerSpecResponseBody.LoadBalancerSpecs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.loadBalancerSpecs = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLoadBalancerSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLoadBalancerSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerTCPListenerAttributeRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerTCPListenerAttributeResponseBody : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var bandwidth: Int32?

    public var description_: String?

    public var eipTransmit: String?

    public var establishedTimeout: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckType: String?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var persistenceTimeout: Int32?

    public var requestId: String?

    public var scheduler: String?

    public var status: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.persistenceTimeout != nil {
            map["PersistenceTimeout"] = self.persistenceTimeout!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") && dict["BackendServerPort"] != nil {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") && dict["EipTransmit"] != nil {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("EstablishedTimeout") && dict["EstablishedTimeout"] != nil {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") && dict["HealthCheckConnectTimeout"] != nil {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckType") && dict["HealthCheckType"] != nil {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("PersistenceTimeout") && dict["PersistenceTimeout"] != nil {
            self.persistenceTimeout = dict["PersistenceTimeout"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class DescribeLoadBalancerTCPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerTCPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLoadBalancerTCPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerUDPListenerAttributeRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerUDPListenerAttributeResponseBody : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var bandwidth: Int32?

    public var description_: String?

    public var eipTransmit: String?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckExp: String?

    public var healthCheckInterval: Int32?

    public var healthCheckReq: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var requestId: String?

    public var scheduler: String?

    public var status: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckExp != nil {
            map["HealthCheckExp"] = self.healthCheckExp!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckReq != nil {
            map["HealthCheckReq"] = self.healthCheckReq!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") && dict["BackendServerPort"] != nil {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") && dict["EipTransmit"] != nil {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") && dict["HealthCheckConnectTimeout"] != nil {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckExp") && dict["HealthCheckExp"] != nil {
            self.healthCheckExp = dict["HealthCheckExp"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckReq") && dict["HealthCheckReq"] != nil {
            self.healthCheckReq = dict["HealthCheckReq"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class DescribeLoadBalancerUDPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerUDPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLoadBalancerUDPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancersRequest : Tea.TeaModel {
    public var address: String?

    public var ensRegionId: String?

    public var loadBalancerId: String?

    public var loadBalancerName: String?

    public var loadBalancerStatus: String?

    public var networkId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var serverId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        if self.loadBalancerStatus != nil {
            map["LoadBalancerStatus"] = self.loadBalancerStatus!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") && dict["LoadBalancerName"] != nil {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
        if dict.keys.contains("LoadBalancerStatus") && dict["LoadBalancerStatus"] != nil {
            self.loadBalancerStatus = dict["LoadBalancerStatus"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
            self.serverId = dict["ServerId"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeLoadBalancersResponseBody : Tea.TeaModel {
    public class LoadBalancers : Tea.TeaModel {
        public class LoadBalancer : Tea.TeaModel {
            public var address: String?

            public var addressIPVersion: String?

            public var createTime: String?

            public var ensRegionId: String?

            public var loadBalancerId: String?

            public var loadBalancerName: String?

            public var loadBalancerStatus: String?

            public var networkId: String?

            public var payType: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressIPVersion != nil {
                    map["AddressIPVersion"] = self.addressIPVersion!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.loadBalancerName != nil {
                    map["LoadBalancerName"] = self.loadBalancerName!
                }
                if self.loadBalancerStatus != nil {
                    map["LoadBalancerStatus"] = self.loadBalancerStatus!
                }
                if self.networkId != nil {
                    map["NetworkId"] = self.networkId!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
                    self.addressIPVersion = dict["AddressIPVersion"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("LoadBalancerName") && dict["LoadBalancerName"] != nil {
                    self.loadBalancerName = dict["LoadBalancerName"] as! String
                }
                if dict.keys.contains("LoadBalancerStatus") && dict["LoadBalancerStatus"] != nil {
                    self.loadBalancerStatus = dict["LoadBalancerStatus"] as! String
                }
                if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
                    self.networkId = dict["NetworkId"] as! String
                }
                if dict.keys.contains("PayType") && dict["PayType"] != nil {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
            }
        }
        public var loadBalancer: [DescribeLoadBalancersResponseBody.LoadBalancers.LoadBalancer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancer != nil {
                var tmp : [Any] = []
                for k in self.loadBalancer! {
                    tmp.append(k.toMap())
                }
                map["LoadBalancer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancer") && dict["LoadBalancer"] != nil {
                var tmp : [DescribeLoadBalancersResponseBody.LoadBalancers.LoadBalancer] = []
                for v in dict["LoadBalancer"] as! [Any] {
                    var model = DescribeLoadBalancersResponseBody.LoadBalancers.LoadBalancer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.loadBalancer = tmp
            }
        }
    }
    public var loadBalancers: DescribeLoadBalancersResponseBody.LoadBalancers?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.loadBalancers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancers != nil {
            map["LoadBalancers"] = self.loadBalancers?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancers") && dict["LoadBalancers"] != nil {
            var model = DescribeLoadBalancersResponseBody.LoadBalancers()
            model.fromMap(dict["LoadBalancers"] as! [String: Any])
            self.loadBalancers = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLoadBalancersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLoadBalancersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeasurementDataRequest : Tea.TeaModel {
    public var endDate: String?

    public var startDate: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
            self.startDate = dict["StartDate"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeMeasurementDataResponseBody : Tea.TeaModel {
    public class MeasurementDatas : Tea.TeaModel {
        public class MeasurementData : Tea.TeaModel {
            public class BandWidthFeeDatas : Tea.TeaModel {
                public class BandWidthFeeData : Tea.TeaModel {
                    public var costCode: String?

                    public var costName: String?

                    public var costVal: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.costCode != nil {
                            map["CostCode"] = self.costCode!
                        }
                        if self.costName != nil {
                            map["CostName"] = self.costName!
                        }
                        if self.costVal != nil {
                            map["CostVal"] = self.costVal!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CostCode") && dict["CostCode"] != nil {
                            self.costCode = dict["CostCode"] as! String
                        }
                        if dict.keys.contains("CostName") && dict["CostName"] != nil {
                            self.costName = dict["CostName"] as! String
                        }
                        if dict.keys.contains("CostVal") && dict["CostVal"] != nil {
                            self.costVal = dict["CostVal"] as! Int32
                        }
                    }
                }
                public var bandWidthFeeData: [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandWidthFeeData != nil {
                        var tmp : [Any] = []
                        for k in self.bandWidthFeeData! {
                            tmp.append(k.toMap())
                        }
                        map["BandWidthFeeData"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BandWidthFeeData") && dict["BandWidthFeeData"] != nil {
                        var tmp : [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData] = []
                        for v in dict["BandWidthFeeData"] as! [Any] {
                            var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.bandWidthFeeData = tmp
                    }
                }
            }
            public class ResourceFeeData : Tea.TeaModel {
                public var memory: Int32?

                public var storage: Int32?

                public var vcpu: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.memory != nil {
                        map["Memory"] = self.memory!
                    }
                    if self.storage != nil {
                        map["Storage"] = self.storage!
                    }
                    if self.vcpu != nil {
                        map["Vcpu"] = self.vcpu!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Memory") && dict["Memory"] != nil {
                        self.memory = dict["Memory"] as! Int32
                    }
                    if dict.keys.contains("Storage") && dict["Storage"] != nil {
                        self.storage = dict["Storage"] as! Int32
                    }
                    if dict.keys.contains("Vcpu") && dict["Vcpu"] != nil {
                        self.vcpu = dict["Vcpu"] as! Int32
                    }
                }
            }
            public class ResourceFeeDataDetails : Tea.TeaModel {
                public class ResourceFeeDataDetail : Tea.TeaModel {
                    public var costCode: String?

                    public var costName: String?

                    public var costVal: Int32?

                    public var resourceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.costCode != nil {
                            map["CostCode"] = self.costCode!
                        }
                        if self.costName != nil {
                            map["CostName"] = self.costName!
                        }
                        if self.costVal != nil {
                            map["CostVal"] = self.costVal!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CostCode") && dict["CostCode"] != nil {
                            self.costCode = dict["CostCode"] as! String
                        }
                        if dict.keys.contains("CostName") && dict["CostName"] != nil {
                            self.costName = dict["CostName"] as! String
                        }
                        if dict.keys.contains("CostVal") && dict["CostVal"] != nil {
                            self.costVal = dict["CostVal"] as! Int32
                        }
                        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                            self.resourceType = dict["ResourceType"] as! String
                        }
                    }
                }
                public var resourceFeeDataDetail: [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails.ResourceFeeDataDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceFeeDataDetail != nil {
                        var tmp : [Any] = []
                        for k in self.resourceFeeDataDetail! {
                            tmp.append(k.toMap())
                        }
                        map["ResourceFeeDataDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceFeeDataDetail") && dict["ResourceFeeDataDetail"] != nil {
                        var tmp : [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails.ResourceFeeDataDetail] = []
                        for v in dict["ResourceFeeDataDetail"] as! [Any] {
                            var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails.ResourceFeeDataDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.resourceFeeDataDetail = tmp
                    }
                }
            }
            public var bandWidthFeeDatas: DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas?

            public var chargeModel: String?

            public var costCycle: String?

            public var costEndTime: String?

            public var costStartTime: String?

            public var resourceFeeData: DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeData?

            public var resourceFeeDataDetails: DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bandWidthFeeDatas?.validate()
                try self.resourceFeeData?.validate()
                try self.resourceFeeDataDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidthFeeDatas != nil {
                    map["BandWidthFeeDatas"] = self.bandWidthFeeDatas?.toMap()
                }
                if self.chargeModel != nil {
                    map["ChargeModel"] = self.chargeModel!
                }
                if self.costCycle != nil {
                    map["CostCycle"] = self.costCycle!
                }
                if self.costEndTime != nil {
                    map["CostEndTime"] = self.costEndTime!
                }
                if self.costStartTime != nil {
                    map["CostStartTime"] = self.costStartTime!
                }
                if self.resourceFeeData != nil {
                    map["ResourceFeeData"] = self.resourceFeeData?.toMap()
                }
                if self.resourceFeeDataDetails != nil {
                    map["ResourceFeeDataDetails"] = self.resourceFeeDataDetails?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandWidthFeeDatas") && dict["BandWidthFeeDatas"] != nil {
                    var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas()
                    model.fromMap(dict["BandWidthFeeDatas"] as! [String: Any])
                    self.bandWidthFeeDatas = model
                }
                if dict.keys.contains("ChargeModel") && dict["ChargeModel"] != nil {
                    self.chargeModel = dict["ChargeModel"] as! String
                }
                if dict.keys.contains("CostCycle") && dict["CostCycle"] != nil {
                    self.costCycle = dict["CostCycle"] as! String
                }
                if dict.keys.contains("CostEndTime") && dict["CostEndTime"] != nil {
                    self.costEndTime = dict["CostEndTime"] as! String
                }
                if dict.keys.contains("CostStartTime") && dict["CostStartTime"] != nil {
                    self.costStartTime = dict["CostStartTime"] as! String
                }
                if dict.keys.contains("ResourceFeeData") && dict["ResourceFeeData"] != nil {
                    var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeData()
                    model.fromMap(dict["ResourceFeeData"] as! [String: Any])
                    self.resourceFeeData = model
                }
                if dict.keys.contains("ResourceFeeDataDetails") && dict["ResourceFeeDataDetails"] != nil {
                    var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails()
                    model.fromMap(dict["ResourceFeeDataDetails"] as! [String: Any])
                    self.resourceFeeDataDetails = model
                }
            }
        }
        public var measurementData: [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.measurementData != nil {
                var tmp : [Any] = []
                for k in self.measurementData! {
                    tmp.append(k.toMap())
                }
                map["MeasurementData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MeasurementData") && dict["MeasurementData"] != nil {
                var tmp : [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData] = []
                for v in dict["MeasurementData"] as! [Any] {
                    var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.measurementData = tmp
            }
        }
    }
    public var measurementDatas: DescribeMeasurementDataResponseBody.MeasurementDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.measurementDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.measurementDatas != nil {
            map["MeasurementDatas"] = self.measurementDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MeasurementDatas") && dict["MeasurementDatas"] != nil {
            var model = DescribeMeasurementDataResponseBody.MeasurementDatas()
            model.fromMap(dict["MeasurementDatas"] as! [String: Any])
            self.measurementDatas = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeasurementDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeasurementDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMeasurementDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMountTargetsRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public var mountTargetName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.mountTargetName != nil {
            map["MountTargetName"] = self.mountTargetName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") && dict["FileSystemId"] != nil {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("MountTargetName") && dict["MountTargetName"] != nil {
            self.mountTargetName = dict["MountTargetName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeMountTargetsResponseBody : Tea.TeaModel {
    public class MountTargets : Tea.TeaModel {
        public var ensRegionId: String?

        public var fileSystemId: String?

        public var mountTargetDomain: String?

        public var mountTargetName: String?

        public var netWorkId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.fileSystemId != nil {
                map["FileSystemId"] = self.fileSystemId!
            }
            if self.mountTargetDomain != nil {
                map["MountTargetDomain"] = self.mountTargetDomain!
            }
            if self.mountTargetName != nil {
                map["MountTargetName"] = self.mountTargetName!
            }
            if self.netWorkId != nil {
                map["NetWorkId"] = self.netWorkId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("FileSystemId") && dict["FileSystemId"] != nil {
                self.fileSystemId = dict["FileSystemId"] as! String
            }
            if dict.keys.contains("MountTargetDomain") && dict["MountTargetDomain"] != nil {
                self.mountTargetDomain = dict["MountTargetDomain"] as! String
            }
            if dict.keys.contains("MountTargetName") && dict["MountTargetName"] != nil {
                self.mountTargetName = dict["MountTargetName"] as! String
            }
            if dict.keys.contains("NetWorkId") && dict["NetWorkId"] != nil {
                self.netWorkId = dict["NetWorkId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var mountTargets: [DescribeMountTargetsResponseBody.MountTargets]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mountTargets != nil {
            var tmp : [Any] = []
            for k in self.mountTargets! {
                tmp.append(k.toMap())
            }
            map["MountTargets"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MountTargets") && dict["MountTargets"] != nil {
            var tmp : [DescribeMountTargetsResponseBody.MountTargets] = []
            for v in dict["MountTargets"] as! [Any] {
                var model = DescribeMountTargetsResponseBody.MountTargets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mountTargets = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeMountTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMountTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMountTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNCInformationRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class DescribeNCInformationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Cpu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Gpu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Hdd : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Info : Tea.TeaModel {
            public var ip: String?

            public var name: String?

            public var tag: [String]?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.uuid != nil {
                    map["Uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! [String]
                }
                if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                    self.uuid = dict["Uuid"] as! String
                }
            }
        }
        public class Memory : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Nvme : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Ssd : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public var cpu: DescribeNCInformationResponseBody.Data.Cpu?

        public var gpu: DescribeNCInformationResponseBody.Data.Gpu?

        public var hdd: DescribeNCInformationResponseBody.Data.Hdd?

        public var info: DescribeNCInformationResponseBody.Data.Info?

        public var memory: DescribeNCInformationResponseBody.Data.Memory?

        public var nvme: DescribeNCInformationResponseBody.Data.Nvme?

        public var online: Bool?

        public var region: String?

        public var ssd: DescribeNCInformationResponseBody.Data.Ssd?

        public var virtual: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cpu?.validate()
            try self.gpu?.validate()
            try self.hdd?.validate()
            try self.info?.validate()
            try self.memory?.validate()
            try self.nvme?.validate()
            try self.ssd?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpu != nil {
                map["Cpu"] = self.cpu?.toMap()
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu?.toMap()
            }
            if self.hdd != nil {
                map["Hdd"] = self.hdd?.toMap()
            }
            if self.info != nil {
                map["Info"] = self.info?.toMap()
            }
            if self.memory != nil {
                map["Memory"] = self.memory?.toMap()
            }
            if self.nvme != nil {
                map["Nvme"] = self.nvme?.toMap()
            }
            if self.online != nil {
                map["Online"] = self.online!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.ssd != nil {
                map["Ssd"] = self.ssd?.toMap()
            }
            if self.virtual != nil {
                map["Virtual"] = self.virtual!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                var model = DescribeNCInformationResponseBody.Data.Cpu()
                model.fromMap(dict["Cpu"] as! [String: Any])
                self.cpu = model
            }
            if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                var model = DescribeNCInformationResponseBody.Data.Gpu()
                model.fromMap(dict["Gpu"] as! [String: Any])
                self.gpu = model
            }
            if dict.keys.contains("Hdd") && dict["Hdd"] != nil {
                var model = DescribeNCInformationResponseBody.Data.Hdd()
                model.fromMap(dict["Hdd"] as! [String: Any])
                self.hdd = model
            }
            if dict.keys.contains("Info") && dict["Info"] != nil {
                var model = DescribeNCInformationResponseBody.Data.Info()
                model.fromMap(dict["Info"] as! [String: Any])
                self.info = model
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                var model = DescribeNCInformationResponseBody.Data.Memory()
                model.fromMap(dict["Memory"] as! [String: Any])
                self.memory = model
            }
            if dict.keys.contains("Nvme") && dict["Nvme"] != nil {
                var model = DescribeNCInformationResponseBody.Data.Nvme()
                model.fromMap(dict["Nvme"] as! [String: Any])
                self.nvme = model
            }
            if dict.keys.contains("Online") && dict["Online"] != nil {
                self.online = dict["Online"] as! Bool
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Ssd") && dict["Ssd"] != nil {
                var model = DescribeNCInformationResponseBody.Data.Ssd()
                model.fromMap(dict["Ssd"] as! [String: Any])
                self.ssd = model
            }
            if dict.keys.contains("Virtual") && dict["Virtual"] != nil {
                self.virtual = dict["Virtual"] as! String
            }
        }
    }
    public class Pager : Tea.TeaModel {
        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var currentPage: Int32?

    public var data: [DescribeNCInformationResponseBody.Data]?

    public var desc: String?

    public var msg: String?

    public var pager: DescribeNCInformationResponseBody.Pager?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pager?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.pager != nil {
            map["Pager"] = self.pager?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeNCInformationResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeNCInformationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Msg") && dict["Msg"] != nil {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("Pager") && dict["Pager"] != nil {
            var model = DescribeNCInformationResponseBody.Pager()
            model.fromMap(dict["Pager"] as! [String: Any])
            self.pager = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNCInformationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNCInformationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNCInformationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNatGatewaysRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var name: String?

    public var natGatewayId: String?

    public var networkId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeNatGatewaysResponseBody : Tea.TeaModel {
    public class NatGateways : Tea.TeaModel {
        public var creationTime: String?

        public var ensRegionId: String?

        public var name: String?

        public var natGatewayId: String?

        public var networkId: String?

        public var spec: String?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
                self.natGatewayId = dict["NatGatewayId"] as! String
            }
            if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("Spec") && dict["Spec"] != nil {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public var natGateways: [DescribeNatGatewaysResponseBody.NatGateways]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGateways != nil {
            var tmp : [Any] = []
            for k in self.natGateways! {
                tmp.append(k.toMap())
            }
            map["NatGateways"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGateways") && dict["NatGateways"] != nil {
            var tmp : [DescribeNatGatewaysResponseBody.NatGateways] = []
            for v in dict["NatGateways"] as! [Any] {
                var model = DescribeNatGatewaysResponseBody.NatGateways()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.natGateways = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNatGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNatGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNatGatewaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkAclsRequest : Tea.TeaModel {
    public var networkAclId: String?

    public var networkAclName: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") && dict["NetworkAclId"] != nil {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("NetworkAclName") && dict["NetworkAclName"] != nil {
            self.networkAclName = dict["NetworkAclName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class DescribeNetworkAclsResponseBody : Tea.TeaModel {
    public class NetworkAcls : Tea.TeaModel {
        public class EgressAclEntries : Tea.TeaModel {
            public var cidrBlock: String?

            public var description_: String?

            public var networkAclEntryId: String?

            public var networkAclEntryName: String?

            public var policy: String?

            public var portRange: String?

            public var priority: Int32?

            public var protocol_: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.networkAclEntryId != nil {
                    map["NetworkAclEntryId"] = self.networkAclEntryId!
                }
                if self.networkAclEntryName != nil {
                    map["NetworkAclEntryName"] = self.networkAclEntryName!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("NetworkAclEntryId") && dict["NetworkAclEntryId"] != nil {
                    self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                }
                if dict.keys.contains("NetworkAclEntryName") && dict["NetworkAclEntryName"] != nil {
                    self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                }
                if dict.keys.contains("Policy") && dict["Policy"] != nil {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
                    self.portRange = dict["PortRange"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class IngressAclEntries : Tea.TeaModel {
            public var cidrBlock: String?

            public var description_: String?

            public var networkAclEntryId: String?

            public var networkAclEntryName: String?

            public var policy: String?

            public var portRange: String?

            public var priority: Int32?

            public var protocol_: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.networkAclEntryId != nil {
                    map["NetworkAclEntryId"] = self.networkAclEntryId!
                }
                if self.networkAclEntryName != nil {
                    map["NetworkAclEntryName"] = self.networkAclEntryName!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("NetworkAclEntryId") && dict["NetworkAclEntryId"] != nil {
                    self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                }
                if dict.keys.contains("NetworkAclEntryName") && dict["NetworkAclEntryName"] != nil {
                    self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                }
                if dict.keys.contains("Policy") && dict["Policy"] != nil {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
                    self.portRange = dict["PortRange"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Resources : Tea.TeaModel {
            public var ensRegionId: String?

            public var resourceId: String?

            public var resourceType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var creationTime: String?

        public var description_: String?

        public var egressAclEntries: [DescribeNetworkAclsResponseBody.NetworkAcls.EgressAclEntries]?

        public var ingressAclEntries: [DescribeNetworkAclsResponseBody.NetworkAcls.IngressAclEntries]?

        public var networkAclId: String?

        public var networkAclName: String?

        public var resources: [DescribeNetworkAclsResponseBody.NetworkAcls.Resources]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.egressAclEntries != nil {
                var tmp : [Any] = []
                for k in self.egressAclEntries! {
                    tmp.append(k.toMap())
                }
                map["EgressAclEntries"] = tmp
            }
            if self.ingressAclEntries != nil {
                var tmp : [Any] = []
                for k in self.ingressAclEntries! {
                    tmp.append(k.toMap())
                }
                map["IngressAclEntries"] = tmp
            }
            if self.networkAclId != nil {
                map["NetworkAclId"] = self.networkAclId!
            }
            if self.networkAclName != nil {
                map["NetworkAclName"] = self.networkAclName!
            }
            if self.resources != nil {
                var tmp : [Any] = []
                for k in self.resources! {
                    tmp.append(k.toMap())
                }
                map["Resources"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EgressAclEntries") && dict["EgressAclEntries"] != nil {
                var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.EgressAclEntries] = []
                for v in dict["EgressAclEntries"] as! [Any] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.EgressAclEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.egressAclEntries = tmp
            }
            if dict.keys.contains("IngressAclEntries") && dict["IngressAclEntries"] != nil {
                var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.IngressAclEntries] = []
                for v in dict["IngressAclEntries"] as! [Any] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.IngressAclEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ingressAclEntries = tmp
            }
            if dict.keys.contains("NetworkAclId") && dict["NetworkAclId"] != nil {
                self.networkAclId = dict["NetworkAclId"] as! String
            }
            if dict.keys.contains("NetworkAclName") && dict["NetworkAclName"] != nil {
                self.networkAclName = dict["NetworkAclName"] as! String
            }
            if dict.keys.contains("Resources") && dict["Resources"] != nil {
                var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.Resources] = []
                for v in dict["Resources"] as! [Any] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.Resources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resources = tmp
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var networkAcls: [DescribeNetworkAclsResponseBody.NetworkAcls]?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAcls != nil {
            var tmp : [Any] = []
            for k in self.networkAcls! {
                tmp.append(k.toMap())
            }
            map["NetworkAcls"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAcls") && dict["NetworkAcls"] != nil {
            var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls] = []
            for v in dict["NetworkAcls"] as! [Any] {
                var model = DescribeNetworkAclsResponseBody.NetworkAcls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkAcls = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeNetworkAclsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkAclsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNetworkAclsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkAttributeRequest : Tea.TeaModel {
    public var networkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
    }
}

public class DescribeNetworkAttributeResponseBody : Tea.TeaModel {
    public class CloudResources : Tea.TeaModel {
        public class CloudResourceSetType : Tea.TeaModel {
            public var resourceCount: Int32?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceCount != nil {
                    map["ResourceCount"] = self.resourceCount!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceCount") && dict["ResourceCount"] != nil {
                    self.resourceCount = dict["ResourceCount"] as! Int32
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
            }
        }
        public var cloudResourceSetType: [DescribeNetworkAttributeResponseBody.CloudResources.CloudResourceSetType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cloudResourceSetType != nil {
                var tmp : [Any] = []
                for k in self.cloudResourceSetType! {
                    tmp.append(k.toMap())
                }
                map["CloudResourceSetType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CloudResourceSetType") && dict["CloudResourceSetType"] != nil {
                var tmp : [DescribeNetworkAttributeResponseBody.CloudResources.CloudResourceSetType] = []
                for v in dict["CloudResourceSetType"] as! [Any] {
                    var model = DescribeNetworkAttributeResponseBody.CloudResources.CloudResourceSetType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cloudResourceSetType = tmp
            }
        }
    }
    public class VSwitchIds : Tea.TeaModel {
        public var vSwitchId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! [String]
            }
        }
    }
    public var cidrBlock: String?

    public var cloudResources: DescribeNetworkAttributeResponseBody.CloudResources?

    public var createdTime: String?

    public var description_: String?

    public var ensRegionId: String?

    public var networkAclId: String?

    public var networkId: String?

    public var networkName: String?

    public var requestId: String?

    public var routerTableId: String?

    public var status: String?

    public var vSwitchIds: DescribeNetworkAttributeResponseBody.VSwitchIds?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cloudResources?.validate()
        try self.vSwitchIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.cloudResources != nil {
            map["CloudResources"] = self.cloudResources?.toMap()
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerTableId != nil {
            map["RouterTableId"] = self.routerTableId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("CloudResources") && dict["CloudResources"] != nil {
            var model = DescribeNetworkAttributeResponseBody.CloudResources()
            model.fromMap(dict["CloudResources"] as! [String: Any])
            self.cloudResources = model
        }
        if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("NetworkAclId") && dict["NetworkAclId"] != nil {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("NetworkName") && dict["NetworkName"] != nil {
            self.networkName = dict["NetworkName"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouterTableId") && dict["RouterTableId"] != nil {
            self.routerTableId = dict["RouterTableId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VSwitchIds") && dict["VSwitchIds"] != nil {
            var model = DescribeNetworkAttributeResponseBody.VSwitchIds()
            model.fromMap(dict["VSwitchIds"] as! [String: Any])
            self.vSwitchIds = model
        }
    }
}

public class DescribeNetworkAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNetworkAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkInterfacesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var instanceId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var primaryIpAddress: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.primaryIpAddress != nil {
            map["PrimaryIpAddress"] = self.primaryIpAddress!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("PrimaryIpAddress") && dict["PrimaryIpAddress"] != nil {
            self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeNetworkInterfacesResponseBody : Tea.TeaModel {
    public class NetworkInterfaceSets : Tea.TeaModel {
        public class NetworkInterfaceSet : Tea.TeaModel {
            public class PrivateIpSets : Tea.TeaModel {
                public class PrivateIpSet : Tea.TeaModel {
                    public var primary: Bool?

                    public var privateIpAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.primary != nil {
                            map["Primary"] = self.primary!
                        }
                        if self.privateIpAddress != nil {
                            map["PrivateIpAddress"] = self.privateIpAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Primary") && dict["Primary"] != nil {
                            self.primary = dict["Primary"] as! Bool
                        }
                        if dict.keys.contains("PrivateIpAddress") && dict["PrivateIpAddress"] != nil {
                            self.privateIpAddress = dict["PrivateIpAddress"] as! String
                        }
                    }
                }
                public var privateIpSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateIpSet != nil {
                        var tmp : [Any] = []
                        for k in self.privateIpSet! {
                            tmp.append(k.toMap())
                        }
                        map["PrivateIpSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateIpSet") && dict["PrivateIpSet"] != nil {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet] = []
                        for v in dict["PrivateIpSet"] as! [Any] {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.privateIpSet = tmp
                    }
                }
            }
            public var creationTime: String?

            public var ensRegionId: String?

            public var instanceId: String?

            public var macAddress: String?

            public var networkInterfaceId: String?

            public var primaryIp: String?

            public var primaryIpType: String?

            public var privateIpSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets?

            public var status: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.privateIpSets?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.macAddress != nil {
                    map["MacAddress"] = self.macAddress!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.primaryIp != nil {
                    map["PrimaryIp"] = self.primaryIp!
                }
                if self.primaryIpType != nil {
                    map["PrimaryIpType"] = self.primaryIpType!
                }
                if self.privateIpSets != nil {
                    map["PrivateIpSets"] = self.privateIpSets?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MacAddress") && dict["MacAddress"] != nil {
                    self.macAddress = dict["MacAddress"] as! String
                }
                if dict.keys.contains("NetworkInterfaceId") && dict["NetworkInterfaceId"] != nil {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                }
                if dict.keys.contains("PrimaryIp") && dict["PrimaryIp"] != nil {
                    self.primaryIp = dict["PrimaryIp"] as! String
                }
                if dict.keys.contains("PrimaryIpType") && dict["PrimaryIpType"] != nil {
                    self.primaryIpType = dict["PrimaryIpType"] as! String
                }
                if dict.keys.contains("PrivateIpSets") && dict["PrivateIpSets"] != nil {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets()
                    model.fromMap(dict["PrivateIpSets"] as! [String: Any])
                    self.privateIpSets = model
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
            }
        }
        public var networkInterfaceSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceSet != nil {
                var tmp : [Any] = []
                for k in self.networkInterfaceSet! {
                    tmp.append(k.toMap())
                }
                map["NetworkInterfaceSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceSet") && dict["NetworkInterfaceSet"] != nil {
                var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet] = []
                for v in dict["NetworkInterfaceSet"] as! [Any] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.networkInterfaceSet = tmp
            }
        }
    }
    public var networkInterfaceSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInterfaceSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceSets != nil {
            map["NetworkInterfaceSets"] = self.networkInterfaceSets?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceSets") && dict["NetworkInterfaceSets"] != nil {
            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets()
            model.fromMap(dict["NetworkInterfaceSets"] as! [String: Any])
            self.networkInterfaceSets = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNetworkInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNetworkInterfacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworksRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var networkId: String?

    public var networkName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("NetworkName") && dict["NetworkName"] != nil {
            self.networkName = dict["NetworkName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeNetworksResponseBody : Tea.TeaModel {
    public class Networks : Tea.TeaModel {
        public class Network : Tea.TeaModel {
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                        self.vSwitchId = dict["VSwitchId"] as! [String]
                    }
                }
            }
            public var cidrBlock: String?

            public var createdTime: String?

            public var description_: String?

            public var ensRegionId: String?

            public var networkAclId: String?

            public var networkId: String?

            public var networkName: String?

            public var routerTableId: String?

            public var status: String?

            public var vSwitchIds: DescribeNetworksResponseBody.Networks.Network.VSwitchIds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.networkAclId != nil {
                    map["NetworkAclId"] = self.networkAclId!
                }
                if self.networkId != nil {
                    map["NetworkId"] = self.networkId!
                }
                if self.networkName != nil {
                    map["NetworkName"] = self.networkName!
                }
                if self.routerTableId != nil {
                    map["RouterTableId"] = self.routerTableId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("NetworkAclId") && dict["NetworkAclId"] != nil {
                    self.networkAclId = dict["NetworkAclId"] as! String
                }
                if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
                    self.networkId = dict["NetworkId"] as! String
                }
                if dict.keys.contains("NetworkName") && dict["NetworkName"] != nil {
                    self.networkName = dict["NetworkName"] as! String
                }
                if dict.keys.contains("RouterTableId") && dict["RouterTableId"] != nil {
                    self.routerTableId = dict["RouterTableId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VSwitchIds") && dict["VSwitchIds"] != nil {
                    var model = DescribeNetworksResponseBody.Networks.Network.VSwitchIds()
                    model.fromMap(dict["VSwitchIds"] as! [String: Any])
                    self.vSwitchIds = model
                }
            }
        }
        public var network: [DescribeNetworksResponseBody.Networks.Network]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.network != nil {
                var tmp : [Any] = []
                for k in self.network! {
                    tmp.append(k.toMap())
                }
                map["Network"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Network") && dict["Network"] != nil {
                var tmp : [DescribeNetworksResponseBody.Networks.Network] = []
                for v in dict["Network"] as! [Any] {
                    var model = DescribeNetworksResponseBody.Networks.Network()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.network = tmp
            }
        }
    }
    public var networks: DescribeNetworksResponseBody.Networks?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networks != nil {
            map["Networks"] = self.networks?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Networks") && dict["Networks"] != nil {
            var model = DescribeNetworksResponseBody.Networks()
            model.fromMap(dict["Networks"] as! [String: Any])
            self.networks = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNetworksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNetworksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrePaidInstanceStockRequest : Tea.TeaModel {
    public var dataDiskSize: Int32?

    public var ensRegionId: String?

    public var instanceSpec: String?

    public var systemDiskSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceSpec != nil {
            map["InstanceSpec"] = self.instanceSpec!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDiskSize") && dict["DataDiskSize"] != nil {
            self.dataDiskSize = dict["DataDiskSize"] as! Int32
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceSpec") && dict["InstanceSpec"] != nil {
            self.instanceSpec = dict["InstanceSpec"] as! String
        }
        if dict.keys.contains("SystemDiskSize") && dict["SystemDiskSize"] != nil {
            self.systemDiskSize = dict["SystemDiskSize"] as! Int32
        }
    }
}

public class DescribePrePaidInstanceStockResponseBody : Tea.TeaModel {
    public var avaliableCount: Int32?

    public var cores: Int32?

    public var dataDiskSize: Int32?

    public var ensRegionId: String?

    public var instanceSpec: String?

    public var memory: Int32?

    public var requestId: String?

    public var resourceGap: String?

    public var systemDiskSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avaliableCount != nil {
            map["AvaliableCount"] = self.avaliableCount!
        }
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceSpec != nil {
            map["InstanceSpec"] = self.instanceSpec!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGap != nil {
            map["ResourceGap"] = self.resourceGap!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvaliableCount") && dict["AvaliableCount"] != nil {
            self.avaliableCount = dict["AvaliableCount"] as! Int32
        }
        if dict.keys.contains("Cores") && dict["Cores"] != nil {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("DataDiskSize") && dict["DataDiskSize"] != nil {
            self.dataDiskSize = dict["DataDiskSize"] as! Int32
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceSpec") && dict["InstanceSpec"] != nil {
            self.instanceSpec = dict["InstanceSpec"] as! String
        }
        if dict.keys.contains("Memory") && dict["Memory"] != nil {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGap") && dict["ResourceGap"] != nil {
            self.resourceGap = dict["ResourceGap"] as! String
        }
        if dict.keys.contains("SystemDiskSize") && dict["SystemDiskSize"] != nil {
            self.systemDiskSize = dict["SystemDiskSize"] as! Int32
        }
    }
}

public class DescribePrePaidInstanceStockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrePaidInstanceStockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePrePaidInstanceStockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePriceRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var category: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
        }
    }
    public var dataDisk: [DescribePriceRequest.DataDisk]?

    public var systemDisk: DescribePriceRequest.SystemDisk?

    public var dataDisks: [DescribePriceRequest.DataDisks]?

    public var ensRegionId: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var quantity: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDisk") && dict["DataDisk"] != nil {
            var tmp : [DescribePriceRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = DescribePriceRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
            var model = DescribePriceRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("DataDisks") && dict["DataDisks"] != nil {
            var tmp : [DescribePriceRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = DescribePriceRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
            self.quantity = dict["Quantity"] as! Int32
        }
    }
}

public class DescribePriceShrinkRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public var dataDisk: [DescribePriceShrinkRequest.DataDisk]?

    public var systemDisk: DescribePriceShrinkRequest.SystemDisk?

    public var dataDisksShrink: String?

    public var ensRegionId: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var quantity: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.dataDisksShrink != nil {
            map["DataDisks"] = self.dataDisksShrink!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDisk") && dict["DataDisk"] != nil {
            var tmp : [DescribePriceShrinkRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = DescribePriceShrinkRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
            var model = DescribePriceShrinkRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("DataDisks") && dict["DataDisks"] != nil {
            self.dataDisksShrink = dict["DataDisks"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
            self.quantity = dict["Quantity"] as! Int32
        }
    }
}

public class DescribePriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public var currency: String?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") && dict["Currency"] != nil {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") && dict["TradePrice"] != nil {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public var price: DescribePriceResponseBody.PriceInfo.Price?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") && dict["Price"] != nil {
                var model = DescribePriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
        }
    }
    public var priceInfo: DescribePriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") && dict["PriceInfo"] != nil {
            var model = DescribePriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionIspsRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
    }
}

public class DescribeRegionIspsResponseBody : Tea.TeaModel {
    public class Isps : Tea.TeaModel {
        public var code: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var isps: [DescribeRegionIspsResponseBody.Isps]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isps != nil {
            var tmp : [Any] = []
            for k in self.isps! {
                tmp.append(k.toMap())
            }
            map["Isps"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Isps") && dict["Isps"] != nil {
            var tmp : [DescribeRegionIspsResponseBody.Isps] = []
            for v in dict["Isps"] as! [Any] {
                var model = DescribeRegionIspsResponseBody.Isps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.isps = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionIspsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionIspsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRegionIspsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionResourceRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ispType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ispType != nil {
            map["IspType"] = self.ispType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("IspType") && dict["IspType"] != nil {
            self.ispType = dict["IspType"] as! String
        }
    }
}

public class DescribeRegionResourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ArmCard : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Bandwidth : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class BlockStorage : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Cpu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Gpu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Hdd : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Ipv4s : Tea.TeaModel {
            public var display: String?

            public var isp: String?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public var vlan: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                if self.vlan != nil {
                    map["Vlan"] = self.vlan!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! String
                }
                if dict.keys.contains("Isp") && dict["Isp"] != nil {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
                if dict.keys.contains("Vlan") && dict["Vlan"] != nil {
                    self.vlan = dict["Vlan"] as! String
                }
            }
        }
        public class Ipv6s : Tea.TeaModel {
            public var display: String?

            public var isp: String?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public var vlan: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                if self.vlan != nil {
                    map["Vlan"] = self.vlan!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! String
                }
                if dict.keys.contains("Isp") && dict["Isp"] != nil {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
                if dict.keys.contains("Vlan") && dict["Vlan"] != nil {
                    self.vlan = dict["Vlan"] as! String
                }
            }
        }
        public class Memory : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Nvme : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class OssStorage : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Pangu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class PcfarmNum : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Ssd : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") && dict["OversellRatio"] != nil {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") && dict["Remain"] != nil {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") && dict["ReserveDisableTotal"] != nil {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") && dict["StatusDisableTotal"] != nil {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") && dict["Total"] != nil {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") && dict["Used"] != nil {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") && dict["UsedRatio"] != nil {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public var areaCode: String?

        public var areaName: String?

        public var armCard: DescribeRegionResourceResponseBody.Data.ArmCard?

        public var attributes: [String]?

        public var bandwidth: DescribeRegionResourceResponseBody.Data.Bandwidth?

        public var blockStorage: DescribeRegionResourceResponseBody.Data.BlockStorage?

        public var countryCode: String?

        public var countryName: String?

        public var cpu: DescribeRegionResourceResponseBody.Data.Cpu?

        public var gpu: DescribeRegionResourceResponseBody.Data.Gpu?

        public var hdd: DescribeRegionResourceResponseBody.Data.Hdd?

        public var houseId: String?

        public var ipv4s: [DescribeRegionResourceResponseBody.Data.Ipv4s]?

        public var ipv6s: [DescribeRegionResourceResponseBody.Data.Ipv6s]?

        public var ispTypes: [String]?

        public var memory: DescribeRegionResourceResponseBody.Data.Memory?

        public var name: String?

        public var nvme: DescribeRegionResourceResponseBody.Data.Nvme?

        public var ossStorage: DescribeRegionResourceResponseBody.Data.OssStorage?

        public var pangu: DescribeRegionResourceResponseBody.Data.Pangu?

        public var pcfarmNum: DescribeRegionResourceResponseBody.Data.PcfarmNum?

        public var poc: Bool?

        public var provinceCode: String?

        public var provinceName: String?

        public var reserveDisable: Bool?

        public var ssd: DescribeRegionResourceResponseBody.Data.Ssd?

        public var statusDisable: Bool?

        public var type: String?

        public var uuid: String?

        public var virtual: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.armCard?.validate()
            try self.bandwidth?.validate()
            try self.blockStorage?.validate()
            try self.cpu?.validate()
            try self.gpu?.validate()
            try self.hdd?.validate()
            try self.memory?.validate()
            try self.nvme?.validate()
            try self.ossStorage?.validate()
            try self.pangu?.validate()
            try self.pcfarmNum?.validate()
            try self.ssd?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.areaCode != nil {
                map["AreaCode"] = self.areaCode!
            }
            if self.areaName != nil {
                map["AreaName"] = self.areaName!
            }
            if self.armCard != nil {
                map["ArmCard"] = self.armCard?.toMap()
            }
            if self.attributes != nil {
                map["Attributes"] = self.attributes!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth?.toMap()
            }
            if self.blockStorage != nil {
                map["BlockStorage"] = self.blockStorage?.toMap()
            }
            if self.countryCode != nil {
                map["CountryCode"] = self.countryCode!
            }
            if self.countryName != nil {
                map["CountryName"] = self.countryName!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu?.toMap()
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu?.toMap()
            }
            if self.hdd != nil {
                map["Hdd"] = self.hdd?.toMap()
            }
            if self.houseId != nil {
                map["HouseId"] = self.houseId!
            }
            if self.ipv4s != nil {
                var tmp : [Any] = []
                for k in self.ipv4s! {
                    tmp.append(k.toMap())
                }
                map["Ipv4s"] = tmp
            }
            if self.ipv6s != nil {
                var tmp : [Any] = []
                for k in self.ipv6s! {
                    tmp.append(k.toMap())
                }
                map["Ipv6s"] = tmp
            }
            if self.ispTypes != nil {
                map["IspTypes"] = self.ispTypes!
            }
            if self.memory != nil {
                map["Memory"] = self.memory?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nvme != nil {
                map["Nvme"] = self.nvme?.toMap()
            }
            if self.ossStorage != nil {
                map["OssStorage"] = self.ossStorage?.toMap()
            }
            if self.pangu != nil {
                map["Pangu"] = self.pangu?.toMap()
            }
            if self.pcfarmNum != nil {
                map["PcfarmNum"] = self.pcfarmNum?.toMap()
            }
            if self.poc != nil {
                map["Poc"] = self.poc!
            }
            if self.provinceCode != nil {
                map["ProvinceCode"] = self.provinceCode!
            }
            if self.provinceName != nil {
                map["ProvinceName"] = self.provinceName!
            }
            if self.reserveDisable != nil {
                map["ReserveDisable"] = self.reserveDisable!
            }
            if self.ssd != nil {
                map["Ssd"] = self.ssd?.toMap()
            }
            if self.statusDisable != nil {
                map["StatusDisable"] = self.statusDisable!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.virtual != nil {
                map["Virtual"] = self.virtual!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AreaCode") && dict["AreaCode"] != nil {
                self.areaCode = dict["AreaCode"] as! String
            }
            if dict.keys.contains("AreaName") && dict["AreaName"] != nil {
                self.areaName = dict["AreaName"] as! String
            }
            if dict.keys.contains("ArmCard") && dict["ArmCard"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.ArmCard()
                model.fromMap(dict["ArmCard"] as! [String: Any])
                self.armCard = model
            }
            if dict.keys.contains("Attributes") && dict["Attributes"] != nil {
                self.attributes = dict["Attributes"] as! [String]
            }
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.Bandwidth()
                model.fromMap(dict["Bandwidth"] as! [String: Any])
                self.bandwidth = model
            }
            if dict.keys.contains("BlockStorage") && dict["BlockStorage"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.BlockStorage()
                model.fromMap(dict["BlockStorage"] as! [String: Any])
                self.blockStorage = model
            }
            if dict.keys.contains("CountryCode") && dict["CountryCode"] != nil {
                self.countryCode = dict["CountryCode"] as! String
            }
            if dict.keys.contains("CountryName") && dict["CountryName"] != nil {
                self.countryName = dict["CountryName"] as! String
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.Cpu()
                model.fromMap(dict["Cpu"] as! [String: Any])
                self.cpu = model
            }
            if dict.keys.contains("Gpu") && dict["Gpu"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.Gpu()
                model.fromMap(dict["Gpu"] as! [String: Any])
                self.gpu = model
            }
            if dict.keys.contains("Hdd") && dict["Hdd"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.Hdd()
                model.fromMap(dict["Hdd"] as! [String: Any])
                self.hdd = model
            }
            if dict.keys.contains("HouseId") && dict["HouseId"] != nil {
                self.houseId = dict["HouseId"] as! String
            }
            if dict.keys.contains("Ipv4s") && dict["Ipv4s"] != nil {
                var tmp : [DescribeRegionResourceResponseBody.Data.Ipv4s] = []
                for v in dict["Ipv4s"] as! [Any] {
                    var model = DescribeRegionResourceResponseBody.Data.Ipv4s()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv4s = tmp
            }
            if dict.keys.contains("Ipv6s") && dict["Ipv6s"] != nil {
                var tmp : [DescribeRegionResourceResponseBody.Data.Ipv6s] = []
                for v in dict["Ipv6s"] as! [Any] {
                    var model = DescribeRegionResourceResponseBody.Data.Ipv6s()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6s = tmp
            }
            if dict.keys.contains("IspTypes") && dict["IspTypes"] != nil {
                self.ispTypes = dict["IspTypes"] as! [String]
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.Memory()
                model.fromMap(dict["Memory"] as! [String: Any])
                self.memory = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Nvme") && dict["Nvme"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.Nvme()
                model.fromMap(dict["Nvme"] as! [String: Any])
                self.nvme = model
            }
            if dict.keys.contains("OssStorage") && dict["OssStorage"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.OssStorage()
                model.fromMap(dict["OssStorage"] as! [String: Any])
                self.ossStorage = model
            }
            if dict.keys.contains("Pangu") && dict["Pangu"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.Pangu()
                model.fromMap(dict["Pangu"] as! [String: Any])
                self.pangu = model
            }
            if dict.keys.contains("PcfarmNum") && dict["PcfarmNum"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.PcfarmNum()
                model.fromMap(dict["PcfarmNum"] as! [String: Any])
                self.pcfarmNum = model
            }
            if dict.keys.contains("Poc") && dict["Poc"] != nil {
                self.poc = dict["Poc"] as! Bool
            }
            if dict.keys.contains("ProvinceCode") && dict["ProvinceCode"] != nil {
                self.provinceCode = dict["ProvinceCode"] as! String
            }
            if dict.keys.contains("ProvinceName") && dict["ProvinceName"] != nil {
                self.provinceName = dict["ProvinceName"] as! String
            }
            if dict.keys.contains("ReserveDisable") && dict["ReserveDisable"] != nil {
                self.reserveDisable = dict["ReserveDisable"] as! Bool
            }
            if dict.keys.contains("Ssd") && dict["Ssd"] != nil {
                var model = DescribeRegionResourceResponseBody.Data.Ssd()
                model.fromMap(dict["Ssd"] as! [String: Any])
                self.ssd = model
            }
            if dict.keys.contains("StatusDisable") && dict["StatusDisable"] != nil {
                self.statusDisable = dict["StatusDisable"] as! Bool
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Virtual") && dict["Virtual"] != nil {
                self.virtual = dict["Virtual"] as! String
            }
        }
    }
    public class Pager : Tea.TeaModel {
        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Page") && dict["Page"] != nil {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var data: [DescribeRegionResourceResponseBody.Data]?

    public var desc: String?

    public var msg: String?

    public var pager: DescribeRegionResourceResponseBody.Pager?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pager?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.pager != nil {
            map["Pager"] = self.pager?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeRegionResourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeRegionResourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Msg") && dict["Msg"] != nil {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("Pager") && dict["Pager"] != nil {
            var model = DescribeRegionResourceResponseBody.Pager()
            model.fromMap(dict["Pager"] as! [String: Any])
            self.pager = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRegionResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservedResourceRequest : Tea.TeaModel {
    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeReservedResourceResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var imageId: String?

            public var imageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                    self.imageName = dict["ImageName"] as! String
                }
            }
        }
        public var image: [DescribeReservedResourceResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") && dict["Image"] != nil {
                var tmp : [DescribeReservedResourceResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeReservedResourceResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public class DataDiskSizes : Tea.TeaModel {
                public var dataDiskSize: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataDiskSize != nil {
                        map["DataDiskSize"] = self.dataDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataDiskSize") && dict["DataDiskSize"] != nil {
                        self.dataDiskSize = dict["DataDiskSize"] as! [String]
                    }
                }
            }
            public class SystemDiskSizes : Tea.TeaModel {
                public var systemDiskSize: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.systemDiskSize != nil {
                        map["SystemDiskSize"] = self.systemDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SystemDiskSize") && dict["SystemDiskSize"] != nil {
                        self.systemDiskSize = dict["SystemDiskSize"] as! [String]
                    }
                }
            }
            public var dataDiskSizes: DescribeReservedResourceResponseBody.SupportResources.SupportResource.DataDiskSizes?

            public var ensRegionId: String?

            public var instanceSpec: String?

            public var supportResourcesCount: String?

            public var systemDiskSizes: DescribeReservedResourceResponseBody.SupportResources.SupportResource.SystemDiskSizes?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataDiskSizes?.validate()
                try self.systemDiskSizes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataDiskSizes != nil {
                    map["DataDiskSizes"] = self.dataDiskSizes?.toMap()
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceSpec != nil {
                    map["InstanceSpec"] = self.instanceSpec!
                }
                if self.supportResourcesCount != nil {
                    map["SupportResourcesCount"] = self.supportResourcesCount!
                }
                if self.systemDiskSizes != nil {
                    map["SystemDiskSizes"] = self.systemDiskSizes?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataDiskSizes") && dict["DataDiskSizes"] != nil {
                    var model = DescribeReservedResourceResponseBody.SupportResources.SupportResource.DataDiskSizes()
                    model.fromMap(dict["DataDiskSizes"] as! [String: Any])
                    self.dataDiskSizes = model
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceSpec") && dict["InstanceSpec"] != nil {
                    self.instanceSpec = dict["InstanceSpec"] as! String
                }
                if dict.keys.contains("SupportResourcesCount") && dict["SupportResourcesCount"] != nil {
                    self.supportResourcesCount = dict["SupportResourcesCount"] as! String
                }
                if dict.keys.contains("SystemDiskSizes") && dict["SystemDiskSizes"] != nil {
                    var model = DescribeReservedResourceResponseBody.SupportResources.SupportResource.SystemDiskSizes()
                    model.fromMap(dict["SystemDiskSizes"] as! [String: Any])
                    self.systemDiskSizes = model
                }
            }
        }
        public var supportResource: [DescribeReservedResourceResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") && dict["SupportResource"] != nil {
                var tmp : [DescribeReservedResourceResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeReservedResourceResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeReservedResourceResponseBody.Images?

    public var requestId: String?

    public var supportResources: DescribeReservedResourceResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") && dict["Images"] != nil {
            var model = DescribeReservedResourceResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") && dict["SupportResources"] != nil {
            var model = DescribeReservedResourceResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeReservedResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeReservedResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceTimelineRequest : Tea.TeaModel {
    public var beginTime: String?

    public var endTime: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") && dict["BeginTime"] != nil {
            self.beginTime = dict["BeginTime"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeResourceTimelineResponseBody : Tea.TeaModel {
    public class AvailableEvents : Tea.TeaModel {
        public var name: String?

        public var occurrenceTime: String?

        public var reason: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OccurrenceTime") && dict["OccurrenceTime"] != nil {
                self.occurrenceTime = dict["OccurrenceTime"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class BizEvents : Tea.TeaModel {
        public var name: String?

        public var occurrenceTime: String?

        public var reason: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OccurrenceTime") && dict["OccurrenceTime"] != nil {
                self.occurrenceTime = dict["OccurrenceTime"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class InventoryEvents : Tea.TeaModel {
        public var name: String?

        public var occurrenceTime: String?

        public var reason: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OccurrenceTime") && dict["OccurrenceTime"] != nil {
                self.occurrenceTime = dict["OccurrenceTime"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ReserveEvents : Tea.TeaModel {
        public var name: String?

        public var occurrenceTime: String?

        public var reason: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OccurrenceTime") && dict["OccurrenceTime"] != nil {
                self.occurrenceTime = dict["OccurrenceTime"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var availableEvents: [DescribeResourceTimelineResponseBody.AvailableEvents]?

    public var bizEvents: [DescribeResourceTimelineResponseBody.BizEvents]?

    public var desc: String?

    public var inventoryEvents: [DescribeResourceTimelineResponseBody.InventoryEvents]?

    public var msg: String?

    public var requestId: String?

    public var reserveEvents: [DescribeResourceTimelineResponseBody.ReserveEvents]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableEvents != nil {
            var tmp : [Any] = []
            for k in self.availableEvents! {
                tmp.append(k.toMap())
            }
            map["AvailableEvents"] = tmp
        }
        if self.bizEvents != nil {
            var tmp : [Any] = []
            for k in self.bizEvents! {
                tmp.append(k.toMap())
            }
            map["BizEvents"] = tmp
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.inventoryEvents != nil {
            var tmp : [Any] = []
            for k in self.inventoryEvents! {
                tmp.append(k.toMap())
            }
            map["InventoryEvents"] = tmp
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reserveEvents != nil {
            var tmp : [Any] = []
            for k in self.reserveEvents! {
                tmp.append(k.toMap())
            }
            map["ReserveEvents"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableEvents") && dict["AvailableEvents"] != nil {
            var tmp : [DescribeResourceTimelineResponseBody.AvailableEvents] = []
            for v in dict["AvailableEvents"] as! [Any] {
                var model = DescribeResourceTimelineResponseBody.AvailableEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.availableEvents = tmp
        }
        if dict.keys.contains("BizEvents") && dict["BizEvents"] != nil {
            var tmp : [DescribeResourceTimelineResponseBody.BizEvents] = []
            for v in dict["BizEvents"] as! [Any] {
                var model = DescribeResourceTimelineResponseBody.BizEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bizEvents = tmp
        }
        if dict.keys.contains("Desc") && dict["Desc"] != nil {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("InventoryEvents") && dict["InventoryEvents"] != nil {
            var tmp : [DescribeResourceTimelineResponseBody.InventoryEvents] = []
            for v in dict["InventoryEvents"] as! [Any] {
                var model = DescribeResourceTimelineResponseBody.InventoryEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inventoryEvents = tmp
        }
        if dict.keys.contains("Msg") && dict["Msg"] != nil {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReserveEvents") && dict["ReserveEvents"] != nil {
            var tmp : [DescribeResourceTimelineResponseBody.ReserveEvents] = []
            for v in dict["ReserveEvents"] as! [Any] {
                var model = DescribeResourceTimelineResponseBody.ReserveEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reserveEvents = tmp
        }
    }
}

public class DescribeResourceTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeResourceTimelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityGroupAttributeRequest : Tea.TeaModel {
    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class DescribeSecurityGroupAttributeResponseBody : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public class Permission : Tea.TeaModel {
            public var creationTime: String?

            public var description_: String?

            public var destCidrIp: String?

            public var direction: String?

            public var ipProtocol: String?

            public var policy: String?

            public var portRange: String?

            public var priority: Int32?

            public var sourceCidrIp: String?

            public var sourcePortRange: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.destCidrIp != nil {
                    map["DestCidrIp"] = self.destCidrIp!
                }
                if self.direction != nil {
                    map["Direction"] = self.direction!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.sourceCidrIp != nil {
                    map["SourceCidrIp"] = self.sourceCidrIp!
                }
                if self.sourcePortRange != nil {
                    map["SourcePortRange"] = self.sourcePortRange!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DestCidrIp") && dict["DestCidrIp"] != nil {
                    self.destCidrIp = dict["DestCidrIp"] as! String
                }
                if dict.keys.contains("Direction") && dict["Direction"] != nil {
                    self.direction = dict["Direction"] as! String
                }
                if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
                    self.ipProtocol = dict["IpProtocol"] as! String
                }
                if dict.keys.contains("Policy") && dict["Policy"] != nil {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
                    self.portRange = dict["PortRange"] as! String
                }
                if dict.keys.contains("Priority") && dict["Priority"] != nil {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("SourceCidrIp") && dict["SourceCidrIp"] != nil {
                    self.sourceCidrIp = dict["SourceCidrIp"] as! String
                }
                if dict.keys.contains("SourcePortRange") && dict["SourcePortRange"] != nil {
                    self.sourcePortRange = dict["SourcePortRange"] as! String
                }
            }
        }
        public var permission: [DescribeSecurityGroupAttributeResponseBody.Permissions.Permission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.permission != nil {
                var tmp : [Any] = []
                for k in self.permission! {
                    tmp.append(k.toMap())
                }
                map["Permission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Permission") && dict["Permission"] != nil {
                var tmp : [DescribeSecurityGroupAttributeResponseBody.Permissions.Permission] = []
                for v in dict["Permission"] as! [Any] {
                    var model = DescribeSecurityGroupAttributeResponseBody.Permissions.Permission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.permission = tmp
            }
        }
    }
    public var description_: String?

    public var permissions: DescribeSecurityGroupAttributeResponseBody.Permissions?

    public var requestId: String?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.permissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.permissions != nil {
            map["Permissions"] = self.permissions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Permissions") && dict["Permissions"] != nil {
            var model = DescribeSecurityGroupAttributeResponseBody.Permissions()
            model.fromMap(dict["Permissions"] as! [String: Any])
            self.permissions = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class DescribeSecurityGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSecurityGroupAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityGroupsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeSecurityGroupsResponseBody : Tea.TeaModel {
    public class SecurityGroups : Tea.TeaModel {
        public class SecurityGroup : Tea.TeaModel {
            public var creationTime: String?

            public var description_: String?

            public var instanceCount: Int32?

            public var securityGroupId: String?

            public var securityGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.securityGroupName != nil {
                    map["SecurityGroupName"] = self.securityGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                    self.instanceCount = dict["InstanceCount"] as! Int32
                }
                if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
                    self.securityGroupName = dict["SecurityGroupName"] as! String
                }
            }
        }
        public var securityGroup: [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroup != nil {
                var tmp : [Any] = []
                for k in self.securityGroup! {
                    tmp.append(k.toMap())
                }
                map["SecurityGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroup") && dict["SecurityGroup"] != nil {
                var tmp : [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup] = []
                for v in dict["SecurityGroup"] as! [Any] {
                    var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityGroup = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var securityGroups: DescribeSecurityGroupsResponseBody.SecurityGroups?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroups != nil {
            map["SecurityGroups"] = self.securityGroups?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroups") && dict["SecurityGroups"] != nil {
            var model = DescribeSecurityGroupsResponseBody.SecurityGroups()
            model.fromMap(dict["SecurityGroups"] as! [String: Any])
            self.securityGroups = model
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSecurityGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSecurityGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSelfImagesRequest : Tea.TeaModel {
    public var imageId: String?

    public var imageName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class DescribeSelfImagesResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var architecture: String?

            public var computeType: String?

            public var creationTime: String?

            public var imageId: String?

            public var imageName: String?

            public var imageOwnerAlias: String?

            public var imageSize: String?

            public var instanceId: String?

            public var osVersion: String?

            public var platform: String?

            public var snapshotId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architecture != nil {
                    map["Architecture"] = self.architecture!
                }
                if self.computeType != nil {
                    map["ComputeType"] = self.computeType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageOwnerAlias != nil {
                    map["ImageOwnerAlias"] = self.imageOwnerAlias!
                }
                if self.imageSize != nil {
                    map["ImageSize"] = self.imageSize!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.osVersion != nil {
                    map["OsVersion"] = self.osVersion!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Architecture") && dict["Architecture"] != nil {
                    self.architecture = dict["Architecture"] as! String
                }
                if dict.keys.contains("ComputeType") && dict["ComputeType"] != nil {
                    self.computeType = dict["ComputeType"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImageOwnerAlias") && dict["ImageOwnerAlias"] != nil {
                    self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
                }
                if dict.keys.contains("ImageSize") && dict["ImageSize"] != nil {
                    self.imageSize = dict["ImageSize"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("OsVersion") && dict["OsVersion"] != nil {
                    self.osVersion = dict["OsVersion"] as! String
                }
                if dict.keys.contains("Platform") && dict["Platform"] != nil {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var image: [DescribeSelfImagesResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") && dict["Image"] != nil {
                var tmp : [DescribeSelfImagesResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeSelfImagesResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeSelfImagesResponseBody.Images?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") && dict["Images"] != nil {
            var model = DescribeSelfImagesResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSelfImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSelfImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSelfImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServcieScheduleRequest : Tea.TeaModel {
    public var appId: String?

    public var podConfigName: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.podConfigName != nil {
            map["PodConfigName"] = self.podConfigName!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("PodConfigName") && dict["PodConfigName"] != nil {
            self.podConfigName = dict["PodConfigName"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeServcieScheduleResponseBody : Tea.TeaModel {
    public class PodAbstractInfo : Tea.TeaModel {
        public class ContainerStatuses : Tea.TeaModel {
            public class ContainerStatus : Tea.TeaModel {
                public var containerId: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.containerId != nil {
                        map["ContainerId"] = self.containerId!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                        self.containerId = dict["ContainerId"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var containerStatus: [DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses.ContainerStatus]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.containerStatus != nil {
                    var tmp : [Any] = []
                    for k in self.containerStatus! {
                        tmp.append(k.toMap())
                    }
                    map["ContainerStatus"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContainerStatus") && dict["ContainerStatus"] != nil {
                    var tmp : [DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses.ContainerStatus] = []
                    for v in dict["ContainerStatus"] as! [Any] {
                        var model = DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses.ContainerStatus()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.containerStatus = tmp
                }
            }
        }
        public var containerService: Bool?

        public var containerStatuses: DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses?

        public var name: Bool?

        public var namespace: Bool?

        public var resourceScope: Bool?

        public var status: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.containerStatuses?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.containerService != nil {
                map["ContainerService"] = self.containerService!
            }
            if self.containerStatuses != nil {
                map["ContainerStatuses"] = self.containerStatuses?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.resourceScope != nil {
                map["ResourceScope"] = self.resourceScope!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContainerService") && dict["ContainerService"] != nil {
                self.containerService = dict["ContainerService"] as! Bool
            }
            if dict.keys.contains("ContainerStatuses") && dict["ContainerStatuses"] != nil {
                var model = DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses()
                model.fromMap(dict["ContainerStatuses"] as! [String: Any])
                self.containerStatuses = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! Bool
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! Bool
            }
            if dict.keys.contains("ResourceScope") && dict["ResourceScope"] != nil {
                self.resourceScope = dict["ResourceScope"] as! Bool
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Bool
            }
        }
    }
    public var index: Int32?

    public var instanceId: String?

    public var instanceIp: String?

    public var instancePort: Int32?

    public var podAbstractInfo: DescribeServcieScheduleResponseBody.PodAbstractInfo?

    public var requestId: String?

    public var requestRepeated: Bool?

    public var tcpPorts: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.podAbstractInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.index != nil {
            map["Index"] = self.index!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIp != nil {
            map["InstanceIp"] = self.instanceIp!
        }
        if self.instancePort != nil {
            map["InstancePort"] = self.instancePort!
        }
        if self.podAbstractInfo != nil {
            map["PodAbstractInfo"] = self.podAbstractInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestRepeated != nil {
            map["RequestRepeated"] = self.requestRepeated!
        }
        if self.tcpPorts != nil {
            map["TcpPorts"] = self.tcpPorts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Index") && dict["Index"] != nil {
            self.index = dict["Index"] as! Int32
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIp") && dict["InstanceIp"] != nil {
            self.instanceIp = dict["InstanceIp"] as! String
        }
        if dict.keys.contains("InstancePort") && dict["InstancePort"] != nil {
            self.instancePort = dict["InstancePort"] as! Int32
        }
        if dict.keys.contains("PodAbstractInfo") && dict["PodAbstractInfo"] != nil {
            var model = DescribeServcieScheduleResponseBody.PodAbstractInfo()
            model.fromMap(dict["PodAbstractInfo"] as! [String: Any])
            self.podAbstractInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestRepeated") && dict["RequestRepeated"] != nil {
            self.requestRepeated = dict["RequestRepeated"] as! Bool
        }
        if dict.keys.contains("TcpPorts") && dict["TcpPorts"] != nil {
            self.tcpPorts = dict["TcpPorts"] as! String
        }
    }
}

public class DescribeServcieScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServcieScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeServcieScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnatTableEntriesRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var snatEntryId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public var sourceCIDR: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.sourceCIDR != nil {
            map["SourceCIDR"] = self.sourceCIDR!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SnatEntryId") && dict["SnatEntryId"] != nil {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatEntryName") && dict["SnatEntryName"] != nil {
            self.snatEntryName = dict["SnatEntryName"] as! String
        }
        if dict.keys.contains("SnatIp") && dict["SnatIp"] != nil {
            self.snatIp = dict["SnatIp"] as! String
        }
        if dict.keys.contains("SourceCIDR") && dict["SourceCIDR"] != nil {
            self.sourceCIDR = dict["SourceCIDR"] as! String
        }
    }
}

public class DescribeSnatTableEntriesResponseBody : Tea.TeaModel {
    public class SnatTableEntries : Tea.TeaModel {
        public var natGatewayId: String?

        public var snatEntryId: String?

        public var snatEntryName: String?

        public var snatIp: String?

        public var sourceCIDR: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.snatEntryId != nil {
                map["SnatEntryId"] = self.snatEntryId!
            }
            if self.snatEntryName != nil {
                map["SnatEntryName"] = self.snatEntryName!
            }
            if self.snatIp != nil {
                map["SnatIp"] = self.snatIp!
            }
            if self.sourceCIDR != nil {
                map["SourceCIDR"] = self.sourceCIDR!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NatGatewayId") && dict["NatGatewayId"] != nil {
                self.natGatewayId = dict["NatGatewayId"] as! String
            }
            if dict.keys.contains("SnatEntryId") && dict["SnatEntryId"] != nil {
                self.snatEntryId = dict["SnatEntryId"] as! String
            }
            if dict.keys.contains("SnatEntryName") && dict["SnatEntryName"] != nil {
                self.snatEntryName = dict["SnatEntryName"] as! String
            }
            if dict.keys.contains("SnatIp") && dict["SnatIp"] != nil {
                self.snatIp = dict["SnatIp"] as! String
            }
            if dict.keys.contains("SourceCIDR") && dict["SourceCIDR"] != nil {
                self.sourceCIDR = dict["SourceCIDR"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snatTableEntries: [DescribeSnatTableEntriesResponseBody.SnatTableEntries]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatTableEntries != nil {
            var tmp : [Any] = []
            for k in self.snatTableEntries! {
                tmp.append(k.toMap())
            }
            map["SnatTableEntries"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnatTableEntries") && dict["SnatTableEntries"] != nil {
            var tmp : [DescribeSnatTableEntriesResponseBody.SnatTableEntries] = []
            for v in dict["SnatTableEntries"] as! [Any] {
                var model = DescribeSnatTableEntriesResponseBody.SnatTableEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.snatTableEntries = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSnatTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnatTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSnatTableEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserBandWidthDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var ensRegionId: String?

    public var instanceId: String?

    public var isp: String?

    public var period: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Isp") && dict["Isp"] != nil {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeUserBandWidthDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class BandWidthMonitorData : Tea.TeaModel {
            public var downBandWidth: Int64?

            public var internetRX: Int64?

            public var internetTX: Int64?

            public var timeStamp: String?

            public var upBandWidth: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downBandWidth != nil {
                    map["DownBandWidth"] = self.downBandWidth!
                }
                if self.internetRX != nil {
                    map["InternetRX"] = self.internetRX!
                }
                if self.internetTX != nil {
                    map["InternetTX"] = self.internetTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.upBandWidth != nil {
                    map["UpBandWidth"] = self.upBandWidth!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DownBandWidth") && dict["DownBandWidth"] != nil {
                    self.downBandWidth = dict["DownBandWidth"] as! Int64
                }
                if dict.keys.contains("InternetRX") && dict["InternetRX"] != nil {
                    self.internetRX = dict["InternetRX"] as! Int64
                }
                if dict.keys.contains("InternetTX") && dict["InternetTX"] != nil {
                    self.internetTX = dict["InternetTX"] as! Int64
                }
                if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("UpBandWidth") && dict["UpBandWidth"] != nil {
                    self.upBandWidth = dict["UpBandWidth"] as! Int64
                }
            }
        }
        public var bandWidthMonitorData: [DescribeUserBandWidthDataResponseBody.MonitorData.BandWidthMonitorData]?

        public var maxDownBandWidth: String?

        public var maxUpBandWidth: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandWidthMonitorData != nil {
                var tmp : [Any] = []
                for k in self.bandWidthMonitorData! {
                    tmp.append(k.toMap())
                }
                map["BandWidthMonitorData"] = tmp
            }
            if self.maxDownBandWidth != nil {
                map["MaxDownBandWidth"] = self.maxDownBandWidth!
            }
            if self.maxUpBandWidth != nil {
                map["MaxUpBandWidth"] = self.maxUpBandWidth!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BandWidthMonitorData") && dict["BandWidthMonitorData"] != nil {
                var tmp : [DescribeUserBandWidthDataResponseBody.MonitorData.BandWidthMonitorData] = []
                for v in dict["BandWidthMonitorData"] as! [Any] {
                    var model = DescribeUserBandWidthDataResponseBody.MonitorData.BandWidthMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bandWidthMonitorData = tmp
            }
            if dict.keys.contains("MaxDownBandWidth") && dict["MaxDownBandWidth"] != nil {
                self.maxDownBandWidth = dict["MaxDownBandWidth"] as! String
            }
            if dict.keys.contains("MaxUpBandWidth") && dict["MaxUpBandWidth"] != nil {
                self.maxUpBandWidth = dict["MaxUpBandWidth"] as! String
            }
        }
    }
    public var code: Int32?

    public var monitorData: DescribeUserBandWidthDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("MonitorData") && dict["MonitorData"] != nil {
            var model = DescribeUserBandWidthDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUserBandWidthDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserBandWidthDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUserBandWidthDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVSwitchesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var networkId: String?

    public var orderByParams: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("OrderByParams") && dict["OrderByParams"] != nil {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchName") && dict["VSwitchName"] != nil {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class DescribeVSwitchesResponseBody : Tea.TeaModel {
    public class VSwitches : Tea.TeaModel {
        public class VSwitch : Tea.TeaModel {
            public var cidrBlock: String?

            public var createdTime: String?

            public var description_: String?

            public var ensRegionId: String?

            public var freeIpCount: Int64?

            public var networkId: String?

            public var status: String?

            public var vSwitchId: String?

            public var vSwitchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.freeIpCount != nil {
                    map["FreeIpCount"] = self.freeIpCount!
                }
                if self.networkId != nil {
                    map["NetworkId"] = self.networkId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vSwitchName != nil {
                    map["VSwitchName"] = self.vSwitchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("FreeIpCount") && dict["FreeIpCount"] != nil {
                    self.freeIpCount = dict["FreeIpCount"] as! Int64
                }
                if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
                    self.networkId = dict["NetworkId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VSwitchName") && dict["VSwitchName"] != nil {
                    self.vSwitchName = dict["VSwitchName"] as! String
                }
            }
        }
        public var vSwitch: [DescribeVSwitchesResponseBody.VSwitches.VSwitch]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitch != nil {
                var tmp : [Any] = []
                for k in self.vSwitch! {
                    tmp.append(k.toMap())
                }
                map["VSwitch"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VSwitch") && dict["VSwitch"] != nil {
                var tmp : [DescribeVSwitchesResponseBody.VSwitches.VSwitch] = []
                for v in dict["VSwitch"] as! [Any] {
                    var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vSwitch = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vSwitches: DescribeVSwitchesResponseBody.VSwitches?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vSwitches?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vSwitches != nil {
            map["VSwitches"] = self.vSwitches?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VSwitches") && dict["VSwitches"] != nil {
            var model = DescribeVSwitchesResponseBody.VSwitches()
            model.fromMap(dict["VSwitches"] as! [String: Any])
            self.vSwitches = model
        }
    }
}

public class DescribeVSwitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVSwitchesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DetachDiskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DistApplicationDataRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var distStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.distStrategy != nil {
            map["DistStrategy"] = self.distStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DistStrategy") && dict["DistStrategy"] != nil {
            self.distStrategy = dict["DistStrategy"] as! String
        }
    }
}

public class DistApplicationDataResponseBody : Tea.TeaModel {
    public class DistInstanceIds : Tea.TeaModel {
        public var distInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.distInstanceId != nil {
                map["DistInstanceId"] = self.distInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DistInstanceId") && dict["DistInstanceId"] != nil {
                self.distInstanceId = dict["DistInstanceId"] as! [String]
            }
        }
    }
    public class DistResults : Tea.TeaModel {
        public class DistResult : Tea.TeaModel {
            public var name: String?

            public var resultCode: Int32?

            public var resultDescrip: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.resultCode != nil {
                    map["ResultCode"] = self.resultCode!
                }
                if self.resultDescrip != nil {
                    map["ResultDescrip"] = self.resultDescrip!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
                    self.resultCode = dict["ResultCode"] as! Int32
                }
                if dict.keys.contains("ResultDescrip") && dict["ResultDescrip"] != nil {
                    self.resultDescrip = dict["ResultDescrip"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var distResult: [DistApplicationDataResponseBody.DistResults.DistResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.distResult != nil {
                var tmp : [Any] = []
                for k in self.distResult! {
                    tmp.append(k.toMap())
                }
                map["DistResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DistResult") && dict["DistResult"] != nil {
                var tmp : [DistApplicationDataResponseBody.DistResults.DistResult] = []
                for v in dict["DistResult"] as! [Any] {
                    var model = DistApplicationDataResponseBody.DistResults.DistResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.distResult = tmp
            }
        }
    }
    public var distInstanceIds: DistApplicationDataResponseBody.DistInstanceIds?

    public var distInstanceTotalCount: Int32?

    public var distResults: DistApplicationDataResponseBody.DistResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.distInstanceIds?.validate()
        try self.distResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.distInstanceIds != nil {
            map["DistInstanceIds"] = self.distInstanceIds?.toMap()
        }
        if self.distInstanceTotalCount != nil {
            map["DistInstanceTotalCount"] = self.distInstanceTotalCount!
        }
        if self.distResults != nil {
            map["DistResults"] = self.distResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DistInstanceIds") && dict["DistInstanceIds"] != nil {
            var model = DistApplicationDataResponseBody.DistInstanceIds()
            model.fromMap(dict["DistInstanceIds"] as! [String: Any])
            self.distInstanceIds = model
        }
        if dict.keys.contains("DistInstanceTotalCount") && dict["DistInstanceTotalCount"] != nil {
            self.distInstanceTotalCount = dict["DistInstanceTotalCount"] as! Int32
        }
        if dict.keys.contains("DistResults") && dict["DistResults"] != nil {
            var model = DistApplicationDataResponseBody.DistResults()
            model.fromMap(dict["DistResults"] as! [String: Any])
            self.distResults = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DistApplicationDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DistApplicationDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DistApplicationDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportBillDetailDataRequest : Tea.TeaModel {
    public var endDate: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class ExportBillDetailDataResponseBody : Tea.TeaModel {
    public var filePath: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportBillDetailDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportBillDetailDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportBillDetailDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportImageRequest : Tea.TeaModel {
    public var imageId: String?

    public var OSSBucket: String?

    public var OSSPrefix: String?

    public var OSSRegionId: String?

    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.OSSBucket != nil {
            map["OSSBucket"] = self.OSSBucket!
        }
        if self.OSSPrefix != nil {
            map["OSSPrefix"] = self.OSSPrefix!
        }
        if self.OSSRegionId != nil {
            map["OSSRegionId"] = self.OSSRegionId!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OSSBucket") && dict["OSSBucket"] != nil {
            self.OSSBucket = dict["OSSBucket"] as! String
        }
        if dict.keys.contains("OSSPrefix") && dict["OSSPrefix"] != nil {
            self.OSSPrefix = dict["OSSPrefix"] as! String
        }
        if dict.keys.contains("OSSRegionId") && dict["OSSRegionId"] != nil {
            self.OSSRegionId = dict["OSSRegionId"] as! String
        }
        if dict.keys.contains("RoleName") && dict["RoleName"] != nil {
            self.roleName = dict["RoleName"] as! String
        }
    }
}

public class ExportImageResponseBody : Tea.TeaModel {
    public var exportedImageURL: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportedImageURL != nil {
            map["ExportedImageURL"] = self.exportedImageURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportedImageURL") && dict["ExportedImageURL"] != nil {
            self.exportedImageURL = dict["ExportedImageURL"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportMeasurementDataRequest : Tea.TeaModel {
    public var endDate: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") && dict["EndDate"] != nil {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("StartDate") && dict["StartDate"] != nil {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class ExportMeasurementDataResponseBody : Tea.TeaModel {
    public var filePath: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportMeasurementDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportMeasurementDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportMeasurementDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeviceInternetPortRequest : Tea.TeaModel {
    public var instanceId: String?

    public var natType: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.natType != nil {
            map["NatType"] = self.natType!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NatType") && dict["NatType"] != nil {
            self.natType = dict["NatType"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class GetDeviceInternetPortResponseBody : Tea.TeaModel {
    public class NetworkInfo : Tea.TeaModel {
        public var externalIp: String?

        public var externalPort: String?

        public var ISP: String?

        public var internalIp: String?

        public var internalPort: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.externalIp != nil {
                map["ExternalIp"] = self.externalIp!
            }
            if self.externalPort != nil {
                map["ExternalPort"] = self.externalPort!
            }
            if self.ISP != nil {
                map["ISP"] = self.ISP!
            }
            if self.internalIp != nil {
                map["InternalIp"] = self.internalIp!
            }
            if self.internalPort != nil {
                map["InternalPort"] = self.internalPort!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExternalIp") && dict["ExternalIp"] != nil {
                self.externalIp = dict["ExternalIp"] as! String
            }
            if dict.keys.contains("ExternalPort") && dict["ExternalPort"] != nil {
                self.externalPort = dict["ExternalPort"] as! String
            }
            if dict.keys.contains("ISP") && dict["ISP"] != nil {
                self.ISP = dict["ISP"] as! String
            }
            if dict.keys.contains("InternalIp") && dict["InternalIp"] != nil {
                self.internalIp = dict["InternalIp"] as! String
            }
            if dict.keys.contains("InternalPort") && dict["InternalPort"] != nil {
                self.internalPort = dict["InternalPort"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var instanceId: String?

    public var networkInfo: [GetDeviceInternetPortResponseBody.NetworkInfo]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInfo != nil {
            var tmp : [Any] = []
            for k in self.networkInfo! {
                tmp.append(k.toMap())
            }
            map["NetworkInfo"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NetworkInfo") && dict["NetworkInfo"] != nil {
            var tmp : [GetDeviceInternetPortResponseBody.NetworkInfo] = []
            for v in dict["NetworkInfo"] as! [Any] {
                var model = GetDeviceInternetPortResponseBody.NetworkInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkInfo = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDeviceInternetPortResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeviceInternetPortResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDeviceInternetPortResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOssStorageAndAccByBucketsRequest : Tea.TeaModel {
    public var bucketList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketList != nil {
            map["BucketList"] = self.bucketList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketList") && dict["BucketList"] != nil {
            self.bucketList = dict["BucketList"] as! String
        }
    }
}

public class GetOssStorageAndAccByBucketsResponseBody : Tea.TeaModel {
    public class BucketList : Tea.TeaModel {
        public var acc: Int64?

        public var bucket: String?

        public var storageUsageByte: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acc != nil {
                map["Acc"] = self.acc!
            }
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.storageUsageByte != nil {
                map["StorageUsageByte"] = self.storageUsageByte!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Acc") && dict["Acc"] != nil {
                self.acc = dict["Acc"] as! Int64
            }
            if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("StorageUsageByte") && dict["StorageUsageByte"] != nil {
                self.storageUsageByte = dict["StorageUsageByte"] as! Int64
            }
        }
    }
    public var bucketList: [GetOssStorageAndAccByBucketsResponseBody.BucketList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketList != nil {
            var tmp : [Any] = []
            for k in self.bucketList! {
                tmp.append(k.toMap())
            }
            map["BucketList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketList") && dict["BucketList"] != nil {
            var tmp : [GetOssStorageAndAccByBucketsResponseBody.BucketList] = []
            for v in dict["BucketList"] as! [Any] {
                var model = GetOssStorageAndAccByBucketsResponseBody.BucketList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bucketList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetOssStorageAndAccByBucketsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOssStorageAndAccByBucketsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOssStorageAndAccByBucketsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOssUsageDataRequest : Tea.TeaModel {
    public var bucket: String?

    public var endTime: String?

    public var period: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") && dict["Bucket"] != nil {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetOssUsageDataResponseBody : Tea.TeaModel {
    public class UsageList : Tea.TeaModel {
        public var lanRxBw: Int64?

        public var lanTxBw: Int64?

        public var point: Int64?

        public var pointTs: String?

        public var storageUsageByte: Int64?

        public var wanRxBw: Int64?

        public var wanTxBw: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lanRxBw != nil {
                map["LanRxBw"] = self.lanRxBw!
            }
            if self.lanTxBw != nil {
                map["LanTxBw"] = self.lanTxBw!
            }
            if self.point != nil {
                map["Point"] = self.point!
            }
            if self.pointTs != nil {
                map["PointTs"] = self.pointTs!
            }
            if self.storageUsageByte != nil {
                map["StorageUsageByte"] = self.storageUsageByte!
            }
            if self.wanRxBw != nil {
                map["WanRxBw"] = self.wanRxBw!
            }
            if self.wanTxBw != nil {
                map["WanTxBw"] = self.wanTxBw!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LanRxBw") && dict["LanRxBw"] != nil {
                self.lanRxBw = dict["LanRxBw"] as! Int64
            }
            if dict.keys.contains("LanTxBw") && dict["LanTxBw"] != nil {
                self.lanTxBw = dict["LanTxBw"] as! Int64
            }
            if dict.keys.contains("Point") && dict["Point"] != nil {
                self.point = dict["Point"] as! Int64
            }
            if dict.keys.contains("PointTs") && dict["PointTs"] != nil {
                self.pointTs = dict["PointTs"] as! String
            }
            if dict.keys.contains("StorageUsageByte") && dict["StorageUsageByte"] != nil {
                self.storageUsageByte = dict["StorageUsageByte"] as! Int64
            }
            if dict.keys.contains("WanRxBw") && dict["WanRxBw"] != nil {
                self.wanRxBw = dict["WanRxBw"] as! Int64
            }
            if dict.keys.contains("WanTxBw") && dict["WanTxBw"] != nil {
                self.wanTxBw = dict["WanTxBw"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var usageList: [GetOssUsageDataResponseBody.UsageList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.usageList != nil {
            var tmp : [Any] = []
            for k in self.usageList! {
                tmp.append(k.toMap())
            }
            map["UsageList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UsageList") && dict["UsageList"] != nil {
            var tmp : [GetOssUsageDataResponseBody.UsageList] = []
            for v in dict["UsageList"] as! [Any] {
                var model = GetOssUsageDataResponseBody.UsageList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.usageList = tmp
        }
    }
}

public class GetOssUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOssUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOssUsageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportKeyPairRequest : Tea.TeaModel {
    public var keyPairName: String?

    public var publicKeyBody: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.publicKeyBody != nil {
            map["PublicKeyBody"] = self.publicKeyBody!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("PublicKeyBody") && dict["PublicKeyBody"] != nil {
            self.publicKeyBody = dict["PublicKeyBody"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class ImportKeyPairResponseBody : Tea.TeaModel {
    public var keyPairFingerPrint: String?

    public var keyPairName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairFingerPrint") && dict["KeyPairFingerPrint"] != nil {
            self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportKeyPairResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinPublicIpsToEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var instanceInfos: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.instanceInfos != nil {
            map["InstanceInfos"] = self.instanceInfos!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("InstanceInfos") && dict["InstanceInfos"] != nil {
            self.instanceInfos = dict["InstanceInfos"] as! String
        }
    }
}

public class JoinPublicIpsToEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinPublicIpsToEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinPublicIpsToEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = JoinPublicIpsToEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinSecurityGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class JoinSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = JoinSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinVSwitchesToEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var vSwitchesInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.vSwitchesInfo != nil {
            map["VSwitchesInfo"] = self.vSwitchesInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("VSwitchesInfo") && dict["VSwitchesInfo"] != nil {
            self.vSwitchesInfo = dict["VSwitchesInfo"] as! String
        }
    }
}

public class JoinVSwitchesToEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinVSwitchesToEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinVSwitchesToEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = JoinVSwitchesToEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LeaveSecurityGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var securityGroupId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class LeaveSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class LeaveSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LeaveSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = LeaveSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationsRequest : Tea.TeaModel {
    public var appVersions: String?

    public var clusterNames: String?

    public var level: String?

    public var maxDate: String?

    public var minDate: String?

    public var outAppInfoParams: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appVersions != nil {
            map["AppVersions"] = self.appVersions!
        }
        if self.clusterNames != nil {
            map["ClusterNames"] = self.clusterNames!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.outAppInfoParams != nil {
            map["OutAppInfoParams"] = self.outAppInfoParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppVersions") && dict["AppVersions"] != nil {
            self.appVersions = dict["AppVersions"] as! String
        }
        if dict.keys.contains("ClusterNames") && dict["ClusterNames"] != nil {
            self.clusterNames = dict["ClusterNames"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MaxDate") && dict["MaxDate"] != nil {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") && dict["MinDate"] != nil {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("OutAppInfoParams") && dict["OutAppInfoParams"] != nil {
            self.outAppInfoParams = dict["OutAppInfoParams"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListApplicationsResponseBody : Tea.TeaModel {
    public class Applications : Tea.TeaModel {
        public class Application : Tea.TeaModel {
            public class AppList : Tea.TeaModel {
                public class App : Tea.TeaModel {
                    public var appId: String?

                    public var appInfo: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appId != nil {
                            map["AppId"] = self.appId!
                        }
                        if self.appInfo != nil {
                            map["AppInfo"] = self.appInfo!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AppId") && dict["AppId"] != nil {
                            self.appId = dict["AppId"] as! String
                        }
                        if dict.keys.contains("AppInfo") && dict["AppInfo"] != nil {
                            self.appInfo = dict["AppInfo"] as! String
                        }
                    }
                }
                public var app: [ListApplicationsResponseBody.Applications.Application.AppList.App]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.app != nil {
                        var tmp : [Any] = []
                        for k in self.app! {
                            tmp.append(k.toMap())
                        }
                        map["App"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("App") && dict["App"] != nil {
                        var tmp : [ListApplicationsResponseBody.Applications.Application.AppList.App] = []
                        for v in dict["App"] as! [Any] {
                            var model = ListApplicationsResponseBody.Applications.Application.AppList.App()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.app = tmp
                    }
                }
            }
            public var appList: ListApplicationsResponseBody.Applications.Application.AppList?

            public var clusterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.appList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appList != nil {
                    map["AppList"] = self.appList?.toMap()
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppList") && dict["AppList"] != nil {
                    var model = ListApplicationsResponseBody.Applications.Application.AppList()
                    model.fromMap(dict["AppList"] as! [String: Any])
                    self.appList = model
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
            }
        }
        public var application: [ListApplicationsResponseBody.Applications.Application]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.application != nil {
                var tmp : [Any] = []
                for k in self.application! {
                    tmp.append(k.toMap())
                }
                map["Application"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Application") && dict["Application"] != nil {
                var tmp : [ListApplicationsResponseBody.Applications.Application] = []
                for v in dict["Application"] as! [Any] {
                    var model = ListApplicationsResponseBody.Applications.Application()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.application = tmp
            }
        }
    }
    public var applications: ListApplicationsResponseBody.Applications?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applications?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            map["Applications"] = self.applications?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Applications") && dict["Applications"] != nil {
            var model = ListApplicationsResponseBody.Applications()
            model.fromMap(dict["Applications"] as! [String: Any])
            self.applications = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEnsEipAddressAttributeRequest : Tea.TeaModel {
    public var allocationId: String?

    public var bandwidth: Int32?

    public var description_: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") && dict["AllocationId"] != nil {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class ModifyEnsEipAddressAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEnsEipAddressAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEnsEipAddressAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyEnsEipAddressAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var EPNInstanceName: String?

    public var internetMaxBandwidthOut: Int32?

    public var networkingModel: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.EPNInstanceName != nil {
            map["EPNInstanceName"] = self.EPNInstanceName!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("EPNInstanceName") && dict["EPNInstanceName"] != nil {
            self.EPNInstanceName = dict["EPNInstanceName"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("NetworkingModel") && dict["NetworkingModel"] != nil {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
    }
}

public class ModifyEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyFileSystemRequest : Tea.TeaModel {
    public var description_: String?

    public var ensRegionId: String?

    public var fileSystemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") && dict["FileSystemId"] != nil {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
    }
}

public class ModifyFileSystemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyFileSystemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFileSystemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyFileSystemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyForwardEntryRequest : Tea.TeaModel {
    public var forwardEntryId: String?

    public var forwardEntryName: String?

    public var healthCheckPort: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.healthCheckPort != nil {
            map["HealthCheckPort"] = self.healthCheckPort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardEntryId") && dict["ForwardEntryId"] != nil {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardEntryName") && dict["ForwardEntryName"] != nil {
            self.forwardEntryName = dict["ForwardEntryName"] as! String
        }
        if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
            self.healthCheckPort = dict["HealthCheckPort"] as! Int32
        }
    }
}

public class ModifyForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageAttributeRequest : Tea.TeaModel {
    public var imageId: String?

    public var imageName: String?

    public var version: String?

    public var product: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        if self.product != nil {
            map["product"] = self.product!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
        if dict.keys.contains("product") && dict["product"] != nil {
            self.product = dict["product"] as! String
        }
    }
}

public class ModifyImageAttributeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyImageAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageSharePermissionRequest : Tea.TeaModel {
    public var addAccounts: String?

    public var imageId: String?

    public var removeAccounts: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addAccounts != nil {
            map["AddAccounts"] = self.addAccounts!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.removeAccounts != nil {
            map["RemoveAccounts"] = self.removeAccounts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddAccounts") && dict["AddAccounts"] != nil {
            self.addAccounts = dict["AddAccounts"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RemoveAccounts") && dict["RemoveAccounts"] != nil {
            self.removeAccounts = dict["RemoveAccounts"] as! String
        }
    }
}

public class ModifyImageSharePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageSharePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageSharePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyImageSharePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAttributeRequest : Tea.TeaModel {
    public var hostName: String?

    public var instanceId: String?

    public var instanceName: String?

    public var password: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var autoRenew: String?

    public var duration: String?

    public var instanceIds: String?

    public var ownerId: String?

    public var renewalStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! String
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RenewalStatus") && dict["RenewalStatus"] != nil {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
    }
}

public class ModifyInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInstanceAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLoadBalancerAttributeRequest : Tea.TeaModel {
    public var loadBalancerId: String?

    public var loadBalancerName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") && dict["LoadBalancerName"] != nil {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
    }
}

public class ModifyLoadBalancerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLoadBalancerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLoadBalancerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyLoadBalancerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNetworkAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var networkId: String?

    public var networkName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NetworkId") && dict["NetworkId"] != nil {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("NetworkName") && dict["NetworkName"] != nil {
            self.networkName = dict["NetworkName"] as! String
        }
    }
}

public class ModifyNetworkAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNetworkAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNetworkAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyNetworkAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPrepayInstanceSpecRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
    }
}

public class ModifyPrepayInstanceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPrepayInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPrepayInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyPrepayInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySecurityGroupAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class ModifySecurityGroupAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySecurityGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySecurityGroupAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVSwitchAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchName") && dict["VSwitchName"] != nil {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
    }
}

public class ModifyVSwitchAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVSwitchAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVSwitchAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyVSwitchAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushApplicationDataRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var pushStrategy: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.pushStrategy != nil {
            map["PushStrategy"] = self.pushStrategy!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("PushStrategy") && dict["PushStrategy"] != nil {
            self.pushStrategy = dict["PushStrategy"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class PushApplicationDataResponseBody : Tea.TeaModel {
    public class PushResults : Tea.TeaModel {
        public class PushResult : Tea.TeaModel {
            public var name: String?

            public var resultCode: Int32?

            public var resultDescrip: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.resultCode != nil {
                    map["ResultCode"] = self.resultCode!
                }
                if self.resultDescrip != nil {
                    map["ResultDescrip"] = self.resultDescrip!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
                    self.resultCode = dict["ResultCode"] as! Int32
                }
                if dict.keys.contains("ResultDescrip") && dict["ResultDescrip"] != nil {
                    self.resultDescrip = dict["ResultDescrip"] as! String
                }
                if dict.keys.contains("Version") && dict["Version"] != nil {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var pushResult: [PushApplicationDataResponseBody.PushResults.PushResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pushResult != nil {
                var tmp : [Any] = []
                for k in self.pushResult! {
                    tmp.append(k.toMap())
                }
                map["PushResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PushResult") && dict["PushResult"] != nil {
                var tmp : [PushApplicationDataResponseBody.PushResults.PushResult] = []
                for v in dict["PushResult"] as! [Any] {
                    var model = PushApplicationDataResponseBody.PushResults.PushResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pushResult = tmp
            }
        }
    }
    public var pushResults: PushApplicationDataResponseBody.PushResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResults != nil {
            map["PushResults"] = self.pushResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResults") && dict["PushResults"] != nil {
            var model = PushApplicationDataResponseBody.PushResults()
            model.fromMap(dict["PushResults"] as! [String: Any])
            self.pushResults = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PushApplicationDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushApplicationDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PushApplicationDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReInitDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var imageId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class ReInitDiskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReInitDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReInitDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReInitDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootAICInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class RebootAICInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootAICInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootAICInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RebootAICInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootARMServerInstanceRequest : Tea.TeaModel {
    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class RebootARMServerInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootARMServerInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootARMServerInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RebootARMServerInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootInstanceRequest : Tea.TeaModel {
    public var forceStop: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceStop") && dict["ForceStop"] != nil {
            self.forceStop = dict["ForceStop"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class RebootInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RebootInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootInstancesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class RebootInstancesShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class RebootInstancesResponseBody : Tea.TeaModel {
    public var instanceResponses: [InstanceOperateResponse]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            var tmp : [Any] = []
            for k in self.instanceResponses! {
                tmp.append(k.toMap())
            }
            map["InstanceResponses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") && dict["InstanceResponses"] != nil {
            var tmp : [InstanceOperateResponse] = []
            for v in dict["InstanceResponses"] as! [Any] {
                var model = InstanceOperateResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceResponses = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RebootInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecoverAICInstanceRequest : Tea.TeaModel {
    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class RecoverAICInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RecoverAICInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverAICInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RecoverAICInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReinitInstanceRequest : Tea.TeaModel {
    public var imageId: String?

    public var instanceId: String?

    public var password: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
    }
}

public class ReinitInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReinitInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReinitInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReinitInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReinitInstancesRequest : Tea.TeaModel {
    public var imageId: String?

    public var instanceIds: [String]?

    public var password: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
    }
}

public class ReinitInstancesShrinkRequest : Tea.TeaModel {
    public var imageId: String?

    public var instanceIdsShrink: String?

    public var password: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
    }
}

public class ReinitInstancesResponseBody : Tea.TeaModel {
    public var instanceResponses: [InstanceOperateResponse]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            var tmp : [Any] = []
            for k in self.instanceResponses! {
                tmp.append(k.toMap())
            }
            map["InstanceResponses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") && dict["InstanceResponses"] != nil {
            var tmp : [InstanceOperateResponse] = []
            for v in dict["InstanceResponses"] as! [Any] {
                var model = InstanceOperateResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceResponses = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReinitInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReinitInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReinitInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseAICInstanceRequest : Tea.TeaModel {
    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class ReleaseAICInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseAICInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseAICInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReleaseAICInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseARMServerInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReleaseARMServerInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseARMServerInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseARMServerInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReleaseARMServerInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReleaseInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReleaseInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleasePostPaidInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReleasePostPaidInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleasePostPaidInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleasePostPaidInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReleasePostPaidInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleasePrePaidInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReleasePrePaidInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleasePrePaidInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleasePrePaidInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReleasePrePaidInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveBackendServersRequest : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public var ip: String?

        public var port: Int32?

        public var serverId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var backendServers: [RemoveBackendServersRequest.BackendServers]?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            var tmp : [Any] = []
            for k in self.backendServers! {
                tmp.append(k.toMap())
            }
            map["BackendServers"] = tmp
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            var tmp : [RemoveBackendServersRequest.BackendServers] = []
            for v in dict["BackendServers"] as! [Any] {
                var model = RemoveBackendServersRequest.BackendServers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendServers = tmp
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class RemoveBackendServersShrinkRequest : Tea.TeaModel {
    public var backendServersShrink: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServersShrink != nil {
            map["BackendServers"] = self.backendServersShrink!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            self.backendServersShrink = dict["BackendServers"] as! String
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class RemoveBackendServersResponseBody : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public class BackendServer : Tea.TeaModel {
            public var ip: String?

            public var port: Int32?

            public var serverId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
                    self.serverId = dict["ServerId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var backendServer: [RemoveBackendServersResponseBody.BackendServers.BackendServer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendServer != nil {
                var tmp : [Any] = []
                for k in self.backendServer! {
                    tmp.append(k.toMap())
                }
                map["BackendServer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendServer") && dict["BackendServer"] != nil {
                var tmp : [RemoveBackendServersResponseBody.BackendServers.BackendServer] = []
                for v in dict["BackendServer"] as! [Any] {
                    var model = RemoveBackendServersResponseBody.BackendServers.BackendServer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backendServer = tmp
            }
        }
    }
    public var backendServers: RemoveBackendServersResponseBody.BackendServers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            map["BackendServers"] = self.backendServers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            var model = RemoveBackendServersResponseBody.BackendServers()
            model.fromMap(dict["BackendServers"] as! [String: Any])
            self.backendServers = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveBackendServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveBackendServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveBackendServersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePublicIpsFromEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var instanceInfos: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.instanceInfos != nil {
            map["InstanceInfos"] = self.instanceInfos!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("InstanceInfos") && dict["InstanceInfos"] != nil {
            self.instanceInfos = dict["InstanceInfos"] as! String
        }
    }
}

public class RemovePublicIpsFromEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePublicIpsFromEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePublicIpsFromEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemovePublicIpsFromEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveVSwitchesFromEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var vSwitchesInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.vSwitchesInfo != nil {
            map["VSwitchesInfo"] = self.vSwitchesInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("VSwitchesInfo") && dict["VSwitchesInfo"] != nil {
            self.vSwitchesInfo = dict["VSwitchesInfo"] as! String
        }
    }
}

public class RemoveVSwitchesFromEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveVSwitchesFromEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveVSwitchesFromEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveVSwitchesFromEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewARMServerInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var period: Int32?

    public var periodUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
    }
}

public class RenewARMServerInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewARMServerInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewARMServerInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RenewARMServerInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var period: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int64
        }
    }
}

public class RenewInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RenewInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RescaleApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var rescaleLevel: String?

    public var rescaleType: String?

    public var resourceSelector: String?

    public var timeout: Int32?

    public var toAppVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.rescaleLevel != nil {
            map["RescaleLevel"] = self.rescaleLevel!
        }
        if self.rescaleType != nil {
            map["RescaleType"] = self.rescaleType!
        }
        if self.resourceSelector != nil {
            map["ResourceSelector"] = self.resourceSelector!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.toAppVersion != nil {
            map["ToAppVersion"] = self.toAppVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("RescaleLevel") && dict["RescaleLevel"] != nil {
            self.rescaleLevel = dict["RescaleLevel"] as! String
        }
        if dict.keys.contains("RescaleType") && dict["RescaleType"] != nil {
            self.rescaleType = dict["RescaleType"] as! String
        }
        if dict.keys.contains("ResourceSelector") && dict["ResourceSelector"] != nil {
            self.resourceSelector = dict["ResourceSelector"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("ToAppVersion") && dict["ToAppVersion"] != nil {
            self.toAppVersion = dict["ToAppVersion"] as! String
        }
    }
}

public class RescaleApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RescaleApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RescaleApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RescaleApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RescaleDeviceServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var imageId: String?

    public var ipType: Int32?

    public var rescaleLevel: String?

    public var rescaleType: String?

    public var resourceInfo: String?

    public var resourceSelector: String?

    public var resourceSpec: String?

    public var serviceId: String?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.rescaleLevel != nil {
            map["RescaleLevel"] = self.rescaleLevel!
        }
        if self.rescaleType != nil {
            map["RescaleType"] = self.rescaleType!
        }
        if self.resourceInfo != nil {
            map["ResourceInfo"] = self.resourceInfo!
        }
        if self.resourceSelector != nil {
            map["ResourceSelector"] = self.resourceSelector!
        }
        if self.resourceSpec != nil {
            map["ResourceSpec"] = self.resourceSpec!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("IpType") && dict["IpType"] != nil {
            self.ipType = dict["IpType"] as! Int32
        }
        if dict.keys.contains("RescaleLevel") && dict["RescaleLevel"] != nil {
            self.rescaleLevel = dict["RescaleLevel"] as! String
        }
        if dict.keys.contains("RescaleType") && dict["RescaleType"] != nil {
            self.rescaleType = dict["RescaleType"] as! String
        }
        if dict.keys.contains("ResourceInfo") && dict["ResourceInfo"] != nil {
            self.resourceInfo = dict["ResourceInfo"] as! String
        }
        if dict.keys.contains("ResourceSelector") && dict["ResourceSelector"] != nil {
            self.resourceSelector = dict["ResourceSelector"] as! String
        }
        if dict.keys.contains("ResourceSpec") && dict["ResourceSpec"] != nil {
            self.resourceSpec = dict["ResourceSpec"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class RescaleDeviceServiceResponseBody : Tea.TeaModel {
    public class ResourceDetailInfos : Tea.TeaModel {
        public var ID: String?

        public var IP: String?

        public var ISP: String?

        public var mac: String?

        public var regionID: String?

        public var server: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ID != nil {
                map["ID"] = self.ID!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.ISP != nil {
                map["ISP"] = self.ISP!
            }
            if self.mac != nil {
                map["Mac"] = self.mac!
            }
            if self.regionID != nil {
                map["RegionID"] = self.regionID!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ID") && dict["ID"] != nil {
                self.ID = dict["ID"] as! String
            }
            if dict.keys.contains("IP") && dict["IP"] != nil {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("ISP") && dict["ISP"] != nil {
                self.ISP = dict["ISP"] as! String
            }
            if dict.keys.contains("Mac") && dict["Mac"] != nil {
                self.mac = dict["Mac"] as! String
            }
            if dict.keys.contains("RegionID") && dict["RegionID"] != nil {
                self.regionID = dict["RegionID"] as! String
            }
            if dict.keys.contains("Server") && dict["Server"] != nil {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var deviceIds: [String]?

    public var orderId: String?

    public var requestId: String?

    public var resourceDetailInfos: [RescaleDeviceServiceResponseBody.ResourceDetailInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceIds != nil {
            map["DeviceIds"] = self.deviceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceDetailInfos != nil {
            var tmp : [Any] = []
            for k in self.resourceDetailInfos! {
                tmp.append(k.toMap())
            }
            map["ResourceDetailInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceIds") && dict["DeviceIds"] != nil {
            self.deviceIds = dict["DeviceIds"] as! [String]
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceDetailInfos") && dict["ResourceDetailInfos"] != nil {
            var tmp : [RescaleDeviceServiceResponseBody.ResourceDetailInfos] = []
            for v in dict["ResourceDetailInfos"] as! [Any] {
                var model = RescaleDeviceServiceResponseBody.ResourceDetailInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceDetailInfos = tmp
        }
    }
}

public class RescaleDeviceServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RescaleDeviceServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RescaleDeviceServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAICInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class ResetAICInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetAICInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAICInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResetAICInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetDeviceInstanceRequest : Tea.TeaModel {
    public var appId: String?

    public var imageId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ResetDeviceInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetDeviceInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDeviceInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResetDeviceInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class ResetDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResetDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResizeDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var newSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.newSize != nil {
            map["NewSize"] = self.newSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("NewSize") && dict["NewSize"] != nil {
            self.newSize = dict["NewSize"] as! String
        }
    }
}

public class ResizeDiskResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResizeDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResizeDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResizeDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartDeviceInstanceRequest : Tea.TeaModel {
    public var appId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class RestartDeviceInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RestartDeviceInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartDeviceInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RestartDeviceInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeSecurityGroupRequest : Tea.TeaModel {
    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var securityGroupId: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") && dict["Priority"] != nil {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourceCidrIp") && dict["SourceCidrIp"] != nil {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") && dict["SourcePortRange"] != nil {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class RevokeSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RevokeSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeSecurityGroupEgressRequest : Tea.TeaModel {
    public var destCidrIp: String?

    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var securityGroupId: String?

    public var sourcePortRange: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestCidrIp") && dict["DestCidrIp"] != nil {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("IpProtocol") && dict["IpProtocol"] != nil {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") && dict["PortRange"] != nil {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") && dict["Priority"] != nil {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourcePortRange") && dict["SourcePortRange"] != nil {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class RevokeSecurityGroupEgressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeSecurityGroupEgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeSecurityGroupEgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RevokeSecurityGroupEgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var fromAppVersion: String?

    public var timeout: Int32?

    public var toAppVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.fromAppVersion != nil {
            map["FromAppVersion"] = self.fromAppVersion!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.toAppVersion != nil {
            map["ToAppVersion"] = self.toAppVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("FromAppVersion") && dict["FromAppVersion"] != nil {
            self.fromAppVersion = dict["FromAppVersion"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("ToAppVersion") && dict["ToAppVersion"] != nil {
            self.toAppVersion = dict["ToAppVersion"] as! String
        }
    }
}

public class RollbackApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RollbackApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RollbackApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunInstancesRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
        }
    }
    public var amount: Int64?

    public var autoRenew: Bool?

    public var carrier: String?

    public var dataDisk: [RunInstancesRequest.DataDisk]?

    public var ensRegionId: String?

    public var hostName: String?

    public var imageId: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int64?

    public var keyPairName: String?

    public var netDistrictCode: String?

    public var netWorkId: String?

    public var password: String?

    public var passwordInherit: Bool?

    public var period: Int64?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var publicIpIdentification: Bool?

    public var scheduleAreaLevel: String?

    public var schedulingPriceStrategy: String?

    public var schedulingStrategy: String?

    public var securityId: String?

    public var systemDisk: RunInstancesRequest.SystemDisk?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.carrier != nil {
            map["Carrier"] = self.carrier!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.netDistrictCode != nil {
            map["NetDistrictCode"] = self.netDistrictCode!
        }
        if self.netWorkId != nil {
            map["NetWorkId"] = self.netWorkId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.publicIpIdentification != nil {
            map["PublicIpIdentification"] = self.publicIpIdentification!
        }
        if self.scheduleAreaLevel != nil {
            map["ScheduleAreaLevel"] = self.scheduleAreaLevel!
        }
        if self.schedulingPriceStrategy != nil {
            map["SchedulingPriceStrategy"] = self.schedulingPriceStrategy!
        }
        if self.schedulingStrategy != nil {
            map["SchedulingStrategy"] = self.schedulingStrategy!
        }
        if self.securityId != nil {
            map["SecurityId"] = self.securityId!
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("Carrier") && dict["Carrier"] != nil {
            self.carrier = dict["Carrier"] as! String
        }
        if dict.keys.contains("DataDisk") && dict["DataDisk"] != nil {
            var tmp : [RunInstancesRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = RunInstancesRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int64
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("NetDistrictCode") && dict["NetDistrictCode"] != nil {
            self.netDistrictCode = dict["NetDistrictCode"] as! String
        }
        if dict.keys.contains("NetWorkId") && dict["NetWorkId"] != nil {
            self.netWorkId = dict["NetWorkId"] as! String
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") && dict["PasswordInherit"] != nil {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int64
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") && dict["PrivateIpAddress"] != nil {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("PublicIpIdentification") && dict["PublicIpIdentification"] != nil {
            self.publicIpIdentification = dict["PublicIpIdentification"] as! Bool
        }
        if dict.keys.contains("ScheduleAreaLevel") && dict["ScheduleAreaLevel"] != nil {
            self.scheduleAreaLevel = dict["ScheduleAreaLevel"] as! String
        }
        if dict.keys.contains("SchedulingPriceStrategy") && dict["SchedulingPriceStrategy"] != nil {
            self.schedulingPriceStrategy = dict["SchedulingPriceStrategy"] as! String
        }
        if dict.keys.contains("SchedulingStrategy") && dict["SchedulingStrategy"] != nil {
            self.schedulingStrategy = dict["SchedulingStrategy"] as! String
        }
        if dict.keys.contains("SecurityId") && dict["SecurityId"] != nil {
            self.securityId = dict["SecurityId"] as! String
        }
        if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
            var model = RunInstancesRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("UniqueSuffix") && dict["UniqueSuffix"] != nil {
            self.uniqueSuffix = dict["UniqueSuffix"] as! Bool
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class RunInstancesShrinkRequest : Tea.TeaModel {
    public var amount: Int64?

    public var autoRenew: Bool?

    public var carrier: String?

    public var dataDiskShrink: String?

    public var ensRegionId: String?

    public var hostName: String?

    public var imageId: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int64?

    public var keyPairName: String?

    public var netDistrictCode: String?

    public var netWorkId: String?

    public var password: String?

    public var passwordInherit: Bool?

    public var period: Int64?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var publicIpIdentification: Bool?

    public var scheduleAreaLevel: String?

    public var schedulingPriceStrategy: String?

    public var schedulingStrategy: String?

    public var securityId: String?

    public var systemDiskShrink: String?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.carrier != nil {
            map["Carrier"] = self.carrier!
        }
        if self.dataDiskShrink != nil {
            map["DataDisk"] = self.dataDiskShrink!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.netDistrictCode != nil {
            map["NetDistrictCode"] = self.netDistrictCode!
        }
        if self.netWorkId != nil {
            map["NetWorkId"] = self.netWorkId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.publicIpIdentification != nil {
            map["PublicIpIdentification"] = self.publicIpIdentification!
        }
        if self.scheduleAreaLevel != nil {
            map["ScheduleAreaLevel"] = self.scheduleAreaLevel!
        }
        if self.schedulingPriceStrategy != nil {
            map["SchedulingPriceStrategy"] = self.schedulingPriceStrategy!
        }
        if self.schedulingStrategy != nil {
            map["SchedulingStrategy"] = self.schedulingStrategy!
        }
        if self.securityId != nil {
            map["SecurityId"] = self.securityId!
        }
        if self.systemDiskShrink != nil {
            map["SystemDisk"] = self.systemDiskShrink!
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") && dict["Amount"] != nil {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("Carrier") && dict["Carrier"] != nil {
            self.carrier = dict["Carrier"] as! String
        }
        if dict.keys.contains("DataDisk") && dict["DataDisk"] != nil {
            self.dataDiskShrink = dict["DataDisk"] as! String
        }
        if dict.keys.contains("EnsRegionId") && dict["EnsRegionId"] != nil {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") && dict["InternetChargeType"] != nil {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") && dict["InternetMaxBandwidthOut"] != nil {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int64
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("NetDistrictCode") && dict["NetDistrictCode"] != nil {
            self.netDistrictCode = dict["NetDistrictCode"] as! String
        }
        if dict.keys.contains("NetWorkId") && dict["NetWorkId"] != nil {
            self.netWorkId = dict["NetWorkId"] as! String
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") && dict["PasswordInherit"] != nil {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int64
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") && dict["PrivateIpAddress"] != nil {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("PublicIpIdentification") && dict["PublicIpIdentification"] != nil {
            self.publicIpIdentification = dict["PublicIpIdentification"] as! Bool
        }
        if dict.keys.contains("ScheduleAreaLevel") && dict["ScheduleAreaLevel"] != nil {
            self.scheduleAreaLevel = dict["ScheduleAreaLevel"] as! String
        }
        if dict.keys.contains("SchedulingPriceStrategy") && dict["SchedulingPriceStrategy"] != nil {
            self.schedulingPriceStrategy = dict["SchedulingPriceStrategy"] as! String
        }
        if dict.keys.contains("SchedulingStrategy") && dict["SchedulingStrategy"] != nil {
            self.schedulingStrategy = dict["SchedulingStrategy"] as! String
        }
        if dict.keys.contains("SecurityId") && dict["SecurityId"] != nil {
            self.securityId = dict["SecurityId"] as! String
        }
        if dict.keys.contains("SystemDisk") && dict["SystemDisk"] != nil {
            self.systemDiskShrink = dict["SystemDisk"] as! String
        }
        if dict.keys.contains("UniqueSuffix") && dict["UniqueSuffix"] != nil {
            self.uniqueSuffix = dict["UniqueSuffix"] as! Bool
        }
        if dict.keys.contains("UserData") && dict["UserData"] != nil {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class RunInstancesResponseBody : Tea.TeaModel {
    public var instanceIds: [String]?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RunInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RunInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunServiceScheduleRequest : Tea.TeaModel {
    public var appId: String?

    public var clientIp: String?

    public var directorys: String?

    public var podConfigName: String?

    public var preLockedTimeout: Int32?

    public var scheduleStrategy: String?

    public var serviceAction: String?

    public var serviceCommands: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clientIp != nil {
            map["ClientIp"] = self.clientIp!
        }
        if self.directorys != nil {
            map["Directorys"] = self.directorys!
        }
        if self.podConfigName != nil {
            map["PodConfigName"] = self.podConfigName!
        }
        if self.preLockedTimeout != nil {
            map["PreLockedTimeout"] = self.preLockedTimeout!
        }
        if self.scheduleStrategy != nil {
            map["ScheduleStrategy"] = self.scheduleStrategy!
        }
        if self.serviceAction != nil {
            map["ServiceAction"] = self.serviceAction!
        }
        if self.serviceCommands != nil {
            map["ServiceCommands"] = self.serviceCommands!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ClientIp") && dict["ClientIp"] != nil {
            self.clientIp = dict["ClientIp"] as! String
        }
        if dict.keys.contains("Directorys") && dict["Directorys"] != nil {
            self.directorys = dict["Directorys"] as! String
        }
        if dict.keys.contains("PodConfigName") && dict["PodConfigName"] != nil {
            self.podConfigName = dict["PodConfigName"] as! String
        }
        if dict.keys.contains("PreLockedTimeout") && dict["PreLockedTimeout"] != nil {
            self.preLockedTimeout = dict["PreLockedTimeout"] as! Int32
        }
        if dict.keys.contains("ScheduleStrategy") && dict["ScheduleStrategy"] != nil {
            self.scheduleStrategy = dict["ScheduleStrategy"] as! String
        }
        if dict.keys.contains("ServiceAction") && dict["ServiceAction"] != nil {
            self.serviceAction = dict["ServiceAction"] as! String
        }
        if dict.keys.contains("ServiceCommands") && dict["ServiceCommands"] != nil {
            self.serviceCommands = dict["ServiceCommands"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class RunServiceScheduleResponseBody : Tea.TeaModel {
    public class CommandResults : Tea.TeaModel {
        public class CommandResult : Tea.TeaModel {
            public var command: String?

            public var containerName: String?

            public var resultMsg: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.containerName != nil {
                    map["ContainerName"] = self.containerName!
                }
                if self.resultMsg != nil {
                    map["ResultMsg"] = self.resultMsg!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Command") && dict["Command"] != nil {
                    self.command = dict["Command"] as! String
                }
                if dict.keys.contains("ContainerName") && dict["ContainerName"] != nil {
                    self.containerName = dict["ContainerName"] as! String
                }
                if dict.keys.contains("ResultMsg") && dict["ResultMsg"] != nil {
                    self.resultMsg = dict["ResultMsg"] as! String
                }
            }
        }
        public var commandResult: [RunServiceScheduleResponseBody.CommandResults.CommandResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commandResult != nil {
                var tmp : [Any] = []
                for k in self.commandResult! {
                    tmp.append(k.toMap())
                }
                map["CommandResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommandResult") && dict["CommandResult"] != nil {
                var tmp : [RunServiceScheduleResponseBody.CommandResults.CommandResult] = []
                for v in dict["CommandResult"] as! [Any] {
                    var model = RunServiceScheduleResponseBody.CommandResults.CommandResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.commandResult = tmp
            }
        }
    }
    public var commandResults: RunServiceScheduleResponseBody.CommandResults?

    public var index: Int32?

    public var instanceId: String?

    public var instanceIp: String?

    public var instancePort: Int32?

    public var requestId: String?

    public var requestRepeated: String?

    public var tcpPorts: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commandResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandResults != nil {
            map["CommandResults"] = self.commandResults?.toMap()
        }
        if self.index != nil {
            map["Index"] = self.index!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIp != nil {
            map["InstanceIp"] = self.instanceIp!
        }
        if self.instancePort != nil {
            map["InstancePort"] = self.instancePort!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestRepeated != nil {
            map["RequestRepeated"] = self.requestRepeated!
        }
        if self.tcpPorts != nil {
            map["TcpPorts"] = self.tcpPorts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandResults") && dict["CommandResults"] != nil {
            var model = RunServiceScheduleResponseBody.CommandResults()
            model.fromMap(dict["CommandResults"] as! [String: Any])
            self.commandResults = model
        }
        if dict.keys.contains("Index") && dict["Index"] != nil {
            self.index = dict["Index"] as! Int32
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIp") && dict["InstanceIp"] != nil {
            self.instanceIp = dict["InstanceIp"] as! String
        }
        if dict.keys.contains("InstancePort") && dict["InstancePort"] != nil {
            self.instancePort = dict["InstancePort"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestRepeated") && dict["RequestRepeated"] != nil {
            self.requestRepeated = dict["RequestRepeated"] as! String
        }
        if dict.keys.contains("TcpPorts") && dict["TcpPorts"] != nil {
            self.tcpPorts = dict["TcpPorts"] as! Bool
        }
    }
}

public class RunServiceScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunServiceScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RunServiceScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetBackendServersRequest : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public var serverId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var backendServers: [SetBackendServersRequest.BackendServers]?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            var tmp : [Any] = []
            for k in self.backendServers! {
                tmp.append(k.toMap())
            }
            map["BackendServers"] = tmp
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            var tmp : [SetBackendServersRequest.BackendServers] = []
            for v in dict["BackendServers"] as! [Any] {
                var model = SetBackendServersRequest.BackendServers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendServers = tmp
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class SetBackendServersShrinkRequest : Tea.TeaModel {
    public var backendServersShrink: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServersShrink != nil {
            map["BackendServers"] = self.backendServersShrink!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            self.backendServersShrink = dict["BackendServers"] as! String
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class SetBackendServersResponseBody : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public class BackendServer : Tea.TeaModel {
            public var ip: String?

            public var port: Int32?

            public var serverId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerId") && dict["ServerId"] != nil {
                    self.serverId = dict["ServerId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var backendServer: [SetBackendServersResponseBody.BackendServers.BackendServer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendServer != nil {
                var tmp : [Any] = []
                for k in self.backendServer! {
                    tmp.append(k.toMap())
                }
                map["BackendServer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendServer") && dict["BackendServer"] != nil {
                var tmp : [SetBackendServersResponseBody.BackendServers.BackendServer] = []
                for v in dict["BackendServer"] as! [Any] {
                    var model = SetBackendServersResponseBody.BackendServers.BackendServer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backendServer = tmp
            }
        }
    }
    public var backendServers: SetBackendServersResponseBody.BackendServers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            map["BackendServers"] = self.backendServers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") && dict["BackendServers"] != nil {
            var model = SetBackendServersResponseBody.BackendServers()
            model.fromMap(dict["BackendServers"] as! [String: Any])
            self.backendServers = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetBackendServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetBackendServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetBackendServersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerHTTPListenerAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") && dict["HealthCheckMethod"] != nil {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") && dict["HealthCheckTimeout"] != nil {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class SetLoadBalancerHTTPListenerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerHTTPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerHTTPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetLoadBalancerHTTPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerHTTPSListenerAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") && dict["HealthCheckMethod"] != nil {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") && dict["HealthCheckTimeout"] != nil {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") && dict["ServerCertificateId"] != nil {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class SetLoadBalancerHTTPSListenerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerHTTPSListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerHTTPSListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetLoadBalancerHTTPSListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerStatusRequest : Tea.TeaModel {
    public var loadBalancerId: String?

    public var loadBalancerStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerStatus != nil {
            map["LoadBalancerStatus"] = self.loadBalancerStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerStatus") && dict["LoadBalancerStatus"] != nil {
            self.loadBalancerStatus = dict["LoadBalancerStatus"] as! String
        }
    }
}

public class SetLoadBalancerStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetLoadBalancerStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerTCPListenerAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var eipTransmit: String?

    public var establishedTimeout: Int32?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckType: String?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var persistenceTimeout: Int32?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.persistenceTimeout != nil {
            map["PersistenceTimeout"] = self.persistenceTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") && dict["EipTransmit"] != nil {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("EstablishedTimeout") && dict["EstablishedTimeout"] != nil {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") && dict["HealthCheckConnectTimeout"] != nil {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") && dict["HealthCheckDomain"] != nil {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") && dict["HealthCheckHttpCode"] != nil {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckType") && dict["HealthCheckType"] != nil {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckURI") && dict["HealthCheckURI"] != nil {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("PersistenceTimeout") && dict["PersistenceTimeout"] != nil {
            self.persistenceTimeout = dict["PersistenceTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class SetLoadBalancerTCPListenerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerTCPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerTCPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetLoadBalancerTCPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerUDPListenerAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var eipTransmit: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckExp: String?

    public var healthCheckInterval: Int32?

    public var healthCheckReq: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckExp != nil {
            map["HealthCheckExp"] = self.healthCheckExp!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckReq != nil {
            map["HealthCheckReq"] = self.healthCheckReq!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") && dict["EipTransmit"] != nil {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") && dict["HealthCheckConnectPort"] != nil {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") && dict["HealthCheckConnectTimeout"] != nil {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckExp") && dict["HealthCheckExp"] != nil {
            self.healthCheckExp = dict["HealthCheckExp"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") && dict["HealthCheckInterval"] != nil {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckReq") && dict["HealthCheckReq"] != nil {
            self.healthCheckReq = dict["HealthCheckReq"] as! String
        }
        if dict.keys.contains("HealthyThreshold") && dict["HealthyThreshold"] != nil {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("Scheduler") && dict["Scheduler"] != nil {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") && dict["UnhealthyThreshold"] != nil {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class SetLoadBalancerUDPListenerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerUDPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerUDPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetLoadBalancerUDPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
    }
}

public class StartEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class StartInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartInstancesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class StartInstancesShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class StartInstancesResponseBody : Tea.TeaModel {
    public var instanceResponses: [InstanceOperateResponse]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            var tmp : [Any] = []
            for k in self.instanceResponses! {
                tmp.append(k.toMap())
            }
            map["InstanceResponses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") && dict["InstanceResponses"] != nil {
            var tmp : [InstanceOperateResponse] = []
            for v in dict["InstanceResponses"] as! [Any] {
                var model = InstanceOperateResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceResponses = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartLoadBalancerListenerRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("ListenerProtocol") && dict["ListenerProtocol"] != nil {
            self.listenerProtocol = dict["ListenerProtocol"] as! String
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class StartLoadBalancerListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartLoadBalancerListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartLoadBalancerListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartLoadBalancerListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") && dict["EPNInstanceId"] != nil {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
    }
}

public class StopEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopInstanceRequest : Tea.TeaModel {
    public var forceStop: String?

    public var instanceId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceStop") && dict["ForceStop"] != nil {
            self.forceStop = dict["ForceStop"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! String
        }
    }
}

public class StopInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopInstancesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class StopInstancesShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class StopInstancesResponseBody : Tea.TeaModel {
    public var instanceResponses: [InstanceOperateResponse]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            var tmp : [Any] = []
            for k in self.instanceResponses! {
                tmp.append(k.toMap())
            }
            map["InstanceResponses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") && dict["InstanceResponses"] != nil {
            var tmp : [InstanceOperateResponse] = []
            for v in dict["InstanceResponses"] as! [Any] {
                var model = InstanceOperateResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceResponses = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopLoadBalancerListenerRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("ListenerProtocol") && dict["ListenerProtocol"] != nil {
            self.listenerProtocol = dict["ListenerProtocol"] as! String
        }
        if dict.keys.contains("LoadBalancerId") && dict["LoadBalancerId"] != nil {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class StopLoadBalancerListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopLoadBalancerListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopLoadBalancerListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopLoadBalancerListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnAssociateEnsEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") && dict["AllocationId"] != nil {
            self.allocationId = dict["AllocationId"] as! String
        }
    }
}

public class UnAssociateEnsEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnAssociateEnsEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnAssociateEnsEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnAssociateEnsEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassignPrivateIpAddressesRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var privateIpAddress: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") && dict["NetworkInterfaceId"] != nil {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") && dict["PrivateIpAddress"] != nil {
            self.privateIpAddress = dict["PrivateIpAddress"] as! [String]
        }
    }
}

public class UnassignPrivateIpAddressesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassignPrivateIpAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassignPrivateIpAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnassignPrivateIpAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateNetworkAclRequest : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var networkAclId: String?

    public var resource: [UnassociateNetworkAclRequest.Resource]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.resource != nil {
            var tmp : [Any] = []
            for k in self.resource! {
                tmp.append(k.toMap())
            }
            map["Resource"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") && dict["NetworkAclId"] != nil {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("Resource") && dict["Resource"] != nil {
            var tmp : [UnassociateNetworkAclRequest.Resource] = []
            for v in dict["Resource"] as! [Any] {
                var model = UnassociateNetworkAclRequest.Resource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resource = tmp
        }
    }
}

public class UnassociateNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnassociateNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeAICInstanceImageRequest : Tea.TeaModel {
    public var imageId: String?

    public var serverIds: [String]?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.serverIds != nil {
            map["ServerIds"] = self.serverIds!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ServerIds") && dict["ServerIds"] != nil {
            self.serverIds = dict["ServerIds"] as! [String]
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpgradeAICInstanceImageShrinkRequest : Tea.TeaModel {
    public var imageId: String?

    public var serverIdsShrink: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.serverIdsShrink != nil {
            map["ServerIds"] = self.serverIdsShrink!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ServerIds") && dict["ServerIds"] != nil {
            self.serverIdsShrink = dict["ServerIds"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpgradeAICInstanceImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpgradeAICInstanceImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeAICInstanceImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpgradeAICInstanceImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var template: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Template") && dict["Template"] != nil {
            self.template = dict["Template"] as! String
        }
        if dict.keys.contains("Timeout") && dict["Timeout"] != nil {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpgradeApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpgradeApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpgradeApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
