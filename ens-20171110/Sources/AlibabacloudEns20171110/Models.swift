import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class BucketInfo : Tea.TeaModel {
    public var bucketAcl: String?

    public var bucketName: String?

    public var comment: String?

    public var createTime: String?

    public var dataRedundancyType: String?

    public var dispatcherType: String?

    public var endpoint: String?

    public var ensRegionId: String?

    public var modifyTime: String?

    public var resourceType: String?

    public var storageClass: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketAcl != nil {
            map["BucketAcl"] = self.bucketAcl!
        }
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dataRedundancyType != nil {
            map["DataRedundancyType"] = self.dataRedundancyType!
        }
        if self.dispatcherType != nil {
            map["DispatcherType"] = self.dispatcherType!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.modifyTime != nil {
            map["ModifyTime"] = self.modifyTime!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.storageClass != nil {
            map["StorageClass"] = self.storageClass!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketAcl") {
            self.bucketAcl = dict["BucketAcl"] as! String
        }
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("DataRedundancyType") {
            self.dataRedundancyType = dict["DataRedundancyType"] as! String
        }
        if dict.keys.contains("DispatcherType") {
            self.dispatcherType = dict["DispatcherType"] as! String
        }
        if dict.keys.contains("Endpoint") {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("ModifyTime") {
            self.modifyTime = dict["ModifyTime"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("StorageClass") {
            self.storageClass = dict["StorageClass"] as! String
        }
    }
}

public class DataDisk : Tea.TeaModel {
    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int64
        }
    }
}

public class HealthCheck : Tea.TeaModel {
    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckType: String?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HealthCheck") {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckType") {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class HttpConfig : Tea.TeaModel {
    public var cookie: String?

    public var cookieTimeout: Int32?

    public var idleTimeout: Int32?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var stickySession: String?

    public var stickySessionType: String?

    public var XForwardedFor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cookie != nil {
            map["Cookie"] = self.cookie!
        }
        if self.cookieTimeout != nil {
            map["CookieTimeout"] = self.cookieTimeout!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.stickySession != nil {
            map["StickySession"] = self.stickySession!
        }
        if self.stickySessionType != nil {
            map["StickySessionType"] = self.stickySessionType!
        }
        if self.XForwardedFor != nil {
            map["XForwardedFor"] = self.XForwardedFor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cookie") {
            self.cookie = dict["Cookie"] as! String
        }
        if dict.keys.contains("CookieTimeout") {
            self.cookieTimeout = dict["CookieTimeout"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("RequestTimeout") {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("StickySession") {
            self.stickySession = dict["StickySession"] as! String
        }
        if dict.keys.contains("StickySessionType") {
            self.stickySessionType = dict["StickySessionType"] as! String
        }
        if dict.keys.contains("XForwardedFor") {
            self.XForwardedFor = dict["XForwardedFor"] as! String
        }
    }
}

public class InstanceActiveOpsGroup : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class InstanceActiveOpsTask : Tea.TeaModel {
    public var instanceActiveOpsTaskId: String?

    public var instanceActiveOpsTaskStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceActiveOpsTaskId != nil {
            map["InstanceActiveOpsTaskId"] = self.instanceActiveOpsTaskId!
        }
        if self.instanceActiveOpsTaskStatus != nil {
            map["InstanceActiveOpsTaskStatus"] = self.instanceActiveOpsTaskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceActiveOpsTaskId") {
            self.instanceActiveOpsTaskId = dict["InstanceActiveOpsTaskId"] as! String
        }
        if dict.keys.contains("InstanceActiveOpsTaskStatus") {
            self.instanceActiveOpsTaskStatus = dict["InstanceActiveOpsTaskStatus"] as! String
        }
    }
}

public class InstanceOperateResponse : Tea.TeaModel {
    public var code: Int64?

    public var instanceId: String?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
    }
}

public class SecurityGroupRule : Tea.TeaModel {
    public var description_: String?

    public var destCidrIp: String?

    public var direction: String?

    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public var priority: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("priority") {
            self.priority = dict["priority"] as! Int32
        }
    }
}

public class TagsInParams : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var tag: [TagsInParams.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tag") {
            var tmp : [TagsInParams.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagsInParams.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TcpConfig : Tea.TeaModel {
    public var establishedTimeout: Int32?

    public var persistenceTimeout: Int32?

    public var scheduler: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.persistenceTimeout != nil {
            map["PersistenceTimeout"] = self.persistenceTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EstablishedTimeout") {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("PersistenceTimeout") {
            self.persistenceTimeout = dict["PersistenceTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
    }
}

public class UdpCheck : Tea.TeaModel {
    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckInterval: Int32?

    public var healthyThreshold: Int32?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class UdpConfig : Tea.TeaModel {
    public var hashKey: String?

    public var scheduler: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hashKey != nil {
            map["HashKey"] = self.hashKey!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HashKey") {
            self.hashKey = dict["HashKey"] as! String
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
    }
}

public class AccosicateNetworkAclRequest : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var networkAclId: String?

    public var resource: [AccosicateNetworkAclRequest.Resource]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.resource != nil {
            var tmp : [Any] = []
            for k in self.resource! {
                tmp.append(k.toMap())
            }
            map["Resource"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("Resource") {
            var tmp : [AccosicateNetworkAclRequest.Resource] = []
            for v in dict["Resource"] as! [Any] {
                var model = AccosicateNetworkAclRequest.Resource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resource = tmp
        }
    }
}

public class AccosicateNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AccosicateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AccosicateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AccosicateNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddBackendServersRequest : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public var ip: String?

        public var port: Int32?

        public var serverId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerId") {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var backendServers: [AddBackendServersRequest.BackendServers]?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            var tmp : [Any] = []
            for k in self.backendServers! {
                tmp.append(k.toMap())
            }
            map["BackendServers"] = tmp
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") {
            var tmp : [AddBackendServersRequest.BackendServers] = []
            for v in dict["BackendServers"] as! [Any] {
                var model = AddBackendServersRequest.BackendServers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendServers = tmp
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class AddBackendServersShrinkRequest : Tea.TeaModel {
    public var backendServersShrink: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServersShrink != nil {
            map["BackendServers"] = self.backendServersShrink!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") {
            self.backendServersShrink = dict["BackendServers"] as! String
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class AddBackendServersResponseBody : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public class BackendServer : Tea.TeaModel {
            public var ip: String?

            public var port: Int32?

            public var serverId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerId") {
                    self.serverId = dict["ServerId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var backendServer: [AddBackendServersResponseBody.BackendServers.BackendServer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendServer != nil {
                var tmp : [Any] = []
                for k in self.backendServer! {
                    tmp.append(k.toMap())
                }
                map["BackendServer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendServer") {
                var tmp : [AddBackendServersResponseBody.BackendServers.BackendServer] = []
                for v in dict["BackendServer"] as! [Any] {
                    var model = AddBackendServersResponseBody.BackendServers.BackendServer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backendServer = tmp
            }
        }
    }
    public var backendServers: AddBackendServersResponseBody.BackendServers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            map["BackendServers"] = self.backendServers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") {
            var model = AddBackendServersResponseBody.BackendServers()
            model.fromMap(dict["BackendServers"] as! [String: Any])
            self.backendServers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddBackendServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBackendServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddBackendServersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddNetworkInterfaceToInstanceRequest : Tea.TeaModel {
    public var autoStart: Bool?

    public var instanceId: String?

    public var networks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStart != nil {
            map["AutoStart"] = self.autoStart!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networks != nil {
            map["Networks"] = self.networks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoStart") {
            self.autoStart = dict["AutoStart"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Networks") {
            self.networks = dict["Networks"] as! String
        }
    }
}

public class AddNetworkInterfaceToInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddNetworkInterfaceToInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddNetworkInterfaceToInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddNetworkInterfaceToInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSnatIpForSnatEntryRequest : Tea.TeaModel {
    public var snatEntryId: String?

    public var snatIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
    }
}

public class AddSnatIpForSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddSnatIpForSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSnatIpForSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSnatIpForSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssignPrivateIpAddressesRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class AssignPrivateIpAddressesResponseBody : Tea.TeaModel {
    public class AssignedPrivateIpAddressesSet : Tea.TeaModel {
        public var networkInterfaceId: String?

        public var privateIpSet: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.privateIpSet != nil {
                map["PrivateIpSet"] = self.privateIpSet!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceId") {
                self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
            }
            if dict.keys.contains("PrivateIpSet") {
                self.privateIpSet = dict["PrivateIpSet"] as! [String]
            }
        }
    }
    public var assignedPrivateIpAddressesSet: AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.assignedPrivateIpAddressesSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedPrivateIpAddressesSet != nil {
            map["AssignedPrivateIpAddressesSet"] = self.assignedPrivateIpAddressesSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssignedPrivateIpAddressesSet") {
            var model = AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet()
            model.fromMap(dict["AssignedPrivateIpAddressesSet"] as! [String: Any])
            self.assignedPrivateIpAddressesSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssignPrivateIpAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignPrivateIpAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssignPrivateIpAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateEnsEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var standby: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.standby != nil {
            map["Standby"] = self.standby!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Standby") {
            self.standby = dict["Standby"] as! Bool
        }
    }
}

public class AssociateEnsEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateEnsEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateEnsEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateEnsEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateHaVipRequest : Tea.TeaModel {
    public var haVipId: String?

    public var instanceId: String?

    public var instanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
    }
}

public class AssociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachDiskRequest : Tea.TeaModel {
    public var deleteWithInstance: String?

    public var diskId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteWithInstance") {
            self.deleteWithInstance = dict["DeleteWithInstance"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AttachDiskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachEnsInstancesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scripts: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scripts != nil {
            map["Scripts"] = self.scripts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Scripts") {
            self.scripts = dict["Scripts"] as! String
        }
    }
}

public class AttachEnsInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachEnsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachEnsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachEnsInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachInstanceSDGRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class AttachInstanceSDGShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class AttachInstanceSDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var errMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMessage != nil {
                        map["ErrMessage"] = self.errMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMessage") {
                        self.errMessage = dict["ErrMessage"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [AttachInstanceSDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [AttachInstanceSDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = AttachInstanceSDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: AttachInstanceSDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = AttachInstanceSDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: AttachInstanceSDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = AttachInstanceSDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachInstanceSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachInstanceSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachInstanceSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachNetworkInterfaceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
    }
}

public class AttachNetworkInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachNetworkInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AuthorizeSecurityGroupRequest : Tea.TeaModel {
    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var securityGroupId: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
    }
}

public class AuthorizeSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AuthorizeSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AuthorizeSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AuthorizeSecurityGroupEgressRequest : Tea.TeaModel {
    public var destCidrIp: String?

    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var securityGroupId: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
    }
}

public class AuthorizeSecurityGroupEgressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AuthorizeSecurityGroupEgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeSecurityGroupEgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AuthorizeSecurityGroupEgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CleanDistDataRequest : Tea.TeaModel {
    public var appId: String?

    public var dataName: String?

    public var dataVersion: String?

    public var ensRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataName != nil {
            map["DataName"] = self.dataName!
        }
        if self.dataVersion != nil {
            map["DataVersion"] = self.dataVersion!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataName") {
            self.dataName = dict["DataName"] as! String
        }
        if dict.keys.contains("DataVersion") {
            self.dataVersion = dict["DataVersion"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
    }
}

public class CleanDistDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CleanDistDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CleanDistDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CleanDistDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopySDGRequest : Tea.TeaModel {
    public var destinationRegionIds: [String]?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationRegionIds != nil {
            map["DestinationRegionIds"] = self.destinationRegionIds!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationRegionIds") {
            self.destinationRegionIds = dict["DestinationRegionIds"] as! [String]
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class CopySDGShrinkRequest : Tea.TeaModel {
    public var destinationRegionIdsShrink: String?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationRegionIdsShrink != nil {
            map["DestinationRegionIds"] = self.destinationRegionIdsShrink!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationRegionIds") {
            self.destinationRegionIdsShrink = dict["DestinationRegionIds"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class CopySDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var destinationRegionId: String?

                public var errorMessage: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destinationRegionId != nil {
                        map["DestinationRegionId"] = self.destinationRegionId!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DestinationRegionId") {
                        self.destinationRegionId = dict["DestinationRegionId"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [CopySDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [CopySDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = CopySDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: CopySDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = CopySDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: CopySDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = CopySDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CopySDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopySDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopySDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopySnapshotRequest : Tea.TeaModel {
    public var destinationRegionIds: [String]?

    public var destinationSnapshotDescription: String?

    public var destinationSnapshotName: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationRegionIds != nil {
            map["DestinationRegionIds"] = self.destinationRegionIds!
        }
        if self.destinationSnapshotDescription != nil {
            map["DestinationSnapshotDescription"] = self.destinationSnapshotDescription!
        }
        if self.destinationSnapshotName != nil {
            map["DestinationSnapshotName"] = self.destinationSnapshotName!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationRegionIds") {
            self.destinationRegionIds = dict["DestinationRegionIds"] as! [String]
        }
        if dict.keys.contains("DestinationSnapshotDescription") {
            self.destinationSnapshotDescription = dict["DestinationSnapshotDescription"] as! String
        }
        if dict.keys.contains("DestinationSnapshotName") {
            self.destinationSnapshotName = dict["DestinationSnapshotName"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class CopySnapshotShrinkRequest : Tea.TeaModel {
    public var destinationRegionIdsShrink: String?

    public var destinationSnapshotDescription: String?

    public var destinationSnapshotName: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationRegionIdsShrink != nil {
            map["DestinationRegionIds"] = self.destinationRegionIdsShrink!
        }
        if self.destinationSnapshotDescription != nil {
            map["DestinationSnapshotDescription"] = self.destinationSnapshotDescription!
        }
        if self.destinationSnapshotName != nil {
            map["DestinationSnapshotName"] = self.destinationSnapshotName!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationRegionIds") {
            self.destinationRegionIdsShrink = dict["DestinationRegionIds"] as! String
        }
        if dict.keys.contains("DestinationSnapshotDescription") {
            self.destinationSnapshotDescription = dict["DestinationSnapshotDescription"] as! String
        }
        if dict.keys.contains("DestinationSnapshotName") {
            self.destinationSnapshotName = dict["DestinationSnapshotName"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class CopySnapshotResponseBody : Tea.TeaModel {
    public class AllocationId : Tea.TeaModel {
        public var ensRegionId: String?

        public var instanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! [String]
            }
        }
    }
    public class UnAllocationId : Tea.TeaModel {
        public var ensRegionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
        }
    }
    public var allocationId: [CopySnapshotResponseBody.AllocationId]?

    public var bizStatusCode: String?

    public var requestId: String?

    public var unAllocationId: [CopySnapshotResponseBody.UnAllocationId]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            var tmp : [Any] = []
            for k in self.allocationId! {
                tmp.append(k.toMap())
            }
            map["AllocationId"] = tmp
        }
        if self.bizStatusCode != nil {
            map["BizStatusCode"] = self.bizStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.unAllocationId != nil {
            var tmp : [Any] = []
            for k in self.unAllocationId! {
                tmp.append(k.toMap())
            }
            map["UnAllocationId"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            var tmp : [CopySnapshotResponseBody.AllocationId] = []
            for v in dict["AllocationId"] as! [Any] {
                var model = CopySnapshotResponseBody.AllocationId()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.allocationId = tmp
        }
        if dict.keys.contains("BizStatusCode") {
            self.bizStatusCode = dict["BizStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UnAllocationId") {
            var tmp : [CopySnapshotResponseBody.UnAllocationId] = []
            for v in dict["UnAllocationId"] as! [Any] {
                var model = CopySnapshotResponseBody.UnAllocationId()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.unAllocationId = tmp
        }
    }
}

public class CopySnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopySnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopySnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateARMServerInstancesRequest : Tea.TeaModel {
    public var amount: Int32?

    public var autoRenew: Bool?

    public var autoUseCoupon: Bool?

    public var cidr: String?

    public var ensRegionId: String?

    public var environmentVar: String?

    public var frequency: Int32?

    public var imageId: String?

    public var instanceType: String?

    public var keyPairName: String?

    public var nameSpace: String?

    public var payType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var resolution: String?

    public var serverName: String?

    public var serverType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.cidr != nil {
            map["Cidr"] = self.cidr!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.environmentVar != nil {
            map["EnvironmentVar"] = self.environmentVar!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.nameSpace != nil {
            map["NameSpace"] = self.nameSpace!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.resolution != nil {
            map["Resolution"] = self.resolution!
        }
        if self.serverName != nil {
            map["ServerName"] = self.serverName!
        }
        if self.serverType != nil {
            map["ServerType"] = self.serverType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoUseCoupon") {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! Bool
        }
        if dict.keys.contains("Cidr") {
            self.cidr = dict["Cidr"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnvironmentVar") {
            self.environmentVar = dict["EnvironmentVar"] as! String
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! Int32
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("NameSpace") {
            self.nameSpace = dict["NameSpace"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Resolution") {
            self.resolution = dict["Resolution"] as! String
        }
        if dict.keys.contains("ServerName") {
            self.serverName = dict["ServerName"] as! String
        }
        if dict.keys.contains("ServerType") {
            self.serverType = dict["ServerType"] as! String
        }
    }
}

public class CreateARMServerInstancesResponseBody : Tea.TeaModel {
    public var instanceIds: [String]?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateARMServerInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateARMServerInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateARMServerInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApplicationRequest : Tea.TeaModel {
    public var template: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class CreateApplicationResponseBody : Tea.TeaModel {
    public var appId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClassicNetworkRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var ensRegionId: String?

    public var networkName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("NetworkName") {
            self.networkName = dict["NetworkName"] as! String
        }
    }
}

public class CreateClassicNetworkResponseBody : Tea.TeaModel {
    public var networkId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateClassicNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClassicNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateClassicNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClusterRequest : Tea.TeaModel {
    public var clusterVersion: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterVersion != nil {
            map["ClusterVersion"] = self.clusterVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterVersion") {
            self.clusterVersion = dict["ClusterVersion"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class CreateClusterResponseBody : Tea.TeaModel {
    public var clusterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiskRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var category: String?

    public var diskName: String?

    public var encrypted: Bool?

    public var ensRegionId: String?

    public var instanceChargeType: String?

    public var KMSKeyId: String?

    public var size: String?

    public var snapshotId: String?

    public var tag: [CreateDiskRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("DiskName") {
            self.diskName = dict["DiskName"] as! String
        }
        if dict.keys.contains("Encrypted") {
            self.encrypted = dict["Encrypted"] as! Bool
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateDiskRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateDiskRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateDiskResponseBody : Tea.TeaModel {
    public var instanceIds: [String]?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEipInstanceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var bandwidth: Int64?

    public var clientToken: String?

    public var description_: String?

    public var ensRegionId: String?

    public var instanceChargeType: String?

    public var internetChargeType: String?

    public var isp: String?

    public var name: String?

    public var tag: [CreateEipInstanceRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int64
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateEipInstanceRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateEipInstanceRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateEipInstanceResponseBody : Tea.TeaModel {
    public var allocationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEipInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEipInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEipInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnsRouteEntryRequest : Tea.TeaModel {
    public var description_: String?

    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopType: String?

    public var routeEntryName: String?

    public var routeTableId: String?

    public var sourceCidrBlock: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.sourceCidrBlock != nil {
            map["SourceCidrBlock"] = self.sourceCidrBlock!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("NextHopId") {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopType") {
            self.nextHopType = dict["NextHopType"] as! String
        }
        if dict.keys.contains("RouteEntryName") {
            self.routeEntryName = dict["RouteEntryName"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("SourceCidrBlock") {
            self.sourceCidrBlock = dict["SourceCidrBlock"] as! String
        }
    }
}

public class CreateEnsRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntryId") {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
    }
}

public class CreateEnsRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnsRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEnsRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnsSaleControlRequest : Tea.TeaModel {
    public class SaleControls : Tea.TeaModel {
        public class ConditionControls : Tea.TeaModel {
            public var conditionControlModuleCode: String?

            public var conditionControlModuleValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conditionControlModuleCode != nil {
                    map["ConditionControlModuleCode"] = self.conditionControlModuleCode!
                }
                if self.conditionControlModuleValue != nil {
                    map["ConditionControlModuleValue"] = self.conditionControlModuleValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConditionControlModuleCode") {
                    self.conditionControlModuleCode = dict["ConditionControlModuleCode"] as! String
                }
                if dict.keys.contains("ConditionControlModuleValue") {
                    self.conditionControlModuleValue = dict["ConditionControlModuleValue"] as! String
                }
            }
        }
        public class ModuleValue : Tea.TeaModel {
            public var moduleMaxValue: String?

            public var moduleMinValue: String?

            public var moduleValue: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.moduleMaxValue != nil {
                    map["ModuleMaxValue"] = self.moduleMaxValue!
                }
                if self.moduleMinValue != nil {
                    map["ModuleMinValue"] = self.moduleMinValue!
                }
                if self.moduleValue != nil {
                    map["ModuleValue"] = self.moduleValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ModuleMaxValue") {
                    self.moduleMaxValue = dict["ModuleMaxValue"] as! String
                }
                if dict.keys.contains("ModuleMinValue") {
                    self.moduleMinValue = dict["ModuleMinValue"] as! String
                }
                if dict.keys.contains("ModuleValue") {
                    self.moduleValue = dict["ModuleValue"] as! [String]
                }
            }
        }
        public var conditionControls: [CreateEnsSaleControlRequest.SaleControls.ConditionControls]?

        public var description_: String?

        public var moduleCode: String?

        public var moduleValue: CreateEnsSaleControlRequest.SaleControls.ModuleValue?

        public var operator_: String?

        public var orderType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.moduleValue?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditionControls != nil {
                var tmp : [Any] = []
                for k in self.conditionControls! {
                    tmp.append(k.toMap())
                }
                map["ConditionControls"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.moduleCode != nil {
                map["ModuleCode"] = self.moduleCode!
            }
            if self.moduleValue != nil {
                map["ModuleValue"] = self.moduleValue?.toMap()
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConditionControls") {
                var tmp : [CreateEnsSaleControlRequest.SaleControls.ConditionControls] = []
                for v in dict["ConditionControls"] as! [Any] {
                    var model = CreateEnsSaleControlRequest.SaleControls.ConditionControls()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditionControls = tmp
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModuleCode") {
                self.moduleCode = dict["ModuleCode"] as! String
            }
            if dict.keys.contains("ModuleValue") {
                var model = CreateEnsSaleControlRequest.SaleControls.ModuleValue()
                model.fromMap(dict["ModuleValue"] as! [String: Any])
                self.moduleValue = model
            }
            if dict.keys.contains("Operator") {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("OrderType") {
                self.orderType = dict["OrderType"] as! String
            }
        }
    }
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var saleControls: [CreateEnsSaleControlRequest.SaleControls]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.saleControls != nil {
            var tmp : [Any] = []
            for k in self.saleControls! {
                tmp.append(k.toMap())
            }
            map["SaleControls"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("SaleControls") {
            var tmp : [CreateEnsSaleControlRequest.SaleControls] = []
            for v in dict["SaleControls"] as! [Any] {
                var model = CreateEnsSaleControlRequest.SaleControls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.saleControls = tmp
        }
    }
}

public class CreateEnsSaleControlShrinkRequest : Tea.TeaModel {
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var saleControlsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.saleControlsShrink != nil {
            map["SaleControls"] = self.saleControlsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("SaleControls") {
            self.saleControlsShrink = dict["SaleControls"] as! String
        }
    }
}

public class CreateEnsSaleControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnsSaleControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnsSaleControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEnsSaleControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEnsServiceRequest : Tea.TeaModel {
    public var ensServiceId: String?

    public var orderType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensServiceId != nil {
            map["EnsServiceId"] = self.ensServiceId!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsServiceId") {
            self.ensServiceId = dict["EnsServiceId"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
    }
}

public class CreateEnsServiceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEnsServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEnsServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEnsServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceName: String?

    public var EPNInstanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var networkingModel: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceName != nil {
            map["EPNInstanceName"] = self.EPNInstanceName!
        }
        if self.EPNInstanceType != nil {
            map["EPNInstanceType"] = self.EPNInstanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceName") {
            self.EPNInstanceName = dict["EPNInstanceName"] as! String
        }
        if dict.keys.contains("EPNInstanceType") {
            self.EPNInstanceType = dict["EPNInstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("NetworkingModel") {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
    }
}

public class CreateEpnInstanceResponseBody : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFileSystemRequest : Tea.TeaModel {
    public class OrderDetails : Tea.TeaModel {
        public var chargeType: String?

        public var ensRegionId: String?

        public var fileSystemName: String?

        public var mountTargetDomain: String?

        public var networkId: String?

        public var orderType: String?

        public var protocolType: String?

        public var storgeType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.fileSystemName != nil {
                map["FileSystemName"] = self.fileSystemName!
            }
            if self.mountTargetDomain != nil {
                map["MountTargetDomain"] = self.mountTargetDomain!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.storgeType != nil {
                map["StorgeType"] = self.storgeType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("FileSystemName") {
                self.fileSystemName = dict["FileSystemName"] as! String
            }
            if dict.keys.contains("MountTargetDomain") {
                self.mountTargetDomain = dict["MountTargetDomain"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("OrderType") {
                self.orderType = dict["OrderType"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("StorgeType") {
                self.storgeType = dict["StorgeType"] as! String
            }
        }
    }
    public var orderDetails: [CreateFileSystemRequest.OrderDetails]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderDetails != nil {
            var tmp : [Any] = []
            for k in self.orderDetails! {
                tmp.append(k.toMap())
            }
            map["OrderDetails"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderDetails") {
            var tmp : [CreateFileSystemRequest.OrderDetails] = []
            for v in dict["OrderDetails"] as! [Any] {
                var model = CreateFileSystemRequest.OrderDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orderDetails = tmp
        }
    }
}

public class CreateFileSystemShrinkRequest : Tea.TeaModel {
    public var orderDetailsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderDetailsShrink != nil {
            map["OrderDetails"] = self.orderDetailsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderDetails") {
            self.orderDetailsShrink = dict["OrderDetails"] as! String
        }
    }
}

public class CreateFileSystemResponseBody : Tea.TeaModel {
    public var allocationId: [String]?

    public var bizStatusCode: String?

    public var requestId: String?

    public var unAllocationId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.bizStatusCode != nil {
            map["BizStatusCode"] = self.bizStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.unAllocationId != nil {
            map["UnAllocationId"] = self.unAllocationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! [String]
        }
        if dict.keys.contains("BizStatusCode") {
            self.bizStatusCode = dict["BizStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UnAllocationId") {
            self.unAllocationId = dict["UnAllocationId"] as! [String]
        }
    }
}

public class CreateFileSystemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFileSystemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFileSystemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateForwardEntryRequest : Tea.TeaModel {
    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryName: String?

    public var healthCheckPort: Int32?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var natGatewayId: String?

    public var standbyExternalIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.healthCheckPort != nil {
            map["HealthCheckPort"] = self.healthCheckPort!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.standbyExternalIp != nil {
            map["StandbyExternalIp"] = self.standbyExternalIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExternalIp") {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ExternalPort") {
            self.externalPort = dict["ExternalPort"] as! String
        }
        if dict.keys.contains("ForwardEntryName") {
            self.forwardEntryName = dict["ForwardEntryName"] as! String
        }
        if dict.keys.contains("HealthCheckPort") {
            self.healthCheckPort = dict["HealthCheckPort"] as! Int32
        }
        if dict.keys.contains("InternalIp") {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("InternalPort") {
            self.internalPort = dict["InternalPort"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("StandbyExternalIp") {
            self.standbyExternalIp = dict["StandbyExternalIp"] as! String
        }
    }
}

public class CreateForwardEntryResponseBody : Tea.TeaModel {
    public var forwardEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHaVipRequest : Tea.TeaModel {
    public var amount: Int32?

    public var description_: String?

    public var ipAddress: String?

    public var name: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateHaVipResponseBody : Tea.TeaModel {
    public var haVipIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipIds != nil {
            map["HaVipIds"] = self.haVipIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVipIds") {
            self.haVipIds = dict["HaVipIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateImageRequest : Tea.TeaModel {
    public var deleteAfterImageUpload: String?

    public var imageName: String?

    public var instanceId: String?

    public var snapshotId: String?

    public var targetOSSRegionId: String?

    public var withDataDisks: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteAfterImageUpload != nil {
            map["DeleteAfterImageUpload"] = self.deleteAfterImageUpload!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.targetOSSRegionId != nil {
            map["TargetOSSRegionId"] = self.targetOSSRegionId!
        }
        if self.withDataDisks != nil {
            map["WithDataDisks"] = self.withDataDisks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteAfterImageUpload") {
            self.deleteAfterImageUpload = dict["DeleteAfterImageUpload"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("TargetOSSRegionId") {
            self.targetOSSRegionId = dict["TargetOSSRegionId"] as! String
        }
        if dict.keys.contains("WithDataDisks") {
            self.withDataDisks = dict["WithDataDisks"] as! Bool
        }
    }
}

public class CreateImageResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var size: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var size: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
        }
    }
    public var dataDisk: [CreateInstanceRequest.DataDisk]?

    public var systemDisk: CreateInstanceRequest.SystemDisk?

    public var autoRenew: String?

    public var autoRenewPeriod: String?

    public var ensRegionId: String?

    public var hostName: String?

    public var imageId: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var ipType: String?

    public var keyPairName: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var paymentType: String?

    public var period: String?

    public var privateIpAddress: String?

    public var publicIpIdentification: Bool?

    public var quantity: String?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.publicIpIdentification != nil {
            map["PublicIpIdentification"] = self.publicIpIdentification!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDisk") {
            var tmp : [CreateInstanceRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = CreateInstanceRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("SystemDisk") {
            var model = CreateInstanceRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! String
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("IpType") {
            self.ipType = dict["IpType"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("PublicIpIdentification") {
            self.publicIpIdentification = dict["PublicIpIdentification"] as! Bool
        }
        if dict.keys.contains("Quantity") {
            self.quantity = dict["Quantity"] as! String
        }
        if dict.keys.contains("UniqueSuffix") {
            self.uniqueSuffix = dict["UniqueSuffix"] as! Bool
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public class InstanceIds : Tea.TeaModel {
        public var instanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! [String]
            }
        }
    }
    public var code: Int32?

    public var instanceIds: CreateInstanceResponseBody.InstanceIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("InstanceIds") {
            var model = CreateInstanceResponseBody.InstanceIds()
            model.fromMap(dict["InstanceIds"] as! [String: Any])
            self.instanceIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceActiveOpsTaskRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class CreateInstanceActiveOpsTaskShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class CreateInstanceActiveOpsTaskResponseBody : Tea.TeaModel {
    public var instanceActiveOpsTask: InstanceActiveOpsTask?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceActiveOpsTask?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceActiveOpsTask != nil {
            map["InstanceActiveOpsTask"] = self.instanceActiveOpsTask?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceActiveOpsTask") {
            var model = InstanceActiveOpsTask()
            model.fromMap(dict["InstanceActiveOpsTask"] as! [String: Any])
            self.instanceActiveOpsTask = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateInstanceActiveOpsTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceActiveOpsTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateInstanceActiveOpsTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateKeyPairRequest : Tea.TeaModel {
    public var keyPairName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
    }
}

public class CreateKeyPairResponseBody : Tea.TeaModel {
    public var keyPairFingerPrint: String?

    public var keyPairId: String?

    public var keyPairName: String?

    public var privateKeyBody: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairId != nil {
            map["KeyPairId"] = self.keyPairId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.privateKeyBody != nil {
            map["PrivateKeyBody"] = self.privateKeyBody!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairFingerPrint") {
            self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
        }
        if dict.keys.contains("KeyPairId") {
            self.keyPairId = dict["KeyPairId"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("PrivateKeyBody") {
            self.privateKeyBody = dict["PrivateKeyBody"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateKeyPairResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ensRegionId: String?

    public var loadBalancerName: String?

    public var loadBalancerSpec: String?

    public var networkId: String?

    public var payType: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        if self.loadBalancerSpec != nil {
            map["LoadBalancerSpec"] = self.loadBalancerSpec!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
        if dict.keys.contains("LoadBalancerSpec") {
            self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateLoadBalancerResponseBody : Tea.TeaModel {
    public var loadBalancerId: String?

    public var loadBalancerName: String?

    public var networkId: String?

    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateLoadBalancerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLoadBalancerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerHTTPListenerRequest : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var description_: String?

    public var forwardPort: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerForward: String?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public var XForwardedFor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.forwardPort != nil {
            map["ForwardPort"] = self.forwardPort!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerForward != nil {
            map["ListenerForward"] = self.listenerForward!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        if self.XForwardedFor != nil {
            map["XForwardedFor"] = self.XForwardedFor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ForwardPort") {
            self.forwardPort = dict["ForwardPort"] as! Int32
        }
        if dict.keys.contains("HealthCheck") {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerForward") {
            self.listenerForward = dict["ListenerForward"] as! String
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("RequestTimeout") {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
        if dict.keys.contains("XForwardedFor") {
            self.XForwardedFor = dict["XForwardedFor"] as! String
        }
    }
}

public class CreateLoadBalancerHTTPListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLoadBalancerHTTPListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerHTTPListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLoadBalancerHTTPListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerHTTPSListenerRequest : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var cookie: String?

    public var cookieTimeout: Int32?

    public var description_: String?

    public var forwardPort: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerForward: String?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var stickySessionType: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.cookie != nil {
            map["Cookie"] = self.cookie!
        }
        if self.cookieTimeout != nil {
            map["CookieTimeout"] = self.cookieTimeout!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.forwardPort != nil {
            map["ForwardPort"] = self.forwardPort!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerForward != nil {
            map["ListenerForward"] = self.listenerForward!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.stickySessionType != nil {
            map["StickySessionType"] = self.stickySessionType!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Cookie") {
            self.cookie = dict["Cookie"] as! String
        }
        if dict.keys.contains("CookieTimeout") {
            self.cookieTimeout = dict["CookieTimeout"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ForwardPort") {
            self.forwardPort = dict["ForwardPort"] as! Int32
        }
        if dict.keys.contains("HealthCheck") {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerForward") {
            self.listenerForward = dict["ListenerForward"] as! String
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("RequestTimeout") {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("StickySessionType") {
            self.stickySessionType = dict["StickySessionType"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class CreateLoadBalancerHTTPSListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLoadBalancerHTTPSListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerHTTPSListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLoadBalancerHTTPSListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerTCPListenerRequest : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var description_: String?

    public var eipTransmit: String?

    public var establishedTimeout: Int32?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckType: String?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var persistenceTimeout: Int32?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.persistenceTimeout != nil {
            map["PersistenceTimeout"] = self.persistenceTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("EstablishedTimeout") {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckType") {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("PersistenceTimeout") {
            self.persistenceTimeout = dict["PersistenceTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class CreateLoadBalancerTCPListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLoadBalancerTCPListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerTCPListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLoadBalancerTCPListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLoadBalancerUDPListenerRequest : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var description_: String?

    public var eipTransmit: String?

    public var establishedTimeout: Int32?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckExp: String?

    public var healthCheckInterval: Int32?

    public var healthCheckReq: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckExp != nil {
            map["HealthCheckExp"] = self.healthCheckExp!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckReq != nil {
            map["HealthCheckReq"] = self.healthCheckReq!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("EstablishedTimeout") {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckExp") {
            self.healthCheckExp = dict["HealthCheckExp"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckReq") {
            self.healthCheckReq = dict["HealthCheckReq"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class CreateLoadBalancerUDPListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLoadBalancerUDPListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLoadBalancerUDPListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLoadBalancerUDPListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMountTargetRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public var mountTargetName: String?

    public var netWorkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.mountTargetName != nil {
            map["MountTargetName"] = self.mountTargetName!
        }
        if self.netWorkId != nil {
            map["NetWorkId"] = self.netWorkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("MountTargetName") {
            self.mountTargetName = dict["MountTargetName"] as! String
        }
        if dict.keys.contains("NetWorkId") {
            self.netWorkId = dict["NetWorkId"] as! String
        }
    }
}

public class CreateMountTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class CreateMountTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMountTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMountTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNatGatewayRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ensRegionId: String?

    public var instanceType: String?

    public var name: String?

    public var networkId: String?

    public var tag: [CreateNatGatewayRequest.Tag]?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateNatGatewayRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateNatGatewayRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateNatGatewayResponseBody : Tea.TeaModel {
    public var natGatewayId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNatGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var cidrBlock: String?

    public var description_: String?

    public var ensRegionId: String?

    public var networkName: String?

    public var tag: [CreateNetworkRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("NetworkName") {
            self.networkName = dict["NetworkName"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateNetworkRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateNetworkRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateNetworkResponseBody : Tea.TeaModel {
    public var networkId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkAclRequest : Tea.TeaModel {
    public var description_: String?

    public var networkAclName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NetworkAclName") {
            self.networkAclName = dict["NetworkAclName"] as! String
        }
    }
}

public class CreateNetworkAclResponseBody : Tea.TeaModel {
    public var networkAclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkAclEntryRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var direction: String?

    public var networkAclEntryName: String?

    public var networkAclId: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.networkAclEntryName != nil {
            map["NetworkAclEntryName"] = self.networkAclEntryName!
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("NetworkAclEntryName") {
            self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
    }
}

public class CreateNetworkAclEntryResponseBody : Tea.TeaModel {
    public var networkAclEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclEntryId != nil {
            map["NetworkAclEntryId"] = self.networkAclEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclEntryId") {
            self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkAclEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkAclEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkAclEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkInterfaceRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var securityGroupIds: [String]?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateNetworkInterfaceShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var securityGroupIdsShrink: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.securityGroupIdsShrink != nil {
            map["SecurityGroupIds"] = self.securityGroupIdsShrink!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIdsShrink = dict["SecurityGroupIds"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateNetworkInterfaceResponseBody : Tea.TeaModel {
    public var networkInterfaceIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceIds != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceIds") {
            self.networkInterfaceIds = dict["NetworkInterfaceIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSDGRequest : Tea.TeaModel {
    public var description_: String?

    public var fromSDGId: String?

    public var instanceId: String?

    public var size: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fromSDGId != nil {
            map["FromSDGId"] = self.fromSDGId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FromSDGId") {
            self.fromSDGId = dict["FromSDGId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! String
        }
    }
}

public class CreateSDGResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class CreateSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSecurityGroupRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var direction: String?

        public var ipProtocol: String?

        public var policy: String?

        public var portRange: String?

        public var priority: Int32?

        public var sourceCidrIp: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.direction != nil {
                map["Direction"] = self.direction!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestCidrIp") {
                self.destCidrIp = dict["DestCidrIp"] as! String
            }
            if dict.keys.contains("Direction") {
                self.direction = dict["Direction"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("SourceCidrIp") {
                self.sourceCidrIp = dict["SourceCidrIp"] as! String
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
        }
    }
    public var description_: String?

    public var permissions: [CreateSecurityGroupRequest.Permissions]?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Permissions") {
            var tmp : [CreateSecurityGroupRequest.Permissions] = []
            for v in dict["Permissions"] as! [Any] {
                var model = CreateSecurityGroupRequest.Permissions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.permissions = tmp
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class CreateSecurityGroupShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var permissionsShrink: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.permissionsShrink != nil {
            map["Permissions"] = self.permissionsShrink!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Permissions") {
            self.permissionsShrink = dict["Permissions"] as! String
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class CreateSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class CreateSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSnapshotRequest : Tea.TeaModel {
    public var description_: String?

    public var diskId: String?

    public var ensRegionId: String?

    public var snapshotName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("SnapshotName") {
            self.snapshotName = dict["SnapshotName"] as! String
        }
    }
}

public class CreateSnapshotResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public var snapShotId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapShotId != nil {
            map["SnapShotId"] = self.snapShotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapShotId") {
            self.snapShotId = dict["SnapShotId"] as! [String]
        }
    }
}

public class CreateSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSnatEntryRequest : Tea.TeaModel {
    public var eipAffinity: Bool?

    public var idleTimeout: Int32?

    public var ispAffinity: Bool?

    public var natGatewayId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public var sourceCIDR: String?

    public var sourceNetworkId: String?

    public var sourceVSwitchId: String?

    public var standbySnatIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipAffinity != nil {
            map["EipAffinity"] = self.eipAffinity!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.ispAffinity != nil {
            map["IspAffinity"] = self.ispAffinity!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.sourceCIDR != nil {
            map["SourceCIDR"] = self.sourceCIDR!
        }
        if self.sourceNetworkId != nil {
            map["SourceNetworkId"] = self.sourceNetworkId!
        }
        if self.sourceVSwitchId != nil {
            map["SourceVSwitchId"] = self.sourceVSwitchId!
        }
        if self.standbySnatIp != nil {
            map["StandbySnatIp"] = self.standbySnatIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipAffinity") {
            self.eipAffinity = dict["EipAffinity"] as! Bool
        }
        if dict.keys.contains("IdleTimeout") {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("IspAffinity") {
            self.ispAffinity = dict["IspAffinity"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("SnatEntryName") {
            self.snatEntryName = dict["SnatEntryName"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
        if dict.keys.contains("SourceCIDR") {
            self.sourceCIDR = dict["SourceCIDR"] as! String
        }
        if dict.keys.contains("SourceNetworkId") {
            self.sourceNetworkId = dict["SourceNetworkId"] as! String
        }
        if dict.keys.contains("SourceVSwitchId") {
            self.sourceVSwitchId = dict["SourceVSwitchId"] as! String
        }
        if dict.keys.contains("StandbySnatIp") {
            self.standbySnatIp = dict["StandbySnatIp"] as! String
        }
    }
}

public class CreateSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snatEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
    }
}

public class CreateSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateStorageGatewayRequest : Tea.TeaModel {
    public class OrderDetails : Tea.TeaModel {
        public var description_: String?

        public var ensRegionId: String?

        public var gatewayName: String?

        public var gatewayType: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.gatewayName != nil {
                map["GatewayName"] = self.gatewayName!
            }
            if self.gatewayType != nil {
                map["GatewayType"] = self.gatewayType!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("GatewayName") {
                self.gatewayName = dict["GatewayName"] as! String
            }
            if dict.keys.contains("GatewayType") {
                self.gatewayType = dict["GatewayType"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var orderDetails: [CreateStorageGatewayRequest.OrderDetails]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderDetails != nil {
            var tmp : [Any] = []
            for k in self.orderDetails! {
                tmp.append(k.toMap())
            }
            map["OrderDetails"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderDetails") {
            var tmp : [CreateStorageGatewayRequest.OrderDetails] = []
            for v in dict["OrderDetails"] as! [Any] {
                var model = CreateStorageGatewayRequest.OrderDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orderDetails = tmp
        }
    }
}

public class CreateStorageGatewayShrinkRequest : Tea.TeaModel {
    public var orderDetailsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderDetailsShrink != nil {
            map["OrderDetails"] = self.orderDetailsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderDetails") {
            self.orderDetailsShrink = dict["OrderDetails"] as! String
        }
    }
}

public class CreateStorageGatewayResponseBody : Tea.TeaModel {
    public class AllocationId : Tea.TeaModel {
        public var ensRegionId: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public class UnAllocationId : Tea.TeaModel {
        public var ensRegionId: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public var allocationId: [CreateStorageGatewayResponseBody.AllocationId]?

    public var bizStatusCode: String?

    public var requestId: String?

    public var unAllocationId: [CreateStorageGatewayResponseBody.UnAllocationId]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            var tmp : [Any] = []
            for k in self.allocationId! {
                tmp.append(k.toMap())
            }
            map["AllocationId"] = tmp
        }
        if self.bizStatusCode != nil {
            map["BizStatusCode"] = self.bizStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.unAllocationId != nil {
            var tmp : [Any] = []
            for k in self.unAllocationId! {
                tmp.append(k.toMap())
            }
            map["UnAllocationId"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            var tmp : [CreateStorageGatewayResponseBody.AllocationId] = []
            for v in dict["AllocationId"] as! [Any] {
                var model = CreateStorageGatewayResponseBody.AllocationId()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.allocationId = tmp
        }
        if dict.keys.contains("BizStatusCode") {
            self.bizStatusCode = dict["BizStatusCode"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UnAllocationId") {
            var tmp : [CreateStorageGatewayResponseBody.UnAllocationId] = []
            for v in dict["UnAllocationId"] as! [Any] {
                var model = CreateStorageGatewayResponseBody.UnAllocationId()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.unAllocationId = tmp
        }
    }
}

public class CreateStorageGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStorageGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateStorageGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateStorageVolumeRequest : Tea.TeaModel {
    public var authPassword: String?

    public var authProtocol: String?

    public var authUser: String?

    public var description_: String?

    public var ensRegionId: String?

    public var gatewayId: String?

    public var isAuth: String?

    public var isEnable: String?

    public var storageId: String?

    public var volumeName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authPassword != nil {
            map["AuthPassword"] = self.authPassword!
        }
        if self.authProtocol != nil {
            map["AuthProtocol"] = self.authProtocol!
        }
        if self.authUser != nil {
            map["AuthUser"] = self.authUser!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.isAuth != nil {
            map["IsAuth"] = self.isAuth!
        }
        if self.isEnable != nil {
            map["IsEnable"] = self.isEnable!
        }
        if self.storageId != nil {
            map["StorageId"] = self.storageId!
        }
        if self.volumeName != nil {
            map["VolumeName"] = self.volumeName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthPassword") {
            self.authPassword = dict["AuthPassword"] as! String
        }
        if dict.keys.contains("AuthProtocol") {
            self.authProtocol = dict["AuthProtocol"] as! String
        }
        if dict.keys.contains("AuthUser") {
            self.authUser = dict["AuthUser"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! String
        }
        if dict.keys.contains("IsAuth") {
            self.isAuth = dict["IsAuth"] as! String
        }
        if dict.keys.contains("IsEnable") {
            self.isEnable = dict["IsEnable"] as! String
        }
        if dict.keys.contains("StorageId") {
            self.storageId = dict["StorageId"] as! String
        }
        if dict.keys.contains("VolumeName") {
            self.volumeName = dict["VolumeName"] as! String
        }
    }
}

public class CreateStorageVolumeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var volumeId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.volumeId != nil {
            map["VolumeId"] = self.volumeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VolumeId") {
            self.volumeId = dict["VolumeId"] as! [String]
        }
    }
}

public class CreateStorageVolumeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStorageVolumeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateStorageVolumeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVSwitchRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var cidrBlock: String?

    public var description_: String?

    public var ensRegionId: String?

    public var networkId: String?

    public var tag: [CreateVSwitchRequest.Tag]?

    public var vSwitchName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateVSwitchRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateVSwitchRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
    }
}

public class CreateVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class DeleteApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBucketRequest : Tea.TeaModel {
    public var bucketName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
    }
}

public class DeleteBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBucketLifecycleRequest : Tea.TeaModel {
    public var bucketName: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class DeleteBucketLifecycleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBucketLifecycleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBucketLifecycleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBucketLifecycleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
    }
}

public class DeleteDiskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEipRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteEipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnsRouteEntryRequest : Tea.TeaModel {
    public var routeEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RouteEntryId") {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
    }
}

public class DeleteEnsRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnsRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnsRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEnsRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnsSaleConditionControlRequest : Tea.TeaModel {
    public class SaleControls : Tea.TeaModel {
        public class ConditionControls : Tea.TeaModel {
            public var conditionControlModuleCode: String?

            public var conditionControlModuleValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conditionControlModuleCode != nil {
                    map["ConditionControlModuleCode"] = self.conditionControlModuleCode!
                }
                if self.conditionControlModuleValue != nil {
                    map["ConditionControlModuleValue"] = self.conditionControlModuleValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConditionControlModuleCode") {
                    self.conditionControlModuleCode = dict["ConditionControlModuleCode"] as! String
                }
                if dict.keys.contains("ConditionControlModuleValue") {
                    self.conditionControlModuleValue = dict["ConditionControlModuleValue"] as! String
                }
            }
        }
        public var conditionControls: [DeleteEnsSaleConditionControlRequest.SaleControls.ConditionControls]?

        public var moduleCode: String?

        public var orderType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditionControls != nil {
                var tmp : [Any] = []
                for k in self.conditionControls! {
                    tmp.append(k.toMap())
                }
                map["ConditionControls"] = tmp
            }
            if self.moduleCode != nil {
                map["ModuleCode"] = self.moduleCode!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConditionControls") {
                var tmp : [DeleteEnsSaleConditionControlRequest.SaleControls.ConditionControls] = []
                for v in dict["ConditionControls"] as! [Any] {
                    var model = DeleteEnsSaleConditionControlRequest.SaleControls.ConditionControls()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditionControls = tmp
            }
            if dict.keys.contains("ModuleCode") {
                self.moduleCode = dict["ModuleCode"] as! String
            }
            if dict.keys.contains("OrderType") {
                self.orderType = dict["OrderType"] as! String
            }
        }
    }
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var saleControls: [DeleteEnsSaleConditionControlRequest.SaleControls]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.saleControls != nil {
            var tmp : [Any] = []
            for k in self.saleControls! {
                tmp.append(k.toMap())
            }
            map["SaleControls"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("SaleControls") {
            var tmp : [DeleteEnsSaleConditionControlRequest.SaleControls] = []
            for v in dict["SaleControls"] as! [Any] {
                var model = DeleteEnsSaleConditionControlRequest.SaleControls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.saleControls = tmp
        }
    }
}

public class DeleteEnsSaleConditionControlShrinkRequest : Tea.TeaModel {
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var saleControlsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.saleControlsShrink != nil {
            map["SaleControls"] = self.saleControlsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("SaleControls") {
            self.saleControlsShrink = dict["SaleControls"] as! String
        }
    }
}

public class DeleteEnsSaleConditionControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnsSaleConditionControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnsSaleConditionControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEnsSaleConditionControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEnsSaleControlRequest : Tea.TeaModel {
    public class SaleControls : Tea.TeaModel {
        public var moduleCode: String?

        public var orderType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.moduleCode != nil {
                map["ModuleCode"] = self.moduleCode!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModuleCode") {
                self.moduleCode = dict["ModuleCode"] as! String
            }
            if dict.keys.contains("OrderType") {
                self.orderType = dict["OrderType"] as! String
            }
        }
    }
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var saleControls: [DeleteEnsSaleControlRequest.SaleControls]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.saleControls != nil {
            var tmp : [Any] = []
            for k in self.saleControls! {
                tmp.append(k.toMap())
            }
            map["SaleControls"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("SaleControls") {
            var tmp : [DeleteEnsSaleControlRequest.SaleControls] = []
            for v in dict["SaleControls"] as! [Any] {
                var model = DeleteEnsSaleControlRequest.SaleControls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.saleControls = tmp
        }
    }
}

public class DeleteEnsSaleControlShrinkRequest : Tea.TeaModel {
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var saleControlsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.saleControlsShrink != nil {
            map["SaleControls"] = self.saleControlsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("SaleControls") {
            self.saleControlsShrink = dict["SaleControls"] as! String
        }
    }
}

public class DeleteEnsSaleControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEnsSaleControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEnsSaleControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEnsSaleControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
    }
}

public class DeleteEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFileSystemRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
    }
}

public class DeleteFileSystemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFileSystemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFileSystemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFileSystemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteForwardEntryRequest : Tea.TeaModel {
    public var forwardEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
    }
}

public class DeleteForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHaVipsRequest : Tea.TeaModel {
    public var haVipIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipIds != nil {
            map["HaVipIds"] = self.haVipIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVipIds") {
            self.haVipIds = dict["HaVipIds"] as! [String]
        }
    }
}

public class DeleteHaVipsShrinkRequest : Tea.TeaModel {
    public var haVipIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipIdsShrink != nil {
            map["HaVipIds"] = self.haVipIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVipIds") {
            self.haVipIdsShrink = dict["HaVipIds"] as! String
        }
    }
}

public class DeleteHaVipsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteHaVipsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHaVipsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteHaVipsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImageRequest : Tea.TeaModel {
    public var imageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
    }
}

public class DeleteImageResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteKeyPairsRequest : Tea.TeaModel {
    public var keyPairId: String?

    public var keyPairName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairId != nil {
            map["KeyPairId"] = self.keyPairId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairId") {
            self.keyPairId = dict["KeyPairId"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
    }
}

public class DeleteKeyPairsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteKeyPairsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteKeyPairsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteKeyPairsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLoadBalancerListenerRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("ListenerProtocol") {
            self.listenerProtocol = dict["ListenerProtocol"] as! String
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DeleteLoadBalancerListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLoadBalancerListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLoadBalancerListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLoadBalancerListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMountTargetRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public var mountTargetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.mountTargetName != nil {
            map["MountTargetName"] = self.mountTargetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("MountTargetName") {
            self.mountTargetName = dict["MountTargetName"] as! String
        }
    }
}

public class DeleteMountTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMountTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMountTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMountTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNatGatewayRequest : Tea.TeaModel {
    public var forceDelete: Bool?

    public var natGatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceDelete != nil {
            map["ForceDelete"] = self.forceDelete!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceDelete") {
            self.forceDelete = dict["ForceDelete"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
    }
}

public class DeleteNatGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNatGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkRequest : Tea.TeaModel {
    public var networkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
    }
}

public class DeleteNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkAclRequest : Tea.TeaModel {
    public var networkAclId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
    }
}

public class DeleteNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkAclEntryRequest : Tea.TeaModel {
    public var networkAclEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclEntryId != nil {
            map["NetworkAclEntryId"] = self.networkAclEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclEntryId") {
            self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
        }
    }
}

public class DeleteNetworkAclEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkAclEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkAclEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkAclEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkInterfacesRequest : Tea.TeaModel {
    public var networkInterfaceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceIds != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceIds") {
            self.networkInterfaceIds = dict["NetworkInterfaceIds"] as! [String]
        }
    }
}

public class DeleteNetworkInterfacesShrinkRequest : Tea.TeaModel {
    public var networkInterfaceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceIdsShrink != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceIds") {
            self.networkInterfaceIdsShrink = dict["NetworkInterfaceIds"] as! String
        }
    }
}

public class DeleteNetworkInterfacesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkInterfacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteObjectRequest : Tea.TeaModel {
    public var bucketName: String?

    public var objectKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.objectKey != nil {
            map["ObjectKey"] = self.objectKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("ObjectKey") {
            self.objectKey = dict["ObjectKey"] as! String
        }
    }
}

public class DeleteObjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteObjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteObjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteObjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSDGRequest : Tea.TeaModel {
    public var SDGId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! [String]
        }
    }
}

public class DeleteSDGShrinkRequest : Tea.TeaModel {
    public var SDGIdShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.SDGIdShrink != nil {
            map["SDGId"] = self.SDGIdShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SDGId") {
            self.SDGIdShrink = dict["SDGId"] as! String
        }
    }
}

public class DeleteSDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public class Item : Tea.TeaModel {
                    public var sdgId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.sdgId != nil {
                            map["SdgId"] = self.sdgId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SdgId") {
                            self.sdgId = dict["SdgId"] as! String
                        }
                    }
                }
                public var errMessage: String?

                public var item: DeleteSDGResponseBody.Data.Result.FailedItems.Item?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.item?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMessage != nil {
                        map["ErrMessage"] = self.errMessage!
                    }
                    if self.item != nil {
                        map["Item"] = self.item?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMessage") {
                        self.errMessage = dict["ErrMessage"] as! String
                    }
                    if dict.keys.contains("Item") {
                        var model = DeleteSDGResponseBody.Data.Result.FailedItems.Item()
                        model.fromMap(dict["Item"] as! [String: Any])
                        self.item = model
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [DeleteSDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [DeleteSDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = DeleteSDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: DeleteSDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = DeleteSDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: DeleteSDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeleteSDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSecurityGroupRequest : Tea.TeaModel {
    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class DeleteSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnapshotRequest : Tea.TeaModel {
    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class DeleteSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnatEntryRequest : Tea.TeaModel {
    public var snatEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
    }
}

public class DeleteSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnatIpForSnatEntryRequest : Tea.TeaModel {
    public var snatEntryId: String?

    public var snatIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
    }
}

public class DeleteSnatIpForSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSnatIpForSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnatIpForSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnatIpForSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStorageGatewayRequest : Tea.TeaModel {
    public var gatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! String
        }
    }
}

public class DeleteStorageGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteStorageGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStorageGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteStorageGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStorageVolumeRequest : Tea.TeaModel {
    public var volumeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.volumeId != nil {
            map["VolumeId"] = self.volumeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VolumeId") {
            self.volumeId = dict["VolumeId"] as! String
        }
    }
}

public class DeleteStorageVolumeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteStorageVolumeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStorageVolumeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteStorageVolumeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVSwitchRequest : Tea.TeaModel {
    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DeleteVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeployInstanceSDGRequest : Tea.TeaModel {
    public var deploymentType: String?

    public var instanceIds: [String]?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentType != nil {
            map["DeploymentType"] = self.deploymentType!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentType") {
            self.deploymentType = dict["DeploymentType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class DeployInstanceSDGShrinkRequest : Tea.TeaModel {
    public var deploymentType: String?

    public var instanceIdsShrink: String?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentType != nil {
            map["DeploymentType"] = self.deploymentType!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentType") {
            self.deploymentType = dict["DeploymentType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class DeployInstanceSDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var errMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMessage != nil {
                        map["ErrMessage"] = self.errMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMessage") {
                        self.errMessage = dict["ErrMessage"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [DeployInstanceSDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [DeployInstanceSDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = DeployInstanceSDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: DeployInstanceSDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = DeployInstanceSDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: DeployInstanceSDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeployInstanceSDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeployInstanceSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployInstanceSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeployInstanceSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeploySDGRequest : Tea.TeaModel {
    public var deploymentType: String?

    public var instanceIds: [String]?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentType != nil {
            map["DeploymentType"] = self.deploymentType!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentType") {
            self.deploymentType = dict["DeploymentType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class DeploySDGShrinkRequest : Tea.TeaModel {
    public var deploymentType: String?

    public var instanceIdsShrink: String?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentType != nil {
            map["DeploymentType"] = self.deploymentType!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentType") {
            self.deploymentType = dict["DeploymentType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class DeploySDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var errMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMessage != nil {
                        map["ErrMessage"] = self.errMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMessage") {
                        self.errMessage = dict["ErrMessage"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [DeploySDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [DeploySDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = DeploySDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: DeploySDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = DeploySDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: DeploySDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DeploySDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeploySDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeploySDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeploySDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAICImagesRequest : Tea.TeaModel {
    public var description_: String?

    public var imageId: String?

    public var imageType: String?

    public var imageUrl: String?

    public var maxDate: String?

    public var minDate: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageType != nil {
            map["ImageType"] = self.imageType!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageType") {
            self.imageType = dict["ImageType"] as! String
        }
        if dict.keys.contains("ImageUrl") {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("MaxDate") {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeAICImagesResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public var creationTime: String?

        public var description_: String?

        public var imageId: String?

        public var imageUrl: String?

        public var status: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageUrl") {
                self.imageUrl = dict["ImageUrl"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var images: [DescribeAICImagesResponseBody.Images]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            var tmp : [Any] = []
            for k in self.images! {
                tmp.append(k.toMap())
            }
            map["Images"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Images") {
            var tmp : [DescribeAICImagesResponseBody.Images] = []
            for v in dict["Images"] as! [Any] {
                var model = DescribeAICImagesResponseBody.Images()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.images = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAICImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAICImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAICImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeARMServerInstancesRequest : Tea.TeaModel {
    public var AICSpecs: [String]?

    public var describeAICInstances: Bool?

    public var ensRegionIds: [String]?

    public var maxDate: String?

    public var minDate: String?

    public var name: String?

    public var namespace: String?

    public var orderByParams: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var serverIds: [String]?

    public var serverSpecs: [String]?

    public var states: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AICSpecs != nil {
            map["AICSpecs"] = self.AICSpecs!
        }
        if self.describeAICInstances != nil {
            map["DescribeAICInstances"] = self.describeAICInstances!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serverIds != nil {
            map["ServerIds"] = self.serverIds!
        }
        if self.serverSpecs != nil {
            map["ServerSpecs"] = self.serverSpecs!
        }
        if self.states != nil {
            map["States"] = self.states!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AICSpecs") {
            self.AICSpecs = dict["AICSpecs"] as! [String]
        }
        if dict.keys.contains("DescribeAICInstances") {
            self.describeAICInstances = dict["DescribeAICInstances"] as! Bool
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("MaxDate") {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("OrderByParams") {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServerIds") {
            self.serverIds = dict["ServerIds"] as! [String]
        }
        if dict.keys.contains("ServerSpecs") {
            self.serverSpecs = dict["ServerSpecs"] as! [String]
        }
        if dict.keys.contains("States") {
            self.states = dict["States"] as! [String]
        }
    }
}

public class DescribeARMServerInstancesShrinkRequest : Tea.TeaModel {
    public var AICSpecsShrink: String?

    public var describeAICInstances: Bool?

    public var ensRegionIdsShrink: String?

    public var maxDate: String?

    public var minDate: String?

    public var name: String?

    public var namespace: String?

    public var orderByParams: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var serverIdsShrink: String?

    public var serverSpecsShrink: String?

    public var statesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.AICSpecsShrink != nil {
            map["AICSpecs"] = self.AICSpecsShrink!
        }
        if self.describeAICInstances != nil {
            map["DescribeAICInstances"] = self.describeAICInstances!
        }
        if self.ensRegionIdsShrink != nil {
            map["EnsRegionIds"] = self.ensRegionIdsShrink!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serverIdsShrink != nil {
            map["ServerIds"] = self.serverIdsShrink!
        }
        if self.serverSpecsShrink != nil {
            map["ServerSpecs"] = self.serverSpecsShrink!
        }
        if self.statesShrink != nil {
            map["States"] = self.statesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AICSpecs") {
            self.AICSpecsShrink = dict["AICSpecs"] as! String
        }
        if dict.keys.contains("DescribeAICInstances") {
            self.describeAICInstances = dict["DescribeAICInstances"] as! Bool
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIdsShrink = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("MaxDate") {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("OrderByParams") {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServerIds") {
            self.serverIdsShrink = dict["ServerIds"] as! String
        }
        if dict.keys.contains("ServerSpecs") {
            self.serverSpecsShrink = dict["ServerSpecs"] as! String
        }
        if dict.keys.contains("States") {
            self.statesShrink = dict["States"] as! String
        }
    }
}

public class DescribeARMServerInstancesResponseBody : Tea.TeaModel {
    public class Servers : Tea.TeaModel {
        public class AICInstances : Tea.TeaModel {
            public class NetworkAttributes : Tea.TeaModel {
                public var ipAddress: String?

                public var networkId: String?

                public var vSwitchId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    if self.networkId != nil {
                        map["NetworkId"] = self.networkId!
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpAddress") {
                        self.ipAddress = dict["IpAddress"] as! String
                    }
                    if dict.keys.contains("NetworkId") {
                        self.networkId = dict["NetworkId"] as! String
                    }
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! String
                    }
                }
            }
            public class SdgDeployInfo : Tea.TeaModel {
                public var SDGId: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.SDGId != nil {
                        map["SDGId"] = self.SDGId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SDGId") {
                        self.SDGId = dict["SDGId"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var frequency: Int64?

            public var imageId: String?

            public var instanceId: String?

            public var latestAction: String?

            public var name: String?

            public var networkAttributes: DescribeARMServerInstancesResponseBody.Servers.AICInstances.NetworkAttributes?

            public var resolution: String?

            public var sdgDeployInfo: DescribeARMServerInstancesResponseBody.Servers.AICInstances.SdgDeployInfo?

            public var spec: String?

            public var state: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.networkAttributes?.validate()
                try self.sdgDeployInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.frequency != nil {
                    map["Frequency"] = self.frequency!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.latestAction != nil {
                    map["LatestAction"] = self.latestAction!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.networkAttributes != nil {
                    map["NetworkAttributes"] = self.networkAttributes?.toMap()
                }
                if self.resolution != nil {
                    map["Resolution"] = self.resolution!
                }
                if self.sdgDeployInfo != nil {
                    map["SdgDeployInfo"] = self.sdgDeployInfo?.toMap()
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Frequency") {
                    self.frequency = dict["Frequency"] as! Int64
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LatestAction") {
                    self.latestAction = dict["LatestAction"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NetworkAttributes") {
                    var model = DescribeARMServerInstancesResponseBody.Servers.AICInstances.NetworkAttributes()
                    model.fromMap(dict["NetworkAttributes"] as! [String: Any])
                    self.networkAttributes = model
                }
                if dict.keys.contains("Resolution") {
                    self.resolution = dict["Resolution"] as! String
                }
                if dict.keys.contains("SdgDeployInfo") {
                    var model = DescribeARMServerInstancesResponseBody.Servers.AICInstances.SdgDeployInfo()
                    model.fromMap(dict["SdgDeployInfo"] as! [String: Any])
                    self.sdgDeployInfo = model
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var AICInstances: [DescribeARMServerInstancesResponseBody.Servers.AICInstances]?

        public var creationTime: String?

        public var ensRegionId: String?

        public var expiredTime: String?

        public var latestAction: String?

        public var name: String?

        public var namespace: String?

        public var payType: String?

        public var serverId: String?

        public var specName: String?

        public var state: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.AICInstances != nil {
                var tmp : [Any] = []
                for k in self.AICInstances! {
                    tmp.append(k.toMap())
                }
                map["AICInstances"] = tmp
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.latestAction != nil {
                map["LatestAction"] = self.latestAction!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.specName != nil {
                map["SpecName"] = self.specName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AICInstances") {
                var tmp : [DescribeARMServerInstancesResponseBody.Servers.AICInstances] = []
                for v in dict["AICInstances"] as! [Any] {
                    var model = DescribeARMServerInstancesResponseBody.Servers.AICInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.AICInstances = tmp
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("LatestAction") {
                self.latestAction = dict["LatestAction"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("ServerId") {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("SpecName") {
                self.specName = dict["SpecName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var servers: [DescribeARMServerInstancesResponseBody.Servers]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.servers != nil {
            var tmp : [Any] = []
            for k in self.servers! {
                tmp.append(k.toMap())
            }
            map["Servers"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Servers") {
            var tmp : [DescribeARMServerInstancesResponseBody.Servers] = []
            for v in dict["Servers"] as! [Any] {
                var model = DescribeARMServerInstancesResponseBody.Servers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.servers = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeARMServerInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeARMServerInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeARMServerInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var appVersions: String?

    public var level: String?

    public var outDetailStatParams: String?

    public var resourceSelector: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appVersions != nil {
            map["AppVersions"] = self.appVersions!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.outDetailStatParams != nil {
            map["OutDetailStatParams"] = self.outDetailStatParams!
        }
        if self.resourceSelector != nil {
            map["ResourceSelector"] = self.resourceSelector!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppVersions") {
            self.appVersions = dict["AppVersions"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("OutDetailStatParams") {
            self.outDetailStatParams = dict["OutDetailStatParams"] as! String
        }
        if dict.keys.contains("ResourceSelector") {
            self.resourceSelector = dict["ResourceSelector"] as! String
        }
    }
}

public class DescribeApplicationResponseBody : Tea.TeaModel {
    public var application: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.application != nil {
            map["Application"] = self.application!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Application") {
            self.application = dict["Application"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvailableResourceResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var imageId: String?

            public var imageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") {
                    self.imageName = dict["ImageName"] as! String
                }
            }
        }
        public var image: [DescribeAvailableResourceResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") {
                var tmp : [DescribeAvailableResourceResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeAvailableResourceResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public var dataDiskSize: String?

            public var ensRegionId: String?

            public var instanceSpec: String?

            public var supportResourcesCount: String?

            public var systemDiskSize: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataDiskSize != nil {
                    map["DataDiskSize"] = self.dataDiskSize!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceSpec != nil {
                    map["InstanceSpec"] = self.instanceSpec!
                }
                if self.supportResourcesCount != nil {
                    map["SupportResourcesCount"] = self.supportResourcesCount!
                }
                if self.systemDiskSize != nil {
                    map["SystemDiskSize"] = self.systemDiskSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataDiskSize") {
                    self.dataDiskSize = dict["DataDiskSize"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceSpec") {
                    self.instanceSpec = dict["InstanceSpec"] as! String
                }
                if dict.keys.contains("SupportResourcesCount") {
                    self.supportResourcesCount = dict["SupportResourcesCount"] as! String
                }
                if dict.keys.contains("SystemDiskSize") {
                    self.systemDiskSize = dict["SystemDiskSize"] as! String
                }
            }
        }
        public var supportResource: [DescribeAvailableResourceResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") {
                var tmp : [DescribeAvailableResourceResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeAvailableResourceResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeAvailableResourceResponseBody.Images?

    public var requestId: String?

    public var supportResources: DescribeAvailableResourceResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") {
            var model = DescribeAvailableResourceResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") {
            var model = DescribeAvailableResourceResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeAvailableResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAvailableResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvailableResourceInfoResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var imageId: String?

            public var imageName: String?

            public var imageSize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageSize != nil {
                    map["ImageSize"] = self.imageSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImageSize") {
                    self.imageSize = dict["ImageSize"] as! Int32
                }
            }
        }
        public var image: [DescribeAvailableResourceInfoResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") {
                var tmp : [DescribeAvailableResourceInfoResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeAvailableResourceInfoResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public class BandwidthTypes : Tea.TeaModel {
                public var bandwidthType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandwidthType != nil {
                        map["BandwidthType"] = self.bandwidthType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BandwidthType") {
                        self.bandwidthType = dict["BandwidthType"] as! [String]
                    }
                }
            }
            public class EnsRegionIds : Tea.TeaModel {
                public var ensRegionId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ensRegionId != nil {
                        map["EnsRegionId"] = self.ensRegionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnsRegionId") {
                        self.ensRegionId = dict["EnsRegionId"] as! [String]
                    }
                }
            }
            public class EnsRegionIdsExtends : Tea.TeaModel {
                public class EnsRegionId : Tea.TeaModel {
                    public var area: String?

                    public var enName: String?

                    public var ensRegionId: String?

                    public var isp: String?

                    public var name: String?

                    public var province: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.area != nil {
                            map["Area"] = self.area!
                        }
                        if self.enName != nil {
                            map["EnName"] = self.enName!
                        }
                        if self.ensRegionId != nil {
                            map["EnsRegionId"] = self.ensRegionId!
                        }
                        if self.isp != nil {
                            map["Isp"] = self.isp!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.province != nil {
                            map["Province"] = self.province!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Area") {
                            self.area = dict["Area"] as! String
                        }
                        if dict.keys.contains("EnName") {
                            self.enName = dict["EnName"] as! String
                        }
                        if dict.keys.contains("EnsRegionId") {
                            self.ensRegionId = dict["EnsRegionId"] as! String
                        }
                        if dict.keys.contains("Isp") {
                            self.isp = dict["Isp"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Province") {
                            self.province = dict["Province"] as! String
                        }
                    }
                }
                public var ensRegionId: [DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends.EnsRegionId]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ensRegionId != nil {
                        var tmp : [Any] = []
                        for k in self.ensRegionId! {
                            tmp.append(k.toMap())
                        }
                        map["EnsRegionId"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnsRegionId") {
                        var tmp : [DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends.EnsRegionId] = []
                        for v in dict["EnsRegionId"] as! [Any] {
                            var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends.EnsRegionId()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ensRegionId = tmp
                    }
                }
            }
            public class InstanceSpeces : Tea.TeaModel {
                public var instanceSpec: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceSpec != nil {
                        map["InstanceSpec"] = self.instanceSpec!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceSpec") {
                        self.instanceSpec = dict["InstanceSpec"] as! [String]
                    }
                }
            }
            public class Isp : Tea.TeaModel {
                public var isp: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isp != nil {
                        map["Isp"] = self.isp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Isp") {
                        self.isp = dict["Isp"] as! [String]
                    }
                }
            }
            public var bandwidthTypes: DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.BandwidthTypes?

            public var dataDiskMaxSize: Int32?

            public var dataDiskMinSize: Int32?

            public var ensRegionIds: DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIds?

            public var ensRegionIdsExtends: DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends?

            public var instanceSpeces: DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.InstanceSpeces?

            public var isp: DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.Isp?

            public var systemDiskMaxSize: Int32?

            public var systemDiskMinSize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bandwidthTypes?.validate()
                try self.ensRegionIds?.validate()
                try self.ensRegionIdsExtends?.validate()
                try self.instanceSpeces?.validate()
                try self.isp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidthTypes != nil {
                    map["BandwidthTypes"] = self.bandwidthTypes?.toMap()
                }
                if self.dataDiskMaxSize != nil {
                    map["DataDiskMaxSize"] = self.dataDiskMaxSize!
                }
                if self.dataDiskMinSize != nil {
                    map["DataDiskMinSize"] = self.dataDiskMinSize!
                }
                if self.ensRegionIds != nil {
                    map["EnsRegionIds"] = self.ensRegionIds?.toMap()
                }
                if self.ensRegionIdsExtends != nil {
                    map["EnsRegionIdsExtends"] = self.ensRegionIdsExtends?.toMap()
                }
                if self.instanceSpeces != nil {
                    map["InstanceSpeces"] = self.instanceSpeces?.toMap()
                }
                if self.isp != nil {
                    map["Isp"] = self.isp?.toMap()
                }
                if self.systemDiskMaxSize != nil {
                    map["SystemDiskMaxSize"] = self.systemDiskMaxSize!
                }
                if self.systemDiskMinSize != nil {
                    map["SystemDiskMinSize"] = self.systemDiskMinSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandwidthTypes") {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.BandwidthTypes()
                    model.fromMap(dict["BandwidthTypes"] as! [String: Any])
                    self.bandwidthTypes = model
                }
                if dict.keys.contains("DataDiskMaxSize") {
                    self.dataDiskMaxSize = dict["DataDiskMaxSize"] as! Int32
                }
                if dict.keys.contains("DataDiskMinSize") {
                    self.dataDiskMinSize = dict["DataDiskMinSize"] as! Int32
                }
                if dict.keys.contains("EnsRegionIds") {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIds()
                    model.fromMap(dict["EnsRegionIds"] as! [String: Any])
                    self.ensRegionIds = model
                }
                if dict.keys.contains("EnsRegionIdsExtends") {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.EnsRegionIdsExtends()
                    model.fromMap(dict["EnsRegionIdsExtends"] as! [String: Any])
                    self.ensRegionIdsExtends = model
                }
                if dict.keys.contains("InstanceSpeces") {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.InstanceSpeces()
                    model.fromMap(dict["InstanceSpeces"] as! [String: Any])
                    self.instanceSpeces = model
                }
                if dict.keys.contains("Isp") {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource.Isp()
                    model.fromMap(dict["Isp"] as! [String: Any])
                    self.isp = model
                }
                if dict.keys.contains("SystemDiskMaxSize") {
                    self.systemDiskMaxSize = dict["SystemDiskMaxSize"] as! Int32
                }
                if dict.keys.contains("SystemDiskMinSize") {
                    self.systemDiskMinSize = dict["SystemDiskMinSize"] as! Int32
                }
            }
        }
        public var supportResource: [DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") {
                var tmp : [DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeAvailableResourceInfoResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var images: DescribeAvailableResourceInfoResponseBody.Images?

    public var requestId: String?

    public var supportResources: DescribeAvailableResourceInfoResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Images") {
            var model = DescribeAvailableResourceInfoResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") {
            var model = DescribeAvailableResourceInfoResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeAvailableResourceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableResourceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAvailableResourceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBandWithdChargeTypeResponseBody : Tea.TeaModel {
    public var bandWithTypeInfo: String?

    public var chargeContractType: String?

    public var chargeCycleInfo: String?

    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandWithTypeInfo != nil {
            map["BandWithTypeInfo"] = self.bandWithTypeInfo!
        }
        if self.chargeContractType != nil {
            map["ChargeContractType"] = self.chargeContractType!
        }
        if self.chargeCycleInfo != nil {
            map["ChargeCycleInfo"] = self.chargeCycleInfo!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandWithTypeInfo") {
            self.bandWithTypeInfo = dict["BandWithTypeInfo"] as! String
        }
        if dict.keys.contains("ChargeContractType") {
            self.chargeContractType = dict["ChargeContractType"] as! String
        }
        if dict.keys.contains("ChargeCycleInfo") {
            self.chargeCycleInfo = dict["ChargeCycleInfo"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBandWithdChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandWithdChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBandWithdChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBandwitdhByInternetChargeTypeRequest : Tea.TeaModel {
    public var endTime: String?

    public var ensRegionId: String?

    public var isp: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeBandwitdhByInternetChargeTypeResponseBody : Tea.TeaModel {
    public var bandwidthValue: Int64?

    public var internetChargeType: String?

    public var requestId: String?

    public var timeStamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthValue != nil {
            map["BandwidthValue"] = self.bandwidthValue!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthValue") {
            self.bandwidthValue = dict["BandwidthValue"] as! Int64
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeStamp") {
            self.timeStamp = dict["TimeStamp"] as! String
        }
    }
}

public class DescribeBandwitdhByInternetChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandwitdhByInternetChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBandwitdhByInternetChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudDiskAvailableResourceInfoResponseBody : Tea.TeaModel {
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public class Ability : Tea.TeaModel {
                public var ability: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ability != nil {
                        map["Ability"] = self.ability!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ability") {
                        self.ability = dict["Ability"] as! [String]
                    }
                }
            }
            public var ability: DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources.SupportResource.Ability?

            public var canBuyCount: Int64?

            public var category: String?

            public var defaultDiskSize: Int64?

            public var diskMaxSize: Int64?

            public var diskMinSize: Int64?

            public var ensRegionId: String?

            public var ensRegionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ability?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ability != nil {
                    map["Ability"] = self.ability?.toMap()
                }
                if self.canBuyCount != nil {
                    map["CanBuyCount"] = self.canBuyCount!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.defaultDiskSize != nil {
                    map["DefaultDiskSize"] = self.defaultDiskSize!
                }
                if self.diskMaxSize != nil {
                    map["DiskMaxSize"] = self.diskMaxSize!
                }
                if self.diskMinSize != nil {
                    map["DiskMinSize"] = self.diskMinSize!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.ensRegionName != nil {
                    map["EnsRegionName"] = self.ensRegionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ability") {
                    var model = DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources.SupportResource.Ability()
                    model.fromMap(dict["Ability"] as! [String: Any])
                    self.ability = model
                }
                if dict.keys.contains("CanBuyCount") {
                    self.canBuyCount = dict["CanBuyCount"] as! Int64
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("DefaultDiskSize") {
                    self.defaultDiskSize = dict["DefaultDiskSize"] as! Int64
                }
                if dict.keys.contains("DiskMaxSize") {
                    self.diskMaxSize = dict["DiskMaxSize"] as! Int64
                }
                if dict.keys.contains("DiskMinSize") {
                    self.diskMinSize = dict["DiskMinSize"] as! Int64
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("EnsRegionName") {
                    self.ensRegionName = dict["EnsRegionName"] as! String
                }
            }
        }
        public var supportResource: [DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") {
                var tmp : [DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var requestId: String?

    public var supportResources: DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") {
            var model = DescribeCloudDiskAvailableResourceInfoResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeCloudDiskAvailableResourceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudDiskAvailableResourceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudDiskAvailableResourceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudDiskTypesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
    }
}

public class DescribeCloudDiskTypesShrinkRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIdsShrink != nil {
            map["EnsRegionIds"] = self.ensRegionIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIdsShrink = dict["EnsRegionIds"] as! String
        }
    }
}

public class DescribeCloudDiskTypesResponseBody : Tea.TeaModel {
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public var category: String?

            public var ensRegionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
            }
        }
        public var supportResource: [DescribeCloudDiskTypesResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") {
                var tmp : [DescribeCloudDiskTypesResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeCloudDiskTypesResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var requestId: String?

    public var supportResources: DescribeCloudDiskTypesResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") {
            var model = DescribeCloudDiskTypesResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeCloudDiskTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudDiskTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudDiskTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class DescribeClusterResponseBody : Tea.TeaModel {
    public class Clusters : Tea.TeaModel {
        public var clusterId: String?

        public var currentVersion: String?

        public var name: String?

        public var nextVersion: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.currentVersion != nil {
                map["CurrentVersion"] = self.currentVersion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nextVersion != nil {
                map["NextVersion"] = self.nextVersion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("CurrentVersion") {
                self.currentVersion = dict["CurrentVersion"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NextVersion") {
                self.nextVersion = dict["NextVersion"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var clusters: [DescribeClusterResponseBody.Clusters]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            var tmp : [Any] = []
            for k in self.clusters! {
                tmp.append(k.toMap())
            }
            map["Clusters"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") {
            var tmp : [DescribeClusterResponseBody.Clusters] = []
            for v in dict["Clusters"] as! [Any] {
                var model = DescribeClusterResponseBody.Clusters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clusters = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterKubeConfigRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class DescribeClusterKubeConfigResponseBody : Tea.TeaModel {
    public var clusterId: String?

    public var kubeconfig: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.kubeconfig != nil {
            map["Kubeconfig"] = self.kubeconfig!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Kubeconfig") {
            self.kubeconfig = dict["Kubeconfig"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClusterKubeConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterKubeConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeClusterKubeConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCreatePrePaidInstanceResultRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeCreatePrePaidInstanceResultResponseBody : Tea.TeaModel {
    public class InstanceCreateResult : Tea.TeaModel {
        public var instanceCreateStatus: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceCreateStatus != nil {
                map["InstanceCreateStatus"] = self.instanceCreateStatus!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceCreateStatus") {
                self.instanceCreateStatus = dict["InstanceCreateStatus"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public var instanceCreateResult: DescribeCreatePrePaidInstanceResultResponseBody.InstanceCreateResult?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceCreateResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCreateResult != nil {
            map["InstanceCreateResult"] = self.instanceCreateResult?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceCreateResult") {
            var model = DescribeCreatePrePaidInstanceResultResponseBody.InstanceCreateResult()
            model.fromMap(dict["InstanceCreateResult"] as! [String: Any])
            self.instanceCreateResult = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCreatePrePaidInstanceResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCreatePrePaidInstanceResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCreatePrePaidInstanceResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataDistResultRequest : Tea.TeaModel {
    public var appId: String?

    public var dataNames: String?

    public var dataVersions: String?

    public var ensRegionIds: [String]?

    public var instanceIds: String?

    public var maxDate: String?

    public var minDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataNames != nil {
            map["DataNames"] = self.dataNames!
        }
        if self.dataVersions != nil {
            map["DataVersions"] = self.dataVersions!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataNames") {
            self.dataNames = dict["DataNames"] as! String
        }
        if dict.keys.contains("DataVersions") {
            self.dataVersions = dict["DataVersions"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("MaxDate") {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeDataDistResultShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var dataNames: String?

    public var dataVersions: String?

    public var ensRegionIdsShrink: String?

    public var instanceIds: String?

    public var maxDate: String?

    public var minDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataNames != nil {
            map["DataNames"] = self.dataNames!
        }
        if self.dataVersions != nil {
            map["DataVersions"] = self.dataVersions!
        }
        if self.ensRegionIdsShrink != nil {
            map["EnsRegionIds"] = self.ensRegionIdsShrink!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataNames") {
            self.dataNames = dict["DataNames"] as! String
        }
        if dict.keys.contains("DataVersions") {
            self.dataVersions = dict["DataVersions"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIdsShrink = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("MaxDate") {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeDataDistResultResponseBody : Tea.TeaModel {
    public class DistResults : Tea.TeaModel {
        public class DistResult : Tea.TeaModel {
            public class StatusStats : Tea.TeaModel {
                public class StatusStat : Tea.TeaModel {
                    public class Instances : Tea.TeaModel {
                        public class Instance : Tea.TeaModel {
                            public var instanceId: String?

                            public var startTime: String?

                            public var statusDescrip: String?

                            public var updateTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.instanceId != nil {
                                    map["InstanceId"] = self.instanceId!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.statusDescrip != nil {
                                    map["StatusDescrip"] = self.statusDescrip!
                                }
                                if self.updateTime != nil {
                                    map["UpdateTime"] = self.updateTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("InstanceId") {
                                    self.instanceId = dict["InstanceId"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("StatusDescrip") {
                                    self.statusDescrip = dict["StatusDescrip"] as! String
                                }
                                if dict.keys.contains("UpdateTime") {
                                    self.updateTime = dict["UpdateTime"] as! String
                                }
                            }
                        }
                        public var instance: [DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances.Instance]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.instance != nil {
                                var tmp : [Any] = []
                                for k in self.instance! {
                                    tmp.append(k.toMap())
                                }
                                map["Instance"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Instance") {
                                var tmp : [DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances.Instance] = []
                                for v in dict["Instance"] as! [Any] {
                                    var model = DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances.Instance()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.instance = tmp
                            }
                        }
                    }
                    public var instanceCount: String?

                    public var instances: DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.instances?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceCount != nil {
                            map["InstanceCount"] = self.instanceCount!
                        }
                        if self.instances != nil {
                            map["Instances"] = self.instances?.toMap()
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceCount") {
                            self.instanceCount = dict["InstanceCount"] as! String
                        }
                        if dict.keys.contains("Instances") {
                            var model = DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat.Instances()
                            model.fromMap(dict["Instances"] as! [String: Any])
                            self.instances = model
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var statusStat: [DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.statusStat != nil {
                        var tmp : [Any] = []
                        for k in self.statusStat! {
                            tmp.append(k.toMap())
                        }
                        map["StatusStat"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StatusStat") {
                        var tmp : [DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat] = []
                        for v in dict["StatusStat"] as! [Any] {
                            var model = DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats.StatusStat()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.statusStat = tmp
                    }
                }
            }
            public var name: String?

            public var statusStats: DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.statusStats?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.statusStats != nil {
                    map["StatusStats"] = self.statusStats?.toMap()
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("StatusStats") {
                    var model = DescribeDataDistResultResponseBody.DistResults.DistResult.StatusStats()
                    model.fromMap(dict["StatusStats"] as! [String: Any])
                    self.statusStats = model
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var distResult: [DescribeDataDistResultResponseBody.DistResults.DistResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.distResult != nil {
                var tmp : [Any] = []
                for k in self.distResult! {
                    tmp.append(k.toMap())
                }
                map["DistResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DistResult") {
                var tmp : [DescribeDataDistResultResponseBody.DistResults.DistResult] = []
                for v in dict["DistResult"] as! [Any] {
                    var model = DescribeDataDistResultResponseBody.DistResults.DistResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.distResult = tmp
            }
        }
    }
    public var distResults: DescribeDataDistResultResponseBody.DistResults?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.distResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.distResults != nil {
            map["DistResults"] = self.distResults?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DistResults") {
            var model = DescribeDataDistResultResponseBody.DistResults()
            model.fromMap(dict["DistResults"] as! [String: Any])
            self.distResults = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDataDistResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataDistResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataDistResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataDownloadURLRequest : Tea.TeaModel {
    public var appId: String?

    public var dataName: String?

    public var dataVersion: String?

    public var expireTimeout: Int64?

    public var serverFilterStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataName != nil {
            map["DataName"] = self.dataName!
        }
        if self.dataVersion != nil {
            map["DataVersion"] = self.dataVersion!
        }
        if self.expireTimeout != nil {
            map["ExpireTimeout"] = self.expireTimeout!
        }
        if self.serverFilterStrategy != nil {
            map["ServerFilterStrategy"] = self.serverFilterStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataName") {
            self.dataName = dict["DataName"] as! String
        }
        if dict.keys.contains("DataVersion") {
            self.dataVersion = dict["DataVersion"] as! String
        }
        if dict.keys.contains("ExpireTimeout") {
            self.expireTimeout = dict["ExpireTimeout"] as! Int64
        }
        if dict.keys.contains("ServerFilterStrategy") {
            self.serverFilterStrategy = dict["ServerFilterStrategy"] as! String
        }
    }
}

public class DescribeDataDownloadURLResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ServerList : Tea.TeaModel {
            public var host: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var expireTime: String?

        public var serverList: [DescribeDataDownloadURLResponseBody.Data.ServerList]?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.serverList != nil {
                var tmp : [Any] = []
                for k in self.serverList! {
                    tmp.append(k.toMap())
                }
                map["ServerList"] = tmp
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("ServerList") {
                var tmp : [DescribeDataDownloadURLResponseBody.Data.ServerList] = []
                for v in dict["ServerList"] as! [Any] {
                    var model = DescribeDataDownloadURLResponseBody.Data.ServerList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serverList = tmp
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: DescribeDataDownloadURLResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = DescribeDataDownloadURLResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDataDownloadURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataDownloadURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataDownloadURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDataPushResultRequest : Tea.TeaModel {
    public var appId: String?

    public var dataNames: String?

    public var dataVersions: String?

    public var maxDate: String?

    public var minDate: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataNames != nil {
            map["DataNames"] = self.dataNames!
        }
        if self.dataVersions != nil {
            map["DataVersions"] = self.dataVersions!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionIds != nil {
            map["RegionIds"] = self.regionIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DataNames") {
            self.dataNames = dict["DataNames"] as! String
        }
        if dict.keys.contains("DataVersions") {
            self.dataVersions = dict["DataVersions"] as! String
        }
        if dict.keys.contains("MaxDate") {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionIds") {
            self.regionIds = dict["RegionIds"] as! String
        }
    }
}

public class DescribeDataPushResultResponseBody : Tea.TeaModel {
    public class PushResults : Tea.TeaModel {
        public class PushResult : Tea.TeaModel {
            public class StatusStatS : Tea.TeaModel {
                public class StatusStat : Tea.TeaModel {
                    public class RegionIds : Tea.TeaModel {
                        public class RegionId : Tea.TeaModel {
                            public var regionId: String?

                            public var startTime: String?

                            public var statusDescrip: String?

                            public var updateTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.regionId != nil {
                                    map["RegionId"] = self.regionId!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.statusDescrip != nil {
                                    map["StatusDescrip"] = self.statusDescrip!
                                }
                                if self.updateTime != nil {
                                    map["UpdateTime"] = self.updateTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("RegionId") {
                                    self.regionId = dict["RegionId"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("StatusDescrip") {
                                    self.statusDescrip = dict["StatusDescrip"] as! String
                                }
                                if dict.keys.contains("UpdateTime") {
                                    self.updateTime = dict["UpdateTime"] as! String
                                }
                            }
                        }
                        public var regionId: [DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds.RegionId]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.regionId != nil {
                                var tmp : [Any] = []
                                for k in self.regionId! {
                                    tmp.append(k.toMap())
                                }
                                map["RegionId"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("RegionId") {
                                var tmp : [DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds.RegionId] = []
                                for v in dict["RegionId"] as! [Any] {
                                    var model = DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds.RegionId()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.regionId = tmp
                            }
                        }
                    }
                    public var regionIdCount: Int32?

                    public var regionIds: DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.regionIds?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.regionIdCount != nil {
                            map["RegionIdCount"] = self.regionIdCount!
                        }
                        if self.regionIds != nil {
                            map["RegionIds"] = self.regionIds?.toMap()
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("RegionIdCount") {
                            self.regionIdCount = dict["RegionIdCount"] as! Int32
                        }
                        if dict.keys.contains("RegionIds") {
                            var model = DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat.RegionIds()
                            model.fromMap(dict["RegionIds"] as! [String: Any])
                            self.regionIds = model
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var statusStat: [DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.statusStat != nil {
                        var tmp : [Any] = []
                        for k in self.statusStat! {
                            tmp.append(k.toMap())
                        }
                        map["StatusStat"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StatusStat") {
                        var tmp : [DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat] = []
                        for v in dict["StatusStat"] as! [Any] {
                            var model = DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS.StatusStat()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.statusStat = tmp
                    }
                }
            }
            public var name: String?

            public var statusStatS: DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.statusStatS?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.statusStatS != nil {
                    map["StatusStatS"] = self.statusStatS?.toMap()
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("StatusStatS") {
                    var model = DescribeDataPushResultResponseBody.PushResults.PushResult.StatusStatS()
                    model.fromMap(dict["StatusStatS"] as! [String: Any])
                    self.statusStatS = model
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var pushResult: [DescribeDataPushResultResponseBody.PushResults.PushResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pushResult != nil {
                var tmp : [Any] = []
                for k in self.pushResult! {
                    tmp.append(k.toMap())
                }
                map["PushResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PushResult") {
                var tmp : [DescribeDataPushResultResponseBody.PushResults.PushResult] = []
                for v in dict["PushResult"] as! [Any] {
                    var model = DescribeDataPushResultResponseBody.PushResults.PushResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pushResult = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pushResults: DescribeDataPushResultResponseBody.PushResults?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pushResults != nil {
            map["PushResults"] = self.pushResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PushResults") {
            var model = DescribeDataPushResultResponseBody.PushResults()
            model.fromMap(dict["PushResults"] as! [String: Any])
            self.pushResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDataPushResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDataPushResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDataPushResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeviceServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var ensRegionId: String?

    public var instanceId: String?

    public var orderId: String?

    public var regionId: String?

    public var serviceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! String
        }
    }
}

public class DescribeDeviceServiceResponseBody : Tea.TeaModel {
    public class AppMetaData : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var appStableVersion: String?

        public var appType: String?

        public var clusterName: String?

        public var createTime: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.appStableVersion != nil {
                map["AppStableVersion"] = self.appStableVersion!
            }
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("AppStableVersion") {
                self.appStableVersion = dict["AppStableVersion"] as! String
            }
            if dict.keys.contains("AppType") {
                self.appType = dict["AppType"] as! String
            }
            if dict.keys.contains("ClusterName") {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class AppStatus : Tea.TeaModel {
        public var phase: String?

        public var statusDescrip: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.statusDescrip != nil {
                map["StatusDescrip"] = self.statusDescrip!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Phase") {
                self.phase = dict["Phase"] as! String
            }
            if dict.keys.contains("StatusDescrip") {
                self.statusDescrip = dict["StatusDescrip"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public class ResourceDetailInfos : Tea.TeaModel {
        public var deviceName: String?

        public var ID: String?

        public var IP: String?

        public var ISP: String?

        public var imageID: String?

        public var mac: String?

        public var regionID: String?

        public var server: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceName != nil {
                map["DeviceName"] = self.deviceName!
            }
            if self.ID != nil {
                map["ID"] = self.ID!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.ISP != nil {
                map["ISP"] = self.ISP!
            }
            if self.imageID != nil {
                map["ImageID"] = self.imageID!
            }
            if self.mac != nil {
                map["Mac"] = self.mac!
            }
            if self.regionID != nil {
                map["RegionID"] = self.regionID!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceName") {
                self.deviceName = dict["DeviceName"] as! String
            }
            if dict.keys.contains("ID") {
                self.ID = dict["ID"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("ISP") {
                self.ISP = dict["ISP"] as! String
            }
            if dict.keys.contains("ImageID") {
                self.imageID = dict["ImageID"] as! String
            }
            if dict.keys.contains("Mac") {
                self.mac = dict["Mac"] as! String
            }
            if dict.keys.contains("RegionID") {
                self.regionID = dict["RegionID"] as! String
            }
            if dict.keys.contains("Server") {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ResourceInfos : Tea.TeaModel {
        public class DeviceInfos : Tea.TeaModel {
            public class Network : Tea.TeaModel {
                public var containerPorts: String?

                public var externalIp: String?

                public var hostPorts: String?

                public var protocol_: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.containerPorts != nil {
                        map["ContainerPorts"] = self.containerPorts!
                    }
                    if self.externalIp != nil {
                        map["ExternalIp"] = self.externalIp!
                    }
                    if self.hostPorts != nil {
                        map["HostPorts"] = self.hostPorts!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContainerPorts") {
                        self.containerPorts = dict["ContainerPorts"] as! String
                    }
                    if dict.keys.contains("ExternalIp") {
                        self.externalIp = dict["ExternalIp"] as! String
                    }
                    if dict.keys.contains("HostPorts") {
                        self.hostPorts = dict["HostPorts"] as! String
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                }
            }
            public var name: String?

            public var network: [DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos.Network]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.network != nil {
                    var tmp : [Any] = []
                    for k in self.network! {
                        tmp.append(k.toMap())
                    }
                    map["Network"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Network") {
                    var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos.Network] = []
                    for v in dict["Network"] as! [Any] {
                        var model = DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos.Network()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.network = tmp
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class InternalIps : Tea.TeaModel {
            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
            }
        }
        public class PublicIps : Tea.TeaModel {
            public var ip: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
            }
        }
        public var appVersion: String?

        public var areaCode: String?

        public var areaName: String?

        public var createTime: String?

        public var deviceInfos: [DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos]?

        public var instanceId: String?

        public var instanceStatus: String?

        public var internalIps: [DescribeDeviceServiceResponseBody.ResourceInfos.InternalIps]?

        public var publicIps: [DescribeDeviceServiceResponseBody.ResourceInfos.PublicIps]?

        public var regionCode: String?

        public var regionId: String?

        public var regionName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appVersion != nil {
                map["AppVersion"] = self.appVersion!
            }
            if self.areaCode != nil {
                map["AreaCode"] = self.areaCode!
            }
            if self.areaName != nil {
                map["AreaName"] = self.areaName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deviceInfos != nil {
                var tmp : [Any] = []
                for k in self.deviceInfos! {
                    tmp.append(k.toMap())
                }
                map["DeviceInfos"] = tmp
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceStatus != nil {
                map["InstanceStatus"] = self.instanceStatus!
            }
            if self.internalIps != nil {
                var tmp : [Any] = []
                for k in self.internalIps! {
                    tmp.append(k.toMap())
                }
                map["InternalIps"] = tmp
            }
            if self.publicIps != nil {
                var tmp : [Any] = []
                for k in self.publicIps! {
                    tmp.append(k.toMap())
                }
                map["PublicIps"] = tmp
            }
            if self.regionCode != nil {
                map["RegionCode"] = self.regionCode!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppVersion") {
                self.appVersion = dict["AppVersion"] as! String
            }
            if dict.keys.contains("AreaCode") {
                self.areaCode = dict["AreaCode"] as! String
            }
            if dict.keys.contains("AreaName") {
                self.areaName = dict["AreaName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeviceInfos") {
                var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos] = []
                for v in dict["DeviceInfos"] as! [Any] {
                    var model = DescribeDeviceServiceResponseBody.ResourceInfos.DeviceInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deviceInfos = tmp
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceStatus") {
                self.instanceStatus = dict["InstanceStatus"] as! String
            }
            if dict.keys.contains("InternalIps") {
                var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos.InternalIps] = []
                for v in dict["InternalIps"] as! [Any] {
                    var model = DescribeDeviceServiceResponseBody.ResourceInfos.InternalIps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.internalIps = tmp
            }
            if dict.keys.contains("PublicIps") {
                var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos.PublicIps] = []
                for v in dict["PublicIps"] as! [Any] {
                    var model = DescribeDeviceServiceResponseBody.ResourceInfos.PublicIps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.publicIps = tmp
            }
            if dict.keys.contains("RegionCode") {
                self.regionCode = dict["RegionCode"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") {
                self.regionName = dict["RegionName"] as! String
            }
        }
    }
    public var appMetaData: DescribeDeviceServiceResponseBody.AppMetaData?

    public var appStatus: DescribeDeviceServiceResponseBody.AppStatus?

    public var requestId: String?

    public var resourceDetailInfos: [DescribeDeviceServiceResponseBody.ResourceDetailInfos]?

    public var resourceInfos: [DescribeDeviceServiceResponseBody.ResourceInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appMetaData?.validate()
        try self.appStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appMetaData != nil {
            map["AppMetaData"] = self.appMetaData?.toMap()
        }
        if self.appStatus != nil {
            map["AppStatus"] = self.appStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceDetailInfos != nil {
            var tmp : [Any] = []
            for k in self.resourceDetailInfos! {
                tmp.append(k.toMap())
            }
            map["ResourceDetailInfos"] = tmp
        }
        if self.resourceInfos != nil {
            var tmp : [Any] = []
            for k in self.resourceInfos! {
                tmp.append(k.toMap())
            }
            map["ResourceInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppMetaData") {
            var model = DescribeDeviceServiceResponseBody.AppMetaData()
            model.fromMap(dict["AppMetaData"] as! [String: Any])
            self.appMetaData = model
        }
        if dict.keys.contains("AppStatus") {
            var model = DescribeDeviceServiceResponseBody.AppStatus()
            model.fromMap(dict["AppStatus"] as! [String: Any])
            self.appStatus = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceDetailInfos") {
            var tmp : [DescribeDeviceServiceResponseBody.ResourceDetailInfos] = []
            for v in dict["ResourceDetailInfos"] as! [Any] {
                var model = DescribeDeviceServiceResponseBody.ResourceDetailInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceDetailInfos = tmp
        }
        if dict.keys.contains("ResourceInfos") {
            var tmp : [DescribeDeviceServiceResponseBody.ResourceInfos] = []
            for v in dict["ResourceInfos"] as! [Any] {
                var model = DescribeDeviceServiceResponseBody.ResourceInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceInfos = tmp
        }
    }
}

public class DescribeDeviceServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeviceServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDeviceServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiskIopsListRequest : Tea.TeaModel {
    public var diskId: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeDiskIopsListResponseBody : Tea.TeaModel {
    public class DiskIopsList : Tea.TeaModel {
        public var bizTime: String?

        public var diskId: String?

        public var readBytes: Int64?

        public var readLatency: Int64?

        public var readOps: Int64?

        public var regionId: String?

        public var writeBytes: Int64?

        public var writeLatency: Int64?

        public var writeOps: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizTime != nil {
                map["BizTime"] = self.bizTime!
            }
            if self.diskId != nil {
                map["DiskId"] = self.diskId!
            }
            if self.readBytes != nil {
                map["ReadBytes"] = self.readBytes!
            }
            if self.readLatency != nil {
                map["ReadLatency"] = self.readLatency!
            }
            if self.readOps != nil {
                map["ReadOps"] = self.readOps!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.writeBytes != nil {
                map["WriteBytes"] = self.writeBytes!
            }
            if self.writeLatency != nil {
                map["WriteLatency"] = self.writeLatency!
            }
            if self.writeOps != nil {
                map["WriteOps"] = self.writeOps!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizTime") {
                self.bizTime = dict["BizTime"] as! String
            }
            if dict.keys.contains("DiskId") {
                self.diskId = dict["DiskId"] as! String
            }
            if dict.keys.contains("ReadBytes") {
                self.readBytes = dict["ReadBytes"] as! Int64
            }
            if dict.keys.contains("ReadLatency") {
                self.readLatency = dict["ReadLatency"] as! Int64
            }
            if dict.keys.contains("ReadOps") {
                self.readOps = dict["ReadOps"] as! Int64
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("WriteBytes") {
                self.writeBytes = dict["WriteBytes"] as! Int64
            }
            if dict.keys.contains("WriteLatency") {
                self.writeLatency = dict["WriteLatency"] as! Int64
            }
            if dict.keys.contains("WriteOps") {
                self.writeOps = dict["WriteOps"] as! Int64
            }
        }
    }
    public var diskIopsList: [DescribeDiskIopsListResponseBody.DiskIopsList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskIopsList != nil {
            var tmp : [Any] = []
            for k in self.diskIopsList! {
                tmp.append(k.toMap())
            }
            map["DiskIopsList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskIopsList") {
            var tmp : [DescribeDiskIopsListResponseBody.DiskIopsList] = []
            for v in dict["DiskIopsList"] as! [Any] {
                var model = DescribeDiskIopsListResponseBody.DiskIopsList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.diskIopsList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDiskIopsListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiskIopsListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiskIopsListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDisksRequest : Tea.TeaModel {
    public var category: String?

    public var diskChargeType: String?

    public var diskId: String?

    public var diskIds: String?

    public var diskName: String?

    public var diskType: String?

    public var ensRegionId: String?

    public var ensRegionIds: String?

    public var instanceId: String?

    public var orderByParams: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var snapshotId: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.diskChargeType != nil {
            map["DiskChargeType"] = self.diskChargeType!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("DiskChargeType") {
            self.diskChargeType = dict["DiskChargeType"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("DiskIds") {
            self.diskIds = dict["DiskIds"] as! String
        }
        if dict.keys.contains("DiskName") {
            self.diskName = dict["DiskName"] as! String
        }
        if dict.keys.contains("DiskType") {
            self.diskType = dict["DiskType"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderByParams") {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeDisksResponseBody : Tea.TeaModel {
    public class Disks : Tea.TeaModel {
        public class Disks : Tea.TeaModel {
            public var category: String?

            public var creationTime: String?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var diskChargeType: String?

            public var diskId: String?

            public var diskName: String?

            public var encrypted: Bool?

            public var encryptedKeyId: String?

            public var ensRegionId: String?

            public var instanceId: String?

            public var instanceName: String?

            public var portable: Bool?

            public var serialId: String?

            public var size: Int32?

            public var snapshotId: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.diskChargeType != nil {
                    map["DiskChargeType"] = self.diskChargeType!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.encryptedKeyId != nil {
                    map["EncryptedKeyId"] = self.encryptedKeyId!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.portable != nil {
                    map["Portable"] = self.portable!
                }
                if self.serialId != nil {
                    map["SerialId"] = self.serialId!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DeleteWithInstance") {
                    self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DiskChargeType") {
                    self.diskChargeType = dict["DiskChargeType"] as! String
                }
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskName") {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("Encrypted") {
                    self.encrypted = dict["Encrypted"] as! Bool
                }
                if dict.keys.contains("EncryptedKeyId") {
                    self.encryptedKeyId = dict["EncryptedKeyId"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Portable") {
                    self.portable = dict["Portable"] as! Bool
                }
                if dict.keys.contains("SerialId") {
                    self.serialId = dict["SerialId"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int32
                }
                if dict.keys.contains("SnapshotId") {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var disks: [DescribeDisksResponseBody.Disks.Disks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disks != nil {
                var tmp : [Any] = []
                for k in self.disks! {
                    tmp.append(k.toMap())
                }
                map["Disks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Disks") {
                var tmp : [DescribeDisksResponseBody.Disks.Disks] = []
                for v in dict["Disks"] as! [Any] {
                    var model = DescribeDisksResponseBody.Disks.Disks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.disks = tmp
            }
        }
    }
    public var code: Int32?

    public var disks: DescribeDisksResponseBody.Disks?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.disks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.disks != nil {
            map["Disks"] = self.disks?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Disks") {
            var model = DescribeDisksResponseBody.Disks()
            model.fromMap(dict["Disks"] as! [String: Any])
            self.disks = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDisksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDisksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDisksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeElbAvailableResourceInfoResponseBody : Tea.TeaModel {
    public class ElbAvailableResourceInfo : Tea.TeaModel {
        public var ability: [String]?

        public var area: String?

        public var canBuyCount: String?

        public var enName: String?

        public var ensRegionId: String?

        public var loadBalancerSpec: [String]?

        public var name: String?

        public var province: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ability != nil {
                map["Ability"] = self.ability!
            }
            if self.area != nil {
                map["Area"] = self.area!
            }
            if self.canBuyCount != nil {
                map["CanBuyCount"] = self.canBuyCount!
            }
            if self.enName != nil {
                map["EnName"] = self.enName!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.loadBalancerSpec != nil {
                map["LoadBalancerSpec"] = self.loadBalancerSpec!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ability") {
                self.ability = dict["Ability"] as! [String]
            }
            if dict.keys.contains("Area") {
                self.area = dict["Area"] as! String
            }
            if dict.keys.contains("CanBuyCount") {
                self.canBuyCount = dict["CanBuyCount"] as! String
            }
            if dict.keys.contains("EnName") {
                self.enName = dict["EnName"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("LoadBalancerSpec") {
                self.loadBalancerSpec = dict["LoadBalancerSpec"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Province") {
                self.province = dict["Province"] as! String
            }
        }
    }
    public var elbAvailableResourceInfo: [DescribeElbAvailableResourceInfoResponseBody.ElbAvailableResourceInfo]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elbAvailableResourceInfo != nil {
            var tmp : [Any] = []
            for k in self.elbAvailableResourceInfo! {
                tmp.append(k.toMap())
            }
            map["ElbAvailableResourceInfo"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ElbAvailableResourceInfo") {
            var tmp : [DescribeElbAvailableResourceInfoResponseBody.ElbAvailableResourceInfo] = []
            for v in dict["ElbAvailableResourceInfo"] as! [Any] {
                var model = DescribeElbAvailableResourceInfoResponseBody.ElbAvailableResourceInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.elbAvailableResourceInfo = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeElbAvailableResourceInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElbAvailableResourceInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeElbAvailableResourceInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsCommodityCodeRequest : Tea.TeaModel {
    public var commodityCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
    }
}

public class DescribeEnsCommodityCodeResponseBody : Tea.TeaModel {
    public class CommodityCodeInfo : Tea.TeaModel {
        public var commodityCode: String?

        public var commodityName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.commodityName != nil {
                map["CommodityName"] = self.commodityName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommodityCode") {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("CommodityName") {
                self.commodityName = dict["CommodityName"] as! String
            }
        }
    }
    public var commodityCodeInfo: [DescribeEnsCommodityCodeResponseBody.CommodityCodeInfo]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCodeInfo != nil {
            var tmp : [Any] = []
            for k in self.commodityCodeInfo! {
                tmp.append(k.toMap())
            }
            map["CommodityCodeInfo"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityCodeInfo") {
            var tmp : [DescribeEnsCommodityCodeResponseBody.CommodityCodeInfo] = []
            for v in dict["CommodityCodeInfo"] as! [Any] {
                var model = DescribeEnsCommodityCodeResponseBody.CommodityCodeInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.commodityCodeInfo = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsCommodityCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsCommodityCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsCommodityCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsCommodityModuleCodeRequest : Tea.TeaModel {
    public var commodityCode: String?

    public var moduleCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.moduleCode != nil {
            map["ModuleCode"] = self.moduleCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("ModuleCode") {
            self.moduleCode = dict["ModuleCode"] as! String
        }
    }
}

public class DescribeEnsCommodityModuleCodeResponseBody : Tea.TeaModel {
    public class CommodityCodesInfo : Tea.TeaModel {
        public class ModuleCodesInfo : Tea.TeaModel {
            public var moduleCode: String?

            public var moduleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.moduleCode != nil {
                    map["ModuleCode"] = self.moduleCode!
                }
                if self.moduleName != nil {
                    map["ModuleName"] = self.moduleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ModuleCode") {
                    self.moduleCode = dict["ModuleCode"] as! String
                }
                if dict.keys.contains("ModuleName") {
                    self.moduleName = dict["ModuleName"] as! String
                }
            }
        }
        public var commodityCode: String?

        public var moduleCodesInfo: [DescribeEnsCommodityModuleCodeResponseBody.CommodityCodesInfo.ModuleCodesInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.moduleCodesInfo != nil {
                var tmp : [Any] = []
                for k in self.moduleCodesInfo! {
                    tmp.append(k.toMap())
                }
                map["ModuleCodesInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommodityCode") {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("ModuleCodesInfo") {
                var tmp : [DescribeEnsCommodityModuleCodeResponseBody.CommodityCodesInfo.ModuleCodesInfo] = []
                for v in dict["ModuleCodesInfo"] as! [Any] {
                    var model = DescribeEnsCommodityModuleCodeResponseBody.CommodityCodesInfo.ModuleCodesInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.moduleCodesInfo = tmp
            }
        }
    }
    public var commodityCodesInfo: [DescribeEnsCommodityModuleCodeResponseBody.CommodityCodesInfo]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCodesInfo != nil {
            var tmp : [Any] = []
            for k in self.commodityCodesInfo! {
                tmp.append(k.toMap())
            }
            map["CommodityCodesInfo"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityCodesInfo") {
            var tmp : [DescribeEnsCommodityModuleCodeResponseBody.CommodityCodesInfo] = []
            for v in dict["CommodityCodesInfo"] as! [Any] {
                var model = DescribeEnsCommodityModuleCodeResponseBody.CommodityCodesInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.commodityCodesInfo = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsCommodityModuleCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsCommodityModuleCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsCommodityModuleCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsEipAddressesRequest : Tea.TeaModel {
    public var allocationId: String?

    public var associatedInstanceId: String?

    public var associatedInstanceType: String?

    public var eipAddress: String?

    public var eipName: String?

    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var standby: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.associatedInstanceId != nil {
            map["AssociatedInstanceId"] = self.associatedInstanceId!
        }
        if self.associatedInstanceType != nil {
            map["AssociatedInstanceType"] = self.associatedInstanceType!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.eipName != nil {
            map["EipName"] = self.eipName!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.standby != nil {
            map["Standby"] = self.standby!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("AssociatedInstanceId") {
            self.associatedInstanceId = dict["AssociatedInstanceId"] as! String
        }
        if dict.keys.contains("AssociatedInstanceType") {
            self.associatedInstanceType = dict["AssociatedInstanceType"] as! String
        }
        if dict.keys.contains("EipAddress") {
            self.eipAddress = dict["EipAddress"] as! String
        }
        if dict.keys.contains("EipName") {
            self.eipName = dict["EipName"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Standby") {
            self.standby = dict["Standby"] as! String
        }
    }
}

public class DescribeEnsEipAddressesResponseBody : Tea.TeaModel {
    public class EipAddresses : Tea.TeaModel {
        public class EipAddress : Tea.TeaModel {
            public var allocationId: String?

            public var allocationTime: String?

            public var bandwidth: Int32?

            public var chargeType: String?

            public var description_: String?

            public var ensRegionId: String?

            public var instanceId: String?

            public var instanceType: String?

            public var internetChargeType: String?

            public var ipAddress: String?

            public var ipStatus: String?

            public var isp: String?

            public var name: String?

            public var standby: Bool?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationId != nil {
                    map["AllocationId"] = self.allocationId!
                }
                if self.allocationTime != nil {
                    map["AllocationTime"] = self.allocationTime!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.ipStatus != nil {
                    map["IpStatus"] = self.ipStatus!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.standby != nil {
                    map["Standby"] = self.standby!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocationId") {
                    self.allocationId = dict["AllocationId"] as! String
                }
                if dict.keys.contains("AllocationTime") {
                    self.allocationTime = dict["AllocationTime"] as! String
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InternetChargeType") {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("IpStatus") {
                    self.ipStatus = dict["IpStatus"] as! String
                }
                if dict.keys.contains("Isp") {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Standby") {
                    self.standby = dict["Standby"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var eipAddress: [DescribeEnsEipAddressesResponseBody.EipAddresses.EipAddress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipAddress != nil {
                var tmp : [Any] = []
                for k in self.eipAddress! {
                    tmp.append(k.toMap())
                }
                map["EipAddress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipAddress") {
                var tmp : [DescribeEnsEipAddressesResponseBody.EipAddresses.EipAddress] = []
                for v in dict["EipAddress"] as! [Any] {
                    var model = DescribeEnsEipAddressesResponseBody.EipAddresses.EipAddress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipAddress = tmp
            }
        }
    }
    public var eipAddresses: DescribeEnsEipAddressesResponseBody.EipAddresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipAddresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipAddresses != nil {
            map["EipAddresses"] = self.eipAddresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipAddresses") {
            var model = DescribeEnsEipAddressesResponseBody.EipAddresses()
            model.fromMap(dict["EipAddresses"] as! [String: Any])
            self.eipAddresses = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEnsEipAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsEipAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsEipAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsNetDistrictRequest : Tea.TeaModel {
    public var netDistrictCode: String?

    public var netLevelCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.netDistrictCode != nil {
            map["NetDistrictCode"] = self.netDistrictCode!
        }
        if self.netLevelCode != nil {
            map["NetLevelCode"] = self.netLevelCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetDistrictCode") {
            self.netDistrictCode = dict["NetDistrictCode"] as! String
        }
        if dict.keys.contains("NetLevelCode") {
            self.netLevelCode = dict["NetLevelCode"] as! String
        }
    }
}

public class DescribeEnsNetDistrictResponseBody : Tea.TeaModel {
    public class EnsNetDistricts : Tea.TeaModel {
        public class EnsNetDistrict : Tea.TeaModel {
            public var ensRegionIdCount: String?

            public var netDistrictCode: String?

            public var netDistrictEnName: String?

            public var netDistrictFatherCode: String?

            public var netDistrictLevel: String?

            public var netDistrictName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ensRegionIdCount != nil {
                    map["EnsRegionIdCount"] = self.ensRegionIdCount!
                }
                if self.netDistrictCode != nil {
                    map["NetDistrictCode"] = self.netDistrictCode!
                }
                if self.netDistrictEnName != nil {
                    map["NetDistrictEnName"] = self.netDistrictEnName!
                }
                if self.netDistrictFatherCode != nil {
                    map["NetDistrictFatherCode"] = self.netDistrictFatherCode!
                }
                if self.netDistrictLevel != nil {
                    map["NetDistrictLevel"] = self.netDistrictLevel!
                }
                if self.netDistrictName != nil {
                    map["NetDistrictName"] = self.netDistrictName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnsRegionIdCount") {
                    self.ensRegionIdCount = dict["EnsRegionIdCount"] as! String
                }
                if dict.keys.contains("NetDistrictCode") {
                    self.netDistrictCode = dict["NetDistrictCode"] as! String
                }
                if dict.keys.contains("NetDistrictEnName") {
                    self.netDistrictEnName = dict["NetDistrictEnName"] as! String
                }
                if dict.keys.contains("NetDistrictFatherCode") {
                    self.netDistrictFatherCode = dict["NetDistrictFatherCode"] as! String
                }
                if dict.keys.contains("NetDistrictLevel") {
                    self.netDistrictLevel = dict["NetDistrictLevel"] as! String
                }
                if dict.keys.contains("NetDistrictName") {
                    self.netDistrictName = dict["NetDistrictName"] as! String
                }
            }
        }
        public var ensNetDistrict: [DescribeEnsNetDistrictResponseBody.EnsNetDistricts.EnsNetDistrict]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensNetDistrict != nil {
                var tmp : [Any] = []
                for k in self.ensNetDistrict! {
                    tmp.append(k.toMap())
                }
                map["EnsNetDistrict"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsNetDistrict") {
                var tmp : [DescribeEnsNetDistrictResponseBody.EnsNetDistricts.EnsNetDistrict] = []
                for v in dict["EnsNetDistrict"] as! [Any] {
                    var model = DescribeEnsNetDistrictResponseBody.EnsNetDistricts.EnsNetDistrict()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensNetDistrict = tmp
            }
        }
    }
    public var code: Int32?

    public var ensNetDistricts: DescribeEnsNetDistrictResponseBody.EnsNetDistricts?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensNetDistricts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ensNetDistricts != nil {
            map["EnsNetDistricts"] = self.ensNetDistricts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EnsNetDistricts") {
            var model = DescribeEnsNetDistrictResponseBody.EnsNetDistricts()
            model.fromMap(dict["EnsNetDistricts"] as! [String: Any])
            self.ensNetDistricts = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsNetDistrictResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsNetDistrictResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsNetDistrictResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsNetLevelResponseBody : Tea.TeaModel {
    public class EnsNetLevels : Tea.TeaModel {
        public class EnsNetLevel : Tea.TeaModel {
            public var ensNetLevelCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ensNetLevelCode != nil {
                    map["EnsNetLevelCode"] = self.ensNetLevelCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnsNetLevelCode") {
                    self.ensNetLevelCode = dict["EnsNetLevelCode"] as! String
                }
            }
        }
        public var ensNetLevel: [DescribeEnsNetLevelResponseBody.EnsNetLevels.EnsNetLevel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensNetLevel != nil {
                var tmp : [Any] = []
                for k in self.ensNetLevel! {
                    tmp.append(k.toMap())
                }
                map["EnsNetLevel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsNetLevel") {
                var tmp : [DescribeEnsNetLevelResponseBody.EnsNetLevels.EnsNetLevel] = []
                for v in dict["EnsNetLevel"] as! [Any] {
                    var model = DescribeEnsNetLevelResponseBody.EnsNetLevels.EnsNetLevel()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensNetLevel = tmp
            }
        }
    }
    public var code: Int32?

    public var ensNetLevels: DescribeEnsNetLevelResponseBody.EnsNetLevels?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensNetLevels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ensNetLevels != nil {
            map["EnsNetLevels"] = self.ensNetLevels?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EnsNetLevels") {
            var model = DescribeEnsNetLevelResponseBody.EnsNetLevels()
            model.fromMap(dict["EnsNetLevels"] as! [String: Any])
            self.ensNetLevels = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsNetLevelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsNetLevelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsNetLevelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsNetSaleDistrictRequest : Tea.TeaModel {
    public var netDistrictCode: String?

    public var netLevelCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.netDistrictCode != nil {
            map["NetDistrictCode"] = self.netDistrictCode!
        }
        if self.netLevelCode != nil {
            map["NetLevelCode"] = self.netLevelCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetDistrictCode") {
            self.netDistrictCode = dict["NetDistrictCode"] as! String
        }
        if dict.keys.contains("NetLevelCode") {
            self.netLevelCode = dict["NetLevelCode"] as! String
        }
    }
}

public class DescribeEnsNetSaleDistrictResponseBody : Tea.TeaModel {
    public class EnsNetDistricts : Tea.TeaModel {
        public class EnsNetDistrict : Tea.TeaModel {
            public var ensRegionIdCount: String?

            public var instanceCount: String?

            public var netDistrictCode: String?

            public var netDistrictEnName: String?

            public var netDistrictFatherCode: String?

            public var netDistrictLevel: String?

            public var netDistrictName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ensRegionIdCount != nil {
                    map["EnsRegionIdCount"] = self.ensRegionIdCount!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.netDistrictCode != nil {
                    map["NetDistrictCode"] = self.netDistrictCode!
                }
                if self.netDistrictEnName != nil {
                    map["NetDistrictEnName"] = self.netDistrictEnName!
                }
                if self.netDistrictFatherCode != nil {
                    map["NetDistrictFatherCode"] = self.netDistrictFatherCode!
                }
                if self.netDistrictLevel != nil {
                    map["NetDistrictLevel"] = self.netDistrictLevel!
                }
                if self.netDistrictName != nil {
                    map["NetDistrictName"] = self.netDistrictName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnsRegionIdCount") {
                    self.ensRegionIdCount = dict["EnsRegionIdCount"] as! String
                }
                if dict.keys.contains("InstanceCount") {
                    self.instanceCount = dict["InstanceCount"] as! String
                }
                if dict.keys.contains("NetDistrictCode") {
                    self.netDistrictCode = dict["NetDistrictCode"] as! String
                }
                if dict.keys.contains("NetDistrictEnName") {
                    self.netDistrictEnName = dict["NetDistrictEnName"] as! String
                }
                if dict.keys.contains("NetDistrictFatherCode") {
                    self.netDistrictFatherCode = dict["NetDistrictFatherCode"] as! String
                }
                if dict.keys.contains("NetDistrictLevel") {
                    self.netDistrictLevel = dict["NetDistrictLevel"] as! String
                }
                if dict.keys.contains("NetDistrictName") {
                    self.netDistrictName = dict["NetDistrictName"] as! String
                }
            }
        }
        public var ensNetDistrict: [DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts.EnsNetDistrict]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensNetDistrict != nil {
                var tmp : [Any] = []
                for k in self.ensNetDistrict! {
                    tmp.append(k.toMap())
                }
                map["EnsNetDistrict"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsNetDistrict") {
                var tmp : [DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts.EnsNetDistrict] = []
                for v in dict["EnsNetDistrict"] as! [Any] {
                    var model = DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts.EnsNetDistrict()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensNetDistrict = tmp
            }
        }
    }
    public var code: Int32?

    public var ensNetDistricts: DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensNetDistricts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ensNetDistricts != nil {
            map["EnsNetDistricts"] = self.ensNetDistricts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EnsNetDistricts") {
            var model = DescribeEnsNetSaleDistrictResponseBody.EnsNetDistricts()
            model.fromMap(dict["EnsNetDistricts"] as! [String: Any])
            self.ensNetDistricts = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsNetSaleDistrictResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsNetSaleDistrictResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsNetSaleDistrictResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsRegionIdIpv6InfoRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
    }
}

public class DescribeEnsRegionIdIpv6InfoResponseBody : Tea.TeaModel {
    public class SupportIpv6Info : Tea.TeaModel {
        public var ensRegionId: String?

        public var supportIpv6: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.supportIpv6 != nil {
                map["SupportIpv6"] = self.supportIpv6!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("SupportIpv6") {
                self.supportIpv6 = dict["SupportIpv6"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var supportIpv6Info: DescribeEnsRegionIdIpv6InfoResponseBody.SupportIpv6Info?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.supportIpv6Info?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportIpv6Info != nil {
            map["SupportIpv6Info"] = self.supportIpv6Info?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportIpv6Info") {
            var model = DescribeEnsRegionIdIpv6InfoResponseBody.SupportIpv6Info()
            model.fromMap(dict["SupportIpv6Info"] as! [String: Any])
            self.supportIpv6Info = model
        }
    }
}

public class DescribeEnsRegionIdIpv6InfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsRegionIdIpv6InfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsRegionIdIpv6InfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsRegionIdResourceRequest : Tea.TeaModel {
    public var endTime: String?

    public var isp: String?

    public var orderByParams: String?

    public var pageNumber: Int32?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("OrderByParams") {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeEnsRegionIdResourceResponseBody : Tea.TeaModel {
    public class EnsRegionIdResources : Tea.TeaModel {
        public class EnsRegionIdResource : Tea.TeaModel {
            public var area: String?

            public var areaCode: String?

            public var bizDate: String?

            public var ensRegionId: String?

            public var ensRegionIdName: String?

            public var instanceCount: Int32?

            public var internetBandwidth: Int64?

            public var isp: String?

            public var VCpu: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area != nil {
                    map["Area"] = self.area!
                }
                if self.areaCode != nil {
                    map["AreaCode"] = self.areaCode!
                }
                if self.bizDate != nil {
                    map["BizDate"] = self.bizDate!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.ensRegionIdName != nil {
                    map["EnsRegionIdName"] = self.ensRegionIdName!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.internetBandwidth != nil {
                    map["InternetBandwidth"] = self.internetBandwidth!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.VCpu != nil {
                    map["VCpu"] = self.VCpu!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Area") {
                    self.area = dict["Area"] as! String
                }
                if dict.keys.contains("AreaCode") {
                    self.areaCode = dict["AreaCode"] as! String
                }
                if dict.keys.contains("BizDate") {
                    self.bizDate = dict["BizDate"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("EnsRegionIdName") {
                    self.ensRegionIdName = dict["EnsRegionIdName"] as! String
                }
                if dict.keys.contains("InstanceCount") {
                    self.instanceCount = dict["InstanceCount"] as! Int32
                }
                if dict.keys.contains("InternetBandwidth") {
                    self.internetBandwidth = dict["InternetBandwidth"] as! Int64
                }
                if dict.keys.contains("Isp") {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("VCpu") {
                    self.VCpu = dict["VCpu"] as! Int32
                }
            }
        }
        public var ensRegionIdResource: [DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources.EnsRegionIdResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionIdResource != nil {
                var tmp : [Any] = []
                for k in self.ensRegionIdResource! {
                    tmp.append(k.toMap())
                }
                map["EnsRegionIdResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionIdResource") {
                var tmp : [DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources.EnsRegionIdResource] = []
                for v in dict["EnsRegionIdResource"] as! [Any] {
                    var model = DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources.EnsRegionIdResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensRegionIdResource = tmp
            }
        }
    }
    public var ensRegionIdResources: DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensRegionIdResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionIdResources != nil {
            map["EnsRegionIdResources"] = self.ensRegionIdResources?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionIdResources") {
            var model = DescribeEnsRegionIdResourceResponseBody.EnsRegionIdResources()
            model.fromMap(dict["EnsRegionIdResources"] as! [String: Any])
            self.ensRegionIdResources = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEnsRegionIdResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsRegionIdResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsRegionIdResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsRegionsRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
    }
}

public class DescribeEnsRegionsResponseBody : Tea.TeaModel {
    public class EnsRegions : Tea.TeaModel {
        public class EnsRegions : Tea.TeaModel {
            public var area: String?

            public var enName: String?

            public var ensRegionId: String?

            public var name: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area != nil {
                    map["Area"] = self.area!
                }
                if self.enName != nil {
                    map["EnName"] = self.enName!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Area") {
                    self.area = dict["Area"] as! String
                }
                if dict.keys.contains("EnName") {
                    self.enName = dict["EnName"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var ensRegions: [DescribeEnsRegionsResponseBody.EnsRegions.EnsRegions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegions != nil {
                var tmp : [Any] = []
                for k in self.ensRegions! {
                    tmp.append(k.toMap())
                }
                map["EnsRegions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegions") {
                var tmp : [DescribeEnsRegionsResponseBody.EnsRegions.EnsRegions] = []
                for v in dict["EnsRegions"] as! [Any] {
                    var model = DescribeEnsRegionsResponseBody.EnsRegions.EnsRegions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ensRegions = tmp
            }
        }
    }
    public var code: Int32?

    public var ensRegions: DescribeEnsRegionsResponseBody.EnsRegions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ensRegions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.ensRegions != nil {
            map["EnsRegions"] = self.ensRegions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("EnsRegions") {
            var model = DescribeEnsRegionsResponseBody.EnsRegions()
            model.fromMap(dict["EnsRegions"] as! [String: Any])
            self.ensRegions = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsResourceUsageRequest : Tea.TeaModel {
    public var expiredEndTime: String?

    public var expiredStartTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.expiredEndTime != nil {
            map["ExpiredEndTime"] = self.expiredEndTime!
        }
        if self.expiredStartTime != nil {
            map["ExpiredStartTime"] = self.expiredStartTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExpiredEndTime") {
            self.expiredEndTime = dict["ExpiredEndTime"] as! String
        }
        if dict.keys.contains("ExpiredStartTime") {
            self.expiredStartTime = dict["ExpiredStartTime"] as! String
        }
    }
}

public class DescribeEnsResourceUsageResponseBody : Tea.TeaModel {
    public class EnsResourceUsage : Tea.TeaModel {
        public var computeResourceCount: Int32?

        public var cpuSum: Int64?

        public var diskCount: Int32?

        public var downCount: Int32?

        public var expiredCount: Int32?

        public var expiringCount: Int32?

        public var gpuSum: Int64?

        public var instanceCount: Int32?

        public var runningCount: Int32?

        public var serviceType: String?

        public var storageSum: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.computeResourceCount != nil {
                map["ComputeResourceCount"] = self.computeResourceCount!
            }
            if self.cpuSum != nil {
                map["CpuSum"] = self.cpuSum!
            }
            if self.diskCount != nil {
                map["DiskCount"] = self.diskCount!
            }
            if self.downCount != nil {
                map["DownCount"] = self.downCount!
            }
            if self.expiredCount != nil {
                map["ExpiredCount"] = self.expiredCount!
            }
            if self.expiringCount != nil {
                map["ExpiringCount"] = self.expiringCount!
            }
            if self.gpuSum != nil {
                map["GpuSum"] = self.gpuSum!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.runningCount != nil {
                map["RunningCount"] = self.runningCount!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.storageSum != nil {
                map["StorageSum"] = self.storageSum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComputeResourceCount") {
                self.computeResourceCount = dict["ComputeResourceCount"] as! Int32
            }
            if dict.keys.contains("CpuSum") {
                self.cpuSum = dict["CpuSum"] as! Int64
            }
            if dict.keys.contains("DiskCount") {
                self.diskCount = dict["DiskCount"] as! Int32
            }
            if dict.keys.contains("DownCount") {
                self.downCount = dict["DownCount"] as! Int32
            }
            if dict.keys.contains("ExpiredCount") {
                self.expiredCount = dict["ExpiredCount"] as! Int32
            }
            if dict.keys.contains("ExpiringCount") {
                self.expiringCount = dict["ExpiringCount"] as! Int32
            }
            if dict.keys.contains("GpuSum") {
                self.gpuSum = dict["GpuSum"] as! Int64
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("RunningCount") {
                self.runningCount = dict["RunningCount"] as! Int32
            }
            if dict.keys.contains("ServiceType") {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("StorageSum") {
                self.storageSum = dict["StorageSum"] as! Int64
            }
        }
    }
    public var ensResourceUsage: [DescribeEnsResourceUsageResponseBody.EnsResourceUsage]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensResourceUsage != nil {
            var tmp : [Any] = []
            for k in self.ensResourceUsage! {
                tmp.append(k.toMap())
            }
            map["EnsResourceUsage"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsResourceUsage") {
            var tmp : [DescribeEnsResourceUsageResponseBody.EnsResourceUsage] = []
            for v in dict["EnsResourceUsage"] as! [Any] {
                var model = DescribeEnsResourceUsageResponseBody.EnsResourceUsage()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ensResourceUsage = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEnsResourceUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsResourceUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsResourceUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsRouteEntryListRequest : Tea.TeaModel {
    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var routeEntryId: String?

    public var routeEntryName: String?

    public var routeEntryType: String?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        if self.routeEntryType != nil {
            map["RouteEntryType"] = self.routeEntryType!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("NextHopId") {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopType") {
            self.nextHopType = dict["NextHopType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RouteEntryId") {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
        if dict.keys.contains("RouteEntryName") {
            self.routeEntryName = dict["RouteEntryName"] as! String
        }
        if dict.keys.contains("RouteEntryType") {
            self.routeEntryType = dict["RouteEntryType"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class DescribeEnsRouteEntryListResponseBody : Tea.TeaModel {
    public class RouteEntrys : Tea.TeaModel {
        public class NextHops : Tea.TeaModel {
            public var nextHopId: String?

            public var nextHopName: String?

            public var nextHopType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nextHopId != nil {
                    map["NextHopId"] = self.nextHopId!
                }
                if self.nextHopName != nil {
                    map["NextHopName"] = self.nextHopName!
                }
                if self.nextHopType != nil {
                    map["NextHopType"] = self.nextHopType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NextHopId") {
                    self.nextHopId = dict["NextHopId"] as! String
                }
                if dict.keys.contains("NextHopName") {
                    self.nextHopName = dict["NextHopName"] as! String
                }
                if dict.keys.contains("NextHopType") {
                    self.nextHopType = dict["NextHopType"] as! String
                }
            }
        }
        public var creationTime: String?

        public var description_: String?

        public var destinationCidrBlock: String?

        public var nextHops: [DescribeEnsRouteEntryListResponseBody.RouteEntrys.NextHops]?

        public var routeEntryId: String?

        public var routeEntryName: String?

        public var routeTableId: String?

        public var sourceCidrBlock: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationCidrBlock != nil {
                map["DestinationCidrBlock"] = self.destinationCidrBlock!
            }
            if self.nextHops != nil {
                var tmp : [Any] = []
                for k in self.nextHops! {
                    tmp.append(k.toMap())
                }
                map["NextHops"] = tmp
            }
            if self.routeEntryId != nil {
                map["RouteEntryId"] = self.routeEntryId!
            }
            if self.routeEntryName != nil {
                map["RouteEntryName"] = self.routeEntryName!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            if self.sourceCidrBlock != nil {
                map["SourceCidrBlock"] = self.sourceCidrBlock!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationCidrBlock") {
                self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
            }
            if dict.keys.contains("NextHops") {
                var tmp : [DescribeEnsRouteEntryListResponseBody.RouteEntrys.NextHops] = []
                for v in dict["NextHops"] as! [Any] {
                    var model = DescribeEnsRouteEntryListResponseBody.RouteEntrys.NextHops()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nextHops = tmp
            }
            if dict.keys.contains("RouteEntryId") {
                self.routeEntryId = dict["RouteEntryId"] as! String
            }
            if dict.keys.contains("RouteEntryName") {
                self.routeEntryName = dict["RouteEntryName"] as! String
            }
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! String
            }
            if dict.keys.contains("SourceCidrBlock") {
                self.sourceCidrBlock = dict["SourceCidrBlock"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routeEntrys: [DescribeEnsRouteEntryListResponseBody.RouteEntrys]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeEntrys != nil {
            var tmp : [Any] = []
            for k in self.routeEntrys! {
                tmp.append(k.toMap())
            }
            map["RouteEntrys"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteEntrys") {
            var tmp : [DescribeEnsRouteEntryListResponseBody.RouteEntrys] = []
            for v in dict["RouteEntrys"] as! [Any] {
                var model = DescribeEnsRouteEntryListResponseBody.RouteEntrys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeEntrys = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEnsRouteEntryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsRouteEntryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsRouteEntryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsRouteTablesRequest : Tea.TeaModel {
    public var associateType: String?

    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public var networkId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var routeTableId: String?

    public var routeTableName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associateType != nil {
            map["AssociateType"] = self.associateType!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssociateType") {
            self.associateType = dict["AssociateType"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("RouteTableName") {
            self.routeTableName = dict["RouteTableName"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeEnsRouteTablesResponseBody : Tea.TeaModel {
    public class RouteTables : Tea.TeaModel {
        public var associateType: String?

        public var creationTime: String?

        public var description_: String?

        public var ensRegionId: String?

        public var isDefaultGatewayRouteTable: Bool?

        public var networkId: String?

        public var routeTableId: String?

        public var routeTableName: String?

        public var status: String?

        public var type: String?

        public var vSwitchIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associateType != nil {
                map["AssociateType"] = self.associateType!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.isDefaultGatewayRouteTable != nil {
                map["IsDefaultGatewayRouteTable"] = self.isDefaultGatewayRouteTable!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            if self.routeTableName != nil {
                map["RouteTableName"] = self.routeTableName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociateType") {
                self.associateType = dict["AssociateType"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("IsDefaultGatewayRouteTable") {
                self.isDefaultGatewayRouteTable = dict["IsDefaultGatewayRouteTable"] as! Bool
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! String
            }
            if dict.keys.contains("RouteTableName") {
                self.routeTableName = dict["RouteTableName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("VSwitchIds") {
                self.vSwitchIds = dict["VSwitchIds"] as! [String]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routeTables: [DescribeEnsRouteTablesResponseBody.RouteTables]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTables != nil {
            var tmp : [Any] = []
            for k in self.routeTables! {
                tmp.append(k.toMap())
            }
            map["RouteTables"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteTables") {
            var tmp : [DescribeEnsRouteTablesResponseBody.RouteTables] = []
            for v in dict["RouteTables"] as! [Any] {
                var model = DescribeEnsRouteTablesResponseBody.RouteTables()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeTables = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEnsRouteTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsRouteTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsRouteTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsSaleControlRequest : Tea.TeaModel {
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var moduleCode: String?

    public var orderType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.moduleCode != nil {
            map["ModuleCode"] = self.moduleCode!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("ModuleCode") {
            self.moduleCode = dict["ModuleCode"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
    }
}

public class DescribeEnsSaleControlResponseBody : Tea.TeaModel {
    public class SaleControl : Tea.TeaModel {
        public class SaleControlItems : Tea.TeaModel {
            public class SaleControlItem : Tea.TeaModel {
                public class BasicSaleControl : Tea.TeaModel {
                    public class ModuleValue : Tea.TeaModel {
                        public var moduleMaxValue: String?

                        public var moduleMinValue: String?

                        public var moduleValue: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.moduleMaxValue != nil {
                                map["ModuleMaxValue"] = self.moduleMaxValue!
                            }
                            if self.moduleMinValue != nil {
                                map["ModuleMinValue"] = self.moduleMinValue!
                            }
                            if self.moduleValue != nil {
                                map["ModuleValue"] = self.moduleValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ModuleMaxValue") {
                                self.moduleMaxValue = dict["ModuleMaxValue"] as! String
                            }
                            if dict.keys.contains("ModuleMinValue") {
                                self.moduleMinValue = dict["ModuleMinValue"] as! String
                            }
                            if dict.keys.contains("ModuleValue") {
                                self.moduleValue = dict["ModuleValue"] as! [String]
                            }
                        }
                    }
                    public var description_: String?

                    public var moduleValue: DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.BasicSaleControl.ModuleValue?

                    public var operator_: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.moduleValue?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.moduleValue != nil {
                            map["ModuleValue"] = self.moduleValue?.toMap()
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("ModuleValue") {
                            var model = DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.BasicSaleControl.ModuleValue()
                            model.fromMap(dict["ModuleValue"] as! [String: Any])
                            self.moduleValue = model
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                    }
                }
                public class ConditionSaleControl : Tea.TeaModel {
                    public class ConditionControl : Tea.TeaModel {
                        public var conditionControlModuleCode: String?

                        public var conditionControlModuleValue: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.conditionControlModuleCode != nil {
                                map["ConditionControlModuleCode"] = self.conditionControlModuleCode!
                            }
                            if self.conditionControlModuleValue != nil {
                                map["ConditionControlModuleValue"] = self.conditionControlModuleValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ConditionControlModuleCode") {
                                self.conditionControlModuleCode = dict["ConditionControlModuleCode"] as! String
                            }
                            if dict.keys.contains("ConditionControlModuleValue") {
                                self.conditionControlModuleValue = dict["ConditionControlModuleValue"] as! String
                            }
                        }
                    }
                    public class ModuleValue : Tea.TeaModel {
                        public var moduleMaxValue: String?

                        public var moduleMinValue: String?

                        public var moduleValue: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.moduleMaxValue != nil {
                                map["ModuleMaxValue"] = self.moduleMaxValue!
                            }
                            if self.moduleMinValue != nil {
                                map["ModuleMinValue"] = self.moduleMinValue!
                            }
                            if self.moduleValue != nil {
                                map["ModuleValue"] = self.moduleValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ModuleMaxValue") {
                                self.moduleMaxValue = dict["ModuleMaxValue"] as! String
                            }
                            if dict.keys.contains("ModuleMinValue") {
                                self.moduleMinValue = dict["ModuleMinValue"] as! String
                            }
                            if dict.keys.contains("ModuleValue") {
                                self.moduleValue = dict["ModuleValue"] as! [String]
                            }
                        }
                    }
                    public var conditionControl: DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl.ConditionControl?

                    public var description_: String?

                    public var moduleValue: DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl.ModuleValue?

                    public var operator_: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.conditionControl?.validate()
                        try self.moduleValue?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.conditionControl != nil {
                            map["ConditionControl"] = self.conditionControl?.toMap()
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.moduleValue != nil {
                            map["ModuleValue"] = self.moduleValue?.toMap()
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConditionControl") {
                            var model = DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl.ConditionControl()
                            model.fromMap(dict["ConditionControl"] as! [String: Any])
                            self.conditionControl = model
                        }
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("ModuleValue") {
                            var model = DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl.ModuleValue()
                            model.fromMap(dict["ModuleValue"] as! [String: Any])
                            self.moduleValue = model
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                    }
                }
                public var basicSaleControl: DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.BasicSaleControl?

                public var conditionSaleControl: [DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.basicSaleControl?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.basicSaleControl != nil {
                        map["BasicSaleControl"] = self.basicSaleControl?.toMap()
                    }
                    if self.conditionSaleControl != nil {
                        var tmp : [Any] = []
                        for k in self.conditionSaleControl! {
                            tmp.append(k.toMap())
                        }
                        map["ConditionSaleControl"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BasicSaleControl") {
                        var model = DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.BasicSaleControl()
                        model.fromMap(dict["BasicSaleControl"] as! [String: Any])
                        self.basicSaleControl = model
                    }
                    if dict.keys.contains("ConditionSaleControl") {
                        var tmp : [DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl] = []
                        for v in dict["ConditionSaleControl"] as! [Any] {
                            var model = DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.conditionSaleControl = tmp
                    }
                }
            }
            public var moduleCode: String?

            public var saleControlItem: DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.saleControlItem?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.moduleCode != nil {
                    map["ModuleCode"] = self.moduleCode!
                }
                if self.saleControlItem != nil {
                    map["SaleControlItem"] = self.saleControlItem?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ModuleCode") {
                    self.moduleCode = dict["ModuleCode"] as! String
                }
                if dict.keys.contains("SaleControlItem") {
                    var model = DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems.SaleControlItem()
                    model.fromMap(dict["SaleControlItem"] as! [String: Any])
                    self.saleControlItem = model
                }
            }
        }
        public var commodityCode: String?

        public var orderType: String?

        public var saleControlItems: [DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            if self.saleControlItems != nil {
                var tmp : [Any] = []
                for k in self.saleControlItems! {
                    tmp.append(k.toMap())
                }
                map["SaleControlItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommodityCode") {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("OrderType") {
                self.orderType = dict["OrderType"] as! String
            }
            if dict.keys.contains("SaleControlItems") {
                var tmp : [DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems] = []
                for v in dict["SaleControlItems"] as! [Any] {
                    var model = DescribeEnsSaleControlResponseBody.SaleControl.SaleControlItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.saleControlItems = tmp
            }
        }
    }
    public var requestId: String?

    public var saleControl: [DescribeEnsSaleControlResponseBody.SaleControl]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.saleControl != nil {
            var tmp : [Any] = []
            for k in self.saleControl! {
                tmp.append(k.toMap())
            }
            map["SaleControl"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SaleControl") {
            var tmp : [DescribeEnsSaleControlResponseBody.SaleControl] = []
            for v in dict["SaleControl"] as! [Any] {
                var model = DescribeEnsSaleControlResponseBody.SaleControl()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.saleControl = tmp
        }
    }
}

public class DescribeEnsSaleControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsSaleControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsSaleControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsSaleControlAvailableResourceRequest : Tea.TeaModel {
    public var commodityCode: String?

    public var customAccount: String?

    public var orderType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
    }
}

public class DescribeEnsSaleControlAvailableResourceResponseBody : Tea.TeaModel {
    public class SaleControlAvailableResource : Tea.TeaModel {
        public class AvailableDiskType : Tea.TeaModel {
            public var diskName: String?

            public var diskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.diskType != nil {
                    map["DiskType"] = self.diskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskName") {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("DiskType") {
                    self.diskType = dict["DiskType"] as! String
                }
            }
        }
        public class AvailableRegion : Tea.TeaModel {
            public var area: String?

            public var city: String?

            public var country: String?

            public var ensRegionId: String?

            public var ensRegionName: String?

            public var isp: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area != nil {
                    map["Area"] = self.area!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.country != nil {
                    map["Country"] = self.country!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.ensRegionName != nil {
                    map["EnsRegionName"] = self.ensRegionName!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Area") {
                    self.area = dict["Area"] as! String
                }
                if dict.keys.contains("City") {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("Country") {
                    self.country = dict["Country"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("EnsRegionName") {
                    self.ensRegionName = dict["EnsRegionName"] as! String
                }
                if dict.keys.contains("Isp") {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public class AvailableSpec : Tea.TeaModel {
            public var cores: String?

            public var memory: String?

            public var specName: String?

            public var specValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cores != nil {
                    map["Cores"] = self.cores!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.specName != nil {
                    map["SpecName"] = self.specName!
                }
                if self.specValue != nil {
                    map["SpecValue"] = self.specValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cores") {
                    self.cores = dict["Cores"] as! String
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! String
                }
                if dict.keys.contains("SpecName") {
                    self.specName = dict["SpecName"] as! String
                }
                if dict.keys.contains("SpecValue") {
                    self.specValue = dict["SpecValue"] as! String
                }
            }
        }
        public class AvailableStorageType : Tea.TeaModel {
            public class AvailableDefaultStorageType : Tea.TeaModel {
                public var storageName: String?

                public var storageType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.storageName != nil {
                        map["StorageName"] = self.storageName!
                    }
                    if self.storageType != nil {
                        map["StorageType"] = self.storageType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StorageName") {
                        self.storageName = dict["StorageName"] as! String
                    }
                    if dict.keys.contains("StorageType") {
                        self.storageType = dict["StorageType"] as! String
                    }
                }
            }
            public class AvailableSpecialStorageType : Tea.TeaModel {
                public var storageType: String?

                public var storageName: String?

                public var ensRegionId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.storageType != nil {
                        map["StorageType"] = self.storageType!
                    }
                    if self.storageName != nil {
                        map["StorageName"] = self.storageName!
                    }
                    if self.ensRegionId != nil {
                        map["EnsRegionId"] = self.ensRegionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StorageType") {
                        self.storageType = dict["StorageType"] as! String
                    }
                    if dict.keys.contains("StorageName") {
                        self.storageName = dict["StorageName"] as! String
                    }
                    if dict.keys.contains("EnsRegionId") {
                        self.ensRegionId = dict["EnsRegionId"] as! String
                    }
                }
            }
            public var availableDefaultStorageType: [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableStorageType.AvailableDefaultStorageType]?

            public var availableSpecialStorageType: [[DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableStorageType.AvailableSpecialStorageType]]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableDefaultStorageType != nil {
                    var tmp : [Any] = []
                    for k in self.availableDefaultStorageType! {
                        tmp.append(k.toMap())
                    }
                    map["AvailableDefaultStorageType"] = tmp
                }
                if self.availableSpecialStorageType != nil {
                    var tmp : [Any] = []
                    for k in self.availableSpecialStorageType! {
                        var l1 : [Any] = []
                        for k1 in k {
                            l1.append(k1.toMap())
                        }
                        tmp.append(l1)
                    }
                    map["AvailableSpecialStorageType"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableDefaultStorageType") {
                    var tmp : [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableStorageType.AvailableDefaultStorageType] = []
                    for v in dict["AvailableDefaultStorageType"] as! [Any] {
                        var model = DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableStorageType.AvailableDefaultStorageType()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.availableDefaultStorageType = tmp
                }
                if dict.keys.contains("AvailableSpecialStorageType") {
                    var tmp : [[DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableStorageType.AvailableSpecialStorageType]] = []
                    for v in dict["AvailableSpecialStorageType"] as! [Any] {
                        var l1 : [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableStorageType.AvailableSpecialStorageType] = []
                        for v1 in v as! [Any] {
                            var model = DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableStorageType.AvailableSpecialStorageType()
                            if v1 != nil {
                                model.fromMap(v1 as! [String: Any])
                            }
                            l1.append(model)
                        }
                        tmp.append(l1)
                    }
                    self.availableSpecialStorageType = tmp
                }
            }
        }
        public var availableDiskType: [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableDiskType]?

        public var availableRegion: [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableRegion]?

        public var availableSpec: [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableSpec]?

        public var availableStorageType: DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableStorageType?

        public var commodityCode: String?

        public var orderType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.availableStorageType?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableDiskType != nil {
                var tmp : [Any] = []
                for k in self.availableDiskType! {
                    tmp.append(k.toMap())
                }
                map["AvailableDiskType"] = tmp
            }
            if self.availableRegion != nil {
                var tmp : [Any] = []
                for k in self.availableRegion! {
                    tmp.append(k.toMap())
                }
                map["AvailableRegion"] = tmp
            }
            if self.availableSpec != nil {
                var tmp : [Any] = []
                for k in self.availableSpec! {
                    tmp.append(k.toMap())
                }
                map["AvailableSpec"] = tmp
            }
            if self.availableStorageType != nil {
                map["AvailableStorageType"] = self.availableStorageType?.toMap()
            }
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableDiskType") {
                var tmp : [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableDiskType] = []
                for v in dict["AvailableDiskType"] as! [Any] {
                    var model = DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableDiskType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableDiskType = tmp
            }
            if dict.keys.contains("AvailableRegion") {
                var tmp : [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableRegion] = []
                for v in dict["AvailableRegion"] as! [Any] {
                    var model = DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableRegion()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableRegion = tmp
            }
            if dict.keys.contains("AvailableSpec") {
                var tmp : [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableSpec] = []
                for v in dict["AvailableSpec"] as! [Any] {
                    var model = DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableSpec()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableSpec = tmp
            }
            if dict.keys.contains("AvailableStorageType") {
                var model = DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource.AvailableStorageType()
                model.fromMap(dict["AvailableStorageType"] as! [String: Any])
                self.availableStorageType = model
            }
            if dict.keys.contains("CommodityCode") {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("OrderType") {
                self.orderType = dict["OrderType"] as! String
            }
        }
    }
    public var requestId: String?

    public var saleControlAvailableResource: [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.saleControlAvailableResource != nil {
            var tmp : [Any] = []
            for k in self.saleControlAvailableResource! {
                tmp.append(k.toMap())
            }
            map["SaleControlAvailableResource"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SaleControlAvailableResource") {
            var tmp : [DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource] = []
            for v in dict["SaleControlAvailableResource"] as! [Any] {
                var model = DescribeEnsSaleControlAvailableResourceResponseBody.SaleControlAvailableResource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.saleControlAvailableResource = tmp
        }
    }
}

public class DescribeEnsSaleControlAvailableResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsSaleControlAvailableResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsSaleControlAvailableResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEnsSaleControlStockRequest : Tea.TeaModel {
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var moduleCode: String?

    public var orderType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.moduleCode != nil {
            map["ModuleCode"] = self.moduleCode!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("ModuleCode") {
            self.moduleCode = dict["ModuleCode"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
    }
}

public class DescribeEnsSaleControlStockResponseBody : Tea.TeaModel {
    public class SaleControl : Tea.TeaModel {
        public class SaleControlItems : Tea.TeaModel {
            public class SaleControlItem : Tea.TeaModel {
                public class BasicSaleControl : Tea.TeaModel {
                    public class ModuleValue : Tea.TeaModel {
                        public var moduleMaxValue: String?

                        public var moduleMinValue: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.moduleMaxValue != nil {
                                map["ModuleMaxValue"] = self.moduleMaxValue!
                            }
                            if self.moduleMinValue != nil {
                                map["ModuleMinValue"] = self.moduleMinValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ModuleMaxValue") {
                                self.moduleMaxValue = dict["ModuleMaxValue"] as! String
                            }
                            if dict.keys.contains("ModuleMinValue") {
                                self.moduleMinValue = dict["ModuleMinValue"] as! String
                            }
                        }
                    }
                    public var moduleValue: DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.BasicSaleControl.ModuleValue?

                    public var stockValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.moduleValue?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.moduleValue != nil {
                            map["ModuleValue"] = self.moduleValue?.toMap()
                        }
                        if self.stockValue != nil {
                            map["StockValue"] = self.stockValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ModuleValue") {
                            var model = DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.BasicSaleControl.ModuleValue()
                            model.fromMap(dict["ModuleValue"] as! [String: Any])
                            self.moduleValue = model
                        }
                        if dict.keys.contains("StockValue") {
                            self.stockValue = dict["StockValue"] as! String
                        }
                    }
                }
                public class ConditionSaleControl : Tea.TeaModel {
                    public class ConditionControl : Tea.TeaModel {
                        public var conditionControlModuleCode: String?

                        public var conditionControlModuleValue: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.conditionControlModuleCode != nil {
                                map["ConditionControlModuleCode"] = self.conditionControlModuleCode!
                            }
                            if self.conditionControlModuleValue != nil {
                                map["ConditionControlModuleValue"] = self.conditionControlModuleValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ConditionControlModuleCode") {
                                self.conditionControlModuleCode = dict["ConditionControlModuleCode"] as! String
                            }
                            if dict.keys.contains("ConditionControlModuleValue") {
                                self.conditionControlModuleValue = dict["ConditionControlModuleValue"] as! String
                            }
                        }
                    }
                    public class ModuleValue : Tea.TeaModel {
                        public var moduleMaxValue: String?

                        public var moduleMinValue: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.moduleMaxValue != nil {
                                map["ModuleMaxValue"] = self.moduleMaxValue!
                            }
                            if self.moduleMinValue != nil {
                                map["ModuleMinValue"] = self.moduleMinValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ModuleMaxValue") {
                                self.moduleMaxValue = dict["ModuleMaxValue"] as! String
                            }
                            if dict.keys.contains("ModuleMinValue") {
                                self.moduleMinValue = dict["ModuleMinValue"] as! String
                            }
                        }
                    }
                    public var conditionControl: DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl.ConditionControl?

                    public var moduleValue: DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl.ModuleValue?

                    public var stockValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.conditionControl?.validate()
                        try self.moduleValue?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.conditionControl != nil {
                            map["ConditionControl"] = self.conditionControl?.toMap()
                        }
                        if self.moduleValue != nil {
                            map["ModuleValue"] = self.moduleValue?.toMap()
                        }
                        if self.stockValue != nil {
                            map["StockValue"] = self.stockValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConditionControl") {
                            var model = DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl.ConditionControl()
                            model.fromMap(dict["ConditionControl"] as! [String: Any])
                            self.conditionControl = model
                        }
                        if dict.keys.contains("ModuleValue") {
                            var model = DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl.ModuleValue()
                            model.fromMap(dict["ModuleValue"] as! [String: Any])
                            self.moduleValue = model
                        }
                        if dict.keys.contains("StockValue") {
                            self.stockValue = dict["StockValue"] as! String
                        }
                    }
                }
                public var basicSaleControl: DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.BasicSaleControl?

                public var conditionSaleControl: [DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.basicSaleControl?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.basicSaleControl != nil {
                        map["BasicSaleControl"] = self.basicSaleControl?.toMap()
                    }
                    if self.conditionSaleControl != nil {
                        var tmp : [Any] = []
                        for k in self.conditionSaleControl! {
                            tmp.append(k.toMap())
                        }
                        map["ConditionSaleControl"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BasicSaleControl") {
                        var model = DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.BasicSaleControl()
                        model.fromMap(dict["BasicSaleControl"] as! [String: Any])
                        self.basicSaleControl = model
                    }
                    if dict.keys.contains("ConditionSaleControl") {
                        var tmp : [DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl] = []
                        for v in dict["ConditionSaleControl"] as! [Any] {
                            var model = DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem.ConditionSaleControl()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.conditionSaleControl = tmp
                    }
                }
            }
            public var moduleCode: String?

            public var saleControlItem: DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.saleControlItem?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.moduleCode != nil {
                    map["ModuleCode"] = self.moduleCode!
                }
                if self.saleControlItem != nil {
                    map["SaleControlItem"] = self.saleControlItem?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ModuleCode") {
                    self.moduleCode = dict["ModuleCode"] as! String
                }
                if dict.keys.contains("SaleControlItem") {
                    var model = DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems.SaleControlItem()
                    model.fromMap(dict["SaleControlItem"] as! [String: Any])
                    self.saleControlItem = model
                }
            }
        }
        public var commodityCode: String?

        public var orderType: String?

        public var saleControlItems: [DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            if self.saleControlItems != nil {
                var tmp : [Any] = []
                for k in self.saleControlItems! {
                    tmp.append(k.toMap())
                }
                map["SaleControlItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommodityCode") {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("OrderType") {
                self.orderType = dict["OrderType"] as! String
            }
            if dict.keys.contains("SaleControlItems") {
                var tmp : [DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems] = []
                for v in dict["SaleControlItems"] as! [Any] {
                    var model = DescribeEnsSaleControlStockResponseBody.SaleControl.SaleControlItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.saleControlItems = tmp
            }
        }
    }
    public var requestId: String?

    public var saleControl: [DescribeEnsSaleControlStockResponseBody.SaleControl]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.saleControl != nil {
            var tmp : [Any] = []
            for k in self.saleControl! {
                tmp.append(k.toMap())
            }
            map["SaleControl"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SaleControl") {
            var tmp : [DescribeEnsSaleControlStockResponseBody.SaleControl] = []
            for v in dict["SaleControl"] as! [Any] {
                var model = DescribeEnsSaleControlStockResponseBody.SaleControl()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.saleControl = tmp
        }
    }
}

public class DescribeEnsSaleControlStockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnsSaleControlStockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEnsSaleControlStockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnBandWidthDataRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var endTime: String?

    public var ensRegionId: String?

    public var instanceId: String?

    public var isp: String?

    public var networkingModel: String?

    public var period: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("NetworkingModel") {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeEpnBandWidthDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class BandWidthMonitorData : Tea.TeaModel {
            public var downBandWidth: Int64?

            public var internetRX: Int64?

            public var internetTX: Int64?

            public var timeStamp: String?

            public var upBandWidth: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downBandWidth != nil {
                    map["DownBandWidth"] = self.downBandWidth!
                }
                if self.internetRX != nil {
                    map["InternetRX"] = self.internetRX!
                }
                if self.internetTX != nil {
                    map["InternetTX"] = self.internetTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.upBandWidth != nil {
                    map["UpBandWidth"] = self.upBandWidth!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DownBandWidth") {
                    self.downBandWidth = dict["DownBandWidth"] as! Int64
                }
                if dict.keys.contains("InternetRX") {
                    self.internetRX = dict["InternetRX"] as! Int64
                }
                if dict.keys.contains("InternetTX") {
                    self.internetTX = dict["InternetTX"] as! Int64
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("UpBandWidth") {
                    self.upBandWidth = dict["UpBandWidth"] as! Int64
                }
            }
        }
        public var bandWidthMonitorData: [DescribeEpnBandWidthDataResponseBody.MonitorData.BandWidthMonitorData]?

        public var maxDownBandWidth: Int64?

        public var maxUpBandWidth: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandWidthMonitorData != nil {
                var tmp : [Any] = []
                for k in self.bandWidthMonitorData! {
                    tmp.append(k.toMap())
                }
                map["BandWidthMonitorData"] = tmp
            }
            if self.maxDownBandWidth != nil {
                map["MaxDownBandWidth"] = self.maxDownBandWidth!
            }
            if self.maxUpBandWidth != nil {
                map["MaxUpBandWidth"] = self.maxUpBandWidth!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BandWidthMonitorData") {
                var tmp : [DescribeEpnBandWidthDataResponseBody.MonitorData.BandWidthMonitorData] = []
                for v in dict["BandWidthMonitorData"] as! [Any] {
                    var model = DescribeEpnBandWidthDataResponseBody.MonitorData.BandWidthMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bandWidthMonitorData = tmp
            }
            if dict.keys.contains("MaxDownBandWidth") {
                self.maxDownBandWidth = dict["MaxDownBandWidth"] as! Int64
            }
            if dict.keys.contains("MaxUpBandWidth") {
                self.maxUpBandWidth = dict["MaxUpBandWidth"] as! Int64
            }
        }
    }
    public var monitorData: DescribeEpnBandWidthDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorData") {
            var model = DescribeEpnBandWidthDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEpnBandWidthDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnBandWidthDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEpnBandWidthDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnBandwitdhByInternetChargeTypeRequest : Tea.TeaModel {
    public var endTime: String?

    public var ensRegionId: String?

    public var isp: String?

    public var networkingModel: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("NetworkingModel") {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeEpnBandwitdhByInternetChargeTypeResponseBody : Tea.TeaModel {
    public var bandwidthValue: Int64?

    public var internetChargeType: String?

    public var requestId: String?

    public var timeStamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthValue != nil {
            map["BandwidthValue"] = self.bandwidthValue!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthValue") {
            self.bandwidthValue = dict["BandwidthValue"] as! Int64
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeStamp") {
            self.timeStamp = dict["TimeStamp"] as! String
        }
    }
}

public class DescribeEpnBandwitdhByInternetChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnBandwitdhByInternetChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEpnBandwitdhByInternetChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnInstanceAttributeRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
    }
}

public class DescribeEpnInstanceAttributeResponseBody : Tea.TeaModel {
    public class ConfVersions : Tea.TeaModel {
        public var confVersion: String?

        public var ensRegionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confVersion != nil {
                map["ConfVersion"] = self.confVersion!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfVersion") {
                self.confVersion = dict["ConfVersion"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
        }
    }
    public class Instances : Tea.TeaModel {
        public var ensRegionId: String?

        public var instanceId: String?

        public var instanceName: String?

        public var isp: String?

        public var privateIpAddress: String?

        public var publicIpAddress: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress!
            }
            if self.publicIpAddress != nil {
                map["PublicIpAddress"] = self.publicIpAddress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("Isp") {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("PrivateIpAddress") {
                self.privateIpAddress = dict["PrivateIpAddress"] as! String
            }
            if dict.keys.contains("PublicIpAddress") {
                self.publicIpAddress = dict["PublicIpAddress"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class VSwitches : Tea.TeaModel {
        public var cidrBlock: String?

        public var ensRegionId: String?

        public var vSwitchId: String?

        public var vSwitchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchName != nil {
                map["VSwitchName"] = self.vSwitchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrBlock") {
                self.cidrBlock = dict["CidrBlock"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VSwitchName") {
                self.vSwitchName = dict["VSwitchName"] as! String
            }
        }
    }
    public var confVersions: [DescribeEpnInstanceAttributeResponseBody.ConfVersions]?

    public var EPNInstanceId: String?

    public var EPNInstanceName: String?

    public var instances: [DescribeEpnInstanceAttributeResponseBody.Instances]?

    public var networkingModel: String?

    public var requestId: String?

    public var vSwitches: [DescribeEpnInstanceAttributeResponseBody.VSwitches]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confVersions != nil {
            var tmp : [Any] = []
            for k in self.confVersions! {
                tmp.append(k.toMap())
            }
            map["ConfVersions"] = tmp
        }
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.EPNInstanceName != nil {
            map["EPNInstanceName"] = self.EPNInstanceName!
        }
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitches != nil {
            var tmp : [Any] = []
            for k in self.vSwitches! {
                tmp.append(k.toMap())
            }
            map["VSwitches"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfVersions") {
            var tmp : [DescribeEpnInstanceAttributeResponseBody.ConfVersions] = []
            for v in dict["ConfVersions"] as! [Any] {
                var model = DescribeEpnInstanceAttributeResponseBody.ConfVersions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.confVersions = tmp
        }
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("EPNInstanceName") {
            self.EPNInstanceName = dict["EPNInstanceName"] as! String
        }
        if dict.keys.contains("Instances") {
            var tmp : [DescribeEpnInstanceAttributeResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = DescribeEpnInstanceAttributeResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("NetworkingModel") {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitches") {
            var tmp : [DescribeEpnInstanceAttributeResponseBody.VSwitches] = []
            for v in dict["VSwitches"] as! [Any] {
                var model = DescribeEpnInstanceAttributeResponseBody.VSwitches()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vSwitches = tmp
        }
    }
}

public class DescribeEpnInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEpnInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnInstancesRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var EPNInstanceName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.EPNInstanceName != nil {
            map["EPNInstanceName"] = self.EPNInstanceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("EPNInstanceName") {
            self.EPNInstanceName = dict["EPNInstanceName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeEpnInstancesResponseBody : Tea.TeaModel {
    public class EPNInstances : Tea.TeaModel {
        public class EPNInstance : Tea.TeaModel {
            public var creationTime: String?

            public var EPNInstanceId: String?

            public var EPNInstanceName: String?

            public var EPNInstanceType: String?

            public var endTime: String?

            public var internetMaxBandwidthOut: Int32?

            public var modifyTime: String?

            public var networkingModel: String?

            public var startTime: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.EPNInstanceId != nil {
                    map["EPNInstanceId"] = self.EPNInstanceId!
                }
                if self.EPNInstanceName != nil {
                    map["EPNInstanceName"] = self.EPNInstanceName!
                }
                if self.EPNInstanceType != nil {
                    map["EPNInstanceType"] = self.EPNInstanceType!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.internetMaxBandwidthOut != nil {
                    map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.networkingModel != nil {
                    map["NetworkingModel"] = self.networkingModel!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("EPNInstanceId") {
                    self.EPNInstanceId = dict["EPNInstanceId"] as! String
                }
                if dict.keys.contains("EPNInstanceName") {
                    self.EPNInstanceName = dict["EPNInstanceName"] as! String
                }
                if dict.keys.contains("EPNInstanceType") {
                    self.EPNInstanceType = dict["EPNInstanceType"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("InternetMaxBandwidthOut") {
                    self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! String
                }
                if dict.keys.contains("NetworkingModel") {
                    self.networkingModel = dict["NetworkingModel"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var EPNInstance: [DescribeEpnInstancesResponseBody.EPNInstances.EPNInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.EPNInstance != nil {
                var tmp : [Any] = []
                for k in self.EPNInstance! {
                    tmp.append(k.toMap())
                }
                map["EPNInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EPNInstance") {
                var tmp : [DescribeEpnInstancesResponseBody.EPNInstances.EPNInstance] = []
                for v in dict["EPNInstance"] as! [Any] {
                    var model = DescribeEpnInstancesResponseBody.EPNInstances.EPNInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.EPNInstance = tmp
            }
        }
    }
    public var EPNInstances: DescribeEpnInstancesResponseBody.EPNInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.EPNInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstances != nil {
            map["EPNInstances"] = self.EPNInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstances") {
            var model = DescribeEpnInstancesResponseBody.EPNInstances()
            model.fromMap(dict["EPNInstances"] as! [String: Any])
            self.EPNInstances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEpnInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEpnInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEpnMeasurementDataRequest : Tea.TeaModel {
    public var endDate: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeEpnMeasurementDataResponseBody : Tea.TeaModel {
    public class MeasurementDatas : Tea.TeaModel {
        public class MeasurementData : Tea.TeaModel {
            public class BandWidthFeeDatas : Tea.TeaModel {
                public class BandWidthFeeData : Tea.TeaModel {
                    public var costCode: String?

                    public var costName: String?

                    public var costType: String?

                    public var costVal: Int32?

                    public var ispLine: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.costCode != nil {
                            map["CostCode"] = self.costCode!
                        }
                        if self.costName != nil {
                            map["CostName"] = self.costName!
                        }
                        if self.costType != nil {
                            map["CostType"] = self.costType!
                        }
                        if self.costVal != nil {
                            map["CostVal"] = self.costVal!
                        }
                        if self.ispLine != nil {
                            map["IspLine"] = self.ispLine!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CostCode") {
                            self.costCode = dict["CostCode"] as! String
                        }
                        if dict.keys.contains("CostName") {
                            self.costName = dict["CostName"] as! String
                        }
                        if dict.keys.contains("CostType") {
                            self.costType = dict["CostType"] as! String
                        }
                        if dict.keys.contains("CostVal") {
                            self.costVal = dict["CostVal"] as! Int32
                        }
                        if dict.keys.contains("IspLine") {
                            self.ispLine = dict["IspLine"] as! String
                        }
                    }
                }
                public var bandWidthFeeData: [DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandWidthFeeData != nil {
                        var tmp : [Any] = []
                        for k in self.bandWidthFeeData! {
                            tmp.append(k.toMap())
                        }
                        map["BandWidthFeeData"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BandWidthFeeData") {
                        var tmp : [DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData] = []
                        for v in dict["BandWidthFeeData"] as! [Any] {
                            var model = DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.bandWidthFeeData = tmp
                    }
                }
            }
            public var bandWidthFeeDatas: DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas?

            public var chargeModel: String?

            public var costCycle: String?

            public var costEndTime: String?

            public var costStartTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bandWidthFeeDatas?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidthFeeDatas != nil {
                    map["BandWidthFeeDatas"] = self.bandWidthFeeDatas?.toMap()
                }
                if self.chargeModel != nil {
                    map["ChargeModel"] = self.chargeModel!
                }
                if self.costCycle != nil {
                    map["CostCycle"] = self.costCycle!
                }
                if self.costEndTime != nil {
                    map["CostEndTime"] = self.costEndTime!
                }
                if self.costStartTime != nil {
                    map["CostStartTime"] = self.costStartTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandWidthFeeDatas") {
                    var model = DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas()
                    model.fromMap(dict["BandWidthFeeDatas"] as! [String: Any])
                    self.bandWidthFeeDatas = model
                }
                if dict.keys.contains("ChargeModel") {
                    self.chargeModel = dict["ChargeModel"] as! String
                }
                if dict.keys.contains("CostCycle") {
                    self.costCycle = dict["CostCycle"] as! String
                }
                if dict.keys.contains("CostEndTime") {
                    self.costEndTime = dict["CostEndTime"] as! String
                }
                if dict.keys.contains("CostStartTime") {
                    self.costStartTime = dict["CostStartTime"] as! String
                }
            }
        }
        public var measurementData: [DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.measurementData != nil {
                var tmp : [Any] = []
                for k in self.measurementData! {
                    tmp.append(k.toMap())
                }
                map["MeasurementData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MeasurementData") {
                var tmp : [DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData] = []
                for v in dict["MeasurementData"] as! [Any] {
                    var model = DescribeEpnMeasurementDataResponseBody.MeasurementDatas.MeasurementData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.measurementData = tmp
            }
        }
    }
    public var measurementDatas: DescribeEpnMeasurementDataResponseBody.MeasurementDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.measurementDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.measurementDatas != nil {
            map["MeasurementDatas"] = self.measurementDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MeasurementDatas") {
            var model = DescribeEpnMeasurementDataResponseBody.MeasurementDatas()
            model.fromMap(dict["MeasurementDatas"] as! [String: Any])
            self.measurementDatas = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEpnMeasurementDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEpnMeasurementDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEpnMeasurementDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExportImageInfoRequest : Tea.TeaModel {
    public var imageId: String?

    public var imageName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeExportImageInfoResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var architecture: String?

            public var creationTime: String?

            public var exportedImageURL: String?

            public var imageExportStatus: String?

            public var imageId: String?

            public var imageName: String?

            public var imageOwnerAlias: String?

            public var platform: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architecture != nil {
                    map["Architecture"] = self.architecture!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.exportedImageURL != nil {
                    map["ExportedImageURL"] = self.exportedImageURL!
                }
                if self.imageExportStatus != nil {
                    map["ImageExportStatus"] = self.imageExportStatus!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageOwnerAlias != nil {
                    map["ImageOwnerAlias"] = self.imageOwnerAlias!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Architecture") {
                    self.architecture = dict["Architecture"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("ExportedImageURL") {
                    self.exportedImageURL = dict["ExportedImageURL"] as! String
                }
                if dict.keys.contains("ImageExportStatus") {
                    self.imageExportStatus = dict["ImageExportStatus"] as! String
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImageOwnerAlias") {
                    self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
            }
        }
        public var image: [DescribeExportImageInfoResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") {
                var tmp : [DescribeExportImageInfoResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeExportImageInfoResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public var images: DescribeExportImageInfoResponseBody.Images?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Images") {
            var model = DescribeExportImageInfoResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeExportImageInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExportImageInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExportImageInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExportImageStatusRequest : Tea.TeaModel {
    public var imageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
    }
}

public class DescribeExportImageStatusResponseBody : Tea.TeaModel {
    public var imageExportStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageExportStatus != nil {
            map["ImageExportStatus"] = self.imageExportStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageExportStatus") {
            self.imageExportStatus = dict["ImageExportStatus"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeExportImageStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExportImageStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExportImageStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFileSystemsRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public var fileSystemName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.fileSystemName != nil {
            map["FileSystemName"] = self.fileSystemName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("FileSystemName") {
            self.fileSystemName = dict["FileSystemName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeFileSystemsResponseBody : Tea.TeaModel {
    public class FileSystems : Tea.TeaModel {
        public class MountTargets : Tea.TeaModel {
            public var mountTargetDomain: String?

            public var mountTargetName: String?

            public var netWorkId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountTargetDomain != nil {
                    map["MountTargetDomain"] = self.mountTargetDomain!
                }
                if self.mountTargetName != nil {
                    map["MountTargetName"] = self.mountTargetName!
                }
                if self.netWorkId != nil {
                    map["NetWorkId"] = self.netWorkId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountTargetDomain") {
                    self.mountTargetDomain = dict["MountTargetDomain"] as! String
                }
                if dict.keys.contains("MountTargetName") {
                    self.mountTargetName = dict["MountTargetName"] as! String
                }
                if dict.keys.contains("NetWorkId") {
                    self.netWorkId = dict["NetWorkId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var capacity: Int64?

        public var creationTime: String?

        public var description_: String?

        public var ensRegionId: String?

        public var fileSystemId: String?

        public var fileSystemName: String?

        public var meteredSize: Int64?

        public var mountTargets: [DescribeFileSystemsResponseBody.FileSystems.MountTargets]?

        public var payType: String?

        public var protocolType: String?

        public var status: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacity != nil {
                map["Capacity"] = self.capacity!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.fileSystemId != nil {
                map["FileSystemId"] = self.fileSystemId!
            }
            if self.fileSystemName != nil {
                map["FileSystemName"] = self.fileSystemName!
            }
            if self.meteredSize != nil {
                map["MeteredSize"] = self.meteredSize!
            }
            if self.mountTargets != nil {
                var tmp : [Any] = []
                for k in self.mountTargets! {
                    tmp.append(k.toMap())
                }
                map["MountTargets"] = tmp
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Capacity") {
                self.capacity = dict["Capacity"] as! Int64
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("FileSystemId") {
                self.fileSystemId = dict["FileSystemId"] as! String
            }
            if dict.keys.contains("FileSystemName") {
                self.fileSystemName = dict["FileSystemName"] as! String
            }
            if dict.keys.contains("MeteredSize") {
                self.meteredSize = dict["MeteredSize"] as! Int64
            }
            if dict.keys.contains("MountTargets") {
                var tmp : [DescribeFileSystemsResponseBody.FileSystems.MountTargets] = []
                for v in dict["MountTargets"] as! [Any] {
                    var model = DescribeFileSystemsResponseBody.FileSystems.MountTargets()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mountTargets = tmp
            }
            if dict.keys.contains("PayType") {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("ProtocolType") {
                self.protocolType = dict["ProtocolType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public var fileSystems: [DescribeFileSystemsResponseBody.FileSystems]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSystems != nil {
            var tmp : [Any] = []
            for k in self.fileSystems! {
                tmp.append(k.toMap())
            }
            map["FileSystems"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileSystems") {
            var tmp : [DescribeFileSystemsResponseBody.FileSystems] = []
            for v in dict["FileSystems"] as! [Any] {
                var model = DescribeFileSystemsResponseBody.FileSystems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileSystems = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeFileSystemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFileSystemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFileSystemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeForwardTableEntriesRequest : Tea.TeaModel {
    public var externalIp: String?

    public var forwardEntryId: String?

    public var forwardEntryName: String?

    public var internalIp: String?

    public var ipProtocol: String?

    public var natGatewayId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExternalIp") {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardEntryName") {
            self.forwardEntryName = dict["ForwardEntryName"] as! String
        }
        if dict.keys.contains("InternalIp") {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeForwardTableEntriesResponseBody : Tea.TeaModel {
    public class ForwardTableEntries : Tea.TeaModel {
        public var externalIp: String?

        public var externalPort: String?

        public var forwardEntryId: String?

        public var forwardEntryName: String?

        public var healthCheckPort: String?

        public var internalIp: String?

        public var internalPort: String?

        public var ipProtocol: String?

        public var natGatewayId: String?

        public var standbyExternalIp: String?

        public var standbyStatus: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.externalIp != nil {
                map["ExternalIp"] = self.externalIp!
            }
            if self.externalPort != nil {
                map["ExternalPort"] = self.externalPort!
            }
            if self.forwardEntryId != nil {
                map["ForwardEntryId"] = self.forwardEntryId!
            }
            if self.forwardEntryName != nil {
                map["ForwardEntryName"] = self.forwardEntryName!
            }
            if self.healthCheckPort != nil {
                map["HealthCheckPort"] = self.healthCheckPort!
            }
            if self.internalIp != nil {
                map["InternalIp"] = self.internalIp!
            }
            if self.internalPort != nil {
                map["InternalPort"] = self.internalPort!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.standbyExternalIp != nil {
                map["StandbyExternalIp"] = self.standbyExternalIp!
            }
            if self.standbyStatus != nil {
                map["StandbyStatus"] = self.standbyStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExternalIp") {
                self.externalIp = dict["ExternalIp"] as! String
            }
            if dict.keys.contains("ExternalPort") {
                self.externalPort = dict["ExternalPort"] as! String
            }
            if dict.keys.contains("ForwardEntryId") {
                self.forwardEntryId = dict["ForwardEntryId"] as! String
            }
            if dict.keys.contains("ForwardEntryName") {
                self.forwardEntryName = dict["ForwardEntryName"] as! String
            }
            if dict.keys.contains("HealthCheckPort") {
                self.healthCheckPort = dict["HealthCheckPort"] as! String
            }
            if dict.keys.contains("InternalIp") {
                self.internalIp = dict["InternalIp"] as! String
            }
            if dict.keys.contains("InternalPort") {
                self.internalPort = dict["InternalPort"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("NatGatewayId") {
                self.natGatewayId = dict["NatGatewayId"] as! String
            }
            if dict.keys.contains("StandbyExternalIp") {
                self.standbyExternalIp = dict["StandbyExternalIp"] as! String
            }
            if dict.keys.contains("StandbyStatus") {
                self.standbyStatus = dict["StandbyStatus"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var forwardTableEntries: [DescribeForwardTableEntriesResponseBody.ForwardTableEntries]?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardTableEntries != nil {
            var tmp : [Any] = []
            for k in self.forwardTableEntries! {
                tmp.append(k.toMap())
            }
            map["ForwardTableEntries"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardTableEntries") {
            var tmp : [DescribeForwardTableEntriesResponseBody.ForwardTableEntries] = []
            for v in dict["ForwardTableEntries"] as! [Any] {
                var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.forwardTableEntries = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeForwardTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeForwardTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeForwardTableEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHaVipsRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public var haVipAddress: String?

    public var haVipId: String?

    public var name: String?

    public var networkId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var status: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.haVipAddress != nil {
            map["HaVipAddress"] = self.haVipAddress!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("HaVipAddress") {
            self.haVipAddress = dict["HaVipAddress"] as! String
        }
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeHaVipsResponseBody : Tea.TeaModel {
    public class HaVips : Tea.TeaModel {
        public class AssociatedEipAddresses : Tea.TeaModel {
            public var eip: String?

            public var eipId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eip != nil {
                    map["Eip"] = self.eip!
                }
                if self.eipId != nil {
                    map["EipId"] = self.eipId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Eip") {
                    self.eip = dict["Eip"] as! String
                }
                if dict.keys.contains("EipId") {
                    self.eipId = dict["EipId"] as! String
                }
            }
        }
        public class AssociatedInstances : Tea.TeaModel {
            public var creationTime: String?

            public var instanceId: String?

            public var instanceType: String?

            public var ipAddress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var associatedEipAddresses: [DescribeHaVipsResponseBody.HaVips.AssociatedEipAddresses]?

        public var associatedInstances: [DescribeHaVipsResponseBody.HaVips.AssociatedInstances]?

        public var creationTime: String?

        public var description_: String?

        public var ensRegionId: String?

        public var haVipId: String?

        public var ipAddress: String?

        public var name: String?

        public var networkId: String?

        public var status: String?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.associatedEipAddresses != nil {
                var tmp : [Any] = []
                for k in self.associatedEipAddresses! {
                    tmp.append(k.toMap())
                }
                map["AssociatedEipAddresses"] = tmp
            }
            if self.associatedInstances != nil {
                var tmp : [Any] = []
                for k in self.associatedInstances! {
                    tmp.append(k.toMap())
                }
                map["AssociatedInstances"] = tmp
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.haVipId != nil {
                map["HaVipId"] = self.haVipId!
            }
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssociatedEipAddresses") {
                var tmp : [DescribeHaVipsResponseBody.HaVips.AssociatedEipAddresses] = []
                for v in dict["AssociatedEipAddresses"] as! [Any] {
                    var model = DescribeHaVipsResponseBody.HaVips.AssociatedEipAddresses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.associatedEipAddresses = tmp
            }
            if dict.keys.contains("AssociatedInstances") {
                var tmp : [DescribeHaVipsResponseBody.HaVips.AssociatedInstances] = []
                for v in dict["AssociatedInstances"] as! [Any] {
                    var model = DescribeHaVipsResponseBody.HaVips.AssociatedInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.associatedInstances = tmp
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("HaVipId") {
                self.haVipId = dict["HaVipId"] as! String
            }
            if dict.keys.contains("IpAddress") {
                self.ipAddress = dict["IpAddress"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public var haVips: [DescribeHaVipsResponseBody.HaVips]?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVips != nil {
            var tmp : [Any] = []
            for k in self.haVips! {
                tmp.append(k.toMap())
            }
            map["HaVips"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVips") {
            var tmp : [DescribeHaVipsResponseBody.HaVips] = []
            for v in dict["HaVips"] as! [Any] {
                var model = DescribeHaVipsResponseBody.HaVips()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.haVips = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeHaVipsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHaVipsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHaVipsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageInfosRequest : Tea.TeaModel {
    public var osType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OsType") {
            self.osType = dict["OsType"] as! String
        }
    }
}

public class DescribeImageInfosResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public class DiskDeviceMappings : Tea.TeaModel {
                public class DiskDeviceMapping : Tea.TeaModel {
                    public var format: String?

                    public var size: String?

                    public var type: String?

                    public var imageId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.imageId != nil {
                            map["imageId"] = self.imageId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("imageId") {
                            self.imageId = dict["imageId"] as! String
                        }
                    }
                }
                public var diskDeviceMapping: [DescribeImageInfosResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskDeviceMapping != nil {
                        var tmp : [Any] = []
                        for k in self.diskDeviceMapping! {
                            tmp.append(k.toMap())
                        }
                        map["DiskDeviceMapping"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiskDeviceMapping") {
                        var tmp : [DescribeImageInfosResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping] = []
                        for v in dict["DiskDeviceMapping"] as! [Any] {
                            var model = DescribeImageInfosResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.diskDeviceMapping = tmp
                    }
                }
            }
            public var computeType: String?

            public var description_: String?

            public var diskDeviceMappings: DescribeImageInfosResponseBody.Images.Image.DiskDeviceMappings?

            public var imageId: String?

            public var imageSize: String?

            public var imageVersion: String?

            public var OSName: String?

            public var OSType: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.diskDeviceMappings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.computeType != nil {
                    map["ComputeType"] = self.computeType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.diskDeviceMappings != nil {
                    map["DiskDeviceMappings"] = self.diskDeviceMappings?.toMap()
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageSize != nil {
                    map["ImageSize"] = self.imageSize!
                }
                if self.imageVersion != nil {
                    map["ImageVersion"] = self.imageVersion!
                }
                if self.OSName != nil {
                    map["OSName"] = self.OSName!
                }
                if self.OSType != nil {
                    map["OSType"] = self.OSType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComputeType") {
                    self.computeType = dict["ComputeType"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DiskDeviceMappings") {
                    var model = DescribeImageInfosResponseBody.Images.Image.DiskDeviceMappings()
                    model.fromMap(dict["DiskDeviceMappings"] as! [String: Any])
                    self.diskDeviceMappings = model
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageSize") {
                    self.imageSize = dict["ImageSize"] as! String
                }
                if dict.keys.contains("ImageVersion") {
                    self.imageVersion = dict["ImageVersion"] as! String
                }
                if dict.keys.contains("OSName") {
                    self.OSName = dict["OSName"] as! String
                }
                if dict.keys.contains("OSType") {
                    self.OSType = dict["OSType"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var image: [DescribeImageInfosResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") {
                var tmp : [DescribeImageInfosResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeImageInfosResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeImageInfosResponseBody.Images?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") {
            var model = DescribeImageInfosResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageSharePermissionRequest : Tea.TeaModel {
    public var aliyunId: Int64?

    public var imageId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunId != nil {
            map["AliyunId"] = self.aliyunId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunId") {
            self.aliyunId = dict["AliyunId"] as! Int64
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
    }
}

public class DescribeImageSharePermissionResponseBody : Tea.TeaModel {
    public class Accounts : Tea.TeaModel {
        public class Account : Tea.TeaModel {
            public var aliyunUid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunUid") {
                    self.aliyunUid = dict["AliyunUid"] as! String
                }
            }
        }
        public var account: [DescribeImageSharePermissionResponseBody.Accounts.Account]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                var tmp : [Any] = []
                for k in self.account! {
                    tmp.append(k.toMap())
                }
                map["Account"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Account") {
                var tmp : [DescribeImageSharePermissionResponseBody.Accounts.Account] = []
                for v in dict["Account"] as! [Any] {
                    var model = DescribeImageSharePermissionResponseBody.Accounts.Account()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.account = tmp
            }
        }
    }
    public var accounts: DescribeImageSharePermissionResponseBody.Accounts?

    public var imageId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accounts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accounts != nil {
            map["Accounts"] = self.accounts?.toMap()
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Accounts") {
            var model = DescribeImageSharePermissionResponseBody.Accounts()
            model.fromMap(dict["Accounts"] as! [String: Any])
            self.accounts = model
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImageSharePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageSharePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageSharePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImagesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var imageId: String?

    public var imageName: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var snapshotId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeImagesResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public class DiskDeviceMappings : Tea.TeaModel {
                public class DiskDeviceMapping : Tea.TeaModel {
                    public var format: String?

                    public var size: String?

                    public var type: String?

                    public var imageId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.imageId != nil {
                            map["imageId"] = self.imageId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("imageId") {
                            self.imageId = dict["imageId"] as! String
                        }
                    }
                }
                public var diskDeviceMapping: [DescribeImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskDeviceMapping != nil {
                        var tmp : [Any] = []
                        for k in self.diskDeviceMapping! {
                            tmp.append(k.toMap())
                        }
                        map["DiskDeviceMapping"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiskDeviceMapping") {
                        var tmp : [DescribeImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping] = []
                        for v in dict["DiskDeviceMapping"] as! [Any] {
                            var model = DescribeImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.diskDeviceMapping = tmp
                    }
                }
            }
            public var architecture: String?

            public var creationTime: String?

            public var diskDeviceMappings: DescribeImagesResponseBody.Images.Image.DiskDeviceMappings?

            public var imageId: String?

            public var imageName: String?

            public var imageOwnerAlias: String?

            public var imageSize: String?

            public var platform: String?

            public var regionId: String?

            public var snapshotId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.diskDeviceMappings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architecture != nil {
                    map["Architecture"] = self.architecture!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diskDeviceMappings != nil {
                    map["DiskDeviceMappings"] = self.diskDeviceMappings?.toMap()
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageOwnerAlias != nil {
                    map["ImageOwnerAlias"] = self.imageOwnerAlias!
                }
                if self.imageSize != nil {
                    map["ImageSize"] = self.imageSize!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Architecture") {
                    self.architecture = dict["Architecture"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DiskDeviceMappings") {
                    var model = DescribeImagesResponseBody.Images.Image.DiskDeviceMappings()
                    model.fromMap(dict["DiskDeviceMappings"] as! [String: Any])
                    self.diskDeviceMappings = model
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImageOwnerAlias") {
                    self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
                }
                if dict.keys.contains("ImageSize") {
                    self.imageSize = dict["ImageSize"] as! String
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SnapshotId") {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
            }
        }
        public var image: [DescribeImagesResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") {
                var tmp : [DescribeImagesResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeImagesResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeImagesResponseBody.Images?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") {
            var model = DescribeImagesResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public class InstanceRenewAttributes : Tea.TeaModel {
        public class InstanceRenewAttribute : Tea.TeaModel {
            public var autoRenewal: Bool?

            public var duration: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewal != nil {
                    map["AutoRenewal"] = self.autoRenewal!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoRenewal") {
                    self.autoRenewal = dict["AutoRenewal"] as! Bool
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var instanceRenewAttribute: [DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.instanceRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["InstanceRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceRenewAttribute") {
                var tmp : [DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute] = []
                for v in dict["InstanceRenewAttribute"] as! [Any] {
                    var model = DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceRenewAttribute = tmp
            }
        }
    }
    public var code: Int32?

    public var instanceRenewAttributes: DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceRenewAttributes != nil {
            map["InstanceRenewAttributes"] = self.instanceRenewAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("InstanceRenewAttributes") {
            var model = DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes()
            model.fromMap(dict["InstanceRenewAttributes"] as! [String: Any])
            self.instanceRenewAttributes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceBandwidthDetailRequest : Tea.TeaModel {
    public var endTime: String?

    public var ensRegionId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var serviceType: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceBandwidthDetailResponseBody : Tea.TeaModel {
    public class Bandwidths : Tea.TeaModel {
        public var aliUid: Int64?

        public var bizTime: String?

        public var ensRegionId: String?

        public var flowType: Int32?

        public var instanceId: String?

        public var instanceType: String?

        public var ip: String?

        public var isp: String?

        public var rxBw: Int64?

        public var serviceType: String?

        public var txBw: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.bizTime != nil {
                map["BizTime"] = self.bizTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.flowType != nil {
                map["FlowType"] = self.flowType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.rxBw != nil {
                map["RxBw"] = self.rxBw!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.txBw != nil {
                map["TxBw"] = self.txBw!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliUid") {
                self.aliUid = dict["AliUid"] as! Int64
            }
            if dict.keys.contains("BizTime") {
                self.bizTime = dict["BizTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("FlowType") {
                self.flowType = dict["FlowType"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Isp") {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("RxBw") {
                self.rxBw = dict["RxBw"] as! Int64
            }
            if dict.keys.contains("ServiceType") {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("TxBw") {
                self.txBw = dict["TxBw"] as! Int64
            }
        }
    }
    public var bandwidths: [DescribeInstanceBandwidthDetailResponseBody.Bandwidths]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidths != nil {
            var tmp : [Any] = []
            for k in self.bandwidths! {
                tmp.append(k.toMap())
            }
            map["Bandwidths"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidths") {
            var tmp : [DescribeInstanceBandwidthDetailResponseBody.Bandwidths] = []
            for v in dict["Bandwidths"] as! [Any] {
                var model = DescribeInstanceBandwidthDetailResponseBody.Bandwidths()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bandwidths = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceBandwidthDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceBandwidthDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceBandwidthDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceBootConfigurationRequest : Tea.TeaModel {
    public var bootSet: String?

    public var bootType: String?

    public var diskSet: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bootSet != nil {
            map["BootSet"] = self.bootSet!
        }
        if self.bootType != nil {
            map["BootType"] = self.bootType!
        }
        if self.diskSet != nil {
            map["DiskSet"] = self.diskSet!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BootSet") {
            self.bootSet = dict["BootSet"] as! String
        }
        if dict.keys.contains("BootType") {
            self.bootType = dict["BootType"] as! String
        }
        if dict.keys.contains("DiskSet") {
            self.diskSet = dict["DiskSet"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceBootConfigurationResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var bootSet: String?

        public var bootType: String?

        public var diskSet: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bootSet != nil {
                map["BootSet"] = self.bootSet!
            }
            if self.bootType != nil {
                map["BootType"] = self.bootType!
            }
            if self.diskSet != nil {
                map["DiskSet"] = self.diskSet!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BootSet") {
                self.bootSet = dict["BootSet"] as! String
            }
            if dict.keys.contains("BootType") {
                self.bootType = dict["BootType"] as! String
            }
            if dict.keys.contains("DiskSet") {
                self.diskSet = dict["DiskSet"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public var instances: DescribeInstanceBootConfigurationResponseBody.Instances?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var model = DescribeInstanceBootConfigurationResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceBootConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceBootConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceBootConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceMonitorDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var period: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class InstanceMonitorData : Tea.TeaModel {
            public var CPU: String?

            public var instanceId: String?

            public var memory: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.CPU != nil {
                    map["CPU"] = self.CPU!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CPU") {
                    self.CPU = dict["CPU"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! String
                }
            }
        }
        public var instanceMonitorData: [DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceMonitorData != nil {
                var tmp : [Any] = []
                for k in self.instanceMonitorData! {
                    tmp.append(k.toMap())
                }
                map["InstanceMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceMonitorData") {
                var tmp : [DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData] = []
                for v in dict["InstanceMonitorData"] as! [Any] {
                    var model = DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceMonitorData = tmp
            }
        }
    }
    public var code: Int32?

    public var monitorData: DescribeInstanceMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("MonitorData") {
            var model = DescribeInstanceMonitorDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceSDGStatusRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SDGIds: [String]?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SDGIds != nil {
            map["SDGIds"] = self.SDGIds!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SDGIds") {
            self.SDGIds = dict["SDGIds"] as! [String]
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeInstanceSDGStatusShrinkRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SDGIdsShrink: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SDGIdsShrink != nil {
            map["SDGIds"] = self.SDGIdsShrink!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SDGIds") {
            self.SDGIdsShrink = dict["SDGIds"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeInstanceSDGStatusResponseBody : Tea.TeaModel {
    public class DeploymentStatus : Tea.TeaModel {
        public var ensRegionId: String?

        public var instanceId: String?

        public var mountType: String?

        public var phase: String?

        public var SDGId: String?

        public var status: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.mountType != nil {
                map["MountType"] = self.mountType!
            }
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.SDGId != nil {
                map["SDGId"] = self.SDGId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MountType") {
                self.mountType = dict["MountType"] as! String
            }
            if dict.keys.contains("Phase") {
                self.phase = dict["Phase"] as! String
            }
            if dict.keys.contains("SDGId") {
                self.SDGId = dict["SDGId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var deploymentStatus: [DescribeInstanceSDGStatusResponseBody.DeploymentStatus]?

    public var pageNumber: Int64?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentStatus != nil {
            var tmp : [Any] = []
            for k in self.deploymentStatus! {
                tmp.append(k.toMap())
            }
            map["DeploymentStatus"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentStatus") {
            var tmp : [DescribeInstanceSDGStatusResponseBody.DeploymentStatus] = []
            for v in dict["DeploymentStatus"] as! [Any] {
                var model = DescribeInstanceSDGStatusResponseBody.DeploymentStatus()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deploymentStatus = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeInstanceSDGStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceSDGStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceSDGStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceSpecResponseBody : Tea.TeaModel {
    public class InstanceSpecs : Tea.TeaModel {
        public class InstanceSpec : Tea.TeaModel {
            public var core: String?

            public var displayName: String?

            public var instanceType: String?

            public var memory: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.core != nil {
                    map["Core"] = self.core!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Core") {
                    self.core = dict["Core"] as! String
                }
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! String
                }
            }
        }
        public var instanceSpec: [DescribeInstanceSpecResponseBody.InstanceSpecs.InstanceSpec]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceSpec != nil {
                var tmp : [Any] = []
                for k in self.instanceSpec! {
                    tmp.append(k.toMap())
                }
                map["InstanceSpec"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceSpec") {
                var tmp : [DescribeInstanceSpecResponseBody.InstanceSpecs.InstanceSpec] = []
                for v in dict["InstanceSpec"] as! [Any] {
                    var model = DescribeInstanceSpecResponseBody.InstanceSpecs.InstanceSpec()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceSpec = tmp
            }
        }
    }
    public var bandwidthLimit: Int32?

    public var code: Int32?

    public var dataDiskMaxSize: Int32?

    public var dataDiskMinSize: Int32?

    public var instanceSpecs: DescribeInstanceSpecResponseBody.InstanceSpecs?

    public var requestId: String?

    public var systemDiskMaxSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceSpecs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthLimit != nil {
            map["BandwidthLimit"] = self.bandwidthLimit!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dataDiskMaxSize != nil {
            map["DataDiskMaxSize"] = self.dataDiskMaxSize!
        }
        if self.dataDiskMinSize != nil {
            map["DataDiskMinSize"] = self.dataDiskMinSize!
        }
        if self.instanceSpecs != nil {
            map["InstanceSpecs"] = self.instanceSpecs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemDiskMaxSize != nil {
            map["SystemDiskMaxSize"] = self.systemDiskMaxSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthLimit") {
            self.bandwidthLimit = dict["BandwidthLimit"] as! Int32
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("DataDiskMaxSize") {
            self.dataDiskMaxSize = dict["DataDiskMaxSize"] as! Int32
        }
        if dict.keys.contains("DataDiskMinSize") {
            self.dataDiskMinSize = dict["DataDiskMinSize"] as! Int32
        }
        if dict.keys.contains("InstanceSpecs") {
            var model = DescribeInstanceSpecResponseBody.InstanceSpecs()
            model.fromMap(dict["InstanceSpecs"] as! [String: Any])
            self.instanceSpecs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemDiskMaxSize") {
            self.systemDiskMaxSize = dict["SystemDiskMaxSize"] as! Int32
        }
    }
}

public class DescribeInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTypesResponseBody : Tea.TeaModel {
    public class InstanceTypes : Tea.TeaModel {
        public class InstanceType : Tea.TeaModel {
            public var cpuCoreCount: Int32?

            public var instanceTypeId: String?

            public var instanceTypeName: String?

            public var memorySize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCoreCount != nil {
                    map["CpuCoreCount"] = self.cpuCoreCount!
                }
                if self.instanceTypeId != nil {
                    map["InstanceTypeId"] = self.instanceTypeId!
                }
                if self.instanceTypeName != nil {
                    map["InstanceTypeName"] = self.instanceTypeName!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CpuCoreCount") {
                    self.cpuCoreCount = dict["CpuCoreCount"] as! Int32
                }
                if dict.keys.contains("InstanceTypeId") {
                    self.instanceTypeId = dict["InstanceTypeId"] as! String
                }
                if dict.keys.contains("InstanceTypeName") {
                    self.instanceTypeName = dict["InstanceTypeName"] as! String
                }
                if dict.keys.contains("MemorySize") {
                    self.memorySize = dict["MemorySize"] as! Int32
                }
            }
        }
        public var instanceType: [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                var tmp : [Any] = []
                for k in self.instanceType! {
                    tmp.append(k.toMap())
                }
                map["InstanceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                var tmp : [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType] = []
                for v in dict["InstanceType"] as! [Any] {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceType = tmp
            }
        }
    }
    public var code: Int32?

    public var instanceTypes: DescribeInstanceTypesResponseBody.InstanceTypes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("InstanceTypes") {
            var model = DescribeInstanceTypesResponseBody.InstanceTypes()
            model.fromMap(dict["InstanceTypes"] as! [String: Any])
            self.instanceTypes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceVncUrlRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceVncUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vncUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vncUrl != nil {
            map["VncUrl"] = self.vncUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VncUrl") {
            self.vncUrl = dict["VncUrl"] as! String
        }
    }
}

public class DescribeInstanceVncUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceVncUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceVncUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstancesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ensRegionId: String?

    public var ensRegionIds: String?

    public var ensServiceId: String?

    public var imageId: String?

    public var instanceId: String?

    public var instanceIds: String?

    public var instanceName: String?

    public var instanceResourceType: String?

    public var instanceType: String?

    public var intranetIp: String?

    public var networkId: String?

    public var orderByParams: String?

    public var pageNumber: Int32?

    public var pageSize: String?

    public var searchKey: String?

    public var securityGroupId: String?

    public var serviceStatus: [String]?

    public var status: String?

    public var tags: [DescribeInstancesRequest.Tags]?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.ensServiceId != nil {
            map["EnsServiceId"] = self.ensServiceId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceResourceType != nil {
            map["InstanceResourceType"] = self.instanceResourceType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.intranetIp != nil {
            map["IntranetIp"] = self.intranetIp!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceStatus != nil {
            map["ServiceStatus"] = self.serviceStatus!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("EnsServiceId") {
            self.ensServiceId = dict["EnsServiceId"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceResourceType") {
            self.instanceResourceType = dict["InstanceResourceType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("IntranetIp") {
            self.intranetIp = dict["IntranetIp"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("OrderByParams") {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("ServiceStatus") {
            self.serviceStatus = dict["ServiceStatus"] as! [String]
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [DescribeInstancesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeInstancesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeInstancesShrinkRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIds: String?

    public var ensServiceId: String?

    public var imageId: String?

    public var instanceId: String?

    public var instanceIds: String?

    public var instanceName: String?

    public var instanceResourceType: String?

    public var instanceType: String?

    public var intranetIp: String?

    public var networkId: String?

    public var orderByParams: String?

    public var pageNumber: Int32?

    public var pageSize: String?

    public var searchKey: String?

    public var securityGroupId: String?

    public var serviceStatusShrink: String?

    public var status: String?

    public var tagsShrink: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.ensServiceId != nil {
            map["EnsServiceId"] = self.ensServiceId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceResourceType != nil {
            map["InstanceResourceType"] = self.instanceResourceType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.intranetIp != nil {
            map["IntranetIp"] = self.intranetIp!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.orderByParams != nil {
            map["OrderByParams"] = self.orderByParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchKey != nil {
            map["SearchKey"] = self.searchKey!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceStatusShrink != nil {
            map["ServiceStatus"] = self.serviceStatusShrink!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("EnsServiceId") {
            self.ensServiceId = dict["EnsServiceId"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceResourceType") {
            self.instanceResourceType = dict["InstanceResourceType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("IntranetIp") {
            self.intranetIp = dict["IntranetIp"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("OrderByParams") {
            self.orderByParams = dict["OrderByParams"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SearchKey") {
            self.searchKey = dict["SearchKey"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("ServiceStatus") {
            self.serviceStatusShrink = dict["ServiceStatus"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tagsShrink = dict["Tags"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public class DataDisk : Tea.TeaModel {
                public class DataDisk : Tea.TeaModel {
                    public var category: String?

                    public var diskId: String?

                    public var diskName: String?

                    public var diskSize: Int32?

                    public var encryptKeyId: String?

                    public var encrypted: Bool?

                    public var size: Int32?

                    public var deviceType: String?

                    public var diskType: String?

                    public var name: String?

                    public var storage: Int32?

                    public var uuid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.category != nil {
                            map["Category"] = self.category!
                        }
                        if self.diskId != nil {
                            map["DiskId"] = self.diskId!
                        }
                        if self.diskName != nil {
                            map["DiskName"] = self.diskName!
                        }
                        if self.diskSize != nil {
                            map["DiskSize"] = self.diskSize!
                        }
                        if self.encryptKeyId != nil {
                            map["EncryptKeyId"] = self.encryptKeyId!
                        }
                        if self.encrypted != nil {
                            map["Encrypted"] = self.encrypted!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.deviceType != nil {
                            map["device_type"] = self.deviceType!
                        }
                        if self.diskType != nil {
                            map["disk_type"] = self.diskType!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.storage != nil {
                            map["storage"] = self.storage!
                        }
                        if self.uuid != nil {
                            map["uuid"] = self.uuid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Category") {
                            self.category = dict["Category"] as! String
                        }
                        if dict.keys.contains("DiskId") {
                            self.diskId = dict["DiskId"] as! String
                        }
                        if dict.keys.contains("DiskName") {
                            self.diskName = dict["DiskName"] as! String
                        }
                        if dict.keys.contains("DiskSize") {
                            self.diskSize = dict["DiskSize"] as! Int32
                        }
                        if dict.keys.contains("EncryptKeyId") {
                            self.encryptKeyId = dict["EncryptKeyId"] as! String
                        }
                        if dict.keys.contains("Encrypted") {
                            self.encrypted = dict["Encrypted"] as! Bool
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! Int32
                        }
                        if dict.keys.contains("device_type") {
                            self.deviceType = dict["device_type"] as! String
                        }
                        if dict.keys.contains("disk_type") {
                            self.diskType = dict["disk_type"] as! String
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("storage") {
                            self.storage = dict["storage"] as! Int32
                        }
                        if dict.keys.contains("uuid") {
                            self.uuid = dict["uuid"] as! String
                        }
                    }
                }
                public var dataDisk: [DescribeInstancesResponseBody.Instances.Instance.DataDisk.DataDisk]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataDisk != nil {
                        var tmp : [Any] = []
                        for k in self.dataDisk! {
                            tmp.append(k.toMap())
                        }
                        map["DataDisk"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataDisk") {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.DataDisk.DataDisk] = []
                        for v in dict["DataDisk"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.DataDisk.DataDisk()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataDisk = tmp
                    }
                }
            }
            public class InnerIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpAddress") {
                        self.ipAddress = dict["IpAddress"] as! [String]
                    }
                }
            }
            public class NetworkAttributes : Tea.TeaModel {
                public class PrivateIpAddress : Tea.TeaModel {
                    public var ipAddress: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IpAddress") {
                            self.ipAddress = dict["IpAddress"] as! [String]
                        }
                    }
                }
                public var networkId: String?

                public var privateIpAddress: DescribeInstancesResponseBody.Instances.Instance.NetworkAttributes.PrivateIpAddress?

                public var vSwitchId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.privateIpAddress?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkId != nil {
                        map["NetworkId"] = self.networkId!
                    }
                    if self.privateIpAddress != nil {
                        map["PrivateIpAddress"] = self.privateIpAddress?.toMap()
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NetworkId") {
                        self.networkId = dict["NetworkId"] as! String
                    }
                    if dict.keys.contains("PrivateIpAddress") {
                        var model = DescribeInstancesResponseBody.Instances.Instance.NetworkAttributes.PrivateIpAddress()
                        model.fromMap(dict["PrivateIpAddress"] as! [String: Any])
                        self.privateIpAddress = model
                    }
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! String
                    }
                }
            }
            public class NetworkInterfaces : Tea.TeaModel {
                public class NetworkInterfaces : Tea.TeaModel {
                    public class Ipv6Sets : Tea.TeaModel {
                        public class Ipv6Set : Tea.TeaModel {
                            public var ipv6Address: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ipv6Address != nil {
                                    map["Ipv6Address"] = self.ipv6Address!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Ipv6Address") {
                                    self.ipv6Address = dict["Ipv6Address"] as! String
                                }
                            }
                        }
                        public var ipv6Set: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.Ipv6Sets.Ipv6Set]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ipv6Set != nil {
                                var tmp : [Any] = []
                                for k in self.ipv6Set! {
                                    tmp.append(k.toMap())
                                }
                                map["Ipv6Set"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Ipv6Set") {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.Ipv6Sets.Ipv6Set] = []
                                for v in dict["Ipv6Set"] as! [Any] {
                                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.Ipv6Sets.Ipv6Set()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.ipv6Set = tmp
                            }
                        }
                    }
                    public class PrivateIpSets : Tea.TeaModel {
                        public class PrivateIpSet : Tea.TeaModel {
                            public var primary: Bool?

                            public var privateIpAddress: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.primary != nil {
                                    map["Primary"] = self.primary!
                                }
                                if self.privateIpAddress != nil {
                                    map["PrivateIpAddress"] = self.privateIpAddress!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Primary") {
                                    self.primary = dict["Primary"] as! Bool
                                }
                                if dict.keys.contains("PrivateIpAddress") {
                                    self.privateIpAddress = dict["PrivateIpAddress"] as! String
                                }
                            }
                        }
                        public var privateIpSet: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.PrivateIpSets.PrivateIpSet]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.privateIpSet != nil {
                                var tmp : [Any] = []
                                for k in self.privateIpSet! {
                                    tmp.append(k.toMap())
                                }
                                map["PrivateIpSet"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("PrivateIpSet") {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.PrivateIpSets.PrivateIpSet] = []
                                for v in dict["PrivateIpSet"] as! [Any] {
                                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.PrivateIpSets.PrivateIpSet()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.privateIpSet = tmp
                            }
                        }
                    }
                    public var ipv6Sets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.Ipv6Sets?

                    public var macAddress: String?

                    public var networkInterfaceId: String?

                    public var primaryIpAddress: String?

                    public var privateIpSets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.PrivateIpSets?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.ipv6Sets?.validate()
                        try self.privateIpSets?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv6Sets != nil {
                            map["Ipv6Sets"] = self.ipv6Sets?.toMap()
                        }
                        if self.macAddress != nil {
                            map["MacAddress"] = self.macAddress!
                        }
                        if self.networkInterfaceId != nil {
                            map["NetworkInterfaceId"] = self.networkInterfaceId!
                        }
                        if self.primaryIpAddress != nil {
                            map["PrimaryIpAddress"] = self.primaryIpAddress!
                        }
                        if self.privateIpSets != nil {
                            map["PrivateIpSets"] = self.privateIpSets?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Ipv6Sets") {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.Ipv6Sets()
                            model.fromMap(dict["Ipv6Sets"] as! [String: Any])
                            self.ipv6Sets = model
                        }
                        if dict.keys.contains("MacAddress") {
                            self.macAddress = dict["MacAddress"] as! String
                        }
                        if dict.keys.contains("NetworkInterfaceId") {
                            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                        }
                        if dict.keys.contains("PrimaryIpAddress") {
                            self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
                        }
                        if dict.keys.contains("PrivateIpSets") {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces.PrivateIpSets()
                            model.fromMap(dict["PrivateIpSets"] as! [String: Any])
                            self.privateIpSets = model
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var networkInterfaces: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkInterfaces != nil {
                        var tmp : [Any] = []
                        for k in self.networkInterfaces! {
                            tmp.append(k.toMap())
                        }
                        map["NetworkInterfaces"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NetworkInterfaces") {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces] = []
                        for v in dict["NetworkInterfaces"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterfaces()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.networkInterfaces = tmp
                    }
                }
            }
            public class PrivateIpAddresses : Tea.TeaModel {
                public class PrivateIpAddress : Tea.TeaModel {
                    public var gateWay: String?

                    public var ip: String?

                    public var isp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gateWay != nil {
                            map["GateWay"] = self.gateWay!
                        }
                        if self.ip != nil {
                            map["Ip"] = self.ip!
                        }
                        if self.isp != nil {
                            map["Isp"] = self.isp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("GateWay") {
                            self.gateWay = dict["GateWay"] as! String
                        }
                        if dict.keys.contains("Ip") {
                            self.ip = dict["Ip"] as! String
                        }
                        if dict.keys.contains("Isp") {
                            self.isp = dict["Isp"] as! String
                        }
                    }
                }
                public var privateIpAddress: [DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses.PrivateIpAddress]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateIpAddress != nil {
                        var tmp : [Any] = []
                        for k in self.privateIpAddress! {
                            tmp.append(k.toMap())
                        }
                        map["PrivateIpAddress"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateIpAddress") {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses.PrivateIpAddress] = []
                        for v in dict["PrivateIpAddress"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses.PrivateIpAddress()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.privateIpAddress = tmp
                    }
                }
            }
            public class PublicIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpAddress") {
                        self.ipAddress = dict["IpAddress"] as! [String]
                    }
                }
            }
            public class PublicIpAddresses : Tea.TeaModel {
                public class PublicIpAddress : Tea.TeaModel {
                    public var gateWay: String?

                    public var ip: String?

                    public var isp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gateWay != nil {
                            map["GateWay"] = self.gateWay!
                        }
                        if self.ip != nil {
                            map["Ip"] = self.ip!
                        }
                        if self.isp != nil {
                            map["Isp"] = self.isp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("GateWay") {
                            self.gateWay = dict["GateWay"] as! String
                        }
                        if dict.keys.contains("Ip") {
                            self.ip = dict["Ip"] as! String
                        }
                        if dict.keys.contains("Isp") {
                            self.isp = dict["Isp"] as! String
                        }
                    }
                }
                public var publicIpAddress: [DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses.PublicIpAddress]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.publicIpAddress != nil {
                        var tmp : [Any] = []
                        for k in self.publicIpAddress! {
                            tmp.append(k.toMap())
                        }
                        map["PublicIpAddress"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PublicIpAddress") {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses.PublicIpAddress] = []
                        for v in dict["PublicIpAddress"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses.PublicIpAddress()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.publicIpAddress = tmp
                    }
                }
            }
            public class SecurityGroupIds : Tea.TeaModel {
                public var securityGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! [String]
                    }
                }
            }
            public class SystemDisk : Tea.TeaModel {
                public var category: String?

                public var diskId: String?

                public var diskName: String?

                public var size: Int32?

                public var deviceType: String?

                public var diskType: String?

                public var name: String?

                public var storage: Int32?

                public var uuid: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.diskId != nil {
                        map["DiskId"] = self.diskId!
                    }
                    if self.diskName != nil {
                        map["DiskName"] = self.diskName!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.deviceType != nil {
                        map["device_type"] = self.deviceType!
                    }
                    if self.diskType != nil {
                        map["disk_type"] = self.diskType!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.storage != nil {
                        map["storage"] = self.storage!
                    }
                    if self.uuid != nil {
                        map["uuid"] = self.uuid!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("DiskId") {
                        self.diskId = dict["DiskId"] as! String
                    }
                    if dict.keys.contains("DiskName") {
                        self.diskName = dict["DiskName"] as! String
                    }
                    if dict.keys.contains("Size") {
                        self.size = dict["Size"] as! Int32
                    }
                    if dict.keys.contains("device_type") {
                        self.deviceType = dict["device_type"] as! String
                    }
                    if dict.keys.contains("disk_type") {
                        self.diskType = dict["disk_type"] as! String
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("storage") {
                        self.storage = dict["storage"] as! Int32
                    }
                    if dict.keys.contains("uuid") {
                        self.uuid = dict["uuid"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tags: [DescribeInstancesResponseBody.Instances.Instance.Tags.Tags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tags != nil {
                        var tmp : [Any] = []
                        for k in self.tags! {
                            tmp.append(k.toMap())
                        }
                        map["Tags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tags") {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.Tags.Tags] = []
                        for v in dict["Tags"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.Tags.Tags()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tags = tmp
                    }
                }
            }
            public var autoReleaseTime: String?

            public var cpu: String?

            public var creationTime: String?

            public var dataDisk: DescribeInstancesResponseBody.Instances.Instance.DataDisk?

            public var disk: Int32?

            public var ensRegionId: String?

            public var expiredTime: String?

            public var hostName: String?

            public var imageId: String?

            public var innerIpAddress: DescribeInstancesResponseBody.Instances.Instance.InnerIpAddress?

            public var instanceId: String?

            public var instanceName: String?

            public var instanceResourceType: String?

            public var instanceTypeFamily: String?

            public var internetMaxBandwidthIn: Int32?

            public var internetMaxBandwidthOut: Int32?

            public var keyPairName: String?

            public var memory: Int32?

            public var networkAttributes: DescribeInstancesResponseBody.Instances.Instance.NetworkAttributes?

            public var networkInterfaces: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces?

            public var OSName: String?

            public var privateIpAddresses: DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses?

            public var publicIpAddress: DescribeInstancesResponseBody.Instances.Instance.PublicIpAddress?

            public var publicIpAddresses: DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses?

            public var securityGroupIds: DescribeInstancesResponseBody.Instances.Instance.SecurityGroupIds?

            public var serviceStatus: String?

            public var specName: String?

            public var spotStrategy: String?

            public var status: String?

            public var systemDisk: DescribeInstancesResponseBody.Instances.Instance.SystemDisk?

            public var tags: DescribeInstancesResponseBody.Instances.Instance.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataDisk?.validate()
                try self.innerIpAddress?.validate()
                try self.networkAttributes?.validate()
                try self.networkInterfaces?.validate()
                try self.privateIpAddresses?.validate()
                try self.publicIpAddress?.validate()
                try self.publicIpAddresses?.validate()
                try self.securityGroupIds?.validate()
                try self.systemDisk?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoReleaseTime != nil {
                    map["AutoReleaseTime"] = self.autoReleaseTime!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.dataDisk != nil {
                    map["DataDisk"] = self.dataDisk?.toMap()
                }
                if self.disk != nil {
                    map["Disk"] = self.disk!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.innerIpAddress != nil {
                    map["InnerIpAddress"] = self.innerIpAddress?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instanceResourceType != nil {
                    map["InstanceResourceType"] = self.instanceResourceType!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.internetMaxBandwidthIn != nil {
                    map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
                }
                if self.internetMaxBandwidthOut != nil {
                    map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                }
                if self.keyPairName != nil {
                    map["KeyPairName"] = self.keyPairName!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.networkAttributes != nil {
                    map["NetworkAttributes"] = self.networkAttributes?.toMap()
                }
                if self.networkInterfaces != nil {
                    map["NetworkInterfaces"] = self.networkInterfaces?.toMap()
                }
                if self.OSName != nil {
                    map["OSName"] = self.OSName!
                }
                if self.privateIpAddresses != nil {
                    map["PrivateIpAddresses"] = self.privateIpAddresses?.toMap()
                }
                if self.publicIpAddress != nil {
                    map["PublicIpAddress"] = self.publicIpAddress?.toMap()
                }
                if self.publicIpAddresses != nil {
                    map["PublicIpAddresses"] = self.publicIpAddresses?.toMap()
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                }
                if self.serviceStatus != nil {
                    map["ServiceStatus"] = self.serviceStatus!
                }
                if self.specName != nil {
                    map["SpecName"] = self.specName!
                }
                if self.spotStrategy != nil {
                    map["SpotStrategy"] = self.spotStrategy!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.systemDisk != nil {
                    map["SystemDisk"] = self.systemDisk?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoReleaseTime") {
                    self.autoReleaseTime = dict["AutoReleaseTime"] as! String
                }
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DataDisk") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.DataDisk()
                    model.fromMap(dict["DataDisk"] as! [String: Any])
                    self.dataDisk = model
                }
                if dict.keys.contains("Disk") {
                    self.disk = dict["Disk"] as! Int32
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("HostName") {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("InnerIpAddress") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.InnerIpAddress()
                    model.fromMap(dict["InnerIpAddress"] as! [String: Any])
                    self.innerIpAddress = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("InstanceResourceType") {
                    self.instanceResourceType = dict["InstanceResourceType"] as! String
                }
                if dict.keys.contains("InstanceTypeFamily") {
                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                }
                if dict.keys.contains("InternetMaxBandwidthIn") {
                    self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
                }
                if dict.keys.contains("InternetMaxBandwidthOut") {
                    self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
                }
                if dict.keys.contains("KeyPairName") {
                    self.keyPairName = dict["KeyPairName"] as! String
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("NetworkAttributes") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkAttributes()
                    model.fromMap(dict["NetworkAttributes"] as! [String: Any])
                    self.networkAttributes = model
                }
                if dict.keys.contains("NetworkInterfaces") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces()
                    model.fromMap(dict["NetworkInterfaces"] as! [String: Any])
                    self.networkInterfaces = model
                }
                if dict.keys.contains("OSName") {
                    self.OSName = dict["OSName"] as! String
                }
                if dict.keys.contains("PrivateIpAddresses") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PrivateIpAddresses()
                    model.fromMap(dict["PrivateIpAddresses"] as! [String: Any])
                    self.privateIpAddresses = model
                }
                if dict.keys.contains("PublicIpAddress") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PublicIpAddress()
                    model.fromMap(dict["PublicIpAddress"] as! [String: Any])
                    self.publicIpAddress = model
                }
                if dict.keys.contains("PublicIpAddresses") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PublicIpAddresses()
                    model.fromMap(dict["PublicIpAddresses"] as! [String: Any])
                    self.publicIpAddresses = model
                }
                if dict.keys.contains("SecurityGroupIds") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.SecurityGroupIds()
                    model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
                    self.securityGroupIds = model
                }
                if dict.keys.contains("ServiceStatus") {
                    self.serviceStatus = dict["ServiceStatus"] as! String
                }
                if dict.keys.contains("SpecName") {
                    self.specName = dict["SpecName"] as! String
                }
                if dict.keys.contains("SpotStrategy") {
                    self.spotStrategy = dict["SpotStrategy"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SystemDisk") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.SystemDisk()
                    model.fromMap(dict["SystemDisk"] as! [String: Any])
                    self.systemDisk = model
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var instance: [DescribeInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                var tmp : [DescribeInstancesResponseBody.Instances.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = DescribeInstancesResponseBody.Instances.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var code: Int32?

    public var instances: DescribeInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Instances") {
            var model = DescribeInstancesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeKeyPairsRequest : Tea.TeaModel {
    public var keyPairId: String?

    public var keyPairName: String?

    public var pageNumber: String?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairId != nil {
            map["KeyPairId"] = self.keyPairId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairId") {
            self.keyPairId = dict["KeyPairId"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
    }
}

public class DescribeKeyPairsResponseBody : Tea.TeaModel {
    public class KeyPairs : Tea.TeaModel {
        public class KeyPair : Tea.TeaModel {
            public var creationTime: String?

            public var keyPairFingerPrint: String?

            public var keyPairId: String?

            public var keyPairName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.keyPairFingerPrint != nil {
                    map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
                }
                if self.keyPairId != nil {
                    map["KeyPairId"] = self.keyPairId!
                }
                if self.keyPairName != nil {
                    map["KeyPairName"] = self.keyPairName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("KeyPairFingerPrint") {
                    self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
                }
                if dict.keys.contains("KeyPairId") {
                    self.keyPairId = dict["KeyPairId"] as! String
                }
                if dict.keys.contains("KeyPairName") {
                    self.keyPairName = dict["KeyPairName"] as! String
                }
            }
        }
        public var keyPair: [DescribeKeyPairsResponseBody.KeyPairs.KeyPair]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keyPair != nil {
                var tmp : [Any] = []
                for k in self.keyPair! {
                    tmp.append(k.toMap())
                }
                map["KeyPair"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("KeyPair") {
                var tmp : [DescribeKeyPairsResponseBody.KeyPairs.KeyPair] = []
                for v in dict["KeyPair"] as! [Any] {
                    var model = DescribeKeyPairsResponseBody.KeyPairs.KeyPair()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.keyPair = tmp
            }
        }
    }
    public var keyPairs: DescribeKeyPairsResponseBody.KeyPairs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.keyPairs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairs != nil {
            map["KeyPairs"] = self.keyPairs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairs") {
            var model = DescribeKeyPairsResponseBody.KeyPairs()
            model.fromMap(dict["KeyPairs"] as! [String: Any])
            self.keyPairs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeKeyPairsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKeyPairsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeKeyPairsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerAttributeRequest : Tea.TeaModel {
    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerAttributeResponseBody : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public var ip: String?

        public var port: String?

        public var serverId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("ServerId") {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class ListenerPortsAndProtocols : Tea.TeaModel {
        public var backendServerPort: Int32?

        public var description_: String?

        public var forwardPort: Int32?

        public var listenerForward: String?

        public var listenerPort: Int32?

        public var listenerProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendServerPort != nil {
                map["BackendServerPort"] = self.backendServerPort!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.forwardPort != nil {
                map["ForwardPort"] = self.forwardPort!
            }
            if self.listenerForward != nil {
                map["ListenerForward"] = self.listenerForward!
            }
            if self.listenerPort != nil {
                map["ListenerPort"] = self.listenerPort!
            }
            if self.listenerProtocol != nil {
                map["ListenerProtocol"] = self.listenerProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendServerPort") {
                self.backendServerPort = dict["BackendServerPort"] as! Int32
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ForwardPort") {
                self.forwardPort = dict["ForwardPort"] as! Int32
            }
            if dict.keys.contains("ListenerForward") {
                self.listenerForward = dict["ListenerForward"] as! String
            }
            if dict.keys.contains("ListenerPort") {
                self.listenerPort = dict["ListenerPort"] as! Int32
            }
            if dict.keys.contains("ListenerProtocol") {
                self.listenerProtocol = dict["ListenerProtocol"] as! String
            }
        }
    }
    public var address: String?

    public var addressIPVersion: String?

    public var backendServers: [DescribeLoadBalancerAttributeResponseBody.BackendServers]?

    public var bandwidth: Int32?

    public var createTime: String?

    public var endTime: String?

    public var ensRegionId: String?

    public var listenerPorts: [String]?

    public var listenerPortsAndProtocols: [DescribeLoadBalancerAttributeResponseBody.ListenerPortsAndProtocols]?

    public var loadBalancerId: String?

    public var loadBalancerName: String?

    public var loadBalancerSpec: String?

    public var loadBalancerStatus: String?

    public var networkId: String?

    public var payType: String?

    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.backendServers != nil {
            var tmp : [Any] = []
            for k in self.backendServers! {
                tmp.append(k.toMap())
            }
            map["BackendServers"] = tmp
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.listenerPorts != nil {
            map["ListenerPorts"] = self.listenerPorts!
        }
        if self.listenerPortsAndProtocols != nil {
            var tmp : [Any] = []
            for k in self.listenerPortsAndProtocols! {
                tmp.append(k.toMap())
            }
            map["ListenerPortsAndProtocols"] = tmp
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        if self.loadBalancerSpec != nil {
            map["LoadBalancerSpec"] = self.loadBalancerSpec!
        }
        if self.loadBalancerStatus != nil {
            map["LoadBalancerStatus"] = self.loadBalancerStatus!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("AddressIPVersion") {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("BackendServers") {
            var tmp : [DescribeLoadBalancerAttributeResponseBody.BackendServers] = []
            for v in dict["BackendServers"] as! [Any] {
                var model = DescribeLoadBalancerAttributeResponseBody.BackendServers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendServers = tmp
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("ListenerPorts") {
            self.listenerPorts = dict["ListenerPorts"] as! [String]
        }
        if dict.keys.contains("ListenerPortsAndProtocols") {
            var tmp : [DescribeLoadBalancerAttributeResponseBody.ListenerPortsAndProtocols] = []
            for v in dict["ListenerPortsAndProtocols"] as! [Any] {
                var model = DescribeLoadBalancerAttributeResponseBody.ListenerPortsAndProtocols()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.listenerPortsAndProtocols = tmp
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
        if dict.keys.contains("LoadBalancerSpec") {
            self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
        }
        if dict.keys.contains("LoadBalancerStatus") {
            self.loadBalancerStatus = dict["LoadBalancerStatus"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeLoadBalancerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoadBalancerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerHTTPListenerAttributeRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerHTTPListenerAttributeResponseBody : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var bandwidth: Int32?

    public var description_: String?

    public var forwardPort: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerForward: String?

    public var listenerPort: Int32?

    public var requestId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var status: String?

    public var unhealthyThreshold: Int32?

    public var XForwardedFor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.forwardPort != nil {
            map["ForwardPort"] = self.forwardPort!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerForward != nil {
            map["ListenerForward"] = self.listenerForward!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        if self.XForwardedFor != nil {
            map["XForwardedFor"] = self.XForwardedFor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ForwardPort") {
            self.forwardPort = dict["ForwardPort"] as! Int32
        }
        if dict.keys.contains("HealthCheck") {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerForward") {
            self.listenerForward = dict["ListenerForward"] as! String
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestTimeout") {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
        if dict.keys.contains("XForwardedFor") {
            self.XForwardedFor = dict["XForwardedFor"] as! String
        }
    }
}

public class DescribeLoadBalancerHTTPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerHTTPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoadBalancerHTTPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerHTTPSListenerAttributeRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerHTTPSListenerAttributeResponseBody : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var bandwidth: Int32?

    public var description_: String?

    public var forwardPort: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerForward: String?

    public var listenerPort: Int32?

    public var requestId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var status: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.forwardPort != nil {
            map["ForwardPort"] = self.forwardPort!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerForward != nil {
            map["ListenerForward"] = self.listenerForward!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ForwardPort") {
            self.forwardPort = dict["ForwardPort"] as! Int32
        }
        if dict.keys.contains("HealthCheck") {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerForward") {
            self.listenerForward = dict["ListenerForward"] as! String
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestTimeout") {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class DescribeLoadBalancerHTTPSListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerHTTPSListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoadBalancerHTTPSListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerListenMonitorRequest : Tea.TeaModel {
    public var endTime: String?

    public var loadBalancerId: String?

    public var proto: String?

    public var startTime: String?

    public var VPort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.proto != nil {
            map["Proto"] = self.proto!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.VPort != nil {
            map["VPort"] = self.VPort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("Proto") {
            self.proto = dict["Proto"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("VPort") {
            self.VPort = dict["VPort"] as! String
        }
    }
}

public class DescribeLoadBalancerListenMonitorResponseBody : Tea.TeaModel {
    public class LoadBalancerMonitorListenData : Tea.TeaModel {
        public var actConns: String?

        public var bizTime: String?

        public var conns: String?

        public var dropConns: String?

        public var ensRegionId: String?

        public var inActConns: String?

        public var inBytes: String?

        public var inDropBytes: String?

        public var inDropPkts: String?

        public var inPkts: String?

        public var inValidRsNum: String?

        public var loadBalancerId: String?

        public var outBytes: String?

        public var outDropBytes: String?

        public var outDropPkts: String?

        public var outPkts: String?

        public var proto: String?

        public var VPort: String?

        public var validRsNum: String?

        public var vip: String?

        public var vni: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actConns != nil {
                map["ActConns"] = self.actConns!
            }
            if self.bizTime != nil {
                map["BizTime"] = self.bizTime!
            }
            if self.conns != nil {
                map["Conns"] = self.conns!
            }
            if self.dropConns != nil {
                map["DropConns"] = self.dropConns!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.inActConns != nil {
                map["InActConns"] = self.inActConns!
            }
            if self.inBytes != nil {
                map["InBytes"] = self.inBytes!
            }
            if self.inDropBytes != nil {
                map["InDropBytes"] = self.inDropBytes!
            }
            if self.inDropPkts != nil {
                map["InDropPkts"] = self.inDropPkts!
            }
            if self.inPkts != nil {
                map["InPkts"] = self.inPkts!
            }
            if self.inValidRsNum != nil {
                map["InValidRsNum"] = self.inValidRsNum!
            }
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.outBytes != nil {
                map["OutBytes"] = self.outBytes!
            }
            if self.outDropBytes != nil {
                map["OutDropBytes"] = self.outDropBytes!
            }
            if self.outDropPkts != nil {
                map["OutDropPkts"] = self.outDropPkts!
            }
            if self.outPkts != nil {
                map["OutPkts"] = self.outPkts!
            }
            if self.proto != nil {
                map["Proto"] = self.proto!
            }
            if self.VPort != nil {
                map["VPort"] = self.VPort!
            }
            if self.validRsNum != nil {
                map["ValidRsNum"] = self.validRsNum!
            }
            if self.vip != nil {
                map["Vip"] = self.vip!
            }
            if self.vni != nil {
                map["Vni"] = self.vni!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActConns") {
                self.actConns = dict["ActConns"] as! String
            }
            if dict.keys.contains("BizTime") {
                self.bizTime = dict["BizTime"] as! String
            }
            if dict.keys.contains("Conns") {
                self.conns = dict["Conns"] as! String
            }
            if dict.keys.contains("DropConns") {
                self.dropConns = dict["DropConns"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("InActConns") {
                self.inActConns = dict["InActConns"] as! String
            }
            if dict.keys.contains("InBytes") {
                self.inBytes = dict["InBytes"] as! String
            }
            if dict.keys.contains("InDropBytes") {
                self.inDropBytes = dict["InDropBytes"] as! String
            }
            if dict.keys.contains("InDropPkts") {
                self.inDropPkts = dict["InDropPkts"] as! String
            }
            if dict.keys.contains("InPkts") {
                self.inPkts = dict["InPkts"] as! String
            }
            if dict.keys.contains("InValidRsNum") {
                self.inValidRsNum = dict["InValidRsNum"] as! String
            }
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("OutBytes") {
                self.outBytes = dict["OutBytes"] as! String
            }
            if dict.keys.contains("OutDropBytes") {
                self.outDropBytes = dict["OutDropBytes"] as! String
            }
            if dict.keys.contains("OutDropPkts") {
                self.outDropPkts = dict["OutDropPkts"] as! String
            }
            if dict.keys.contains("OutPkts") {
                self.outPkts = dict["OutPkts"] as! String
            }
            if dict.keys.contains("Proto") {
                self.proto = dict["Proto"] as! String
            }
            if dict.keys.contains("VPort") {
                self.VPort = dict["VPort"] as! String
            }
            if dict.keys.contains("ValidRsNum") {
                self.validRsNum = dict["ValidRsNum"] as! String
            }
            if dict.keys.contains("Vip") {
                self.vip = dict["Vip"] as! String
            }
            if dict.keys.contains("Vni") {
                self.vni = dict["Vni"] as! String
            }
        }
    }
    public var loadBalancerMonitorListenData: [DescribeLoadBalancerListenMonitorResponseBody.LoadBalancerMonitorListenData]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerMonitorListenData != nil {
            var tmp : [Any] = []
            for k in self.loadBalancerMonitorListenData! {
                tmp.append(k.toMap())
            }
            map["LoadBalancerMonitorListenData"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerMonitorListenData") {
            var tmp : [DescribeLoadBalancerListenMonitorResponseBody.LoadBalancerMonitorListenData] = []
            for v in dict["LoadBalancerMonitorListenData"] as! [Any] {
                var model = DescribeLoadBalancerListenMonitorResponseBody.LoadBalancerMonitorListenData()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.loadBalancerMonitorListenData = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLoadBalancerListenMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerListenMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoadBalancerListenMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerListenersRequest : Tea.TeaModel {
    public var description_: String?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeLoadBalancerListenersResponseBody : Tea.TeaModel {
    public class Listeners : Tea.TeaModel {
        public class Listener : Tea.TeaModel {
            public var backendServerPort: Int32?

            public var createTime: String?

            public var description_: String?

            public var forwardPort: String?

            public var listenerForward: String?

            public var listenerPort: String?

            public var loadBalancerId: String?

            public var protocol_: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backendServerPort != nil {
                    map["BackendServerPort"] = self.backendServerPort!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.forwardPort != nil {
                    map["ForwardPort"] = self.forwardPort!
                }
                if self.listenerForward != nil {
                    map["ListenerForward"] = self.listenerForward!
                }
                if self.listenerPort != nil {
                    map["ListenerPort"] = self.listenerPort!
                }
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BackendServerPort") {
                    self.backendServerPort = dict["BackendServerPort"] as! Int32
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ForwardPort") {
                    self.forwardPort = dict["ForwardPort"] as! String
                }
                if dict.keys.contains("ListenerForward") {
                    self.listenerForward = dict["ListenerForward"] as! String
                }
                if dict.keys.contains("ListenerPort") {
                    self.listenerPort = dict["ListenerPort"] as! String
                }
                if dict.keys.contains("LoadBalancerId") {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var listener: [DescribeLoadBalancerListenersResponseBody.Listeners.Listener]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.listener != nil {
                var tmp : [Any] = []
                for k in self.listener! {
                    tmp.append(k.toMap())
                }
                map["Listener"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Listener") {
                var tmp : [DescribeLoadBalancerListenersResponseBody.Listeners.Listener] = []
                for v in dict["Listener"] as! [Any] {
                    var model = DescribeLoadBalancerListenersResponseBody.Listeners.Listener()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.listener = tmp
            }
        }
    }
    public var listeners: DescribeLoadBalancerListenersResponseBody.Listeners?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.listeners?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listeners != nil {
            map["Listeners"] = self.listeners?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Listeners") {
            var model = DescribeLoadBalancerListenersResponseBody.Listeners()
            model.fromMap(dict["Listeners"] as! [String: Any])
            self.listeners = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLoadBalancerListenersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerListenersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoadBalancerListenersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerSpecRequest : Tea.TeaModel {
    public var loadBalancerSpec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerSpec != nil {
            map["LoadBalancerSpec"] = self.loadBalancerSpec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerSpec") {
            self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
        }
    }
}

public class DescribeLoadBalancerSpecResponseBody : Tea.TeaModel {
    public class LoadBalancerSpecs : Tea.TeaModel {
        public var displayName: String?

        public var loadBalancerSpec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.loadBalancerSpec != nil {
                map["LoadBalancerSpec"] = self.loadBalancerSpec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("LoadBalancerSpec") {
                self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
            }
        }
    }
    public var loadBalancerSpecs: [DescribeLoadBalancerSpecResponseBody.LoadBalancerSpecs]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerSpecs != nil {
            var tmp : [Any] = []
            for k in self.loadBalancerSpecs! {
                tmp.append(k.toMap())
            }
            map["LoadBalancerSpecs"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerSpecs") {
            var tmp : [DescribeLoadBalancerSpecResponseBody.LoadBalancerSpecs] = []
            for v in dict["LoadBalancerSpecs"] as! [Any] {
                var model = DescribeLoadBalancerSpecResponseBody.LoadBalancerSpecs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.loadBalancerSpecs = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLoadBalancerSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoadBalancerSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerTCPListenerAttributeRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerTCPListenerAttributeResponseBody : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var bandwidth: Int32?

    public var description_: String?

    public var eipTransmit: String?

    public var establishedTimeout: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckType: String?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var persistenceTimeout: Int32?

    public var requestId: String?

    public var scheduler: String?

    public var status: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.persistenceTimeout != nil {
            map["PersistenceTimeout"] = self.persistenceTimeout!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("EstablishedTimeout") {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheck") {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckType") {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("PersistenceTimeout") {
            self.persistenceTimeout = dict["PersistenceTimeout"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class DescribeLoadBalancerTCPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerTCPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoadBalancerTCPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancerUDPListenerAttributeRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class DescribeLoadBalancerUDPListenerAttributeResponseBody : Tea.TeaModel {
    public var backendServerPort: Int32?

    public var bandwidth: Int32?

    public var description_: String?

    public var eipTransmit: String?

    public var establishedTimeout: Int32?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckExp: String?

    public var healthCheckInterval: Int32?

    public var healthCheckReq: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var requestId: String?

    public var scheduler: String?

    public var status: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServerPort != nil {
            map["BackendServerPort"] = self.backendServerPort!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckExp != nil {
            map["HealthCheckExp"] = self.healthCheckExp!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckReq != nil {
            map["HealthCheckReq"] = self.healthCheckReq!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServerPort") {
            self.backendServerPort = dict["BackendServerPort"] as! Int32
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("EstablishedTimeout") {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheck") {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckExp") {
            self.healthCheckExp = dict["HealthCheckExp"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckReq") {
            self.healthCheckReq = dict["HealthCheckReq"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class DescribeLoadBalancerUDPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancerUDPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoadBalancerUDPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoadBalancersRequest : Tea.TeaModel {
    public var address: String?

    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public var loadBalancerId: String?

    public var loadBalancerName: String?

    public var loadBalancerStatus: String?

    public var networkId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var serverId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        if self.loadBalancerStatus != nil {
            map["LoadBalancerStatus"] = self.loadBalancerStatus!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
        if dict.keys.contains("LoadBalancerStatus") {
            self.loadBalancerStatus = dict["LoadBalancerStatus"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeLoadBalancersResponseBody : Tea.TeaModel {
    public class LoadBalancers : Tea.TeaModel {
        public class LoadBalancer : Tea.TeaModel {
            public var address: String?

            public var addressIPVersion: String?

            public var createTime: String?

            public var ensRegionId: String?

            public var loadBalancerId: String?

            public var loadBalancerName: String?

            public var loadBalancerStatus: String?

            public var networkId: String?

            public var payType: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.addressIPVersion != nil {
                    map["AddressIPVersion"] = self.addressIPVersion!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.loadBalancerId != nil {
                    map["LoadBalancerId"] = self.loadBalancerId!
                }
                if self.loadBalancerName != nil {
                    map["LoadBalancerName"] = self.loadBalancerName!
                }
                if self.loadBalancerStatus != nil {
                    map["LoadBalancerStatus"] = self.loadBalancerStatus!
                }
                if self.networkId != nil {
                    map["NetworkId"] = self.networkId!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("AddressIPVersion") {
                    self.addressIPVersion = dict["AddressIPVersion"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("LoadBalancerId") {
                    self.loadBalancerId = dict["LoadBalancerId"] as! String
                }
                if dict.keys.contains("LoadBalancerName") {
                    self.loadBalancerName = dict["LoadBalancerName"] as! String
                }
                if dict.keys.contains("LoadBalancerStatus") {
                    self.loadBalancerStatus = dict["LoadBalancerStatus"] as! String
                }
                if dict.keys.contains("NetworkId") {
                    self.networkId = dict["NetworkId"] as! String
                }
                if dict.keys.contains("PayType") {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
            }
        }
        public var loadBalancer: [DescribeLoadBalancersResponseBody.LoadBalancers.LoadBalancer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancer != nil {
                var tmp : [Any] = []
                for k in self.loadBalancer! {
                    tmp.append(k.toMap())
                }
                map["LoadBalancer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancer") {
                var tmp : [DescribeLoadBalancersResponseBody.LoadBalancers.LoadBalancer] = []
                for v in dict["LoadBalancer"] as! [Any] {
                    var model = DescribeLoadBalancersResponseBody.LoadBalancers.LoadBalancer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.loadBalancer = tmp
            }
        }
    }
    public var loadBalancers: DescribeLoadBalancersResponseBody.LoadBalancers?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.loadBalancers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancers != nil {
            map["LoadBalancers"] = self.loadBalancers?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancers") {
            var model = DescribeLoadBalancersResponseBody.LoadBalancers()
            model.fromMap(dict["LoadBalancers"] as! [String: Any])
            self.loadBalancers = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLoadBalancersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoadBalancersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLoadBalancersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeasurementDataRequest : Tea.TeaModel {
    public var endDate: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class DescribeMeasurementDataResponseBody : Tea.TeaModel {
    public class MeasurementDatas : Tea.TeaModel {
        public class MeasurementData : Tea.TeaModel {
            public class BandWidthFeeDatas : Tea.TeaModel {
                public class BandWidthFeeData : Tea.TeaModel {
                    public var costCode: String?

                    public var costName: String?

                    public var costVal: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.costCode != nil {
                            map["CostCode"] = self.costCode!
                        }
                        if self.costName != nil {
                            map["CostName"] = self.costName!
                        }
                        if self.costVal != nil {
                            map["CostVal"] = self.costVal!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CostCode") {
                            self.costCode = dict["CostCode"] as! String
                        }
                        if dict.keys.contains("CostName") {
                            self.costName = dict["CostName"] as! String
                        }
                        if dict.keys.contains("CostVal") {
                            self.costVal = dict["CostVal"] as! Int32
                        }
                    }
                }
                public var bandWidthFeeData: [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandWidthFeeData != nil {
                        var tmp : [Any] = []
                        for k in self.bandWidthFeeData! {
                            tmp.append(k.toMap())
                        }
                        map["BandWidthFeeData"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BandWidthFeeData") {
                        var tmp : [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData] = []
                        for v in dict["BandWidthFeeData"] as! [Any] {
                            var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas.BandWidthFeeData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.bandWidthFeeData = tmp
                    }
                }
            }
            public class ResourceFeeData : Tea.TeaModel {
                public var memory: Int32?

                public var storage: Int32?

                public var vcpu: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.memory != nil {
                        map["Memory"] = self.memory!
                    }
                    if self.storage != nil {
                        map["Storage"] = self.storage!
                    }
                    if self.vcpu != nil {
                        map["Vcpu"] = self.vcpu!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Memory") {
                        self.memory = dict["Memory"] as! Int32
                    }
                    if dict.keys.contains("Storage") {
                        self.storage = dict["Storage"] as! Int32
                    }
                    if dict.keys.contains("Vcpu") {
                        self.vcpu = dict["Vcpu"] as! Int32
                    }
                }
            }
            public class ResourceFeeDataDetails : Tea.TeaModel {
                public class ResourceFeeDataDetail : Tea.TeaModel {
                    public var costCode: String?

                    public var costName: String?

                    public var costVal: Int32?

                    public var resourceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.costCode != nil {
                            map["CostCode"] = self.costCode!
                        }
                        if self.costName != nil {
                            map["CostName"] = self.costName!
                        }
                        if self.costVal != nil {
                            map["CostVal"] = self.costVal!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CostCode") {
                            self.costCode = dict["CostCode"] as! String
                        }
                        if dict.keys.contains("CostName") {
                            self.costName = dict["CostName"] as! String
                        }
                        if dict.keys.contains("CostVal") {
                            self.costVal = dict["CostVal"] as! Int32
                        }
                        if dict.keys.contains("ResourceType") {
                            self.resourceType = dict["ResourceType"] as! String
                        }
                    }
                }
                public var resourceFeeDataDetail: [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails.ResourceFeeDataDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceFeeDataDetail != nil {
                        var tmp : [Any] = []
                        for k in self.resourceFeeDataDetail! {
                            tmp.append(k.toMap())
                        }
                        map["ResourceFeeDataDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceFeeDataDetail") {
                        var tmp : [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails.ResourceFeeDataDetail] = []
                        for v in dict["ResourceFeeDataDetail"] as! [Any] {
                            var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails.ResourceFeeDataDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.resourceFeeDataDetail = tmp
                    }
                }
            }
            public var bandWidthFeeDatas: DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas?

            public var chargeModel: String?

            public var costCycle: String?

            public var costEndTime: String?

            public var costStartTime: String?

            public var resourceFeeData: DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeData?

            public var resourceFeeDataDetails: DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bandWidthFeeDatas?.validate()
                try self.resourceFeeData?.validate()
                try self.resourceFeeDataDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidthFeeDatas != nil {
                    map["BandWidthFeeDatas"] = self.bandWidthFeeDatas?.toMap()
                }
                if self.chargeModel != nil {
                    map["ChargeModel"] = self.chargeModel!
                }
                if self.costCycle != nil {
                    map["CostCycle"] = self.costCycle!
                }
                if self.costEndTime != nil {
                    map["CostEndTime"] = self.costEndTime!
                }
                if self.costStartTime != nil {
                    map["CostStartTime"] = self.costStartTime!
                }
                if self.resourceFeeData != nil {
                    map["ResourceFeeData"] = self.resourceFeeData?.toMap()
                }
                if self.resourceFeeDataDetails != nil {
                    map["ResourceFeeDataDetails"] = self.resourceFeeDataDetails?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandWidthFeeDatas") {
                    var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.BandWidthFeeDatas()
                    model.fromMap(dict["BandWidthFeeDatas"] as! [String: Any])
                    self.bandWidthFeeDatas = model
                }
                if dict.keys.contains("ChargeModel") {
                    self.chargeModel = dict["ChargeModel"] as! String
                }
                if dict.keys.contains("CostCycle") {
                    self.costCycle = dict["CostCycle"] as! String
                }
                if dict.keys.contains("CostEndTime") {
                    self.costEndTime = dict["CostEndTime"] as! String
                }
                if dict.keys.contains("CostStartTime") {
                    self.costStartTime = dict["CostStartTime"] as! String
                }
                if dict.keys.contains("ResourceFeeData") {
                    var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeData()
                    model.fromMap(dict["ResourceFeeData"] as! [String: Any])
                    self.resourceFeeData = model
                }
                if dict.keys.contains("ResourceFeeDataDetails") {
                    var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData.ResourceFeeDataDetails()
                    model.fromMap(dict["ResourceFeeDataDetails"] as! [String: Any])
                    self.resourceFeeDataDetails = model
                }
            }
        }
        public var measurementData: [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.measurementData != nil {
                var tmp : [Any] = []
                for k in self.measurementData! {
                    tmp.append(k.toMap())
                }
                map["MeasurementData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MeasurementData") {
                var tmp : [DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData] = []
                for v in dict["MeasurementData"] as! [Any] {
                    var model = DescribeMeasurementDataResponseBody.MeasurementDatas.MeasurementData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.measurementData = tmp
            }
        }
    }
    public var measurementDatas: DescribeMeasurementDataResponseBody.MeasurementDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.measurementDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.measurementDatas != nil {
            map["MeasurementDatas"] = self.measurementDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MeasurementDatas") {
            var model = DescribeMeasurementDataResponseBody.MeasurementDatas()
            model.fromMap(dict["MeasurementDatas"] as! [String: Any])
            self.measurementDatas = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMeasurementDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeasurementDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeasurementDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMountTargetsRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var fileSystemId: String?

    public var mountTargetName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        if self.mountTargetName != nil {
            map["MountTargetName"] = self.mountTargetName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
        if dict.keys.contains("MountTargetName") {
            self.mountTargetName = dict["MountTargetName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeMountTargetsResponseBody : Tea.TeaModel {
    public class MountTargets : Tea.TeaModel {
        public var ensRegionId: String?

        public var fileSystemId: String?

        public var mountTargetDomain: String?

        public var mountTargetName: String?

        public var netWorkId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.fileSystemId != nil {
                map["FileSystemId"] = self.fileSystemId!
            }
            if self.mountTargetDomain != nil {
                map["MountTargetDomain"] = self.mountTargetDomain!
            }
            if self.mountTargetName != nil {
                map["MountTargetName"] = self.mountTargetName!
            }
            if self.netWorkId != nil {
                map["NetWorkId"] = self.netWorkId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("FileSystemId") {
                self.fileSystemId = dict["FileSystemId"] as! String
            }
            if dict.keys.contains("MountTargetDomain") {
                self.mountTargetDomain = dict["MountTargetDomain"] as! String
            }
            if dict.keys.contains("MountTargetName") {
                self.mountTargetName = dict["MountTargetName"] as! String
            }
            if dict.keys.contains("NetWorkId") {
                self.netWorkId = dict["NetWorkId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var mountTargets: [DescribeMountTargetsResponseBody.MountTargets]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mountTargets != nil {
            var tmp : [Any] = []
            for k in self.mountTargets! {
                tmp.append(k.toMap())
            }
            map["MountTargets"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MountTargets") {
            var tmp : [DescribeMountTargetsResponseBody.MountTargets] = []
            for v in dict["MountTargets"] as! [Any] {
                var model = DescribeMountTargetsResponseBody.MountTargets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mountTargets = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeMountTargetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMountTargetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMountTargetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNCInformationRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class DescribeNCInformationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Cpu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Gpu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Hdd : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Info : Tea.TeaModel {
            public var ip: String?

            public var name: String?

            public var tag: [String]?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.uuid != nil {
                    map["Uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! [String]
                }
                if dict.keys.contains("Uuid") {
                    self.uuid = dict["Uuid"] as! String
                }
            }
        }
        public class Memory : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Nvme : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Ssd : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public var cpu: DescribeNCInformationResponseBody.Data.Cpu?

        public var gpu: DescribeNCInformationResponseBody.Data.Gpu?

        public var hdd: DescribeNCInformationResponseBody.Data.Hdd?

        public var info: DescribeNCInformationResponseBody.Data.Info?

        public var memory: DescribeNCInformationResponseBody.Data.Memory?

        public var nvme: DescribeNCInformationResponseBody.Data.Nvme?

        public var online: Bool?

        public var region: String?

        public var ssd: DescribeNCInformationResponseBody.Data.Ssd?

        public var virtual: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cpu?.validate()
            try self.gpu?.validate()
            try self.hdd?.validate()
            try self.info?.validate()
            try self.memory?.validate()
            try self.nvme?.validate()
            try self.ssd?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpu != nil {
                map["Cpu"] = self.cpu?.toMap()
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu?.toMap()
            }
            if self.hdd != nil {
                map["Hdd"] = self.hdd?.toMap()
            }
            if self.info != nil {
                map["Info"] = self.info?.toMap()
            }
            if self.memory != nil {
                map["Memory"] = self.memory?.toMap()
            }
            if self.nvme != nil {
                map["Nvme"] = self.nvme?.toMap()
            }
            if self.online != nil {
                map["Online"] = self.online!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.ssd != nil {
                map["Ssd"] = self.ssd?.toMap()
            }
            if self.virtual != nil {
                map["Virtual"] = self.virtual!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cpu") {
                var model = DescribeNCInformationResponseBody.Data.Cpu()
                model.fromMap(dict["Cpu"] as! [String: Any])
                self.cpu = model
            }
            if dict.keys.contains("Gpu") {
                var model = DescribeNCInformationResponseBody.Data.Gpu()
                model.fromMap(dict["Gpu"] as! [String: Any])
                self.gpu = model
            }
            if dict.keys.contains("Hdd") {
                var model = DescribeNCInformationResponseBody.Data.Hdd()
                model.fromMap(dict["Hdd"] as! [String: Any])
                self.hdd = model
            }
            if dict.keys.contains("Info") {
                var model = DescribeNCInformationResponseBody.Data.Info()
                model.fromMap(dict["Info"] as! [String: Any])
                self.info = model
            }
            if dict.keys.contains("Memory") {
                var model = DescribeNCInformationResponseBody.Data.Memory()
                model.fromMap(dict["Memory"] as! [String: Any])
                self.memory = model
            }
            if dict.keys.contains("Nvme") {
                var model = DescribeNCInformationResponseBody.Data.Nvme()
                model.fromMap(dict["Nvme"] as! [String: Any])
                self.nvme = model
            }
            if dict.keys.contains("Online") {
                self.online = dict["Online"] as! Bool
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("Ssd") {
                var model = DescribeNCInformationResponseBody.Data.Ssd()
                model.fromMap(dict["Ssd"] as! [String: Any])
                self.ssd = model
            }
            if dict.keys.contains("Virtual") {
                self.virtual = dict["Virtual"] as! String
            }
        }
    }
    public class Pager : Tea.TeaModel {
        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var currentPage: Int32?

    public var data: [DescribeNCInformationResponseBody.Data]?

    public var desc: String?

    public var msg: String?

    public var pager: DescribeNCInformationResponseBody.Pager?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pager?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.pager != nil {
            map["Pager"] = self.pager?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeNCInformationResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeNCInformationResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Msg") {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("Pager") {
            var model = DescribeNCInformationResponseBody.Pager()
            model.fromMap(dict["Pager"] as! [String: Any])
            self.pager = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNCInformationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNCInformationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNCInformationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNatGatewaysRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public var name: String?

    public var natGatewayId: String?

    public var natGatewayIds: [String]?

    public var networkId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.natGatewayIds != nil {
            map["NatGatewayIds"] = self.natGatewayIds!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("NatGatewayIds") {
            self.natGatewayIds = dict["NatGatewayIds"] as! [String]
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeNatGatewaysResponseBody : Tea.TeaModel {
    public class NatGateways : Tea.TeaModel {
        public class IpLists : Tea.TeaModel {
            public var allocationId: String?

            public var ipAddress: String?

            public var usingStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationId != nil {
                    map["AllocationId"] = self.allocationId!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.usingStatus != nil {
                    map["UsingStatus"] = self.usingStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocationId") {
                    self.allocationId = dict["AllocationId"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("UsingStatus") {
                    self.usingStatus = dict["UsingStatus"] as! String
                }
            }
        }
        public var creationTime: String?

        public var ensRegionId: String?

        public var ipLists: [DescribeNatGatewaysResponseBody.NatGateways.IpLists]?

        public var name: String?

        public var natGatewayId: String?

        public var networkId: String?

        public var spec: String?

        public var status: String?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.ipLists != nil {
                var tmp : [Any] = []
                for k in self.ipLists! {
                    tmp.append(k.toMap())
                }
                map["IpLists"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("IpLists") {
                var tmp : [DescribeNatGatewaysResponseBody.NatGateways.IpLists] = []
                for v in dict["IpLists"] as! [Any] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.IpLists()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipLists = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NatGatewayId") {
                self.natGatewayId = dict["NatGatewayId"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public var natGateways: [DescribeNatGatewaysResponseBody.NatGateways]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGateways != nil {
            var tmp : [Any] = []
            for k in self.natGateways! {
                tmp.append(k.toMap())
            }
            map["NatGateways"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGateways") {
            var tmp : [DescribeNatGatewaysResponseBody.NatGateways] = []
            for v in dict["NatGateways"] as! [Any] {
                var model = DescribeNatGatewaysResponseBody.NatGateways()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.natGateways = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNatGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNatGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNatGatewaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkAclsRequest : Tea.TeaModel {
    public var networkAclId: String?

    public var networkAclName: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.networkAclName != nil {
            map["NetworkAclName"] = self.networkAclName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("NetworkAclName") {
            self.networkAclName = dict["NetworkAclName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class DescribeNetworkAclsResponseBody : Tea.TeaModel {
    public class NetworkAcls : Tea.TeaModel {
        public class EgressAclEntries : Tea.TeaModel {
            public var cidrBlock: String?

            public var description_: String?

            public var networkAclEntryId: String?

            public var networkAclEntryName: String?

            public var policy: String?

            public var portRange: String?

            public var priority: Int32?

            public var protocol_: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.networkAclEntryId != nil {
                    map["NetworkAclEntryId"] = self.networkAclEntryId!
                }
                if self.networkAclEntryName != nil {
                    map["NetworkAclEntryName"] = self.networkAclEntryName!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("NetworkAclEntryId") {
                    self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                }
                if dict.keys.contains("NetworkAclEntryName") {
                    self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("PortRange") {
                    self.portRange = dict["PortRange"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class IngressAclEntries : Tea.TeaModel {
            public var cidrBlock: String?

            public var description_: String?

            public var networkAclEntryId: String?

            public var networkAclEntryName: String?

            public var policy: String?

            public var portRange: String?

            public var priority: Int32?

            public var protocol_: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.networkAclEntryId != nil {
                    map["NetworkAclEntryId"] = self.networkAclEntryId!
                }
                if self.networkAclEntryName != nil {
                    map["NetworkAclEntryName"] = self.networkAclEntryName!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("NetworkAclEntryId") {
                    self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                }
                if dict.keys.contains("NetworkAclEntryName") {
                    self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("PortRange") {
                    self.portRange = dict["PortRange"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Resources : Tea.TeaModel {
            public var ensRegionId: String?

            public var resourceId: String?

            public var resourceType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var creationTime: String?

        public var description_: String?

        public var egressAclEntries: [DescribeNetworkAclsResponseBody.NetworkAcls.EgressAclEntries]?

        public var ingressAclEntries: [DescribeNetworkAclsResponseBody.NetworkAcls.IngressAclEntries]?

        public var networkAclId: String?

        public var networkAclName: String?

        public var resources: [DescribeNetworkAclsResponseBody.NetworkAcls.Resources]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.egressAclEntries != nil {
                var tmp : [Any] = []
                for k in self.egressAclEntries! {
                    tmp.append(k.toMap())
                }
                map["EgressAclEntries"] = tmp
            }
            if self.ingressAclEntries != nil {
                var tmp : [Any] = []
                for k in self.ingressAclEntries! {
                    tmp.append(k.toMap())
                }
                map["IngressAclEntries"] = tmp
            }
            if self.networkAclId != nil {
                map["NetworkAclId"] = self.networkAclId!
            }
            if self.networkAclName != nil {
                map["NetworkAclName"] = self.networkAclName!
            }
            if self.resources != nil {
                var tmp : [Any] = []
                for k in self.resources! {
                    tmp.append(k.toMap())
                }
                map["Resources"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EgressAclEntries") {
                var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.EgressAclEntries] = []
                for v in dict["EgressAclEntries"] as! [Any] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.EgressAclEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.egressAclEntries = tmp
            }
            if dict.keys.contains("IngressAclEntries") {
                var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.IngressAclEntries] = []
                for v in dict["IngressAclEntries"] as! [Any] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.IngressAclEntries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ingressAclEntries = tmp
            }
            if dict.keys.contains("NetworkAclId") {
                self.networkAclId = dict["NetworkAclId"] as! String
            }
            if dict.keys.contains("NetworkAclName") {
                self.networkAclName = dict["NetworkAclName"] as! String
            }
            if dict.keys.contains("Resources") {
                var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls.Resources] = []
                for v in dict["Resources"] as! [Any] {
                    var model = DescribeNetworkAclsResponseBody.NetworkAcls.Resources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resources = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var networkAcls: [DescribeNetworkAclsResponseBody.NetworkAcls]?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAcls != nil {
            var tmp : [Any] = []
            for k in self.networkAcls! {
                tmp.append(k.toMap())
            }
            map["NetworkAcls"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAcls") {
            var tmp : [DescribeNetworkAclsResponseBody.NetworkAcls] = []
            for v in dict["NetworkAcls"] as! [Any] {
                var model = DescribeNetworkAclsResponseBody.NetworkAcls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkAcls = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeNetworkAclsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkAclsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkAclsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkAttributeRequest : Tea.TeaModel {
    public var networkId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
    }
}

public class DescribeNetworkAttributeResponseBody : Tea.TeaModel {
    public class CloudResources : Tea.TeaModel {
        public class CloudResourceSetType : Tea.TeaModel {
            public var resourceCount: Int32?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceCount != nil {
                    map["ResourceCount"] = self.resourceCount!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceCount") {
                    self.resourceCount = dict["ResourceCount"] as! Int32
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
            }
        }
        public var cloudResourceSetType: [DescribeNetworkAttributeResponseBody.CloudResources.CloudResourceSetType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cloudResourceSetType != nil {
                var tmp : [Any] = []
                for k in self.cloudResourceSetType! {
                    tmp.append(k.toMap())
                }
                map["CloudResourceSetType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CloudResourceSetType") {
                var tmp : [DescribeNetworkAttributeResponseBody.CloudResources.CloudResourceSetType] = []
                for v in dict["CloudResourceSetType"] as! [Any] {
                    var model = DescribeNetworkAttributeResponseBody.CloudResources.CloudResourceSetType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cloudResourceSetType = tmp
            }
        }
    }
    public class HaVipIds : Tea.TeaModel {
        public var haVipId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.haVipId != nil {
                map["HaVipId"] = self.haVipId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HaVipId") {
                self.haVipId = dict["HaVipId"] as! [String]
            }
        }
    }
    public class InstanceIds : Tea.TeaModel {
        public var instanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! [String]
            }
        }
    }
    public class LoadBalancerIds : Tea.TeaModel {
        public var loadBalancerId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! [String]
            }
        }
    }
    public class NatGatewayIds : Tea.TeaModel {
        public var natGatewayId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NatGatewayId") {
                self.natGatewayId = dict["NatGatewayId"] as! [String]
            }
        }
    }
    public class NetworkInterfaceIds : Tea.TeaModel {
        public var networkInterfaceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceId") {
                self.networkInterfaceId = dict["NetworkInterfaceId"] as! [String]
            }
        }
    }
    public class RouteTableIds : Tea.TeaModel {
        public var routeTableId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeTableId != nil {
                map["RouteTableId"] = self.routeTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouteTableId") {
                self.routeTableId = dict["RouteTableId"] as! [String]
            }
        }
    }
    public class VSwitchIds : Tea.TeaModel {
        public var vSwitchId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! [String]
            }
        }
    }
    public var cidrBlock: String?

    public var cloudResources: DescribeNetworkAttributeResponseBody.CloudResources?

    public var createdTime: String?

    public var description_: String?

    public var ensRegionId: String?

    public var gatewayRouteTableId: String?

    public var haVipIds: DescribeNetworkAttributeResponseBody.HaVipIds?

    public var instanceIds: DescribeNetworkAttributeResponseBody.InstanceIds?

    public var loadBalancerIds: DescribeNetworkAttributeResponseBody.LoadBalancerIds?

    public var natGatewayIds: DescribeNetworkAttributeResponseBody.NatGatewayIds?

    public var networkAclId: String?

    public var networkId: String?

    public var networkInterfaceIds: DescribeNetworkAttributeResponseBody.NetworkInterfaceIds?

    public var networkName: String?

    public var requestId: String?

    public var routeTableId: String?

    public var routeTableIds: DescribeNetworkAttributeResponseBody.RouteTableIds?

    public var routerTableId: String?

    public var status: String?

    public var vSwitchIds: DescribeNetworkAttributeResponseBody.VSwitchIds?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cloudResources?.validate()
        try self.haVipIds?.validate()
        try self.instanceIds?.validate()
        try self.loadBalancerIds?.validate()
        try self.natGatewayIds?.validate()
        try self.networkInterfaceIds?.validate()
        try self.routeTableIds?.validate()
        try self.vSwitchIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.cloudResources != nil {
            map["CloudResources"] = self.cloudResources?.toMap()
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.gatewayRouteTableId != nil {
            map["GatewayRouteTableId"] = self.gatewayRouteTableId!
        }
        if self.haVipIds != nil {
            map["HaVipIds"] = self.haVipIds?.toMap()
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds?.toMap()
        }
        if self.loadBalancerIds != nil {
            map["LoadBalancerIds"] = self.loadBalancerIds?.toMap()
        }
        if self.natGatewayIds != nil {
            map["NatGatewayIds"] = self.natGatewayIds?.toMap()
        }
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.networkInterfaceIds != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIds?.toMap()
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableIds != nil {
            map["RouteTableIds"] = self.routeTableIds?.toMap()
        }
        if self.routerTableId != nil {
            map["RouterTableId"] = self.routerTableId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("CloudResources") {
            var model = DescribeNetworkAttributeResponseBody.CloudResources()
            model.fromMap(dict["CloudResources"] as! [String: Any])
            self.cloudResources = model
        }
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("GatewayRouteTableId") {
            self.gatewayRouteTableId = dict["GatewayRouteTableId"] as! String
        }
        if dict.keys.contains("HaVipIds") {
            var model = DescribeNetworkAttributeResponseBody.HaVipIds()
            model.fromMap(dict["HaVipIds"] as! [String: Any])
            self.haVipIds = model
        }
        if dict.keys.contains("InstanceIds") {
            var model = DescribeNetworkAttributeResponseBody.InstanceIds()
            model.fromMap(dict["InstanceIds"] as! [String: Any])
            self.instanceIds = model
        }
        if dict.keys.contains("LoadBalancerIds") {
            var model = DescribeNetworkAttributeResponseBody.LoadBalancerIds()
            model.fromMap(dict["LoadBalancerIds"] as! [String: Any])
            self.loadBalancerIds = model
        }
        if dict.keys.contains("NatGatewayIds") {
            var model = DescribeNetworkAttributeResponseBody.NatGatewayIds()
            model.fromMap(dict["NatGatewayIds"] as! [String: Any])
            self.natGatewayIds = model
        }
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceIds") {
            var model = DescribeNetworkAttributeResponseBody.NetworkInterfaceIds()
            model.fromMap(dict["NetworkInterfaceIds"] as! [String: Any])
            self.networkInterfaceIds = model
        }
        if dict.keys.contains("NetworkName") {
            self.networkName = dict["NetworkName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("RouteTableIds") {
            var model = DescribeNetworkAttributeResponseBody.RouteTableIds()
            model.fromMap(dict["RouteTableIds"] as! [String: Any])
            self.routeTableIds = model
        }
        if dict.keys.contains("RouterTableId") {
            self.routerTableId = dict["RouterTableId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VSwitchIds") {
            var model = DescribeNetworkAttributeResponseBody.VSwitchIds()
            model.fromMap(dict["VSwitchIds"] as! [String: Any])
            self.vSwitchIds = model
        }
    }
}

public class DescribeNetworkAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkInterfacesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public var instanceId: String?

    public var ipv6Address: [String]?

    public var networkId: String?

    public var networkInterfaceId: String?

    public var networkInterfaceIds: [String]?

    public var networkInterfaceName: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var primaryIpAddress: String?

    public var securityGroupId: String?

    public var status: String?

    public var type: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceIds != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIds!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.primaryIpAddress != nil {
            map["PrimaryIpAddress"] = self.primaryIpAddress!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! [String]
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceIds") {
            self.networkInterfaceIds = dict["NetworkInterfaceIds"] as! [String]
        }
        if dict.keys.contains("NetworkInterfaceName") {
            self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("PrimaryIpAddress") {
            self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeNetworkInterfacesResponseBody : Tea.TeaModel {
    public class NetworkInterfaceSets : Tea.TeaModel {
        public class NetworkInterfaceSet : Tea.TeaModel {
            public class Ipv6Sets : Tea.TeaModel {
                public class Ipv6Set : Tea.TeaModel {
                    public var ipv6Address: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv6Address != nil {
                            map["Ipv6Address"] = self.ipv6Address!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Ipv6Address") {
                            self.ipv6Address = dict["Ipv6Address"] as! String
                        }
                    }
                }
                public var ipv6Set: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6Set != nil {
                        var tmp : [Any] = []
                        for k in self.ipv6Set! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv6Set"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ipv6Set") {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set] = []
                        for v in dict["Ipv6Set"] as! [Any] {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ipv6Set = tmp
                    }
                }
            }
            public class PrivateIpSets : Tea.TeaModel {
                public class PrivateIpSet : Tea.TeaModel {
                    public var primary: Bool?

                    public var privateIpAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.primary != nil {
                            map["Primary"] = self.primary!
                        }
                        if self.privateIpAddress != nil {
                            map["PrivateIpAddress"] = self.privateIpAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Primary") {
                            self.primary = dict["Primary"] as! Bool
                        }
                        if dict.keys.contains("PrivateIpAddress") {
                            self.privateIpAddress = dict["PrivateIpAddress"] as! String
                        }
                    }
                }
                public var privateIpSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateIpSet != nil {
                        var tmp : [Any] = []
                        for k in self.privateIpSet! {
                            tmp.append(k.toMap())
                        }
                        map["PrivateIpSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateIpSet") {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet] = []
                        for v in dict["PrivateIpSet"] as! [Any] {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.privateIpSet = tmp
                    }
                }
            }
            public class SecurityGroupIds : Tea.TeaModel {
                public var securityGroup: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroup != nil {
                        map["SecurityGroup"] = self.securityGroup!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityGroup") {
                        self.securityGroup = dict["SecurityGroup"] as! [String]
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var ensRegionId: String?

            public var instanceId: String?

            public var ipv6Sets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets?

            public var macAddress: String?

            public var networkId: String?

            public var networkInterfaceId: String?

            public var networkInterfaceName: String?

            public var primaryIp: String?

            public var primaryIpType: String?

            public var privateIpSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets?

            public var securityGroupIds: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.SecurityGroupIds?

            public var status: String?

            public var type: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ipv6Sets?.validate()
                try self.privateIpSets?.validate()
                try self.securityGroupIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipv6Sets != nil {
                    map["Ipv6Sets"] = self.ipv6Sets?.toMap()
                }
                if self.macAddress != nil {
                    map["MacAddress"] = self.macAddress!
                }
                if self.networkId != nil {
                    map["NetworkId"] = self.networkId!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.networkInterfaceName != nil {
                    map["NetworkInterfaceName"] = self.networkInterfaceName!
                }
                if self.primaryIp != nil {
                    map["PrimaryIp"] = self.primaryIp!
                }
                if self.primaryIpType != nil {
                    map["PrimaryIpType"] = self.primaryIpType!
                }
                if self.privateIpSets != nil {
                    map["PrivateIpSets"] = self.privateIpSets?.toMap()
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Ipv6Sets") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets()
                    model.fromMap(dict["Ipv6Sets"] as! [String: Any])
                    self.ipv6Sets = model
                }
                if dict.keys.contains("MacAddress") {
                    self.macAddress = dict["MacAddress"] as! String
                }
                if dict.keys.contains("NetworkId") {
                    self.networkId = dict["NetworkId"] as! String
                }
                if dict.keys.contains("NetworkInterfaceId") {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                }
                if dict.keys.contains("NetworkInterfaceName") {
                    self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
                }
                if dict.keys.contains("PrimaryIp") {
                    self.primaryIp = dict["PrimaryIp"] as! String
                }
                if dict.keys.contains("PrimaryIpType") {
                    self.primaryIpType = dict["PrimaryIpType"] as! String
                }
                if dict.keys.contains("PrivateIpSets") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets()
                    model.fromMap(dict["PrivateIpSets"] as! [String: Any])
                    self.privateIpSets = model
                }
                if dict.keys.contains("SecurityGroupIds") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.SecurityGroupIds()
                    model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
                    self.securityGroupIds = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
            }
        }
        public var networkInterfaceSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceSet != nil {
                var tmp : [Any] = []
                for k in self.networkInterfaceSet! {
                    tmp.append(k.toMap())
                }
                map["NetworkInterfaceSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceSet") {
                var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet] = []
                for v in dict["NetworkInterfaceSet"] as! [Any] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.networkInterfaceSet = tmp
            }
        }
    }
    public var networkInterfaceSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInterfaceSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceSets != nil {
            map["NetworkInterfaceSets"] = self.networkInterfaceSets?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceSets") {
            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets()
            model.fromMap(dict["NetworkInterfaceSets"] as! [String: Any])
            self.networkInterfaceSets = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNetworkInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkInterfacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworksRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public var networkId: String?

    public var networkIds: [String]?

    public var networkName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.networkIds != nil {
            map["NetworkIds"] = self.networkIds!
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("NetworkIds") {
            self.networkIds = dict["NetworkIds"] as! [String]
        }
        if dict.keys.contains("NetworkName") {
            self.networkName = dict["NetworkName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeNetworksResponseBody : Tea.TeaModel {
    public class Networks : Tea.TeaModel {
        public class Network : Tea.TeaModel {
            public class RouteTableIds : Tea.TeaModel {
                public var routeTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeTableId != nil {
                        map["RouteTableId"] = self.routeTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RouteTableId") {
                        self.routeTableId = dict["RouteTableId"] as! [String]
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! [String]
                    }
                }
            }
            public var cidrBlock: String?

            public var createdTime: String?

            public var description_: String?

            public var ensRegionId: String?

            public var gatewayRouteTableId: String?

            public var networkAclId: String?

            public var networkId: String?

            public var networkName: String?

            public var routeTableId: String?

            public var routeTableIds: DescribeNetworksResponseBody.Networks.Network.RouteTableIds?

            public var routerTableId: String?

            public var status: String?

            public var vSwitchIds: DescribeNetworksResponseBody.Networks.Network.VSwitchIds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeTableIds?.validate()
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.gatewayRouteTableId != nil {
                    map["GatewayRouteTableId"] = self.gatewayRouteTableId!
                }
                if self.networkAclId != nil {
                    map["NetworkAclId"] = self.networkAclId!
                }
                if self.networkId != nil {
                    map["NetworkId"] = self.networkId!
                }
                if self.networkName != nil {
                    map["NetworkName"] = self.networkName!
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.routeTableIds != nil {
                    map["RouteTableIds"] = self.routeTableIds?.toMap()
                }
                if self.routerTableId != nil {
                    map["RouterTableId"] = self.routerTableId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("GatewayRouteTableId") {
                    self.gatewayRouteTableId = dict["GatewayRouteTableId"] as! String
                }
                if dict.keys.contains("NetworkAclId") {
                    self.networkAclId = dict["NetworkAclId"] as! String
                }
                if dict.keys.contains("NetworkId") {
                    self.networkId = dict["NetworkId"] as! String
                }
                if dict.keys.contains("NetworkName") {
                    self.networkName = dict["NetworkName"] as! String
                }
                if dict.keys.contains("RouteTableId") {
                    self.routeTableId = dict["RouteTableId"] as! String
                }
                if dict.keys.contains("RouteTableIds") {
                    var model = DescribeNetworksResponseBody.Networks.Network.RouteTableIds()
                    model.fromMap(dict["RouteTableIds"] as! [String: Any])
                    self.routeTableIds = model
                }
                if dict.keys.contains("RouterTableId") {
                    self.routerTableId = dict["RouterTableId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VSwitchIds") {
                    var model = DescribeNetworksResponseBody.Networks.Network.VSwitchIds()
                    model.fromMap(dict["VSwitchIds"] as! [String: Any])
                    self.vSwitchIds = model
                }
            }
        }
        public var network: [DescribeNetworksResponseBody.Networks.Network]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.network != nil {
                var tmp : [Any] = []
                for k in self.network! {
                    tmp.append(k.toMap())
                }
                map["Network"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Network") {
                var tmp : [DescribeNetworksResponseBody.Networks.Network] = []
                for v in dict["Network"] as! [Any] {
                    var model = DescribeNetworksResponseBody.Networks.Network()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.network = tmp
            }
        }
    }
    public var networks: DescribeNetworksResponseBody.Networks?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networks != nil {
            map["Networks"] = self.networks?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Networks") {
            var model = DescribeNetworksResponseBody.Networks()
            model.fromMap(dict["Networks"] as! [String: Any])
            self.networks = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNetworksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrePaidInstanceStockRequest : Tea.TeaModel {
    public var dataDiskSize: Int32?

    public var ensRegionId: String?

    public var instanceSpec: String?

    public var systemDiskSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceSpec != nil {
            map["InstanceSpec"] = self.instanceSpec!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDiskSize") {
            self.dataDiskSize = dict["DataDiskSize"] as! Int32
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceSpec") {
            self.instanceSpec = dict["InstanceSpec"] as! String
        }
        if dict.keys.contains("SystemDiskSize") {
            self.systemDiskSize = dict["SystemDiskSize"] as! Int32
        }
    }
}

public class DescribePrePaidInstanceStockResponseBody : Tea.TeaModel {
    public var avaliableCount: Int32?

    public var cores: Int32?

    public var dataDiskSize: Int32?

    public var ensRegionId: String?

    public var instanceSpec: String?

    public var memory: Int32?

    public var requestId: String?

    public var resourceGap: String?

    public var systemDiskSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avaliableCount != nil {
            map["AvaliableCount"] = self.avaliableCount!
        }
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.dataDiskSize != nil {
            map["DataDiskSize"] = self.dataDiskSize!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceSpec != nil {
            map["InstanceSpec"] = self.instanceSpec!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGap != nil {
            map["ResourceGap"] = self.resourceGap!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvaliableCount") {
            self.avaliableCount = dict["AvaliableCount"] as! Int32
        }
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("DataDiskSize") {
            self.dataDiskSize = dict["DataDiskSize"] as! Int32
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceSpec") {
            self.instanceSpec = dict["InstanceSpec"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGap") {
            self.resourceGap = dict["ResourceGap"] as! String
        }
        if dict.keys.contains("SystemDiskSize") {
            self.systemDiskSize = dict["SystemDiskSize"] as! Int32
        }
    }
}

public class DescribePrePaidInstanceStockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrePaidInstanceStockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePrePaidInstanceStockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePriceRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class DataDisks : Tea.TeaModel {
        public var category: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
        }
    }
    public var dataDisk: [DescribePriceRequest.DataDisk]?

    public var systemDisk: DescribePriceRequest.SystemDisk?

    public var dataDisks: [DescribePriceRequest.DataDisks]?

    public var ensRegionId: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var quantity: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.dataDisks != nil {
            var tmp : [Any] = []
            for k in self.dataDisks! {
                tmp.append(k.toMap())
            }
            map["DataDisks"] = tmp
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDisk") {
            var tmp : [DescribePriceRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = DescribePriceRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("SystemDisk") {
            var model = DescribePriceRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("DataDisks") {
            var tmp : [DescribePriceRequest.DataDisks] = []
            for v in dict["DataDisks"] as! [Any] {
                var model = DescribePriceRequest.DataDisks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisks = tmp
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Quantity") {
            self.quantity = dict["Quantity"] as! Int32
        }
    }
}

public class DescribePriceShrinkRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public var dataDisk: [DescribePriceShrinkRequest.DataDisk]?

    public var systemDisk: DescribePriceShrinkRequest.SystemDisk?

    public var dataDisksShrink: String?

    public var ensRegionId: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var quantity: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.dataDisksShrink != nil {
            map["DataDisks"] = self.dataDisksShrink!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDisk") {
            var tmp : [DescribePriceShrinkRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = DescribePriceShrinkRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("SystemDisk") {
            var model = DescribePriceShrinkRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("DataDisks") {
            self.dataDisksShrink = dict["DataDisks"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Quantity") {
            self.quantity = dict["Quantity"] as! Int32
        }
    }
}

public class DescribePriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public var currency: String?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public var price: DescribePriceResponseBody.PriceInfo.Price?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                var model = DescribePriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
        }
    }
    public var priceInfo: DescribePriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribePriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionIspsRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
    }
}

public class DescribeRegionIspsResponseBody : Tea.TeaModel {
    public class Isps : Tea.TeaModel {
        public var code: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var isps: [DescribeRegionIspsResponseBody.Isps]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isps != nil {
            var tmp : [Any] = []
            for k in self.isps! {
                tmp.append(k.toMap())
            }
            map["Isps"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Isps") {
            var tmp : [DescribeRegionIspsResponseBody.Isps] = []
            for v in dict["Isps"] as! [Any] {
                var model = DescribeRegionIspsResponseBody.Isps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.isps = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionIspsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionIspsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionIspsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionResourceRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ispType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ispType != nil {
            map["IspType"] = self.ispType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("IspType") {
            self.ispType = dict["IspType"] as! String
        }
    }
}

public class DescribeRegionResourceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ArmCard : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Bandwidth : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class BlockStorage : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Cpu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Gpu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Hdd : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Ipv4s : Tea.TeaModel {
            public var display: String?

            public var isp: String?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public var vlan: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                if self.vlan != nil {
                    map["Vlan"] = self.vlan!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! String
                }
                if dict.keys.contains("Isp") {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
                if dict.keys.contains("Vlan") {
                    self.vlan = dict["Vlan"] as! String
                }
            }
        }
        public class Ipv6s : Tea.TeaModel {
            public var display: String?

            public var isp: String?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public var vlan: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.isp != nil {
                    map["Isp"] = self.isp!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                if self.vlan != nil {
                    map["Vlan"] = self.vlan!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! String
                }
                if dict.keys.contains("Isp") {
                    self.isp = dict["Isp"] as! String
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
                if dict.keys.contains("Vlan") {
                    self.vlan = dict["Vlan"] as! String
                }
            }
        }
        public class Memory : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Nvme : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class OssStorage : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Pangu : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class PcfarmNum : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public class Ssd : Tea.TeaModel {
            public var display: Bool?

            public var oversellRatio: Int64?

            public var remain: Int64?

            public var reserveDisable: Bool?

            public var reserveDisableTotal: Int64?

            public var reserved: Int64?

            public var statusDisable: Bool?

            public var statusDisableTotal: Int64?

            public var total: Int64?

            public var type: String?

            public var used: Int64?

            public var usedRatio: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.oversellRatio != nil {
                    map["OversellRatio"] = self.oversellRatio!
                }
                if self.remain != nil {
                    map["Remain"] = self.remain!
                }
                if self.reserveDisable != nil {
                    map["ReserveDisable"] = self.reserveDisable!
                }
                if self.reserveDisableTotal != nil {
                    map["ReserveDisableTotal"] = self.reserveDisableTotal!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.statusDisable != nil {
                    map["StatusDisable"] = self.statusDisable!
                }
                if self.statusDisableTotal != nil {
                    map["StatusDisableTotal"] = self.statusDisableTotal!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.used != nil {
                    map["Used"] = self.used!
                }
                if self.usedRatio != nil {
                    map["UsedRatio"] = self.usedRatio!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Display") {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("OversellRatio") {
                    self.oversellRatio = dict["OversellRatio"] as! Int64
                }
                if dict.keys.contains("Remain") {
                    self.remain = dict["Remain"] as! Int64
                }
                if dict.keys.contains("ReserveDisable") {
                    self.reserveDisable = dict["ReserveDisable"] as! Bool
                }
                if dict.keys.contains("ReserveDisableTotal") {
                    self.reserveDisableTotal = dict["ReserveDisableTotal"] as! Int64
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("StatusDisable") {
                    self.statusDisable = dict["StatusDisable"] as! Bool
                }
                if dict.keys.contains("StatusDisableTotal") {
                    self.statusDisableTotal = dict["StatusDisableTotal"] as! Int64
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Used") {
                    self.used = dict["Used"] as! Int64
                }
                if dict.keys.contains("UsedRatio") {
                    self.usedRatio = dict["UsedRatio"] as! Int64
                }
            }
        }
        public var areaCode: String?

        public var areaName: String?

        public var armCard: DescribeRegionResourceResponseBody.Data.ArmCard?

        public var attributes: [String]?

        public var bandwidth: DescribeRegionResourceResponseBody.Data.Bandwidth?

        public var blockStorage: DescribeRegionResourceResponseBody.Data.BlockStorage?

        public var countryCode: String?

        public var countryName: String?

        public var cpu: DescribeRegionResourceResponseBody.Data.Cpu?

        public var gpu: DescribeRegionResourceResponseBody.Data.Gpu?

        public var hdd: DescribeRegionResourceResponseBody.Data.Hdd?

        public var houseId: String?

        public var ipv4s: [DescribeRegionResourceResponseBody.Data.Ipv4s]?

        public var ipv6s: [DescribeRegionResourceResponseBody.Data.Ipv6s]?

        public var ispTypes: [String]?

        public var memory: DescribeRegionResourceResponseBody.Data.Memory?

        public var name: String?

        public var nvme: DescribeRegionResourceResponseBody.Data.Nvme?

        public var ossStorage: DescribeRegionResourceResponseBody.Data.OssStorage?

        public var pangu: DescribeRegionResourceResponseBody.Data.Pangu?

        public var pcfarmNum: DescribeRegionResourceResponseBody.Data.PcfarmNum?

        public var poc: Bool?

        public var provinceCode: String?

        public var provinceName: String?

        public var reserveDisable: Bool?

        public var ssd: DescribeRegionResourceResponseBody.Data.Ssd?

        public var statusDisable: Bool?

        public var type: String?

        public var uuid: String?

        public var virtual: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.armCard?.validate()
            try self.bandwidth?.validate()
            try self.blockStorage?.validate()
            try self.cpu?.validate()
            try self.gpu?.validate()
            try self.hdd?.validate()
            try self.memory?.validate()
            try self.nvme?.validate()
            try self.ossStorage?.validate()
            try self.pangu?.validate()
            try self.pcfarmNum?.validate()
            try self.ssd?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.areaCode != nil {
                map["AreaCode"] = self.areaCode!
            }
            if self.areaName != nil {
                map["AreaName"] = self.areaName!
            }
            if self.armCard != nil {
                map["ArmCard"] = self.armCard?.toMap()
            }
            if self.attributes != nil {
                map["Attributes"] = self.attributes!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth?.toMap()
            }
            if self.blockStorage != nil {
                map["BlockStorage"] = self.blockStorage?.toMap()
            }
            if self.countryCode != nil {
                map["CountryCode"] = self.countryCode!
            }
            if self.countryName != nil {
                map["CountryName"] = self.countryName!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu?.toMap()
            }
            if self.gpu != nil {
                map["Gpu"] = self.gpu?.toMap()
            }
            if self.hdd != nil {
                map["Hdd"] = self.hdd?.toMap()
            }
            if self.houseId != nil {
                map["HouseId"] = self.houseId!
            }
            if self.ipv4s != nil {
                var tmp : [Any] = []
                for k in self.ipv4s! {
                    tmp.append(k.toMap())
                }
                map["Ipv4s"] = tmp
            }
            if self.ipv6s != nil {
                var tmp : [Any] = []
                for k in self.ipv6s! {
                    tmp.append(k.toMap())
                }
                map["Ipv6s"] = tmp
            }
            if self.ispTypes != nil {
                map["IspTypes"] = self.ispTypes!
            }
            if self.memory != nil {
                map["Memory"] = self.memory?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nvme != nil {
                map["Nvme"] = self.nvme?.toMap()
            }
            if self.ossStorage != nil {
                map["OssStorage"] = self.ossStorage?.toMap()
            }
            if self.pangu != nil {
                map["Pangu"] = self.pangu?.toMap()
            }
            if self.pcfarmNum != nil {
                map["PcfarmNum"] = self.pcfarmNum?.toMap()
            }
            if self.poc != nil {
                map["Poc"] = self.poc!
            }
            if self.provinceCode != nil {
                map["ProvinceCode"] = self.provinceCode!
            }
            if self.provinceName != nil {
                map["ProvinceName"] = self.provinceName!
            }
            if self.reserveDisable != nil {
                map["ReserveDisable"] = self.reserveDisable!
            }
            if self.ssd != nil {
                map["Ssd"] = self.ssd?.toMap()
            }
            if self.statusDisable != nil {
                map["StatusDisable"] = self.statusDisable!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.virtual != nil {
                map["Virtual"] = self.virtual!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AreaCode") {
                self.areaCode = dict["AreaCode"] as! String
            }
            if dict.keys.contains("AreaName") {
                self.areaName = dict["AreaName"] as! String
            }
            if dict.keys.contains("ArmCard") {
                var model = DescribeRegionResourceResponseBody.Data.ArmCard()
                model.fromMap(dict["ArmCard"] as! [String: Any])
                self.armCard = model
            }
            if dict.keys.contains("Attributes") {
                self.attributes = dict["Attributes"] as! [String]
            }
            if dict.keys.contains("Bandwidth") {
                var model = DescribeRegionResourceResponseBody.Data.Bandwidth()
                model.fromMap(dict["Bandwidth"] as! [String: Any])
                self.bandwidth = model
            }
            if dict.keys.contains("BlockStorage") {
                var model = DescribeRegionResourceResponseBody.Data.BlockStorage()
                model.fromMap(dict["BlockStorage"] as! [String: Any])
                self.blockStorage = model
            }
            if dict.keys.contains("CountryCode") {
                self.countryCode = dict["CountryCode"] as! String
            }
            if dict.keys.contains("CountryName") {
                self.countryName = dict["CountryName"] as! String
            }
            if dict.keys.contains("Cpu") {
                var model = DescribeRegionResourceResponseBody.Data.Cpu()
                model.fromMap(dict["Cpu"] as! [String: Any])
                self.cpu = model
            }
            if dict.keys.contains("Gpu") {
                var model = DescribeRegionResourceResponseBody.Data.Gpu()
                model.fromMap(dict["Gpu"] as! [String: Any])
                self.gpu = model
            }
            if dict.keys.contains("Hdd") {
                var model = DescribeRegionResourceResponseBody.Data.Hdd()
                model.fromMap(dict["Hdd"] as! [String: Any])
                self.hdd = model
            }
            if dict.keys.contains("HouseId") {
                self.houseId = dict["HouseId"] as! String
            }
            if dict.keys.contains("Ipv4s") {
                var tmp : [DescribeRegionResourceResponseBody.Data.Ipv4s] = []
                for v in dict["Ipv4s"] as! [Any] {
                    var model = DescribeRegionResourceResponseBody.Data.Ipv4s()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv4s = tmp
            }
            if dict.keys.contains("Ipv6s") {
                var tmp : [DescribeRegionResourceResponseBody.Data.Ipv6s] = []
                for v in dict["Ipv6s"] as! [Any] {
                    var model = DescribeRegionResourceResponseBody.Data.Ipv6s()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6s = tmp
            }
            if dict.keys.contains("IspTypes") {
                self.ispTypes = dict["IspTypes"] as! [String]
            }
            if dict.keys.contains("Memory") {
                var model = DescribeRegionResourceResponseBody.Data.Memory()
                model.fromMap(dict["Memory"] as! [String: Any])
                self.memory = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Nvme") {
                var model = DescribeRegionResourceResponseBody.Data.Nvme()
                model.fromMap(dict["Nvme"] as! [String: Any])
                self.nvme = model
            }
            if dict.keys.contains("OssStorage") {
                var model = DescribeRegionResourceResponseBody.Data.OssStorage()
                model.fromMap(dict["OssStorage"] as! [String: Any])
                self.ossStorage = model
            }
            if dict.keys.contains("Pangu") {
                var model = DescribeRegionResourceResponseBody.Data.Pangu()
                model.fromMap(dict["Pangu"] as! [String: Any])
                self.pangu = model
            }
            if dict.keys.contains("PcfarmNum") {
                var model = DescribeRegionResourceResponseBody.Data.PcfarmNum()
                model.fromMap(dict["PcfarmNum"] as! [String: Any])
                self.pcfarmNum = model
            }
            if dict.keys.contains("Poc") {
                self.poc = dict["Poc"] as! Bool
            }
            if dict.keys.contains("ProvinceCode") {
                self.provinceCode = dict["ProvinceCode"] as! String
            }
            if dict.keys.contains("ProvinceName") {
                self.provinceName = dict["ProvinceName"] as! String
            }
            if dict.keys.contains("ReserveDisable") {
                self.reserveDisable = dict["ReserveDisable"] as! Bool
            }
            if dict.keys.contains("Ssd") {
                var model = DescribeRegionResourceResponseBody.Data.Ssd()
                model.fromMap(dict["Ssd"] as! [String: Any])
                self.ssd = model
            }
            if dict.keys.contains("StatusDisable") {
                self.statusDisable = dict["StatusDisable"] as! Bool
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Virtual") {
                self.virtual = dict["Virtual"] as! String
            }
        }
    }
    public class Pager : Tea.TeaModel {
        public var page: Int64?

        public var size: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.page != nil {
                map["Page"] = self.page!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Page") {
                self.page = dict["Page"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var data: [DescribeRegionResourceResponseBody.Data]?

    public var desc: String?

    public var msg: String?

    public var pager: DescribeRegionResourceResponseBody.Pager?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pager?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.pager != nil {
            map["Pager"] = self.pager?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [DescribeRegionResourceResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeRegionResourceResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("Msg") {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("Pager") {
            var model = DescribeRegionResourceResponseBody.Pager()
            model.fromMap(dict["Pager"] as! [String: Any])
            self.pager = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservedResourceResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public var imageId: String?

            public var imageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") {
                    self.imageName = dict["ImageName"] as! String
                }
            }
        }
        public var image: [DescribeReservedResourceResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") {
                var tmp : [DescribeReservedResourceResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeReservedResourceResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public class SupportResources : Tea.TeaModel {
        public class SupportResource : Tea.TeaModel {
            public class DataDiskSizes : Tea.TeaModel {
                public var dataDiskSize: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dataDiskSize != nil {
                        map["DataDiskSize"] = self.dataDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DataDiskSize") {
                        self.dataDiskSize = dict["DataDiskSize"] as! [String]
                    }
                }
            }
            public class SystemDiskSizes : Tea.TeaModel {
                public var systemDiskSize: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.systemDiskSize != nil {
                        map["SystemDiskSize"] = self.systemDiskSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SystemDiskSize") {
                        self.systemDiskSize = dict["SystemDiskSize"] as! [String]
                    }
                }
            }
            public var dataDiskSizes: DescribeReservedResourceResponseBody.SupportResources.SupportResource.DataDiskSizes?

            public var ensRegionId: String?

            public var instanceSpec: String?

            public var supportResourcesCount: String?

            public var systemDiskSizes: DescribeReservedResourceResponseBody.SupportResources.SupportResource.SystemDiskSizes?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataDiskSizes?.validate()
                try self.systemDiskSizes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataDiskSizes != nil {
                    map["DataDiskSizes"] = self.dataDiskSizes?.toMap()
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.instanceSpec != nil {
                    map["InstanceSpec"] = self.instanceSpec!
                }
                if self.supportResourcesCount != nil {
                    map["SupportResourcesCount"] = self.supportResourcesCount!
                }
                if self.systemDiskSizes != nil {
                    map["SystemDiskSizes"] = self.systemDiskSizes?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataDiskSizes") {
                    var model = DescribeReservedResourceResponseBody.SupportResources.SupportResource.DataDiskSizes()
                    model.fromMap(dict["DataDiskSizes"] as! [String: Any])
                    self.dataDiskSizes = model
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("InstanceSpec") {
                    self.instanceSpec = dict["InstanceSpec"] as! String
                }
                if dict.keys.contains("SupportResourcesCount") {
                    self.supportResourcesCount = dict["SupportResourcesCount"] as! String
                }
                if dict.keys.contains("SystemDiskSizes") {
                    var model = DescribeReservedResourceResponseBody.SupportResources.SupportResource.SystemDiskSizes()
                    model.fromMap(dict["SystemDiskSizes"] as! [String: Any])
                    self.systemDiskSizes = model
                }
            }
        }
        public var supportResource: [DescribeReservedResourceResponseBody.SupportResources.SupportResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.supportResource != nil {
                var tmp : [Any] = []
                for k in self.supportResource! {
                    tmp.append(k.toMap())
                }
                map["SupportResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SupportResource") {
                var tmp : [DescribeReservedResourceResponseBody.SupportResources.SupportResource] = []
                for v in dict["SupportResource"] as! [Any] {
                    var model = DescribeReservedResourceResponseBody.SupportResources.SupportResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportResource = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeReservedResourceResponseBody.Images?

    public var requestId: String?

    public var supportResources: DescribeReservedResourceResponseBody.SupportResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
        try self.supportResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportResources != nil {
            map["SupportResources"] = self.supportResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") {
            var model = DescribeReservedResourceResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportResources") {
            var model = DescribeReservedResourceResponseBody.SupportResources()
            model.fromMap(dict["SupportResources"] as! [String: Any])
            self.supportResources = model
        }
    }
}

public class DescribeReservedResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeReservedResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceTimelineRequest : Tea.TeaModel {
    public var beginTime: String?

    public var endTime: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") {
            self.beginTime = dict["BeginTime"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeResourceTimelineResponseBody : Tea.TeaModel {
    public class AvailableEvents : Tea.TeaModel {
        public var name: String?

        public var occurrenceTime: String?

        public var reason: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OccurrenceTime") {
                self.occurrenceTime = dict["OccurrenceTime"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class BizEvents : Tea.TeaModel {
        public var name: String?

        public var occurrenceTime: String?

        public var reason: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OccurrenceTime") {
                self.occurrenceTime = dict["OccurrenceTime"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class InventoryEvents : Tea.TeaModel {
        public var name: String?

        public var occurrenceTime: String?

        public var reason: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OccurrenceTime") {
                self.occurrenceTime = dict["OccurrenceTime"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ReserveEvents : Tea.TeaModel {
        public var name: String?

        public var occurrenceTime: String?

        public var reason: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OccurrenceTime") {
                self.occurrenceTime = dict["OccurrenceTime"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var availableEvents: [DescribeResourceTimelineResponseBody.AvailableEvents]?

    public var bizEvents: [DescribeResourceTimelineResponseBody.BizEvents]?

    public var desc: String?

    public var inventoryEvents: [DescribeResourceTimelineResponseBody.InventoryEvents]?

    public var msg: String?

    public var requestId: String?

    public var reserveEvents: [DescribeResourceTimelineResponseBody.ReserveEvents]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableEvents != nil {
            var tmp : [Any] = []
            for k in self.availableEvents! {
                tmp.append(k.toMap())
            }
            map["AvailableEvents"] = tmp
        }
        if self.bizEvents != nil {
            var tmp : [Any] = []
            for k in self.bizEvents! {
                tmp.append(k.toMap())
            }
            map["BizEvents"] = tmp
        }
        if self.desc != nil {
            map["Desc"] = self.desc!
        }
        if self.inventoryEvents != nil {
            var tmp : [Any] = []
            for k in self.inventoryEvents! {
                tmp.append(k.toMap())
            }
            map["InventoryEvents"] = tmp
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reserveEvents != nil {
            var tmp : [Any] = []
            for k in self.reserveEvents! {
                tmp.append(k.toMap())
            }
            map["ReserveEvents"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableEvents") {
            var tmp : [DescribeResourceTimelineResponseBody.AvailableEvents] = []
            for v in dict["AvailableEvents"] as! [Any] {
                var model = DescribeResourceTimelineResponseBody.AvailableEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.availableEvents = tmp
        }
        if dict.keys.contains("BizEvents") {
            var tmp : [DescribeResourceTimelineResponseBody.BizEvents] = []
            for v in dict["BizEvents"] as! [Any] {
                var model = DescribeResourceTimelineResponseBody.BizEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bizEvents = tmp
        }
        if dict.keys.contains("Desc") {
            self.desc = dict["Desc"] as! String
        }
        if dict.keys.contains("InventoryEvents") {
            var tmp : [DescribeResourceTimelineResponseBody.InventoryEvents] = []
            for v in dict["InventoryEvents"] as! [Any] {
                var model = DescribeResourceTimelineResponseBody.InventoryEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.inventoryEvents = tmp
        }
        if dict.keys.contains("Msg") {
            self.msg = dict["Msg"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReserveEvents") {
            var tmp : [DescribeResourceTimelineResponseBody.ReserveEvents] = []
            for v in dict["ReserveEvents"] as! [Any] {
                var model = DescribeResourceTimelineResponseBody.ReserveEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.reserveEvents = tmp
        }
    }
}

public class DescribeResourceTimelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceTimelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceTimelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSDGRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SDGIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SDGIds != nil {
            map["SDGIds"] = self.SDGIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SDGIds") {
            self.SDGIds = dict["SDGIds"] as! [String]
        }
    }
}

public class DescribeSDGShrinkRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var SDGIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.SDGIdsShrink != nil {
            map["SDGIds"] = self.SDGIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SDGIds") {
            self.SDGIdsShrink = dict["SDGIds"] as! String
        }
    }
}

public class DescribeSDGResponseBody : Tea.TeaModel {
    public class SDGs : Tea.TeaModel {
        public class AvaliableRegionIds : Tea.TeaModel {
            public var creationTime: String?

            public var regionId: String?

            public var snapshotId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SnapshotId") {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class PreloadInfos : Tea.TeaModel {
            public var creationTime: String?

            public var namespace: String?

            public var redundantNum: Int32?

            public var regionId: String?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.redundantNum != nil {
                    map["RedundantNum"] = self.redundantNum!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Namespace") {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RedundantNum") {
                    self.redundantNum = dict["RedundantNum"] as! Int32
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
            }
        }
        public var avaliableRegionIds: [DescribeSDGResponseBody.SDGs.AvaliableRegionIds]?

        public var creationInstanceId: String?

        public var creationRegionId: String?

        public var creationTime: String?

        public var description_: String?

        public var parentSDGId: String?

        public var preloadInfos: [DescribeSDGResponseBody.SDGs.PreloadInfos]?

        public var SDGId: String?

        public var size: Int64?

        public var status: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avaliableRegionIds != nil {
                var tmp : [Any] = []
                for k in self.avaliableRegionIds! {
                    tmp.append(k.toMap())
                }
                map["AvaliableRegionIds"] = tmp
            }
            if self.creationInstanceId != nil {
                map["CreationInstanceId"] = self.creationInstanceId!
            }
            if self.creationRegionId != nil {
                map["CreationRegionId"] = self.creationRegionId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.parentSDGId != nil {
                map["ParentSDGId"] = self.parentSDGId!
            }
            if self.preloadInfos != nil {
                var tmp : [Any] = []
                for k in self.preloadInfos! {
                    tmp.append(k.toMap())
                }
                map["PreloadInfos"] = tmp
            }
            if self.SDGId != nil {
                map["SDGId"] = self.SDGId!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvaliableRegionIds") {
                var tmp : [DescribeSDGResponseBody.SDGs.AvaliableRegionIds] = []
                for v in dict["AvaliableRegionIds"] as! [Any] {
                    var model = DescribeSDGResponseBody.SDGs.AvaliableRegionIds()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.avaliableRegionIds = tmp
            }
            if dict.keys.contains("CreationInstanceId") {
                self.creationInstanceId = dict["CreationInstanceId"] as! String
            }
            if dict.keys.contains("CreationRegionId") {
                self.creationRegionId = dict["CreationRegionId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ParentSDGId") {
                self.parentSDGId = dict["ParentSDGId"] as! String
            }
            if dict.keys.contains("PreloadInfos") {
                var tmp : [DescribeSDGResponseBody.SDGs.PreloadInfos] = []
                for v in dict["PreloadInfos"] as! [Any] {
                    var model = DescribeSDGResponseBody.SDGs.PreloadInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.preloadInfos = tmp
            }
            if dict.keys.contains("SDGId") {
                self.SDGId = dict["SDGId"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var SDGs: [DescribeSDGResponseBody.SDGs]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SDGs != nil {
            var tmp : [Any] = []
            for k in self.SDGs! {
                tmp.append(k.toMap())
            }
            map["SDGs"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SDGs") {
            var tmp : [DescribeSDGResponseBody.SDGs] = []
            for v in dict["SDGs"] as! [Any] {
                var model = DescribeSDGResponseBody.SDGs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.SDGs = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSDGDeploymentStatusRequest : Tea.TeaModel {
    public var deploymentType: String?

    public var instanceIds: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionIds: [String]?

    public var SDGId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentType != nil {
            map["DeploymentType"] = self.deploymentType!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionIds != nil {
            map["RegionIds"] = self.regionIds!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentType") {
            self.deploymentType = dict["DeploymentType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionIds") {
            self.regionIds = dict["RegionIds"] as! [String]
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeSDGDeploymentStatusShrinkRequest : Tea.TeaModel {
    public var deploymentType: String?

    public var instanceIdsShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionIdsShrink: String?

    public var SDGId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentType != nil {
            map["DeploymentType"] = self.deploymentType!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionIdsShrink != nil {
            map["RegionIds"] = self.regionIdsShrink!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentType") {
            self.deploymentType = dict["DeploymentType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionIds") {
            self.regionIdsShrink = dict["RegionIds"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeSDGDeploymentStatusResponseBody : Tea.TeaModel {
    public class DeploymentStatus : Tea.TeaModel {
        public var instanceId: String?

        public var mountType: String?

        public var phase: String?

        public var regionId: String?

        public var status: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.mountType != nil {
                map["MountType"] = self.mountType!
            }
            if self.phase != nil {
                map["Phase"] = self.phase!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MountType") {
                self.mountType = dict["MountType"] as! String
            }
            if dict.keys.contains("Phase") {
                self.phase = dict["Phase"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var deploymentStatus: [DescribeSDGDeploymentStatusResponseBody.DeploymentStatus]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentStatus != nil {
            var tmp : [Any] = []
            for k in self.deploymentStatus! {
                tmp.append(k.toMap())
            }
            map["DeploymentStatus"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentStatus") {
            var tmp : [DescribeSDGDeploymentStatusResponseBody.DeploymentStatus] = []
            for v in dict["DeploymentStatus"] as! [Any] {
                var model = DescribeSDGDeploymentStatusResponseBody.DeploymentStatus()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.deploymentStatus = tmp
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeSDGDeploymentStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSDGDeploymentStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSDGDeploymentStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSDGsRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var SDGIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.SDGIds != nil {
            map["SDGIds"] = self.SDGIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("SDGIds") {
            self.SDGIds = dict["SDGIds"] as! [String]
        }
    }
}

public class DescribeSDGsShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public var SDGIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.SDGIdsShrink != nil {
            map["SDGIds"] = self.SDGIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("SDGIds") {
            self.SDGIdsShrink = dict["SDGIds"] as! String
        }
    }
}

public class DescribeSDGsResponseBody : Tea.TeaModel {
    public class SDGs : Tea.TeaModel {
        public class AvaliableRegionIds : Tea.TeaModel {
            public var creationTime: String?

            public var regionId: String?

            public var snapshotId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SnapshotId") {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class DeployedInstanceIds : Tea.TeaModel {
            public var creationTime: String?

            public var deploymentType: String?

            public var instanceId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deploymentType != nil {
                    map["DeploymentType"] = self.deploymentType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DeploymentType") {
                    self.deploymentType = dict["DeploymentType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var avaliableRegionIds: [DescribeSDGsResponseBody.SDGs.AvaliableRegionIds]?

        public var creationInstanceId: String?

        public var creationRegionId: String?

        public var creationTime: String?

        public var deployedInstanceIds: [DescribeSDGsResponseBody.SDGs.DeployedInstanceIds]?

        public var description_: String?

        public var parentSDGId: String?

        public var SDGId: String?

        public var size: Int64?

        public var status: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avaliableRegionIds != nil {
                var tmp : [Any] = []
                for k in self.avaliableRegionIds! {
                    tmp.append(k.toMap())
                }
                map["AvaliableRegionIds"] = tmp
            }
            if self.creationInstanceId != nil {
                map["CreationInstanceId"] = self.creationInstanceId!
            }
            if self.creationRegionId != nil {
                map["CreationRegionId"] = self.creationRegionId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deployedInstanceIds != nil {
                var tmp : [Any] = []
                for k in self.deployedInstanceIds! {
                    tmp.append(k.toMap())
                }
                map["DeployedInstanceIds"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.parentSDGId != nil {
                map["ParentSDGId"] = self.parentSDGId!
            }
            if self.SDGId != nil {
                map["SDGId"] = self.SDGId!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvaliableRegionIds") {
                var tmp : [DescribeSDGsResponseBody.SDGs.AvaliableRegionIds] = []
                for v in dict["AvaliableRegionIds"] as! [Any] {
                    var model = DescribeSDGsResponseBody.SDGs.AvaliableRegionIds()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.avaliableRegionIds = tmp
            }
            if dict.keys.contains("CreationInstanceId") {
                self.creationInstanceId = dict["CreationInstanceId"] as! String
            }
            if dict.keys.contains("CreationRegionId") {
                self.creationRegionId = dict["CreationRegionId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DeployedInstanceIds") {
                var tmp : [DescribeSDGsResponseBody.SDGs.DeployedInstanceIds] = []
                for v in dict["DeployedInstanceIds"] as! [Any] {
                    var model = DescribeSDGsResponseBody.SDGs.DeployedInstanceIds()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deployedInstanceIds = tmp
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ParentSDGId") {
                self.parentSDGId = dict["ParentSDGId"] as! String
            }
            if dict.keys.contains("SDGId") {
                self.SDGId = dict["SDGId"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var requestId: String?

    public var SDGs: [DescribeSDGsResponseBody.SDGs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SDGs != nil {
            var tmp : [Any] = []
            for k in self.SDGs! {
                tmp.append(k.toMap())
            }
            map["SDGs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SDGs") {
            var tmp : [DescribeSDGsResponseBody.SDGs] = []
            for v in dict["SDGs"] as! [Any] {
                var model = DescribeSDGsResponseBody.SDGs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.SDGs = tmp
        }
    }
}

public class DescribeSDGsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSDGsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSDGsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecondaryPublicIpAddressesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public var isp: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var secondaryPublicIpAddress: String?

    public var secondaryPublicIpId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.secondaryPublicIpAddress != nil {
            map["SecondaryPublicIpAddress"] = self.secondaryPublicIpAddress!
        }
        if self.secondaryPublicIpId != nil {
            map["SecondaryPublicIpId"] = self.secondaryPublicIpId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecondaryPublicIpAddress") {
            self.secondaryPublicIpAddress = dict["SecondaryPublicIpAddress"] as! String
        }
        if dict.keys.contains("SecondaryPublicIpId") {
            self.secondaryPublicIpId = dict["SecondaryPublicIpId"] as! String
        }
    }
}

public class DescribeSecondaryPublicIpAddressesResponseBody : Tea.TeaModel {
    public class SecondaryPublicIpAddresses : Tea.TeaModel {
        public var cidrMask: Int32?

        public var creationTime: String?

        public var ensRegionId: String?

        public var gateway: String?

        public var ipVersion: String?

        public var isp: String?

        public var secondaryPublicIpAddress: String?

        public var secondaryPublicIpId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrMask != nil {
                map["CidrMask"] = self.cidrMask!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.gateway != nil {
                map["Gateway"] = self.gateway!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.secondaryPublicIpAddress != nil {
                map["SecondaryPublicIpAddress"] = self.secondaryPublicIpAddress!
            }
            if self.secondaryPublicIpId != nil {
                map["SecondaryPublicIpId"] = self.secondaryPublicIpId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrMask") {
                self.cidrMask = dict["CidrMask"] as! Int32
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("Gateway") {
                self.gateway = dict["Gateway"] as! String
            }
            if dict.keys.contains("IpVersion") {
                self.ipVersion = dict["IpVersion"] as! String
            }
            if dict.keys.contains("Isp") {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("SecondaryPublicIpAddress") {
                self.secondaryPublicIpAddress = dict["SecondaryPublicIpAddress"] as! String
            }
            if dict.keys.contains("SecondaryPublicIpId") {
                self.secondaryPublicIpId = dict["SecondaryPublicIpId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var secondaryPublicIpAddresses: [DescribeSecondaryPublicIpAddressesResponseBody.SecondaryPublicIpAddresses]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.secondaryPublicIpAddresses != nil {
            var tmp : [Any] = []
            for k in self.secondaryPublicIpAddresses! {
                tmp.append(k.toMap())
            }
            map["SecondaryPublicIpAddresses"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecondaryPublicIpAddresses") {
            var tmp : [DescribeSecondaryPublicIpAddressesResponseBody.SecondaryPublicIpAddresses] = []
            for v in dict["SecondaryPublicIpAddresses"] as! [Any] {
                var model = DescribeSecondaryPublicIpAddressesResponseBody.SecondaryPublicIpAddresses()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.secondaryPublicIpAddresses = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSecondaryPublicIpAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecondaryPublicIpAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSecondaryPublicIpAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityGroupAttributeRequest : Tea.TeaModel {
    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class DescribeSecurityGroupAttributeResponseBody : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public class Permission : Tea.TeaModel {
            public var creationTime: String?

            public var description_: String?

            public var destCidrIp: String?

            public var direction: String?

            public var ipProtocol: String?

            public var policy: String?

            public var portRange: String?

            public var priority: Int32?

            public var sourceCidrIp: String?

            public var sourcePortRange: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.destCidrIp != nil {
                    map["DestCidrIp"] = self.destCidrIp!
                }
                if self.direction != nil {
                    map["Direction"] = self.direction!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.sourceCidrIp != nil {
                    map["SourceCidrIp"] = self.sourceCidrIp!
                }
                if self.sourcePortRange != nil {
                    map["SourcePortRange"] = self.sourcePortRange!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DestCidrIp") {
                    self.destCidrIp = dict["DestCidrIp"] as! String
                }
                if dict.keys.contains("Direction") {
                    self.direction = dict["Direction"] as! String
                }
                if dict.keys.contains("IpProtocol") {
                    self.ipProtocol = dict["IpProtocol"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("PortRange") {
                    self.portRange = dict["PortRange"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("SourceCidrIp") {
                    self.sourceCidrIp = dict["SourceCidrIp"] as! String
                }
                if dict.keys.contains("SourcePortRange") {
                    self.sourcePortRange = dict["SourcePortRange"] as! String
                }
            }
        }
        public var permission: [DescribeSecurityGroupAttributeResponseBody.Permissions.Permission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.permission != nil {
                var tmp : [Any] = []
                for k in self.permission! {
                    tmp.append(k.toMap())
                }
                map["Permission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Permission") {
                var tmp : [DescribeSecurityGroupAttributeResponseBody.Permissions.Permission] = []
                for v in dict["Permission"] as! [Any] {
                    var model = DescribeSecurityGroupAttributeResponseBody.Permissions.Permission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.permission = tmp
            }
        }
    }
    public var description_: String?

    public var permissions: DescribeSecurityGroupAttributeResponseBody.Permissions?

    public var requestId: String?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.permissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.permissions != nil {
            map["Permissions"] = self.permissions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Permissions") {
            var model = DescribeSecurityGroupAttributeResponseBody.Permissions()
            model.fromMap(dict["Permissions"] as! [String: Any])
            self.permissions = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class DescribeSecurityGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSecurityGroupAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityGroupsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class DescribeSecurityGroupsResponseBody : Tea.TeaModel {
    public class SecurityGroups : Tea.TeaModel {
        public class SecurityGroup : Tea.TeaModel {
            public class InstanceIds : Tea.TeaModel {
                public var instanceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! [String]
                    }
                }
            }
            public class NetworkInterfaceIds : Tea.TeaModel {
                public var networkInterfaceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkInterfaceId != nil {
                        map["NetworkInterfaceId"] = self.networkInterfaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NetworkInterfaceId") {
                        self.networkInterfaceId = dict["NetworkInterfaceId"] as! [String]
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var instanceCount: Int32?

            public var instanceIds: DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.InstanceIds?

            public var networkInterfaceIds: DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.NetworkInterfaceIds?

            public var securityGroupId: String?

            public var securityGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceIds?.validate()
                try self.networkInterfaceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.instanceIds != nil {
                    map["InstanceIds"] = self.instanceIds?.toMap()
                }
                if self.networkInterfaceIds != nil {
                    map["NetworkInterfaceIds"] = self.networkInterfaceIds?.toMap()
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.securityGroupName != nil {
                    map["SecurityGroupName"] = self.securityGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceCount") {
                    self.instanceCount = dict["InstanceCount"] as! Int32
                }
                if dict.keys.contains("InstanceIds") {
                    var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.InstanceIds()
                    model.fromMap(dict["InstanceIds"] as! [String: Any])
                    self.instanceIds = model
                }
                if dict.keys.contains("NetworkInterfaceIds") {
                    var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.NetworkInterfaceIds()
                    model.fromMap(dict["NetworkInterfaceIds"] as! [String: Any])
                    self.networkInterfaceIds = model
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("SecurityGroupName") {
                    self.securityGroupName = dict["SecurityGroupName"] as! String
                }
            }
        }
        public var securityGroup: [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroup != nil {
                var tmp : [Any] = []
                for k in self.securityGroup! {
                    tmp.append(k.toMap())
                }
                map["SecurityGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroup") {
                var tmp : [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup] = []
                for v in dict["SecurityGroup"] as! [Any] {
                    var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityGroup = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var securityGroups: DescribeSecurityGroupsResponseBody.SecurityGroups?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroups != nil {
            map["SecurityGroups"] = self.securityGroups?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroups") {
            var model = DescribeSecurityGroupsResponseBody.SecurityGroups()
            model.fromMap(dict["SecurityGroups"] as! [String: Any])
            self.securityGroups = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSecurityGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSecurityGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSelfImagesRequest : Tea.TeaModel {
    public var imageId: String?

    public var imageName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class DescribeSelfImagesResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public class DiskDeviceMappings : Tea.TeaModel {
                public class DiskDeviceMapping : Tea.TeaModel {
                    public var format: String?

                    public var size: String?

                    public var type: String?

                    public var imageId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.imageId != nil {
                            map["imageId"] = self.imageId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("imageId") {
                            self.imageId = dict["imageId"] as! String
                        }
                    }
                }
                public var diskDeviceMapping: [DescribeSelfImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskDeviceMapping != nil {
                        var tmp : [Any] = []
                        for k in self.diskDeviceMapping! {
                            tmp.append(k.toMap())
                        }
                        map["DiskDeviceMapping"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiskDeviceMapping") {
                        var tmp : [DescribeSelfImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping] = []
                        for v in dict["DiskDeviceMapping"] as! [Any] {
                            var model = DescribeSelfImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.diskDeviceMapping = tmp
                    }
                }
            }
            public var architecture: String?

            public var computeType: String?

            public var creationTime: String?

            public var diskDeviceMappings: DescribeSelfImagesResponseBody.Images.Image.DiskDeviceMappings?

            public var imageId: String?

            public var imageName: String?

            public var imageOwnerAlias: String?

            public var imageSize: String?

            public var imageStorageSize: String?

            public var instanceId: String?

            public var osVersion: String?

            public var platform: String?

            public var regionId: String?

            public var snapshotId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.diskDeviceMappings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architecture != nil {
                    map["Architecture"] = self.architecture!
                }
                if self.computeType != nil {
                    map["ComputeType"] = self.computeType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diskDeviceMappings != nil {
                    map["DiskDeviceMappings"] = self.diskDeviceMappings?.toMap()
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageOwnerAlias != nil {
                    map["ImageOwnerAlias"] = self.imageOwnerAlias!
                }
                if self.imageSize != nil {
                    map["ImageSize"] = self.imageSize!
                }
                if self.imageStorageSize != nil {
                    map["ImageStorageSize"] = self.imageStorageSize!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.osVersion != nil {
                    map["OsVersion"] = self.osVersion!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Architecture") {
                    self.architecture = dict["Architecture"] as! String
                }
                if dict.keys.contains("ComputeType") {
                    self.computeType = dict["ComputeType"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DiskDeviceMappings") {
                    var model = DescribeSelfImagesResponseBody.Images.Image.DiskDeviceMappings()
                    model.fromMap(dict["DiskDeviceMappings"] as! [String: Any])
                    self.diskDeviceMappings = model
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImageOwnerAlias") {
                    self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
                }
                if dict.keys.contains("ImageSize") {
                    self.imageSize = dict["ImageSize"] as! String
                }
                if dict.keys.contains("ImageStorageSize") {
                    self.imageStorageSize = dict["ImageStorageSize"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("OsVersion") {
                    self.osVersion = dict["OsVersion"] as! String
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SnapshotId") {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var image: [DescribeSelfImagesResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") {
                var tmp : [DescribeSelfImagesResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeSelfImagesResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public var code: Int32?

    public var images: DescribeSelfImagesResponseBody.Images?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Images") {
            var model = DescribeSelfImagesResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeSelfImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSelfImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSelfImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServcieScheduleRequest : Tea.TeaModel {
    public var appId: String?

    public var podConfigName: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.podConfigName != nil {
            map["PodConfigName"] = self.podConfigName!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("PodConfigName") {
            self.podConfigName = dict["PodConfigName"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeServcieScheduleResponseBody : Tea.TeaModel {
    public class PodAbstractInfo : Tea.TeaModel {
        public class ContainerStatuses : Tea.TeaModel {
            public class ContainerStatus : Tea.TeaModel {
                public var containerId: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.containerId != nil {
                        map["ContainerId"] = self.containerId!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContainerId") {
                        self.containerId = dict["ContainerId"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var containerStatus: [DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses.ContainerStatus]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.containerStatus != nil {
                    var tmp : [Any] = []
                    for k in self.containerStatus! {
                        tmp.append(k.toMap())
                    }
                    map["ContainerStatus"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContainerStatus") {
                    var tmp : [DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses.ContainerStatus] = []
                    for v in dict["ContainerStatus"] as! [Any] {
                        var model = DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses.ContainerStatus()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.containerStatus = tmp
                }
            }
        }
        public var containerService: Bool?

        public var containerStatuses: DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses?

        public var name: Bool?

        public var namespace: Bool?

        public var resourceScope: Bool?

        public var status: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.containerStatuses?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.containerService != nil {
                map["ContainerService"] = self.containerService!
            }
            if self.containerStatuses != nil {
                map["ContainerStatuses"] = self.containerStatuses?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.resourceScope != nil {
                map["ResourceScope"] = self.resourceScope!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContainerService") {
                self.containerService = dict["ContainerService"] as! Bool
            }
            if dict.keys.contains("ContainerStatuses") {
                var model = DescribeServcieScheduleResponseBody.PodAbstractInfo.ContainerStatuses()
                model.fromMap(dict["ContainerStatuses"] as! [String: Any])
                self.containerStatuses = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! Bool
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! Bool
            }
            if dict.keys.contains("ResourceScope") {
                self.resourceScope = dict["ResourceScope"] as! Bool
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Bool
            }
        }
    }
    public var index: Int32?

    public var instanceId: String?

    public var instanceIp: String?

    public var instancePort: Int32?

    public var podAbstractInfo: DescribeServcieScheduleResponseBody.PodAbstractInfo?

    public var requestId: String?

    public var requestRepeated: Bool?

    public var tcpPorts: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.podAbstractInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.index != nil {
            map["Index"] = self.index!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIp != nil {
            map["InstanceIp"] = self.instanceIp!
        }
        if self.instancePort != nil {
            map["InstancePort"] = self.instancePort!
        }
        if self.podAbstractInfo != nil {
            map["PodAbstractInfo"] = self.podAbstractInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestRepeated != nil {
            map["RequestRepeated"] = self.requestRepeated!
        }
        if self.tcpPorts != nil {
            map["TcpPorts"] = self.tcpPorts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Index") {
            self.index = dict["Index"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIp") {
            self.instanceIp = dict["InstanceIp"] as! String
        }
        if dict.keys.contains("InstancePort") {
            self.instancePort = dict["InstancePort"] as! Int32
        }
        if dict.keys.contains("PodAbstractInfo") {
            var model = DescribeServcieScheduleResponseBody.PodAbstractInfo()
            model.fromMap(dict["PodAbstractInfo"] as! [String: Any])
            self.podAbstractInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestRepeated") {
            self.requestRepeated = dict["RequestRepeated"] as! Bool
        }
        if dict.keys.contains("TcpPorts") {
            self.tcpPorts = dict["TcpPorts"] as! String
        }
    }
}

public class DescribeServcieScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServcieScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeServcieScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServerLoadBalancerListenMonitorRequest : Tea.TeaModel {
    public var endTime: String?

    public var loadBalancerId: String?

    public var proto: String?

    public var startTime: String?

    public var VPort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.proto != nil {
            map["Proto"] = self.proto!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.VPort != nil {
            map["VPort"] = self.VPort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("Proto") {
            self.proto = dict["Proto"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("VPort") {
            self.VPort = dict["VPort"] as! String
        }
    }
}

public class DescribeServerLoadBalancerListenMonitorResponseBody : Tea.TeaModel {
    public class ServerLoadBalancerMonitorData : Tea.TeaModel {
        public var acc: Int32?

        public var bizTime: String?

        public var ensRegionId: String?

        public var loadBalancerId: String?

        public var loadBalancerName: String?

        public var loadBalancerSpec: String?

        public var proto: String?

        public var reqs2xx: Int32?

        public var reqs3xx: Int32?

        public var reqs4xx: Int32?

        public var reqs5xx: Int32?

        public var rtAvg: Int32?

        public var vip: String?

        public var vni: Int32?

        public var vport: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acc != nil {
                map["Acc"] = self.acc!
            }
            if self.bizTime != nil {
                map["BizTime"] = self.bizTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.loadBalancerName != nil {
                map["LoadBalancerName"] = self.loadBalancerName!
            }
            if self.loadBalancerSpec != nil {
                map["LoadBalancerSpec"] = self.loadBalancerSpec!
            }
            if self.proto != nil {
                map["Proto"] = self.proto!
            }
            if self.reqs2xx != nil {
                map["Reqs2xx"] = self.reqs2xx!
            }
            if self.reqs3xx != nil {
                map["Reqs3xx"] = self.reqs3xx!
            }
            if self.reqs4xx != nil {
                map["Reqs4xx"] = self.reqs4xx!
            }
            if self.reqs5xx != nil {
                map["Reqs5xx"] = self.reqs5xx!
            }
            if self.rtAvg != nil {
                map["RtAvg"] = self.rtAvg!
            }
            if self.vip != nil {
                map["Vip"] = self.vip!
            }
            if self.vni != nil {
                map["Vni"] = self.vni!
            }
            if self.vport != nil {
                map["Vport"] = self.vport!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Acc") {
                self.acc = dict["Acc"] as! Int32
            }
            if dict.keys.contains("BizTime") {
                self.bizTime = dict["BizTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("LoadBalancerName") {
                self.loadBalancerName = dict["LoadBalancerName"] as! String
            }
            if dict.keys.contains("LoadBalancerSpec") {
                self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
            }
            if dict.keys.contains("Proto") {
                self.proto = dict["Proto"] as! String
            }
            if dict.keys.contains("Reqs2xx") {
                self.reqs2xx = dict["Reqs2xx"] as! Int32
            }
            if dict.keys.contains("Reqs3xx") {
                self.reqs3xx = dict["Reqs3xx"] as! Int32
            }
            if dict.keys.contains("Reqs4xx") {
                self.reqs4xx = dict["Reqs4xx"] as! Int32
            }
            if dict.keys.contains("Reqs5xx") {
                self.reqs5xx = dict["Reqs5xx"] as! Int32
            }
            if dict.keys.contains("RtAvg") {
                self.rtAvg = dict["RtAvg"] as! Int32
            }
            if dict.keys.contains("Vip") {
                self.vip = dict["Vip"] as! String
            }
            if dict.keys.contains("Vni") {
                self.vni = dict["Vni"] as! Int32
            }
            if dict.keys.contains("Vport") {
                self.vport = dict["Vport"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var serverLoadBalancerMonitorData: [DescribeServerLoadBalancerListenMonitorResponseBody.ServerLoadBalancerMonitorData]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serverLoadBalancerMonitorData != nil {
            var tmp : [Any] = []
            for k in self.serverLoadBalancerMonitorData! {
                tmp.append(k.toMap())
            }
            map["ServerLoadBalancerMonitorData"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServerLoadBalancerMonitorData") {
            var tmp : [DescribeServerLoadBalancerListenMonitorResponseBody.ServerLoadBalancerMonitorData] = []
            for v in dict["ServerLoadBalancerMonitorData"] as! [Any] {
                var model = DescribeServerLoadBalancerListenMonitorResponseBody.ServerLoadBalancerMonitorData()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serverLoadBalancerMonitorData = tmp
        }
    }
}

public class DescribeServerLoadBalancerListenMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServerLoadBalancerListenMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeServerLoadBalancerListenMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServerLoadBalancerMonitorRequest : Tea.TeaModel {
    public var endTime: String?

    public var loadBalancerId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeServerLoadBalancerMonitorResponseBody : Tea.TeaModel {
    public class ServerLoadBalancerMonitorData : Tea.TeaModel {
        public var acc: Int32?

        public var bizTime: String?

        public var ensRegionId: String?

        public var loadBalancerId: String?

        public var loadBalancerName: String?

        public var loadBalancerSpec: String?

        public var reqs2xx: Int32?

        public var reqs3xx: Int32?

        public var reqs4xx: Int32?

        public var reqs5xx: Int32?

        public var rtAvg: Int32?

        public var vip: String?

        public var vni: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acc != nil {
                map["Acc"] = self.acc!
            }
            if self.bizTime != nil {
                map["BizTime"] = self.bizTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            if self.loadBalancerName != nil {
                map["LoadBalancerName"] = self.loadBalancerName!
            }
            if self.loadBalancerSpec != nil {
                map["LoadBalancerSpec"] = self.loadBalancerSpec!
            }
            if self.reqs2xx != nil {
                map["Reqs2xx"] = self.reqs2xx!
            }
            if self.reqs3xx != nil {
                map["Reqs3xx"] = self.reqs3xx!
            }
            if self.reqs4xx != nil {
                map["Reqs4xx"] = self.reqs4xx!
            }
            if self.reqs5xx != nil {
                map["Reqs5xx"] = self.reqs5xx!
            }
            if self.rtAvg != nil {
                map["RtAvg"] = self.rtAvg!
            }
            if self.vip != nil {
                map["Vip"] = self.vip!
            }
            if self.vni != nil {
                map["Vni"] = self.vni!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Acc") {
                self.acc = dict["Acc"] as! Int32
            }
            if dict.keys.contains("BizTime") {
                self.bizTime = dict["BizTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! String
            }
            if dict.keys.contains("LoadBalancerName") {
                self.loadBalancerName = dict["LoadBalancerName"] as! String
            }
            if dict.keys.contains("LoadBalancerSpec") {
                self.loadBalancerSpec = dict["LoadBalancerSpec"] as! String
            }
            if dict.keys.contains("Reqs2xx") {
                self.reqs2xx = dict["Reqs2xx"] as! Int32
            }
            if dict.keys.contains("Reqs3xx") {
                self.reqs3xx = dict["Reqs3xx"] as! Int32
            }
            if dict.keys.contains("Reqs4xx") {
                self.reqs4xx = dict["Reqs4xx"] as! Int32
            }
            if dict.keys.contains("Reqs5xx") {
                self.reqs5xx = dict["Reqs5xx"] as! Int32
            }
            if dict.keys.contains("RtAvg") {
                self.rtAvg = dict["RtAvg"] as! Int32
            }
            if dict.keys.contains("Vip") {
                self.vip = dict["Vip"] as! String
            }
            if dict.keys.contains("Vni") {
                self.vni = dict["Vni"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var serverLoadBalancerMonitorData: [DescribeServerLoadBalancerMonitorResponseBody.ServerLoadBalancerMonitorData]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serverLoadBalancerMonitorData != nil {
            var tmp : [Any] = []
            for k in self.serverLoadBalancerMonitorData! {
                tmp.append(k.toMap())
            }
            map["ServerLoadBalancerMonitorData"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServerLoadBalancerMonitorData") {
            var tmp : [DescribeServerLoadBalancerMonitorResponseBody.ServerLoadBalancerMonitorData] = []
            for v in dict["ServerLoadBalancerMonitorData"] as! [Any] {
                var model = DescribeServerLoadBalancerMonitorResponseBody.ServerLoadBalancerMonitorData()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serverLoadBalancerMonitorData = tmp
        }
    }
}

public class DescribeServerLoadBalancerMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServerLoadBalancerMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeServerLoadBalancerMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotsRequest : Tea.TeaModel {
    public var diskId: String?

    public var ensRegionId: String?

    public var ensRegionIds: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var snapshotId: String?

    public var snapshotName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("SnapshotName") {
            self.snapshotName = dict["SnapshotName"] as! String
        }
    }
}

public class DescribeSnapshotsResponseBody : Tea.TeaModel {
    public class Snapshots : Tea.TeaModel {
        public var creationTime: String?

        public var description_: String?

        public var ensRegionId: String?

        public var size: String?

        public var snapshotId: String?

        public var snapshotName: String?

        public var sourceDiskCategory: String?

        public var sourceDiskId: String?

        public var sourceDiskType: String?

        public var sourceEnsRegionId: String?

        public var sourceSnapshotId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.snapshotName != nil {
                map["SnapshotName"] = self.snapshotName!
            }
            if self.sourceDiskCategory != nil {
                map["SourceDiskCategory"] = self.sourceDiskCategory!
            }
            if self.sourceDiskId != nil {
                map["SourceDiskId"] = self.sourceDiskId!
            }
            if self.sourceDiskType != nil {
                map["SourceDiskType"] = self.sourceDiskType!
            }
            if self.sourceEnsRegionId != nil {
                map["SourceEnsRegionId"] = self.sourceEnsRegionId!
            }
            if self.sourceSnapshotId != nil {
                map["SourceSnapshotId"] = self.sourceSnapshotId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
            if dict.keys.contains("SnapshotName") {
                self.snapshotName = dict["SnapshotName"] as! String
            }
            if dict.keys.contains("SourceDiskCategory") {
                self.sourceDiskCategory = dict["SourceDiskCategory"] as! String
            }
            if dict.keys.contains("SourceDiskId") {
                self.sourceDiskId = dict["SourceDiskId"] as! String
            }
            if dict.keys.contains("SourceDiskType") {
                self.sourceDiskType = dict["SourceDiskType"] as! String
            }
            if dict.keys.contains("SourceEnsRegionId") {
                self.sourceEnsRegionId = dict["SourceEnsRegionId"] as! String
            }
            if dict.keys.contains("SourceSnapshotId") {
                self.sourceSnapshotId = dict["SourceSnapshotId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snapshots: [DescribeSnapshotsResponseBody.Snapshots]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshots != nil {
            var tmp : [Any] = []
            for k in self.snapshots! {
                tmp.append(k.toMap())
            }
            map["Snapshots"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Snapshots") {
            var tmp : [DescribeSnapshotsResponseBody.Snapshots] = []
            for v in dict["Snapshots"] as! [Any] {
                var model = DescribeSnapshotsResponseBody.Snapshots()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.snapshots = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSnapshotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnapshotsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnatAttributeRequest : Tea.TeaModel {
    public var snatEntryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
    }
}

public class DescribeSnatAttributeResponseBody : Tea.TeaModel {
    public class SnatIps : Tea.TeaModel {
        public var creationTime: String?

        public var ip: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var creationTime: String?

    public var destCIDR: String?

    public var eipAffinity: Bool?

    public var idleTimeout: Int32?

    public var ispAffinity: Bool?

    public var natGatewayId: String?

    public var requestId: String?

    public var snatEntryId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public var snatIps: [DescribeSnatAttributeResponseBody.SnatIps]?

    public var sourceCIDR: String?

    public var standbySnatIp: String?

    public var standbyStatus: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.destCIDR != nil {
            map["DestCIDR"] = self.destCIDR!
        }
        if self.eipAffinity != nil {
            map["EipAffinity"] = self.eipAffinity!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.ispAffinity != nil {
            map["IspAffinity"] = self.ispAffinity!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.snatIps != nil {
            var tmp : [Any] = []
            for k in self.snatIps! {
                tmp.append(k.toMap())
            }
            map["SnatIps"] = tmp
        }
        if self.sourceCIDR != nil {
            map["SourceCIDR"] = self.sourceCIDR!
        }
        if self.standbySnatIp != nil {
            map["StandbySnatIp"] = self.standbySnatIp!
        }
        if self.standbyStatus != nil {
            map["StandbyStatus"] = self.standbyStatus!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("DestCIDR") {
            self.destCIDR = dict["DestCIDR"] as! String
        }
        if dict.keys.contains("EipAffinity") {
            self.eipAffinity = dict["EipAffinity"] as! Bool
        }
        if dict.keys.contains("IdleTimeout") {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("IspAffinity") {
            self.ispAffinity = dict["IspAffinity"] as! Bool
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatEntryName") {
            self.snatEntryName = dict["SnatEntryName"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
        if dict.keys.contains("SnatIps") {
            var tmp : [DescribeSnatAttributeResponseBody.SnatIps] = []
            for v in dict["SnatIps"] as! [Any] {
                var model = DescribeSnatAttributeResponseBody.SnatIps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.snatIps = tmp
        }
        if dict.keys.contains("SourceCIDR") {
            self.sourceCIDR = dict["SourceCIDR"] as! String
        }
        if dict.keys.contains("StandbySnatIp") {
            self.standbySnatIp = dict["StandbySnatIp"] as! String
        }
        if dict.keys.contains("StandbyStatus") {
            self.standbyStatus = dict["StandbyStatus"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeSnatAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnatAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnatAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnatTableEntriesRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var snatEntryId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public var snatIps: [String]?

    public var sourceCIDR: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        if self.snatIps != nil {
            map["SnatIps"] = self.snatIps!
        }
        if self.sourceCIDR != nil {
            map["SourceCIDR"] = self.sourceCIDR!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatEntryName") {
            self.snatEntryName = dict["SnatEntryName"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
        if dict.keys.contains("SnatIps") {
            self.snatIps = dict["SnatIps"] as! [String]
        }
        if dict.keys.contains("SourceCIDR") {
            self.sourceCIDR = dict["SourceCIDR"] as! String
        }
    }
}

public class DescribeSnatTableEntriesResponseBody : Tea.TeaModel {
    public class SnatTableEntries : Tea.TeaModel {
        public var eipAffinity: Bool?

        public var idleTimeout: Int32?

        public var ispAffinity: Bool?

        public var natGatewayId: String?

        public var snatEntryId: String?

        public var snatEntryName: String?

        public var snatIp: String?

        public var sourceCIDR: String?

        public var standbySnatIp: String?

        public var standbyStatus: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipAffinity != nil {
                map["EipAffinity"] = self.eipAffinity!
            }
            if self.idleTimeout != nil {
                map["IdleTimeout"] = self.idleTimeout!
            }
            if self.ispAffinity != nil {
                map["IspAffinity"] = self.ispAffinity!
            }
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            if self.snatEntryId != nil {
                map["SnatEntryId"] = self.snatEntryId!
            }
            if self.snatEntryName != nil {
                map["SnatEntryName"] = self.snatEntryName!
            }
            if self.snatIp != nil {
                map["SnatIp"] = self.snatIp!
            }
            if self.sourceCIDR != nil {
                map["SourceCIDR"] = self.sourceCIDR!
            }
            if self.standbySnatIp != nil {
                map["StandbySnatIp"] = self.standbySnatIp!
            }
            if self.standbyStatus != nil {
                map["StandbyStatus"] = self.standbyStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipAffinity") {
                self.eipAffinity = dict["EipAffinity"] as! Bool
            }
            if dict.keys.contains("IdleTimeout") {
                self.idleTimeout = dict["IdleTimeout"] as! Int32
            }
            if dict.keys.contains("IspAffinity") {
                self.ispAffinity = dict["IspAffinity"] as! Bool
            }
            if dict.keys.contains("NatGatewayId") {
                self.natGatewayId = dict["NatGatewayId"] as! String
            }
            if dict.keys.contains("SnatEntryId") {
                self.snatEntryId = dict["SnatEntryId"] as! String
            }
            if dict.keys.contains("SnatEntryName") {
                self.snatEntryName = dict["SnatEntryName"] as! String
            }
            if dict.keys.contains("SnatIp") {
                self.snatIp = dict["SnatIp"] as! String
            }
            if dict.keys.contains("SourceCIDR") {
                self.sourceCIDR = dict["SourceCIDR"] as! String
            }
            if dict.keys.contains("StandbySnatIp") {
                self.standbySnatIp = dict["StandbySnatIp"] as! String
            }
            if dict.keys.contains("StandbyStatus") {
                self.standbyStatus = dict["StandbyStatus"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snatTableEntries: [DescribeSnatTableEntriesResponseBody.SnatTableEntries]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snatTableEntries != nil {
            var tmp : [Any] = []
            for k in self.snatTableEntries! {
                tmp.append(k.toMap())
            }
            map["SnatTableEntries"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnatTableEntries") {
            var tmp : [DescribeSnatTableEntriesResponseBody.SnatTableEntries] = []
            for v in dict["SnatTableEntries"] as! [Any] {
                var model = DescribeSnatTableEntriesResponseBody.SnatTableEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.snatTableEntries = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSnatTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnatTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnatTableEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStorageGatewayRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var gatewayId: String?

    public var gatewayType: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.gatewayType != nil {
            map["GatewayType"] = self.gatewayType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! String
        }
        if dict.keys.contains("GatewayType") {
            self.gatewayType = dict["GatewayType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeStorageGatewayResponseBody : Tea.TeaModel {
    public class StorageGateways : Tea.TeaModel {
        public var cidrBlock: String?

        public var creationTime: String?

        public var description_: String?

        public var ensRegionId: String?

        public var serviceIp: String?

        public var status: String?

        public var storageGatewayId: String?

        public var storageGatewayName: String?

        public var storageGatewayType: Int32?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.serviceIp != nil {
                map["ServiceIp"] = self.serviceIp!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageGatewayId != nil {
                map["StorageGatewayId"] = self.storageGatewayId!
            }
            if self.storageGatewayName != nil {
                map["StorageGatewayName"] = self.storageGatewayName!
            }
            if self.storageGatewayType != nil {
                map["StorageGatewayType"] = self.storageGatewayType!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrBlock") {
                self.cidrBlock = dict["CidrBlock"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("ServiceIp") {
                self.serviceIp = dict["ServiceIp"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageGatewayId") {
                self.storageGatewayId = dict["StorageGatewayId"] as! String
            }
            if dict.keys.contains("StorageGatewayName") {
                self.storageGatewayName = dict["StorageGatewayName"] as! String
            }
            if dict.keys.contains("StorageGatewayType") {
                self.storageGatewayType = dict["StorageGatewayType"] as! Int32
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var storageGateways: [DescribeStorageGatewayResponseBody.StorageGateways]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageGateways != nil {
            var tmp : [Any] = []
            for k in self.storageGateways! {
                tmp.append(k.toMap())
            }
            map["StorageGateways"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageGateways") {
            var tmp : [DescribeStorageGatewayResponseBody.StorageGateways] = []
            for v in dict["StorageGateways"] as! [Any] {
                var model = DescribeStorageGatewayResponseBody.StorageGateways()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.storageGateways = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeStorageGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStorageGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStorageVolumeRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var gatewayId: String?

    public var isEnable: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var storageId: String?

    public var volumeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.isEnable != nil {
            map["IsEnable"] = self.isEnable!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.storageId != nil {
            map["StorageId"] = self.storageId!
        }
        if self.volumeId != nil {
            map["VolumeId"] = self.volumeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! String
        }
        if dict.keys.contains("IsEnable") {
            self.isEnable = dict["IsEnable"] as! Int32
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StorageId") {
            self.storageId = dict["StorageId"] as! String
        }
        if dict.keys.contains("VolumeId") {
            self.volumeId = dict["VolumeId"] as! String
        }
    }
}

public class DescribeStorageVolumeResponseBody : Tea.TeaModel {
    public class StorageVolumes : Tea.TeaModel {
        public var authProtocol: String?

        public var creationTime: String?

        public var description_: String?

        public var ensRegionId: String?

        public var isAuth: Int32?

        public var isEnable: Int32?

        public var status: String?

        public var storageGatewayId: String?

        public var storageId: String?

        public var storageVolumeId: String?

        public var storageVolumeName: String?

        public var targetName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authProtocol != nil {
                map["AuthProtocol"] = self.authProtocol!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.isAuth != nil {
                map["IsAuth"] = self.isAuth!
            }
            if self.isEnable != nil {
                map["IsEnable"] = self.isEnable!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageGatewayId != nil {
                map["StorageGatewayId"] = self.storageGatewayId!
            }
            if self.storageId != nil {
                map["StorageId"] = self.storageId!
            }
            if self.storageVolumeId != nil {
                map["StorageVolumeId"] = self.storageVolumeId!
            }
            if self.storageVolumeName != nil {
                map["StorageVolumeName"] = self.storageVolumeName!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthProtocol") {
                self.authProtocol = dict["AuthProtocol"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("IsAuth") {
                self.isAuth = dict["IsAuth"] as! Int32
            }
            if dict.keys.contains("IsEnable") {
                self.isEnable = dict["IsEnable"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageGatewayId") {
                self.storageGatewayId = dict["StorageGatewayId"] as! String
            }
            if dict.keys.contains("StorageId") {
                self.storageId = dict["StorageId"] as! String
            }
            if dict.keys.contains("StorageVolumeId") {
                self.storageVolumeId = dict["StorageVolumeId"] as! String
            }
            if dict.keys.contains("StorageVolumeName") {
                self.storageVolumeName = dict["StorageVolumeName"] as! String
            }
            if dict.keys.contains("TargetName") {
                self.targetName = dict["TargetName"] as! String
            }
        }
    }
    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var storageVolumes: [DescribeStorageVolumeResponseBody.StorageVolumes]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageVolumes != nil {
            var tmp : [Any] = []
            for k in self.storageVolumes! {
                tmp.append(k.toMap())
            }
            map["StorageVolumes"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageVolumes") {
            var tmp : [DescribeStorageVolumeResponseBody.StorageVolumes] = []
            for v in dict["StorageVolumes"] as! [Any] {
                var model = DescribeStorageVolumeResponseBody.StorageVolumes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.storageVolumes = tmp
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DescribeStorageVolumeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageVolumeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStorageVolumeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserBandWidthDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var ensRegionId: String?

    public var instanceId: String?

    public var isp: String?

    public var period: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeUserBandWidthDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class BandWidthMonitorData : Tea.TeaModel {
            public var downBandWidth: Int64?

            public var internetRX: Int64?

            public var internetTX: Int64?

            public var timeStamp: String?

            public var upBandWidth: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downBandWidth != nil {
                    map["DownBandWidth"] = self.downBandWidth!
                }
                if self.internetRX != nil {
                    map["InternetRX"] = self.internetRX!
                }
                if self.internetTX != nil {
                    map["InternetTX"] = self.internetTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.upBandWidth != nil {
                    map["UpBandWidth"] = self.upBandWidth!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DownBandWidth") {
                    self.downBandWidth = dict["DownBandWidth"] as! Int64
                }
                if dict.keys.contains("InternetRX") {
                    self.internetRX = dict["InternetRX"] as! Int64
                }
                if dict.keys.contains("InternetTX") {
                    self.internetTX = dict["InternetTX"] as! Int64
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("UpBandWidth") {
                    self.upBandWidth = dict["UpBandWidth"] as! Int64
                }
            }
        }
        public var bandWidthMonitorData: [DescribeUserBandWidthDataResponseBody.MonitorData.BandWidthMonitorData]?

        public var maxDownBandWidth: String?

        public var maxUpBandWidth: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandWidthMonitorData != nil {
                var tmp : [Any] = []
                for k in self.bandWidthMonitorData! {
                    tmp.append(k.toMap())
                }
                map["BandWidthMonitorData"] = tmp
            }
            if self.maxDownBandWidth != nil {
                map["MaxDownBandWidth"] = self.maxDownBandWidth!
            }
            if self.maxUpBandWidth != nil {
                map["MaxUpBandWidth"] = self.maxUpBandWidth!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BandWidthMonitorData") {
                var tmp : [DescribeUserBandWidthDataResponseBody.MonitorData.BandWidthMonitorData] = []
                for v in dict["BandWidthMonitorData"] as! [Any] {
                    var model = DescribeUserBandWidthDataResponseBody.MonitorData.BandWidthMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bandWidthMonitorData = tmp
            }
            if dict.keys.contains("MaxDownBandWidth") {
                self.maxDownBandWidth = dict["MaxDownBandWidth"] as! String
            }
            if dict.keys.contains("MaxUpBandWidth") {
                self.maxUpBandWidth = dict["MaxUpBandWidth"] as! String
            }
        }
    }
    public var code: Int32?

    public var monitorData: DescribeUserBandWidthDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("MonitorData") {
            var model = DescribeUserBandWidthDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUserBandWidthDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserBandWidthDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUserBandWidthDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVSwitchAttributesRequest : Tea.TeaModel {
    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DescribeVSwitchAttributesResponseBody : Tea.TeaModel {
    public class HaVipIds : Tea.TeaModel {
        public var haVipId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.haVipId != nil {
                map["HaVipId"] = self.haVipId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HaVipId") {
                self.haVipId = dict["HaVipId"] as! [String]
            }
        }
    }
    public class InstanceIds : Tea.TeaModel {
        public var instanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! [String]
            }
        }
    }
    public class LoadBalancerIds : Tea.TeaModel {
        public var loadBalancerId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loadBalancerId != nil {
                map["LoadBalancerId"] = self.loadBalancerId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoadBalancerId") {
                self.loadBalancerId = dict["LoadBalancerId"] as! [String]
            }
        }
    }
    public class NatGatewayIds : Tea.TeaModel {
        public var natGatewayId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natGatewayId != nil {
                map["NatGatewayId"] = self.natGatewayId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NatGatewayId") {
                self.natGatewayId = dict["NatGatewayId"] as! [String]
            }
        }
    }
    public class NetworkInterfaceIds : Tea.TeaModel {
        public var networkInterfaceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceId") {
                self.networkInterfaceId = dict["NetworkInterfaceId"] as! [String]
            }
        }
    }
    public var availableIpAddressCount: Int64?

    public var cidrBlock: String?

    public var createdTime: String?

    public var description_: String?

    public var ensRegionId: String?

    public var haVipIds: DescribeVSwitchAttributesResponseBody.HaVipIds?

    public var instanceIds: DescribeVSwitchAttributesResponseBody.InstanceIds?

    public var loadBalancerIds: DescribeVSwitchAttributesResponseBody.LoadBalancerIds?

    public var natGatewayIds: DescribeVSwitchAttributesResponseBody.NatGatewayIds?

    public var networkId: String?

    public var networkInterfaceIds: DescribeVSwitchAttributesResponseBody.NetworkInterfaceIds?

    public var requestId: String?

    public var status: String?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.haVipIds?.validate()
        try self.instanceIds?.validate()
        try self.loadBalancerIds?.validate()
        try self.natGatewayIds?.validate()
        try self.networkInterfaceIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableIpAddressCount != nil {
            map["AvailableIpAddressCount"] = self.availableIpAddressCount!
        }
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.haVipIds != nil {
            map["HaVipIds"] = self.haVipIds?.toMap()
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds?.toMap()
        }
        if self.loadBalancerIds != nil {
            map["LoadBalancerIds"] = self.loadBalancerIds?.toMap()
        }
        if self.natGatewayIds != nil {
            map["NatGatewayIds"] = self.natGatewayIds?.toMap()
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.networkInterfaceIds != nil {
            map["NetworkInterfaceIds"] = self.networkInterfaceIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableIpAddressCount") {
            self.availableIpAddressCount = dict["AvailableIpAddressCount"] as! Int64
        }
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("HaVipIds") {
            var model = DescribeVSwitchAttributesResponseBody.HaVipIds()
            model.fromMap(dict["HaVipIds"] as! [String: Any])
            self.haVipIds = model
        }
        if dict.keys.contains("InstanceIds") {
            var model = DescribeVSwitchAttributesResponseBody.InstanceIds()
            model.fromMap(dict["InstanceIds"] as! [String: Any])
            self.instanceIds = model
        }
        if dict.keys.contains("LoadBalancerIds") {
            var model = DescribeVSwitchAttributesResponseBody.LoadBalancerIds()
            model.fromMap(dict["LoadBalancerIds"] as! [String: Any])
            self.loadBalancerIds = model
        }
        if dict.keys.contains("NatGatewayIds") {
            var model = DescribeVSwitchAttributesResponseBody.NatGatewayIds()
            model.fromMap(dict["NatGatewayIds"] as! [String: Any])
            self.natGatewayIds = model
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceIds") {
            var model = DescribeVSwitchAttributesResponseBody.NetworkInterfaceIds()
            model.fromMap(dict["NetworkInterfaceIds"] as! [String: Any])
            self.networkInterfaceIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
    }
}

public class DescribeVSwitchAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVSwitchAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVSwitchesRequest : Tea.TeaModel {
    public var ensRegionId: String?

    public var ensRegionIds: [String]?

    public var networkId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var vSwitchId: String?

    public var vSwitchIds: [String]?

    public var vSwitchName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.ensRegionIds != nil {
            map["EnsRegionIds"] = self.ensRegionIds!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("EnsRegionIds") {
            self.ensRegionIds = dict["EnsRegionIds"] as! [String]
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchIds") {
            self.vSwitchIds = dict["VSwitchIds"] as! [String]
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
    }
}

public class DescribeVSwitchesResponseBody : Tea.TeaModel {
    public class VSwitches : Tea.TeaModel {
        public class VSwitch : Tea.TeaModel {
            public var cidrBlock: String?

            public var createdTime: String?

            public var description_: String?

            public var ensRegionId: String?

            public var freeIpCount: Int64?

            public var networkId: String?

            public var status: String?

            public var vSwitchId: String?

            public var vSwitchName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ensRegionId != nil {
                    map["EnsRegionId"] = self.ensRegionId!
                }
                if self.freeIpCount != nil {
                    map["FreeIpCount"] = self.freeIpCount!
                }
                if self.networkId != nil {
                    map["NetworkId"] = self.networkId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vSwitchName != nil {
                    map["VSwitchName"] = self.vSwitchName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnsRegionId") {
                    self.ensRegionId = dict["EnsRegionId"] as! String
                }
                if dict.keys.contains("FreeIpCount") {
                    self.freeIpCount = dict["FreeIpCount"] as! Int64
                }
                if dict.keys.contains("NetworkId") {
                    self.networkId = dict["NetworkId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VSwitchName") {
                    self.vSwitchName = dict["VSwitchName"] as! String
                }
            }
        }
        public var vSwitch: [DescribeVSwitchesResponseBody.VSwitches.VSwitch]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitch != nil {
                var tmp : [Any] = []
                for k in self.vSwitch! {
                    tmp.append(k.toMap())
                }
                map["VSwitch"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VSwitch") {
                var tmp : [DescribeVSwitchesResponseBody.VSwitches.VSwitch] = []
                for v in dict["VSwitch"] as! [Any] {
                    var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vSwitch = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vSwitches: DescribeVSwitchesResponseBody.VSwitches?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vSwitches?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vSwitches != nil {
            map["VSwitches"] = self.vSwitches?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VSwitches") {
            var model = DescribeVSwitchesResponseBody.VSwitches()
            model.fromMap(dict["VSwitches"] as! [String: Any])
            self.vSwitches = model
        }
    }
}

public class DescribeVSwitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVSwitchesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DetachDiskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachInstanceSDGRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class DetachInstanceSDGShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class DetachInstanceSDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var errMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMessage != nil {
                        map["ErrMessage"] = self.errMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMessage") {
                        self.errMessage = dict["ErrMessage"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [DetachInstanceSDGResponseBody.Data.Result.FailedItems]?

            public var successCount: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [DetachInstanceSDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = DetachInstanceSDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! String
                }
            }
        }
        public var message: String?

        public var result: DetachInstanceSDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = DetachInstanceSDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: DetachInstanceSDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DetachInstanceSDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachInstanceSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachInstanceSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachInstanceSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachNetworkInterfaceRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
    }
}

public class DetachNetworkInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachNetworkInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DistApplicationDataRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var distStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.distStrategy != nil {
            map["DistStrategy"] = self.distStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DistStrategy") {
            self.distStrategy = dict["DistStrategy"] as! String
        }
    }
}

public class DistApplicationDataResponseBody : Tea.TeaModel {
    public class DistInstanceIds : Tea.TeaModel {
        public var distInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.distInstanceId != nil {
                map["DistInstanceId"] = self.distInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DistInstanceId") {
                self.distInstanceId = dict["DistInstanceId"] as! [String]
            }
        }
    }
    public class DistResults : Tea.TeaModel {
        public class DistResult : Tea.TeaModel {
            public var name: String?

            public var resultCode: Int32?

            public var resultDescrip: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.resultCode != nil {
                    map["ResultCode"] = self.resultCode!
                }
                if self.resultDescrip != nil {
                    map["ResultDescrip"] = self.resultDescrip!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ResultCode") {
                    self.resultCode = dict["ResultCode"] as! Int32
                }
                if dict.keys.contains("ResultDescrip") {
                    self.resultDescrip = dict["ResultDescrip"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var distResult: [DistApplicationDataResponseBody.DistResults.DistResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.distResult != nil {
                var tmp : [Any] = []
                for k in self.distResult! {
                    tmp.append(k.toMap())
                }
                map["DistResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DistResult") {
                var tmp : [DistApplicationDataResponseBody.DistResults.DistResult] = []
                for v in dict["DistResult"] as! [Any] {
                    var model = DistApplicationDataResponseBody.DistResults.DistResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.distResult = tmp
            }
        }
    }
    public var distInstanceIds: DistApplicationDataResponseBody.DistInstanceIds?

    public var distInstanceTotalCount: Int32?

    public var distResults: DistApplicationDataResponseBody.DistResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.distInstanceIds?.validate()
        try self.distResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.distInstanceIds != nil {
            map["DistInstanceIds"] = self.distInstanceIds?.toMap()
        }
        if self.distInstanceTotalCount != nil {
            map["DistInstanceTotalCount"] = self.distInstanceTotalCount!
        }
        if self.distResults != nil {
            map["DistResults"] = self.distResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DistInstanceIds") {
            var model = DistApplicationDataResponseBody.DistInstanceIds()
            model.fromMap(dict["DistInstanceIds"] as! [String: Any])
            self.distInstanceIds = model
        }
        if dict.keys.contains("DistInstanceTotalCount") {
            self.distInstanceTotalCount = dict["DistInstanceTotalCount"] as! Int32
        }
        if dict.keys.contains("DistResults") {
            var model = DistApplicationDataResponseBody.DistResults()
            model.fromMap(dict["DistResults"] as! [String: Any])
            self.distResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DistApplicationDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DistApplicationDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DistApplicationDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportBillDetailDataRequest : Tea.TeaModel {
    public var endDate: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class ExportBillDetailDataResponseBody : Tea.TeaModel {
    public var filePath: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportBillDetailDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportBillDetailDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportBillDetailDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportImageRequest : Tea.TeaModel {
    public var imageId: String?

    public var OSSBucket: String?

    public var OSSPrefix: String?

    public var OSSRegionId: String?

    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.OSSBucket != nil {
            map["OSSBucket"] = self.OSSBucket!
        }
        if self.OSSPrefix != nil {
            map["OSSPrefix"] = self.OSSPrefix!
        }
        if self.OSSRegionId != nil {
            map["OSSRegionId"] = self.OSSRegionId!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OSSBucket") {
            self.OSSBucket = dict["OSSBucket"] as! String
        }
        if dict.keys.contains("OSSPrefix") {
            self.OSSPrefix = dict["OSSPrefix"] as! String
        }
        if dict.keys.contains("OSSRegionId") {
            self.OSSRegionId = dict["OSSRegionId"] as! String
        }
        if dict.keys.contains("RoleName") {
            self.roleName = dict["RoleName"] as! String
        }
    }
}

public class ExportImageResponseBody : Tea.TeaModel {
    public var exportedImageURL: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportedImageURL != nil {
            map["ExportedImageURL"] = self.exportedImageURL!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportedImageURL") {
            self.exportedImageURL = dict["ExportedImageURL"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportMeasurementDataRequest : Tea.TeaModel {
    public var endDate: String?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["EndDate"] = self.endDate!
        }
        if self.startDate != nil {
            map["StartDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndDate") {
            self.endDate = dict["EndDate"] as! String
        }
        if dict.keys.contains("StartDate") {
            self.startDate = dict["StartDate"] as! String
        }
    }
}

public class ExportMeasurementDataResponseBody : Tea.TeaModel {
    public var filePath: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportMeasurementDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportMeasurementDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportMeasurementDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBucketAclRequest : Tea.TeaModel {
    public var bucketName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
    }
}

public class GetBucketAclResponseBody : Tea.TeaModel {
    public var bucketAcl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketAcl != nil {
            map["BucketAcl"] = self.bucketAcl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketAcl") {
            self.bucketAcl = dict["BucketAcl"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetBucketAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBucketAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBucketAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBucketInfoRequest : Tea.TeaModel {
    public var bucketName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
    }
}

public class GetBucketInfoResponseBody : Tea.TeaModel {
    public class BucketInfo : Tea.TeaModel {
        public var bucketAcl: String?

        public var bucketName: String?

        public var comment: String?

        public var createTime: String?

        public var logicalBucketType: String?

        public var modifyTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucketAcl != nil {
                map["BucketAcl"] = self.bucketAcl!
            }
            if self.bucketName != nil {
                map["BucketName"] = self.bucketName!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.logicalBucketType != nil {
                map["LogicalBucketType"] = self.logicalBucketType!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BucketAcl") {
                self.bucketAcl = dict["BucketAcl"] as! String
            }
            if dict.keys.contains("BucketName") {
                self.bucketName = dict["BucketName"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("LogicalBucketType") {
                self.logicalBucketType = dict["LogicalBucketType"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
        }
    }
    public var bucketInfo: GetBucketInfoResponseBody.BucketInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bucketInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketInfo != nil {
            map["BucketInfo"] = self.bucketInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketInfo") {
            var model = GetBucketInfoResponseBody.BucketInfo()
            model.fromMap(dict["BucketInfo"] as! [String: Any])
            self.bucketInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetBucketInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBucketInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBucketInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBucketLifecycleRequest : Tea.TeaModel {
    public var bucketName: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class GetBucketLifecycleResponseBody : Tea.TeaModel {
    public class Rule : Tea.TeaModel {
        public class Expiration : Tea.TeaModel {
            public var createdBeforeDate: String?

            public var days: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdBeforeDate != nil {
                    map["CreatedBeforeDate"] = self.createdBeforeDate!
                }
                if self.days != nil {
                    map["Days"] = self.days!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedBeforeDate") {
                    self.createdBeforeDate = dict["CreatedBeforeDate"] as! String
                }
                if dict.keys.contains("Days") {
                    self.days = dict["Days"] as! String
                }
            }
        }
        public var expiration: GetBucketLifecycleResponseBody.Rule.Expiration?

        public var ID: String?

        public var prefix_: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.expiration?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expiration != nil {
                map["Expiration"] = self.expiration?.toMap()
            }
            if self.ID != nil {
                map["ID"] = self.ID!
            }
            if self.prefix_ != nil {
                map["Prefix"] = self.prefix_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Expiration") {
                var model = GetBucketLifecycleResponseBody.Rule.Expiration()
                model.fromMap(dict["Expiration"] as! [String: Any])
                self.expiration = model
            }
            if dict.keys.contains("ID") {
                self.ID = dict["ID"] as! String
            }
            if dict.keys.contains("Prefix") {
                self.prefix_ = dict["Prefix"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var requestId: String?

    public var rule: [GetBucketLifecycleResponseBody.Rule]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rule != nil {
            var tmp : [Any] = []
            for k in self.rule! {
                tmp.append(k.toMap())
            }
            map["Rule"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Rule") {
            var tmp : [GetBucketLifecycleResponseBody.Rule] = []
            for v in dict["Rule"] as! [Any] {
                var model = GetBucketLifecycleResponseBody.Rule()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.rule = tmp
        }
    }
}

public class GetBucketLifecycleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBucketLifecycleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBucketLifecycleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOssStorageAndAccByBucketsRequest : Tea.TeaModel {
    public var bucketList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketList != nil {
            map["BucketList"] = self.bucketList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketList") {
            self.bucketList = dict["BucketList"] as! String
        }
    }
}

public class GetOssStorageAndAccByBucketsResponseBody : Tea.TeaModel {
    public class BucketList : Tea.TeaModel {
        public var acc: Int64?

        public var bucket: String?

        public var storageUsageByte: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acc != nil {
                map["Acc"] = self.acc!
            }
            if self.bucket != nil {
                map["Bucket"] = self.bucket!
            }
            if self.storageUsageByte != nil {
                map["StorageUsageByte"] = self.storageUsageByte!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Acc") {
                self.acc = dict["Acc"] as! Int64
            }
            if dict.keys.contains("Bucket") {
                self.bucket = dict["Bucket"] as! String
            }
            if dict.keys.contains("StorageUsageByte") {
                self.storageUsageByte = dict["StorageUsageByte"] as! Int64
            }
        }
    }
    public var bucketList: [GetOssStorageAndAccByBucketsResponseBody.BucketList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketList != nil {
            var tmp : [Any] = []
            for k in self.bucketList! {
                tmp.append(k.toMap())
            }
            map["BucketList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketList") {
            var tmp : [GetOssStorageAndAccByBucketsResponseBody.BucketList] = []
            for v in dict["BucketList"] as! [Any] {
                var model = GetOssStorageAndAccByBucketsResponseBody.BucketList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bucketList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetOssStorageAndAccByBucketsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOssStorageAndAccByBucketsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOssStorageAndAccByBucketsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOssUsageDataRequest : Tea.TeaModel {
    public var bucket: String?

    public var endTime: String?

    public var period: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetOssUsageDataResponseBody : Tea.TeaModel {
    public class UsageList : Tea.TeaModel {
        public var lanRxBw: Int64?

        public var lanTxBw: Int64?

        public var point: Int64?

        public var pointTs: String?

        public var storageUsageByte: Int64?

        public var wanRxBw: Int64?

        public var wanTxBw: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lanRxBw != nil {
                map["LanRxBw"] = self.lanRxBw!
            }
            if self.lanTxBw != nil {
                map["LanTxBw"] = self.lanTxBw!
            }
            if self.point != nil {
                map["Point"] = self.point!
            }
            if self.pointTs != nil {
                map["PointTs"] = self.pointTs!
            }
            if self.storageUsageByte != nil {
                map["StorageUsageByte"] = self.storageUsageByte!
            }
            if self.wanRxBw != nil {
                map["WanRxBw"] = self.wanRxBw!
            }
            if self.wanTxBw != nil {
                map["WanTxBw"] = self.wanTxBw!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LanRxBw") {
                self.lanRxBw = dict["LanRxBw"] as! Int64
            }
            if dict.keys.contains("LanTxBw") {
                self.lanTxBw = dict["LanTxBw"] as! Int64
            }
            if dict.keys.contains("Point") {
                self.point = dict["Point"] as! Int64
            }
            if dict.keys.contains("PointTs") {
                self.pointTs = dict["PointTs"] as! String
            }
            if dict.keys.contains("StorageUsageByte") {
                self.storageUsageByte = dict["StorageUsageByte"] as! Int64
            }
            if dict.keys.contains("WanRxBw") {
                self.wanRxBw = dict["WanRxBw"] as! Int64
            }
            if dict.keys.contains("WanTxBw") {
                self.wanTxBw = dict["WanTxBw"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var usageList: [GetOssUsageDataResponseBody.UsageList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.usageList != nil {
            var tmp : [Any] = []
            for k in self.usageList! {
                tmp.append(k.toMap())
            }
            map["UsageList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UsageList") {
            var tmp : [GetOssUsageDataResponseBody.UsageList] = []
            for v in dict["UsageList"] as! [Any] {
                var model = GetOssUsageDataResponseBody.UsageList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.usageList = tmp
        }
    }
}

public class GetOssUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOssUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOssUsageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportImageRequest : Tea.TeaModel {
    public class DiskDeviceMapping : Tea.TeaModel {
        public var OSSBucket: String?

        public var OSSObject: String?

        public var OSSRegion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.OSSBucket != nil {
                map["OSSBucket"] = self.OSSBucket!
            }
            if self.OSSObject != nil {
                map["OSSObject"] = self.OSSObject!
            }
            if self.OSSRegion != nil {
                map["OSSRegion"] = self.OSSRegion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OSSBucket") {
                self.OSSBucket = dict["OSSBucket"] as! String
            }
            if dict.keys.contains("OSSObject") {
                self.OSSObject = dict["OSSObject"] as! String
            }
            if dict.keys.contains("OSSRegion") {
                self.OSSRegion = dict["OSSRegion"] as! String
            }
        }
    }
    public var architecture: String?

    public var computeType: String?

    public var diskDeviceMapping: [ImportImageRequest.DiskDeviceMapping]?

    public var imageFormat: String?

    public var imageName: String?

    public var OSSBucket: String?

    public var OSSObject: String?

    public var OSSRegion: String?

    public var OSType: String?

    public var OSVersion: String?

    public var platform: String?

    public var targetOSSRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.computeType != nil {
            map["ComputeType"] = self.computeType!
        }
        if self.diskDeviceMapping != nil {
            var tmp : [Any] = []
            for k in self.diskDeviceMapping! {
                tmp.append(k.toMap())
            }
            map["DiskDeviceMapping"] = tmp
        }
        if self.imageFormat != nil {
            map["ImageFormat"] = self.imageFormat!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.OSSBucket != nil {
            map["OSSBucket"] = self.OSSBucket!
        }
        if self.OSSObject != nil {
            map["OSSObject"] = self.OSSObject!
        }
        if self.OSSRegion != nil {
            map["OSSRegion"] = self.OSSRegion!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.OSVersion != nil {
            map["OSVersion"] = self.OSVersion!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.targetOSSRegionId != nil {
            map["TargetOSSRegionId"] = self.targetOSSRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Architecture") {
            self.architecture = dict["Architecture"] as! String
        }
        if dict.keys.contains("ComputeType") {
            self.computeType = dict["ComputeType"] as! String
        }
        if dict.keys.contains("DiskDeviceMapping") {
            var tmp : [ImportImageRequest.DiskDeviceMapping] = []
            for v in dict["DiskDeviceMapping"] as! [Any] {
                var model = ImportImageRequest.DiskDeviceMapping()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.diskDeviceMapping = tmp
        }
        if dict.keys.contains("ImageFormat") {
            self.imageFormat = dict["ImageFormat"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("OSSBucket") {
            self.OSSBucket = dict["OSSBucket"] as! String
        }
        if dict.keys.contains("OSSObject") {
            self.OSSObject = dict["OSSObject"] as! String
        }
        if dict.keys.contains("OSSRegion") {
            self.OSSRegion = dict["OSSRegion"] as! String
        }
        if dict.keys.contains("OSType") {
            self.OSType = dict["OSType"] as! String
        }
        if dict.keys.contains("OSVersion") {
            self.OSVersion = dict["OSVersion"] as! String
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("TargetOSSRegionId") {
            self.targetOSSRegionId = dict["TargetOSSRegionId"] as! String
        }
    }
}

public class ImportImageShrinkRequest : Tea.TeaModel {
    public var architecture: String?

    public var computeType: String?

    public var diskDeviceMappingShrink: String?

    public var imageFormat: String?

    public var imageName: String?

    public var OSSBucket: String?

    public var OSSObject: String?

    public var OSSRegion: String?

    public var OSType: String?

    public var OSVersion: String?

    public var platform: String?

    public var targetOSSRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.computeType != nil {
            map["ComputeType"] = self.computeType!
        }
        if self.diskDeviceMappingShrink != nil {
            map["DiskDeviceMapping"] = self.diskDeviceMappingShrink!
        }
        if self.imageFormat != nil {
            map["ImageFormat"] = self.imageFormat!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.OSSBucket != nil {
            map["OSSBucket"] = self.OSSBucket!
        }
        if self.OSSObject != nil {
            map["OSSObject"] = self.OSSObject!
        }
        if self.OSSRegion != nil {
            map["OSSRegion"] = self.OSSRegion!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.OSVersion != nil {
            map["OSVersion"] = self.OSVersion!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.targetOSSRegionId != nil {
            map["TargetOSSRegionId"] = self.targetOSSRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Architecture") {
            self.architecture = dict["Architecture"] as! String
        }
        if dict.keys.contains("ComputeType") {
            self.computeType = dict["ComputeType"] as! String
        }
        if dict.keys.contains("DiskDeviceMapping") {
            self.diskDeviceMappingShrink = dict["DiskDeviceMapping"] as! String
        }
        if dict.keys.contains("ImageFormat") {
            self.imageFormat = dict["ImageFormat"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("OSSBucket") {
            self.OSSBucket = dict["OSSBucket"] as! String
        }
        if dict.keys.contains("OSSObject") {
            self.OSSObject = dict["OSSObject"] as! String
        }
        if dict.keys.contains("OSSRegion") {
            self.OSSRegion = dict["OSSRegion"] as! String
        }
        if dict.keys.contains("OSType") {
            self.OSType = dict["OSType"] as! String
        }
        if dict.keys.contains("OSVersion") {
            self.OSVersion = dict["OSVersion"] as! String
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("TargetOSSRegionId") {
            self.targetOSSRegionId = dict["TargetOSSRegionId"] as! String
        }
    }
}

public class ImportImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportKeyPairRequest : Tea.TeaModel {
    public var keyPairName: String?

    public var publicKeyBody: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.publicKeyBody != nil {
            map["PublicKeyBody"] = self.publicKeyBody!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("PublicKeyBody") {
            self.publicKeyBody = dict["PublicKeyBody"] as! String
        }
    }
}

public class ImportKeyPairResponseBody : Tea.TeaModel {
    public var keyPairFingerPrint: String?

    public var keyPairName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairFingerPrint") {
            self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportKeyPairResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinPublicIpsToEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var instanceInfos: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.instanceInfos != nil {
            map["InstanceInfos"] = self.instanceInfos!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("InstanceInfos") {
            self.instanceInfos = dict["InstanceInfos"] as! String
        }
    }
}

public class JoinPublicIpsToEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinPublicIpsToEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinPublicIpsToEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinPublicIpsToEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinSecurityGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkInterfaceId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class JoinSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinVSwitchesToEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var vSwitchesInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.vSwitchesInfo != nil {
            map["VSwitchesInfo"] = self.vSwitchesInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("VSwitchesInfo") {
            self.vSwitchesInfo = dict["VSwitchesInfo"] as! String
        }
    }
}

public class JoinVSwitchesToEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinVSwitchesToEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinVSwitchesToEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinVSwitchesToEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LeaveSecurityGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkInterfaceId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class LeaveSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class LeaveSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LeaveSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LeaveSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationsRequest : Tea.TeaModel {
    public var appVersions: String?

    public var clusterNames: String?

    public var level: String?

    public var maxDate: String?

    public var minDate: String?

    public var outAppInfoParams: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appVersions != nil {
            map["AppVersions"] = self.appVersions!
        }
        if self.clusterNames != nil {
            map["ClusterNames"] = self.clusterNames!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.maxDate != nil {
            map["MaxDate"] = self.maxDate!
        }
        if self.minDate != nil {
            map["MinDate"] = self.minDate!
        }
        if self.outAppInfoParams != nil {
            map["OutAppInfoParams"] = self.outAppInfoParams!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppVersions") {
            self.appVersions = dict["AppVersions"] as! String
        }
        if dict.keys.contains("ClusterNames") {
            self.clusterNames = dict["ClusterNames"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MaxDate") {
            self.maxDate = dict["MaxDate"] as! String
        }
        if dict.keys.contains("MinDate") {
            self.minDate = dict["MinDate"] as! String
        }
        if dict.keys.contains("OutAppInfoParams") {
            self.outAppInfoParams = dict["OutAppInfoParams"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListApplicationsResponseBody : Tea.TeaModel {
    public class Applications : Tea.TeaModel {
        public class Application : Tea.TeaModel {
            public class AppList : Tea.TeaModel {
                public class App : Tea.TeaModel {
                    public var appId: String?

                    public var appInfo: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.appId != nil {
                            map["AppId"] = self.appId!
                        }
                        if self.appInfo != nil {
                            map["AppInfo"] = self.appInfo!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AppId") {
                            self.appId = dict["AppId"] as! String
                        }
                        if dict.keys.contains("AppInfo") {
                            self.appInfo = dict["AppInfo"] as! String
                        }
                    }
                }
                public var app: [ListApplicationsResponseBody.Applications.Application.AppList.App]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.app != nil {
                        var tmp : [Any] = []
                        for k in self.app! {
                            tmp.append(k.toMap())
                        }
                        map["App"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("App") {
                        var tmp : [ListApplicationsResponseBody.Applications.Application.AppList.App] = []
                        for v in dict["App"] as! [Any] {
                            var model = ListApplicationsResponseBody.Applications.Application.AppList.App()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.app = tmp
                    }
                }
            }
            public var appList: ListApplicationsResponseBody.Applications.Application.AppList?

            public var clusterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.appList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appList != nil {
                    map["AppList"] = self.appList?.toMap()
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppList") {
                    var model = ListApplicationsResponseBody.Applications.Application.AppList()
                    model.fromMap(dict["AppList"] as! [String: Any])
                    self.appList = model
                }
                if dict.keys.contains("ClusterName") {
                    self.clusterName = dict["ClusterName"] as! String
                }
            }
        }
        public var application: [ListApplicationsResponseBody.Applications.Application]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.application != nil {
                var tmp : [Any] = []
                for k in self.application! {
                    tmp.append(k.toMap())
                }
                map["Application"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Application") {
                var tmp : [ListApplicationsResponseBody.Applications.Application] = []
                for v in dict["Application"] as! [Any] {
                    var model = ListApplicationsResponseBody.Applications.Application()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.application = tmp
            }
        }
    }
    public var applications: ListApplicationsResponseBody.Applications?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applications?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            map["Applications"] = self.applications?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Applications") {
            var model = ListApplicationsResponseBody.Applications()
            model.fromMap(dict["Applications"] as! [String: Any])
            self.applications = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBucketsRequest : Tea.TeaModel {
    public var pageNumber: String?

    public var pageSize: String?

    public var prefix_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.prefix_ != nil {
            map["Prefix"] = self.prefix_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Prefix") {
            self.prefix_ = dict["Prefix"] as! String
        }
    }
}

public class ListBucketsResponseBody : Tea.TeaModel {
    public class BucketInfos : Tea.TeaModel {
        public var bucketAcl: String?

        public var bucketName: String?

        public var comment: String?

        public var createTime: String?

        public var ensRegionId: String?

        public var logicalBucketType: String?

        public var modifyTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucketAcl != nil {
                map["BucketAcl"] = self.bucketAcl!
            }
            if self.bucketName != nil {
                map["BucketName"] = self.bucketName!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.ensRegionId != nil {
                map["EnsRegionId"] = self.ensRegionId!
            }
            if self.logicalBucketType != nil {
                map["LogicalBucketType"] = self.logicalBucketType!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BucketAcl") {
                self.bucketAcl = dict["BucketAcl"] as! String
            }
            if dict.keys.contains("BucketName") {
                self.bucketName = dict["BucketName"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EnsRegionId") {
                self.ensRegionId = dict["EnsRegionId"] as! String
            }
            if dict.keys.contains("LogicalBucketType") {
                self.logicalBucketType = dict["LogicalBucketType"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! String
            }
        }
    }
    public var bucketInfos: [ListBucketsResponseBody.BucketInfos]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketInfos != nil {
            var tmp : [Any] = []
            for k in self.bucketInfos! {
                tmp.append(k.toMap())
            }
            map["BucketInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketInfos") {
            var tmp : [ListBucketsResponseBody.BucketInfos] = []
            for v in dict["BucketInfos"] as! [Any] {
                var model = ListBucketsResponseBody.BucketInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bucketInfos = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListBucketsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBucketsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBucketsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListObjectsRequest : Tea.TeaModel {
    public var bucketName: String?

    public var continuationToken: String?

    public var encodingType: String?

    public var marker: String?

    public var maxKeys: Int64?

    public var prefix_: String?

    public var startAfter: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.continuationToken != nil {
            map["ContinuationToken"] = self.continuationToken!
        }
        if self.encodingType != nil {
            map["EncodingType"] = self.encodingType!
        }
        if self.marker != nil {
            map["Marker"] = self.marker!
        }
        if self.maxKeys != nil {
            map["MaxKeys"] = self.maxKeys!
        }
        if self.prefix_ != nil {
            map["Prefix"] = self.prefix_!
        }
        if self.startAfter != nil {
            map["StartAfter"] = self.startAfter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("ContinuationToken") {
            self.continuationToken = dict["ContinuationToken"] as! String
        }
        if dict.keys.contains("EncodingType") {
            self.encodingType = dict["EncodingType"] as! String
        }
        if dict.keys.contains("Marker") {
            self.marker = dict["Marker"] as! String
        }
        if dict.keys.contains("MaxKeys") {
            self.maxKeys = dict["MaxKeys"] as! Int64
        }
        if dict.keys.contains("Prefix") {
            self.prefix_ = dict["Prefix"] as! String
        }
        if dict.keys.contains("StartAfter") {
            self.startAfter = dict["StartAfter"] as! String
        }
    }
}

public class ListObjectsResponseBody : Tea.TeaModel {
    public class Contents : Tea.TeaModel {
        public var ETag: String?

        public var key: String?

        public var lastModified: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ETag != nil {
                map["ETag"] = self.ETag!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.lastModified != nil {
                map["LastModified"] = self.lastModified!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ETag") {
                self.ETag = dict["ETag"] as! String
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("LastModified") {
                self.lastModified = dict["LastModified"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
        }
    }
    public var bucketName: String?

    public var commonPrefixes: [String]?

    public var contents: [ListObjectsResponseBody.Contents]?

    public var continuationToken: String?

    public var delimiter: String?

    public var encodingType: String?

    public var isTruncated: Bool?

    public var keyCount: Int64?

    public var marker: String?

    public var maxKeys: Int64?

    public var nextContinuationToken: String?

    public var nextMarker: String?

    public var prefix_: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.commonPrefixes != nil {
            map["CommonPrefixes"] = self.commonPrefixes!
        }
        if self.contents != nil {
            var tmp : [Any] = []
            for k in self.contents! {
                tmp.append(k.toMap())
            }
            map["Contents"] = tmp
        }
        if self.continuationToken != nil {
            map["ContinuationToken"] = self.continuationToken!
        }
        if self.delimiter != nil {
            map["Delimiter"] = self.delimiter!
        }
        if self.encodingType != nil {
            map["EncodingType"] = self.encodingType!
        }
        if self.isTruncated != nil {
            map["IsTruncated"] = self.isTruncated!
        }
        if self.keyCount != nil {
            map["KeyCount"] = self.keyCount!
        }
        if self.marker != nil {
            map["Marker"] = self.marker!
        }
        if self.maxKeys != nil {
            map["MaxKeys"] = self.maxKeys!
        }
        if self.nextContinuationToken != nil {
            map["NextContinuationToken"] = self.nextContinuationToken!
        }
        if self.nextMarker != nil {
            map["NextMarker"] = self.nextMarker!
        }
        if self.prefix_ != nil {
            map["Prefix"] = self.prefix_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("CommonPrefixes") {
            self.commonPrefixes = dict["CommonPrefixes"] as! [String]
        }
        if dict.keys.contains("Contents") {
            var tmp : [ListObjectsResponseBody.Contents] = []
            for v in dict["Contents"] as! [Any] {
                var model = ListObjectsResponseBody.Contents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.contents = tmp
        }
        if dict.keys.contains("ContinuationToken") {
            self.continuationToken = dict["ContinuationToken"] as! String
        }
        if dict.keys.contains("Delimiter") {
            self.delimiter = dict["Delimiter"] as! String
        }
        if dict.keys.contains("EncodingType") {
            self.encodingType = dict["EncodingType"] as! String
        }
        if dict.keys.contains("IsTruncated") {
            self.isTruncated = dict["IsTruncated"] as! Bool
        }
        if dict.keys.contains("KeyCount") {
            self.keyCount = dict["KeyCount"] as! Int64
        }
        if dict.keys.contains("Marker") {
            self.marker = dict["Marker"] as! String
        }
        if dict.keys.contains("MaxKeys") {
            self.maxKeys = dict["MaxKeys"] as! Int64
        }
        if dict.keys.contains("NextContinuationToken") {
            self.nextContinuationToken = dict["NextContinuationToken"] as! String
        }
        if dict.keys.contains("NextMarker") {
            self.nextMarker = dict["NextMarker"] as! String
        }
        if dict.keys.contains("Prefix") {
            self.prefix_ = dict["Prefix"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListObjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListObjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListObjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProductAbilitiesResponseBody : Tea.TeaModel {
    public var productAbilities: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.productAbilities != nil {
            map["ProductAbilities"] = self.productAbilities!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProductAbilities") {
            self.productAbilities = dict["ProductAbilities"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListProductAbilitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProductAbilitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProductAbilitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var nextToken: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var tmp : [ListTagResourcesResponseBody.TagResources] = []
            for v in dict["TagResources"] as! [Any] {
                var model = ListTagResourcesResponseBody.TagResources()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagResources = tmp
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEnsEipAddressAttributeRequest : Tea.TeaModel {
    public var allocationId: String?

    public var bandwidth: Int32?

    public var description_: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class ModifyEnsEipAddressAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEnsEipAddressAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEnsEipAddressAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEnsEipAddressAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEnsRouteEntryRequest : Tea.TeaModel {
    public var description_: String?

    public var routeEntryId: String?

    public var routeEntryName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.routeEntryId != nil {
            map["RouteEntryId"] = self.routeEntryId!
        }
        if self.routeEntryName != nil {
            map["RouteEntryName"] = self.routeEntryName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RouteEntryId") {
            self.routeEntryId = dict["RouteEntryId"] as! String
        }
        if dict.keys.contains("RouteEntryName") {
            self.routeEntryName = dict["RouteEntryName"] as! String
        }
    }
}

public class ModifyEnsRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEnsRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEnsRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEnsRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var EPNInstanceName: String?

    public var internetMaxBandwidthOut: Int32?

    public var networkingModel: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.EPNInstanceName != nil {
            map["EPNInstanceName"] = self.EPNInstanceName!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.networkingModel != nil {
            map["NetworkingModel"] = self.networkingModel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("EPNInstanceName") {
            self.EPNInstanceName = dict["EPNInstanceName"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("NetworkingModel") {
            self.networkingModel = dict["NetworkingModel"] as! String
        }
    }
}

public class ModifyEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyFileSystemRequest : Tea.TeaModel {
    public var description_: String?

    public var ensRegionId: String?

    public var fileSystemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.fileSystemId != nil {
            map["FileSystemId"] = self.fileSystemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("FileSystemId") {
            self.fileSystemId = dict["FileSystemId"] as! String
        }
    }
}

public class ModifyFileSystemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyFileSystemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFileSystemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyFileSystemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyForwardEntryRequest : Tea.TeaModel {
    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryId: String?

    public var forwardEntryName: String?

    public var healthCheckPort: Int32?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardEntryName != nil {
            map["ForwardEntryName"] = self.forwardEntryName!
        }
        if self.healthCheckPort != nil {
            map["HealthCheckPort"] = self.healthCheckPort!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExternalIp") {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ExternalPort") {
            self.externalPort = dict["ExternalPort"] as! String
        }
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardEntryName") {
            self.forwardEntryName = dict["ForwardEntryName"] as! String
        }
        if dict.keys.contains("HealthCheckPort") {
            self.healthCheckPort = dict["HealthCheckPort"] as! Int32
        }
        if dict.keys.contains("InternalIp") {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("InternalPort") {
            self.internalPort = dict["InternalPort"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
    }
}

public class ModifyForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHaVipAttributeRequest : Tea.TeaModel {
    public var haVipId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class ModifyHaVipAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyHaVipAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHaVipAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyHaVipAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageAttributeRequest : Tea.TeaModel {
    public var imageId: String?

    public var imageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
    }
}

public class ModifyImageAttributeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyImageAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageSharePermissionRequest : Tea.TeaModel {
    public var addAccounts: String?

    public var imageId: String?

    public var removeAccounts: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addAccounts != nil {
            map["AddAccounts"] = self.addAccounts!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.removeAccounts != nil {
            map["RemoveAccounts"] = self.removeAccounts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddAccounts") {
            self.addAccounts = dict["AddAccounts"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RemoveAccounts") {
            self.removeAccounts = dict["RemoveAccounts"] as! String
        }
    }
}

public class ModifyImageSharePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageSharePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageSharePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyImageSharePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAttributeRequest : Tea.TeaModel {
    public var hostName: String?

    public var instanceId: String?

    public var instanceName: String?

    public var password: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var autoRenew: String?

    public var duration: String?

    public var instanceIds: String?

    public var ownerId: String?

    public var renewalStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("RenewalStatus") {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
    }
}

public class ModifyInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceBootConfigurationRequest : Tea.TeaModel {
    public var bootSet: String?

    public var bootType: String?

    public var diskSet: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bootSet != nil {
            map["BootSet"] = self.bootSet!
        }
        if self.bootType != nil {
            map["BootType"] = self.bootType!
        }
        if self.diskSet != nil {
            map["DiskSet"] = self.diskSet!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BootSet") {
            self.bootSet = dict["BootSet"] as! String
        }
        if dict.keys.contains("BootType") {
            self.bootType = dict["BootType"] as! String
        }
        if dict.keys.contains("DiskSet") {
            self.diskSet = dict["DiskSet"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ModifyInstanceBootConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceBootConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceBootConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceBootConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var includeDataDisks: Bool?

    public var instanceChargeType: String?

    public var instanceIds: [String]?

    public var period: String?

    public var periodUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.includeDataDisks != nil {
            map["IncludeDataDisks"] = self.includeDataDisks!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("IncludeDataDisks") {
            self.includeDataDisks = dict["IncludeDataDisks"] as! Bool
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
    }
}

public class ModifyInstanceChargeTypeShrinkRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var includeDataDisks: Bool?

    public var instanceChargeType: String?

    public var instanceIdsShrink: String?

    public var period: String?

    public var periodUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.includeDataDisks != nil {
            map["IncludeDataDisks"] = self.includeDataDisks!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("IncludeDataDisks") {
            self.includeDataDisks = dict["IncludeDataDisks"] as! Bool
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
    }
}

public class ModifyInstanceChargeTypeResponseBody : Tea.TeaModel {
    public var instanceIds: [String]?

    public var orderId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLoadBalancerAttributeRequest : Tea.TeaModel {
    public var loadBalancerId: String?

    public var loadBalancerName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerName != nil {
            map["LoadBalancerName"] = self.loadBalancerName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerName") {
            self.loadBalancerName = dict["LoadBalancerName"] as! String
        }
    }
}

public class ModifyLoadBalancerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLoadBalancerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLoadBalancerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyLoadBalancerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNetworkAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var networkId: String?

    public var networkName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.networkName != nil {
            map["NetworkName"] = self.networkName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("NetworkName") {
            self.networkName = dict["NetworkName"] as! String
        }
    }
}

public class ModifyNetworkAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNetworkAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNetworkAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNetworkAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNetworkInterfaceAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var networkInterfaceId: String?

    public var networkInterfaceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceName") {
            self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
        }
    }
}

public class ModifyNetworkInterfaceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNetworkInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNetworkInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNetworkInterfaceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPrepayInstanceSpecRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
    }
}

public class ModifyPrepayInstanceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPrepayInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPrepayInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPrepayInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySecurityGroupAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class ModifySecurityGroupAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySecurityGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySecurityGroupAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySnapshotAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var snapshotId: String?

    public var snapshotName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("SnapshotName") {
            self.snapshotName = dict["SnapshotName"] as! String
        }
    }
}

public class ModifySnapshotAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySnapshotAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySnapshotAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySnapshotAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySnatEntryRequest : Tea.TeaModel {
    public var eipAffinity: Bool?

    public var ispAffinity: Bool?

    public var snatEntryId: String?

    public var snatEntryName: String?

    public var snatIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipAffinity != nil {
            map["EipAffinity"] = self.eipAffinity!
        }
        if self.ispAffinity != nil {
            map["IspAffinity"] = self.ispAffinity!
        }
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatEntryName != nil {
            map["SnatEntryName"] = self.snatEntryName!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipAffinity") {
            self.eipAffinity = dict["EipAffinity"] as! Bool
        }
        if dict.keys.contains("IspAffinity") {
            self.ispAffinity = dict["IspAffinity"] as! Bool
        }
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatEntryName") {
            self.snatEntryName = dict["SnatEntryName"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
    }
}

public class ModifySnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVSwitchAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
    }
}

public class ModifyVSwitchAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVSwitchAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVSwitchAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVSwitchAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MountInstanceSDGRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class MountInstanceSDGShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class MountInstanceSDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var errMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMessage != nil {
                        map["ErrMessage"] = self.errMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMessage") {
                        self.errMessage = dict["ErrMessage"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [MountInstanceSDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [MountInstanceSDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = MountInstanceSDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: MountInstanceSDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = MountInstanceSDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: MountInstanceSDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = MountInstanceSDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MountInstanceSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MountInstanceSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MountInstanceSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PreloadRegionSDGRequest : Tea.TeaModel {
    public var destinationRegionIds: [String]?

    public var namespaces: [String]?

    public var redundantNum: Int32?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationRegionIds != nil {
            map["DestinationRegionIds"] = self.destinationRegionIds!
        }
        if self.namespaces != nil {
            map["Namespaces"] = self.namespaces!
        }
        if self.redundantNum != nil {
            map["RedundantNum"] = self.redundantNum!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationRegionIds") {
            self.destinationRegionIds = dict["DestinationRegionIds"] as! [String]
        }
        if dict.keys.contains("Namespaces") {
            self.namespaces = dict["Namespaces"] as! [String]
        }
        if dict.keys.contains("RedundantNum") {
            self.redundantNum = dict["RedundantNum"] as! Int32
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class PreloadRegionSDGShrinkRequest : Tea.TeaModel {
    public var destinationRegionIdsShrink: String?

    public var namespacesShrink: String?

    public var redundantNum: Int32?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationRegionIdsShrink != nil {
            map["DestinationRegionIds"] = self.destinationRegionIdsShrink!
        }
        if self.namespacesShrink != nil {
            map["Namespaces"] = self.namespacesShrink!
        }
        if self.redundantNum != nil {
            map["RedundantNum"] = self.redundantNum!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationRegionIds") {
            self.destinationRegionIdsShrink = dict["DestinationRegionIds"] as! String
        }
        if dict.keys.contains("Namespaces") {
            self.namespacesShrink = dict["Namespaces"] as! String
        }
        if dict.keys.contains("RedundantNum") {
            self.redundantNum = dict["RedundantNum"] as! Int32
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class PreloadRegionSDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var destinationRegionId: String?

                public var errorMessage: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destinationRegionId != nil {
                        map["DestinationRegionId"] = self.destinationRegionId!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DestinationRegionId") {
                        self.destinationRegionId = dict["DestinationRegionId"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [PreloadRegionSDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [PreloadRegionSDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = PreloadRegionSDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: PreloadRegionSDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = PreloadRegionSDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: PreloadRegionSDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = PreloadRegionSDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PreloadRegionSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreloadRegionSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PreloadRegionSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PrepareUploadRequest : Tea.TeaModel {
    public var bucketName: String?

    public var clientIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.clientIp != nil {
            map["ClientIp"] = self.clientIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("ClientIp") {
            self.clientIp = dict["ClientIp"] as! String
        }
    }
}

public class PrepareUploadResponseBody : Tea.TeaModel {
    public var bucketName: String?

    public var endpoint: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("Endpoint") {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PrepareUploadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PrepareUploadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PrepareUploadResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PushApplicationDataRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var pushStrategy: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.pushStrategy != nil {
            map["PushStrategy"] = self.pushStrategy!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("PushStrategy") {
            self.pushStrategy = dict["PushStrategy"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class PushApplicationDataResponseBody : Tea.TeaModel {
    public class PushResults : Tea.TeaModel {
        public class PushResult : Tea.TeaModel {
            public var name: String?

            public var resultCode: Int32?

            public var resultDescrip: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.resultCode != nil {
                    map["ResultCode"] = self.resultCode!
                }
                if self.resultDescrip != nil {
                    map["ResultDescrip"] = self.resultDescrip!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ResultCode") {
                    self.resultCode = dict["ResultCode"] as! Int32
                }
                if dict.keys.contains("ResultDescrip") {
                    self.resultDescrip = dict["ResultDescrip"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var pushResult: [PushApplicationDataResponseBody.PushResults.PushResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pushResult != nil {
                var tmp : [Any] = []
                for k in self.pushResult! {
                    tmp.append(k.toMap())
                }
                map["PushResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PushResult") {
                var tmp : [PushApplicationDataResponseBody.PushResults.PushResult] = []
                for v in dict["PushResult"] as! [Any] {
                    var model = PushApplicationDataResponseBody.PushResults.PushResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pushResult = tmp
            }
        }
    }
    public var pushResults: PushApplicationDataResponseBody.PushResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushResults != nil {
            map["PushResults"] = self.pushResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushResults") {
            var model = PushApplicationDataResponseBody.PushResults()
            model.fromMap(dict["PushResults"] as! [String: Any])
            self.pushResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PushApplicationDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PushApplicationDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PushApplicationDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutBucketRequest : Tea.TeaModel {
    public var bucketAcl: String?

    public var bucketName: String?

    public var comment: String?

    public var dispatchScope: String?

    public var ensRegionId: String?

    public var logicalBucketType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketAcl != nil {
            map["BucketAcl"] = self.bucketAcl!
        }
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.dispatchScope != nil {
            map["DispatchScope"] = self.dispatchScope!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.logicalBucketType != nil {
            map["LogicalBucketType"] = self.logicalBucketType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketAcl") {
            self.bucketAcl = dict["BucketAcl"] as! String
        }
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("DispatchScope") {
            self.dispatchScope = dict["DispatchScope"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("LogicalBucketType") {
            self.logicalBucketType = dict["LogicalBucketType"] as! String
        }
    }
}

public class PutBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PutBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PutBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutBucketAclRequest : Tea.TeaModel {
    public var bucketAcl: String?

    public var bucketName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketAcl != nil {
            map["BucketAcl"] = self.bucketAcl!
        }
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BucketAcl") {
            self.bucketAcl = dict["BucketAcl"] as! String
        }
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
    }
}

public class PutBucketAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PutBucketAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutBucketAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PutBucketAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PutBucketLifecycleRequest : Tea.TeaModel {
    public var allowSameActionOverlap: String?

    public var bucketName: String?

    public var createdBeforeDate: String?

    public var expirationDays: Int64?

    public var prefix_: String?

    public var ruleId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSameActionOverlap != nil {
            map["AllowSameActionOverlap"] = self.allowSameActionOverlap!
        }
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.createdBeforeDate != nil {
            map["CreatedBeforeDate"] = self.createdBeforeDate!
        }
        if self.expirationDays != nil {
            map["ExpirationDays"] = self.expirationDays!
        }
        if self.prefix_ != nil {
            map["Prefix"] = self.prefix_!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSameActionOverlap") {
            self.allowSameActionOverlap = dict["AllowSameActionOverlap"] as! String
        }
        if dict.keys.contains("BucketName") {
            self.bucketName = dict["BucketName"] as! String
        }
        if dict.keys.contains("CreatedBeforeDate") {
            self.createdBeforeDate = dict["CreatedBeforeDate"] as! String
        }
        if dict.keys.contains("ExpirationDays") {
            self.expirationDays = dict["ExpirationDays"] as! Int64
        }
        if dict.keys.contains("Prefix") {
            self.prefix_ = dict["Prefix"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class PutBucketLifecycleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class PutBucketLifecycleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutBucketLifecycleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PutBucketLifecycleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReInitDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var imageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
    }
}

public class ReInitDiskResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReInitDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReInitDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReInitDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootAICInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceIds: [String]?

    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class RebootAICInstanceShrinkRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceIdsShrink: String?

    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class RebootAICInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootAICInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootAICInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RebootAICInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootARMServerInstanceRequest : Tea.TeaModel {
    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class RebootARMServerInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootARMServerInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootARMServerInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RebootARMServerInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootInstanceRequest : Tea.TeaModel {
    public var forceStop: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceStop") {
            self.forceStop = dict["ForceStop"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class RebootInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RebootInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootInstancesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class RebootInstancesShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class RebootInstancesResponseBody : Tea.TeaModel {
    public var instanceResponses: [InstanceOperateResponse]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            var tmp : [Any] = []
            for k in self.instanceResponses! {
                tmp.append(k.toMap())
            }
            map["InstanceResponses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") {
            var tmp : [InstanceOperateResponse] = []
            for v in dict["InstanceResponses"] as! [Any] {
                var model = InstanceOperateResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceResponses = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RebootInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecoverAICInstanceRequest : Tea.TeaModel {
    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class RecoverAICInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RecoverAICInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverAICInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecoverAICInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReinitInstanceRequest : Tea.TeaModel {
    public var imageId: String?

    public var instanceId: String?

    public var password: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
    }
}

public class ReinitInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReinitInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReinitInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReinitInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReinitInstancesRequest : Tea.TeaModel {
    public var imageId: String?

    public var instanceIds: [String]?

    public var password: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
    }
}

public class ReinitInstancesShrinkRequest : Tea.TeaModel {
    public var imageId: String?

    public var instanceIdsShrink: String?

    public var password: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
    }
}

public class ReinitInstancesResponseBody : Tea.TeaModel {
    public var instanceResponses: [InstanceOperateResponse]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            var tmp : [Any] = []
            for k in self.instanceResponses! {
                tmp.append(k.toMap())
            }
            map["InstanceResponses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") {
            var tmp : [InstanceOperateResponse] = []
            for v in dict["InstanceResponses"] as! [Any] {
                var model = InstanceOperateResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceResponses = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReinitInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReinitInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReinitInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseAICInstanceRequest : Tea.TeaModel {
    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class ReleaseAICInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseAICInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseAICInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseAICInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseARMServerInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReleaseARMServerInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseARMServerInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseARMServerInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseARMServerInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReleaseInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ReleaseInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleasePostPaidInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReleasePostPaidInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleasePostPaidInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleasePostPaidInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleasePostPaidInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleasePrePaidInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ReleasePrePaidInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleasePrePaidInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleasePrePaidInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleasePrePaidInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveBackendServersRequest : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public var ip: String?

        public var port: Int32?

        public var serverId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("ServerId") {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var backendServers: [RemoveBackendServersRequest.BackendServers]?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            var tmp : [Any] = []
            for k in self.backendServers! {
                tmp.append(k.toMap())
            }
            map["BackendServers"] = tmp
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") {
            var tmp : [RemoveBackendServersRequest.BackendServers] = []
            for v in dict["BackendServers"] as! [Any] {
                var model = RemoveBackendServersRequest.BackendServers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendServers = tmp
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class RemoveBackendServersShrinkRequest : Tea.TeaModel {
    public var backendServersShrink: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServersShrink != nil {
            map["BackendServers"] = self.backendServersShrink!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") {
            self.backendServersShrink = dict["BackendServers"] as! String
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class RemoveBackendServersResponseBody : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public class BackendServer : Tea.TeaModel {
            public var ip: String?

            public var port: Int32?

            public var serverId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerId") {
                    self.serverId = dict["ServerId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var backendServer: [RemoveBackendServersResponseBody.BackendServers.BackendServer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendServer != nil {
                var tmp : [Any] = []
                for k in self.backendServer! {
                    tmp.append(k.toMap())
                }
                map["BackendServer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendServer") {
                var tmp : [RemoveBackendServersResponseBody.BackendServers.BackendServer] = []
                for v in dict["BackendServer"] as! [Any] {
                    var model = RemoveBackendServersResponseBody.BackendServers.BackendServer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backendServer = tmp
            }
        }
    }
    public var backendServers: RemoveBackendServersResponseBody.BackendServers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            map["BackendServers"] = self.backendServers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") {
            var model = RemoveBackendServersResponseBody.BackendServers()
            model.fromMap(dict["BackendServers"] as! [String: Any])
            self.backendServers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveBackendServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveBackendServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveBackendServersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveInstanceSDGRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class RemoveInstanceSDGShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class RemoveInstanceSDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var errMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMessage != nil {
                        map["ErrMessage"] = self.errMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMessage") {
                        self.errMessage = dict["ErrMessage"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [RemoveInstanceSDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [RemoveInstanceSDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = RemoveInstanceSDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: RemoveInstanceSDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = RemoveInstanceSDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var code: Int32?

    public var data: RemoveInstanceSDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = RemoveInstanceSDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveInstanceSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveInstanceSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveInstanceSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePublicIpsFromEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var instanceInfos: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.instanceInfos != nil {
            map["InstanceInfos"] = self.instanceInfos!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("InstanceInfos") {
            self.instanceInfos = dict["InstanceInfos"] as! String
        }
    }
}

public class RemovePublicIpsFromEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePublicIpsFromEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePublicIpsFromEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemovePublicIpsFromEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveSDGRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class RemoveSDGShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class RemoveSDGResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveVSwitchesFromEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public var vSwitchesInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        if self.vSwitchesInfo != nil {
            map["VSwitchesInfo"] = self.vSwitchesInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
        if dict.keys.contains("VSwitchesInfo") {
            self.vSwitchesInfo = dict["VSwitchesInfo"] as! String
        }
    }
}

public class RemoveVSwitchesFromEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveVSwitchesFromEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveVSwitchesFromEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveVSwitchesFromEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewARMServerInstanceRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var instanceId: String?

    public var period: Int32?

    public var periodUnit: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
    }
}

public class RenewARMServerInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewARMServerInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewARMServerInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewARMServerInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var period: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int64
        }
    }
}

public class RenewInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RescaleApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var rescaleLevel: String?

    public var rescaleType: String?

    public var resourceSelector: String?

    public var timeout: Int32?

    public var toAppVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.rescaleLevel != nil {
            map["RescaleLevel"] = self.rescaleLevel!
        }
        if self.rescaleType != nil {
            map["RescaleType"] = self.rescaleType!
        }
        if self.resourceSelector != nil {
            map["ResourceSelector"] = self.resourceSelector!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.toAppVersion != nil {
            map["ToAppVersion"] = self.toAppVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("RescaleLevel") {
            self.rescaleLevel = dict["RescaleLevel"] as! String
        }
        if dict.keys.contains("RescaleType") {
            self.rescaleType = dict["RescaleType"] as! String
        }
        if dict.keys.contains("ResourceSelector") {
            self.resourceSelector = dict["ResourceSelector"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("ToAppVersion") {
            self.toAppVersion = dict["ToAppVersion"] as! String
        }
    }
}

public class RescaleApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RescaleApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RescaleApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RescaleApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RescaleDeviceServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var imageId: String?

    public var ipType: Int32?

    public var rescaleLevel: String?

    public var rescaleType: String?

    public var resourceInfo: String?

    public var resourceSelector: String?

    public var resourceSpec: String?

    public var serviceId: String?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.rescaleLevel != nil {
            map["RescaleLevel"] = self.rescaleLevel!
        }
        if self.rescaleType != nil {
            map["RescaleType"] = self.rescaleType!
        }
        if self.resourceInfo != nil {
            map["ResourceInfo"] = self.resourceInfo!
        }
        if self.resourceSelector != nil {
            map["ResourceSelector"] = self.resourceSelector!
        }
        if self.resourceSpec != nil {
            map["ResourceSpec"] = self.resourceSpec!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("IpType") {
            self.ipType = dict["IpType"] as! Int32
        }
        if dict.keys.contains("RescaleLevel") {
            self.rescaleLevel = dict["RescaleLevel"] as! String
        }
        if dict.keys.contains("RescaleType") {
            self.rescaleType = dict["RescaleType"] as! String
        }
        if dict.keys.contains("ResourceInfo") {
            self.resourceInfo = dict["ResourceInfo"] as! String
        }
        if dict.keys.contains("ResourceSelector") {
            self.resourceSelector = dict["ResourceSelector"] as! String
        }
        if dict.keys.contains("ResourceSpec") {
            self.resourceSpec = dict["ResourceSpec"] as! String
        }
        if dict.keys.contains("ServiceId") {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class RescaleDeviceServiceResponseBody : Tea.TeaModel {
    public class ResourceDetailInfos : Tea.TeaModel {
        public var ID: String?

        public var IP: String?

        public var ISP: String?

        public var mac: String?

        public var regionID: String?

        public var server: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ID != nil {
                map["ID"] = self.ID!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.ISP != nil {
                map["ISP"] = self.ISP!
            }
            if self.mac != nil {
                map["Mac"] = self.mac!
            }
            if self.regionID != nil {
                map["RegionID"] = self.regionID!
            }
            if self.server != nil {
                map["Server"] = self.server!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ID") {
                self.ID = dict["ID"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("ISP") {
                self.ISP = dict["ISP"] as! String
            }
            if dict.keys.contains("Mac") {
                self.mac = dict["Mac"] as! String
            }
            if dict.keys.contains("RegionID") {
                self.regionID = dict["RegionID"] as! String
            }
            if dict.keys.contains("Server") {
                self.server = dict["Server"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var deviceIds: [String]?

    public var orderId: String?

    public var requestId: String?

    public var resourceDetailInfos: [RescaleDeviceServiceResponseBody.ResourceDetailInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceIds != nil {
            map["DeviceIds"] = self.deviceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceDetailInfos != nil {
            var tmp : [Any] = []
            for k in self.resourceDetailInfos! {
                tmp.append(k.toMap())
            }
            map["ResourceDetailInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceIds") {
            self.deviceIds = dict["DeviceIds"] as! [String]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceDetailInfos") {
            var tmp : [RescaleDeviceServiceResponseBody.ResourceDetailInfos] = []
            for v in dict["ResourceDetailInfos"] as! [Any] {
                var model = RescaleDeviceServiceResponseBody.ResourceDetailInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceDetailInfos = tmp
        }
    }
}

public class RescaleDeviceServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RescaleDeviceServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RescaleDeviceServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAICInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var serverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.serverId != nil {
            map["ServerId"] = self.serverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ServerId") {
            self.serverId = dict["ServerId"] as! String
        }
    }
}

public class ResetAICInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetAICInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAICInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetAICInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class ResetDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResizeDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var newSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.newSize != nil {
            map["NewSize"] = self.newSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("NewSize") {
            self.newSize = dict["NewSize"] as! String
        }
    }
}

public class ResizeDiskResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResizeDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResizeDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResizeDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeSecurityGroupRequest : Tea.TeaModel {
    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var securityGroupId: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
    }
}

public class RevokeSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeSecurityGroupEgressRequest : Tea.TeaModel {
    public var destCidrIp: String?

    public var ipProtocol: String?

    public var policy: String?

    public var portRange: String?

    public var priority: Int32?

    public var securityGroupId: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
    }
}

public class RevokeSecurityGroupEgressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeSecurityGroupEgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeSecurityGroupEgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeSecurityGroupEgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var fromAppVersion: String?

    public var timeout: Int32?

    public var toAppVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.fromAppVersion != nil {
            map["FromAppVersion"] = self.fromAppVersion!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.toAppVersion != nil {
            map["ToAppVersion"] = self.toAppVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("FromAppVersion") {
            self.fromAppVersion = dict["FromAppVersion"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
        if dict.keys.contains("ToAppVersion") {
            self.toAppVersion = dict["ToAppVersion"] as! String
        }
    }
}

public class RollbackApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RollbackApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RollbackApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunInstancesRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var amount: Int64?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoUseCoupon: String?

    public var billingCycle: String?

    public var carrier: String?

    public var dataDisk: [RunInstancesRequest.DataDisk]?

    public var ensRegionId: String?

    public var hostName: String?

    public var imageId: String?

    public var instanceChargeStrategy: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int64?

    public var ipType: String?

    public var keyPairName: String?

    public var netDistrictCode: String?

    public var netWorkId: String?

    public var password: String?

    public var passwordInherit: Bool?

    public var period: Int64?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var publicIpIdentification: Bool?

    public var scheduleAreaLevel: String?

    public var schedulingPriceStrategy: String?

    public var schedulingStrategy: String?

    public var securityId: String?

    public var spotDuration: Int32?

    public var spotStrategy: String?

    public var systemDisk: RunInstancesRequest.SystemDisk?

    public var tag: [RunInstancesRequest.Tag]?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.billingCycle != nil {
            map["BillingCycle"] = self.billingCycle!
        }
        if self.carrier != nil {
            map["Carrier"] = self.carrier!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeStrategy != nil {
            map["InstanceChargeStrategy"] = self.instanceChargeStrategy!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.netDistrictCode != nil {
            map["NetDistrictCode"] = self.netDistrictCode!
        }
        if self.netWorkId != nil {
            map["NetWorkId"] = self.netWorkId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.publicIpIdentification != nil {
            map["PublicIpIdentification"] = self.publicIpIdentification!
        }
        if self.scheduleAreaLevel != nil {
            map["ScheduleAreaLevel"] = self.scheduleAreaLevel!
        }
        if self.schedulingPriceStrategy != nil {
            map["SchedulingPriceStrategy"] = self.schedulingPriceStrategy!
        }
        if self.schedulingStrategy != nil {
            map["SchedulingStrategy"] = self.schedulingStrategy!
        }
        if self.securityId != nil {
            map["SecurityId"] = self.securityId!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoUseCoupon") {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! String
        }
        if dict.keys.contains("BillingCycle") {
            self.billingCycle = dict["BillingCycle"] as! String
        }
        if dict.keys.contains("Carrier") {
            self.carrier = dict["Carrier"] as! String
        }
        if dict.keys.contains("DataDisk") {
            var tmp : [RunInstancesRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = RunInstancesRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceChargeStrategy") {
            self.instanceChargeStrategy = dict["InstanceChargeStrategy"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int64
        }
        if dict.keys.contains("IpType") {
            self.ipType = dict["IpType"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("NetDistrictCode") {
            self.netDistrictCode = dict["NetDistrictCode"] as! String
        }
        if dict.keys.contains("NetWorkId") {
            self.netWorkId = dict["NetWorkId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int64
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("PublicIpIdentification") {
            self.publicIpIdentification = dict["PublicIpIdentification"] as! Bool
        }
        if dict.keys.contains("ScheduleAreaLevel") {
            self.scheduleAreaLevel = dict["ScheduleAreaLevel"] as! String
        }
        if dict.keys.contains("SchedulingPriceStrategy") {
            self.schedulingPriceStrategy = dict["SchedulingPriceStrategy"] as! String
        }
        if dict.keys.contains("SchedulingStrategy") {
            self.schedulingStrategy = dict["SchedulingStrategy"] as! String
        }
        if dict.keys.contains("SecurityId") {
            self.securityId = dict["SecurityId"] as! String
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDisk") {
            var model = RunInstancesRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Tag") {
            var tmp : [RunInstancesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = RunInstancesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("UniqueSuffix") {
            self.uniqueSuffix = dict["UniqueSuffix"] as! Bool
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class RunInstancesShrinkRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var amount: Int64?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoUseCoupon: String?

    public var billingCycle: String?

    public var carrier: String?

    public var dataDiskShrink: String?

    public var ensRegionId: String?

    public var hostName: String?

    public var imageId: String?

    public var instanceChargeStrategy: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int64?

    public var ipType: String?

    public var keyPairName: String?

    public var netDistrictCode: String?

    public var netWorkId: String?

    public var password: String?

    public var passwordInherit: Bool?

    public var period: Int64?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var publicIpIdentification: Bool?

    public var scheduleAreaLevel: String?

    public var schedulingPriceStrategy: String?

    public var schedulingStrategy: String?

    public var securityId: String?

    public var spotDuration: Int32?

    public var spotStrategy: String?

    public var systemDiskShrink: String?

    public var tag: [RunInstancesShrinkRequest.Tag]?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.billingCycle != nil {
            map["BillingCycle"] = self.billingCycle!
        }
        if self.carrier != nil {
            map["Carrier"] = self.carrier!
        }
        if self.dataDiskShrink != nil {
            map["DataDisk"] = self.dataDiskShrink!
        }
        if self.ensRegionId != nil {
            map["EnsRegionId"] = self.ensRegionId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeStrategy != nil {
            map["InstanceChargeStrategy"] = self.instanceChargeStrategy!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ipType != nil {
            map["IpType"] = self.ipType!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.netDistrictCode != nil {
            map["NetDistrictCode"] = self.netDistrictCode!
        }
        if self.netWorkId != nil {
            map["NetWorkId"] = self.netWorkId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.publicIpIdentification != nil {
            map["PublicIpIdentification"] = self.publicIpIdentification!
        }
        if self.scheduleAreaLevel != nil {
            map["ScheduleAreaLevel"] = self.scheduleAreaLevel!
        }
        if self.schedulingPriceStrategy != nil {
            map["SchedulingPriceStrategy"] = self.schedulingPriceStrategy!
        }
        if self.schedulingStrategy != nil {
            map["SchedulingStrategy"] = self.schedulingStrategy!
        }
        if self.securityId != nil {
            map["SecurityId"] = self.securityId!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskShrink != nil {
            map["SystemDisk"] = self.systemDiskShrink!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int64
        }
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoUseCoupon") {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! String
        }
        if dict.keys.contains("BillingCycle") {
            self.billingCycle = dict["BillingCycle"] as! String
        }
        if dict.keys.contains("Carrier") {
            self.carrier = dict["Carrier"] as! String
        }
        if dict.keys.contains("DataDisk") {
            self.dataDiskShrink = dict["DataDisk"] as! String
        }
        if dict.keys.contains("EnsRegionId") {
            self.ensRegionId = dict["EnsRegionId"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceChargeStrategy") {
            self.instanceChargeStrategy = dict["InstanceChargeStrategy"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int64
        }
        if dict.keys.contains("IpType") {
            self.ipType = dict["IpType"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("NetDistrictCode") {
            self.netDistrictCode = dict["NetDistrictCode"] as! String
        }
        if dict.keys.contains("NetWorkId") {
            self.netWorkId = dict["NetWorkId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int64
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("PublicIpIdentification") {
            self.publicIpIdentification = dict["PublicIpIdentification"] as! Bool
        }
        if dict.keys.contains("ScheduleAreaLevel") {
            self.scheduleAreaLevel = dict["ScheduleAreaLevel"] as! String
        }
        if dict.keys.contains("SchedulingPriceStrategy") {
            self.schedulingPriceStrategy = dict["SchedulingPriceStrategy"] as! String
        }
        if dict.keys.contains("SchedulingStrategy") {
            self.schedulingStrategy = dict["SchedulingStrategy"] as! String
        }
        if dict.keys.contains("SecurityId") {
            self.securityId = dict["SecurityId"] as! String
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDisk") {
            self.systemDiskShrink = dict["SystemDisk"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [RunInstancesShrinkRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = RunInstancesShrinkRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("UniqueSuffix") {
            self.uniqueSuffix = dict["UniqueSuffix"] as! Bool
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class RunInstancesResponseBody : Tea.TeaModel {
    public var instanceIds: [String]?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RunInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunServiceScheduleRequest : Tea.TeaModel {
    public var appId: String?

    public var clientIp: String?

    public var directorys: String?

    public var podConfigName: String?

    public var preLockedTimeout: Int32?

    public var scheduleStrategy: String?

    public var serviceAction: String?

    public var serviceCommands: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.clientIp != nil {
            map["ClientIp"] = self.clientIp!
        }
        if self.directorys != nil {
            map["Directorys"] = self.directorys!
        }
        if self.podConfigName != nil {
            map["PodConfigName"] = self.podConfigName!
        }
        if self.preLockedTimeout != nil {
            map["PreLockedTimeout"] = self.preLockedTimeout!
        }
        if self.scheduleStrategy != nil {
            map["ScheduleStrategy"] = self.scheduleStrategy!
        }
        if self.serviceAction != nil {
            map["ServiceAction"] = self.serviceAction!
        }
        if self.serviceCommands != nil {
            map["ServiceCommands"] = self.serviceCommands!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ClientIp") {
            self.clientIp = dict["ClientIp"] as! String
        }
        if dict.keys.contains("Directorys") {
            self.directorys = dict["Directorys"] as! String
        }
        if dict.keys.contains("PodConfigName") {
            self.podConfigName = dict["PodConfigName"] as! String
        }
        if dict.keys.contains("PreLockedTimeout") {
            self.preLockedTimeout = dict["PreLockedTimeout"] as! Int32
        }
        if dict.keys.contains("ScheduleStrategy") {
            self.scheduleStrategy = dict["ScheduleStrategy"] as! String
        }
        if dict.keys.contains("ServiceAction") {
            self.serviceAction = dict["ServiceAction"] as! String
        }
        if dict.keys.contains("ServiceCommands") {
            self.serviceCommands = dict["ServiceCommands"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class RunServiceScheduleResponseBody : Tea.TeaModel {
    public class CommandResults : Tea.TeaModel {
        public class CommandResult : Tea.TeaModel {
            public var command: String?

            public var containerName: String?

            public var resultMsg: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.containerName != nil {
                    map["ContainerName"] = self.containerName!
                }
                if self.resultMsg != nil {
                    map["ResultMsg"] = self.resultMsg!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Command") {
                    self.command = dict["Command"] as! String
                }
                if dict.keys.contains("ContainerName") {
                    self.containerName = dict["ContainerName"] as! String
                }
                if dict.keys.contains("ResultMsg") {
                    self.resultMsg = dict["ResultMsg"] as! String
                }
            }
        }
        public var commandResult: [RunServiceScheduleResponseBody.CommandResults.CommandResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commandResult != nil {
                var tmp : [Any] = []
                for k in self.commandResult! {
                    tmp.append(k.toMap())
                }
                map["CommandResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommandResult") {
                var tmp : [RunServiceScheduleResponseBody.CommandResults.CommandResult] = []
                for v in dict["CommandResult"] as! [Any] {
                    var model = RunServiceScheduleResponseBody.CommandResults.CommandResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.commandResult = tmp
            }
        }
    }
    public var commandResults: RunServiceScheduleResponseBody.CommandResults?

    public var index: Int32?

    public var instanceId: String?

    public var instanceIp: String?

    public var instancePort: Int32?

    public var requestId: String?

    public var requestRepeated: String?

    public var tcpPorts: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commandResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandResults != nil {
            map["CommandResults"] = self.commandResults?.toMap()
        }
        if self.index != nil {
            map["Index"] = self.index!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIp != nil {
            map["InstanceIp"] = self.instanceIp!
        }
        if self.instancePort != nil {
            map["InstancePort"] = self.instancePort!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestRepeated != nil {
            map["RequestRepeated"] = self.requestRepeated!
        }
        if self.tcpPorts != nil {
            map["TcpPorts"] = self.tcpPorts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandResults") {
            var model = RunServiceScheduleResponseBody.CommandResults()
            model.fromMap(dict["CommandResults"] as! [String: Any])
            self.commandResults = model
        }
        if dict.keys.contains("Index") {
            self.index = dict["Index"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceIp") {
            self.instanceIp = dict["InstanceIp"] as! String
        }
        if dict.keys.contains("InstancePort") {
            self.instancePort = dict["InstancePort"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestRepeated") {
            self.requestRepeated = dict["RequestRepeated"] as! String
        }
        if dict.keys.contains("TcpPorts") {
            self.tcpPorts = dict["TcpPorts"] as! Bool
        }
    }
}

public class RunServiceScheduleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunServiceScheduleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunServiceScheduleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveSDGRequest : Tea.TeaModel {
    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class SaveSDGResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SaveSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetBackendServersRequest : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public var serverId: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serverId != nil {
                map["ServerId"] = self.serverId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServerId") {
                self.serverId = dict["ServerId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public var backendServers: [SetBackendServersRequest.BackendServers]?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            var tmp : [Any] = []
            for k in self.backendServers! {
                tmp.append(k.toMap())
            }
            map["BackendServers"] = tmp
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") {
            var tmp : [SetBackendServersRequest.BackendServers] = []
            for v in dict["BackendServers"] as! [Any] {
                var model = SetBackendServersRequest.BackendServers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendServers = tmp
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class SetBackendServersShrinkRequest : Tea.TeaModel {
    public var backendServersShrink: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServersShrink != nil {
            map["BackendServers"] = self.backendServersShrink!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") {
            self.backendServersShrink = dict["BackendServers"] as! String
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class SetBackendServersResponseBody : Tea.TeaModel {
    public class BackendServers : Tea.TeaModel {
        public class BackendServer : Tea.TeaModel {
            public var ip: String?

            public var port: Int32?

            public var serverId: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.serverId != nil {
                    map["ServerId"] = self.serverId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("ServerId") {
                    self.serverId = dict["ServerId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public var backendServer: [SetBackendServersResponseBody.BackendServers.BackendServer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendServer != nil {
                var tmp : [Any] = []
                for k in self.backendServer! {
                    tmp.append(k.toMap())
                }
                map["BackendServer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendServer") {
                var tmp : [SetBackendServersResponseBody.BackendServers.BackendServer] = []
                for v in dict["BackendServer"] as! [Any] {
                    var model = SetBackendServersResponseBody.BackendServers.BackendServer()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backendServer = tmp
            }
        }
    }
    public var backendServers: SetBackendServersResponseBody.BackendServers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendServers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendServers != nil {
            map["BackendServers"] = self.backendServers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendServers") {
            var model = SetBackendServersResponseBody.BackendServers()
            model.fromMap(dict["BackendServers"] as! [String: Any])
            self.backendServers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetBackendServersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetBackendServersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetBackendServersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerHTTPListenerAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public var XForwardedFor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        if self.XForwardedFor != nil {
            map["XForwardedFor"] = self.XForwardedFor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HealthCheck") {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("RequestTimeout") {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
        if dict.keys.contains("XForwardedFor") {
            self.XForwardedFor = dict["XForwardedFor"] as! String
        }
    }
}

public class SetLoadBalancerHTTPListenerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerHTTPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerHTTPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLoadBalancerHTTPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerHTTPSListenerAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var healthCheck: String?

    public var healthCheckConnectPort: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckMethod: String?

    public var healthCheckTimeout: Int32?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var idleTimeout: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var requestTimeout: Int32?

    public var scheduler: String?

    public var serverCertificateId: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckMethod != nil {
            map["HealthCheckMethod"] = self.healthCheckMethod!
        }
        if self.healthCheckTimeout != nil {
            map["HealthCheckTimeout"] = self.healthCheckTimeout!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.serverCertificateId != nil {
            map["ServerCertificateId"] = self.serverCertificateId!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HealthCheck") {
            self.healthCheck = dict["HealthCheck"] as! String
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckMethod") {
            self.healthCheckMethod = dict["HealthCheckMethod"] as! String
        }
        if dict.keys.contains("HealthCheckTimeout") {
            self.healthCheckTimeout = dict["HealthCheckTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("IdleTimeout") {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("RequestTimeout") {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("ServerCertificateId") {
            self.serverCertificateId = dict["ServerCertificateId"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class SetLoadBalancerHTTPSListenerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerHTTPSListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerHTTPSListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLoadBalancerHTTPSListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerStatusRequest : Tea.TeaModel {
    public var loadBalancerId: String?

    public var loadBalancerStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.loadBalancerStatus != nil {
            map["LoadBalancerStatus"] = self.loadBalancerStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("LoadBalancerStatus") {
            self.loadBalancerStatus = dict["LoadBalancerStatus"] as! String
        }
    }
}

public class SetLoadBalancerStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLoadBalancerStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerTCPListenerAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var eipTransmit: String?

    public var establishedTimeout: Int32?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckDomain: String?

    public var healthCheckHttpCode: String?

    public var healthCheckInterval: Int32?

    public var healthCheckType: String?

    public var healthCheckURI: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var persistenceTimeout: Int32?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckDomain != nil {
            map["HealthCheckDomain"] = self.healthCheckDomain!
        }
        if self.healthCheckHttpCode != nil {
            map["HealthCheckHttpCode"] = self.healthCheckHttpCode!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckType != nil {
            map["HealthCheckType"] = self.healthCheckType!
        }
        if self.healthCheckURI != nil {
            map["HealthCheckURI"] = self.healthCheckURI!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.persistenceTimeout != nil {
            map["PersistenceTimeout"] = self.persistenceTimeout!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("EstablishedTimeout") {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckDomain") {
            self.healthCheckDomain = dict["HealthCheckDomain"] as! String
        }
        if dict.keys.contains("HealthCheckHttpCode") {
            self.healthCheckHttpCode = dict["HealthCheckHttpCode"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckType") {
            self.healthCheckType = dict["HealthCheckType"] as! String
        }
        if dict.keys.contains("HealthCheckURI") {
            self.healthCheckURI = dict["HealthCheckURI"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("PersistenceTimeout") {
            self.persistenceTimeout = dict["PersistenceTimeout"] as! Int32
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class SetLoadBalancerTCPListenerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerTCPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerTCPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLoadBalancerTCPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLoadBalancerUDPListenerAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var eipTransmit: String?

    public var establishedTimeout: Int32?

    public var healthCheckConnectPort: Int32?

    public var healthCheckConnectTimeout: Int32?

    public var healthCheckExp: String?

    public var healthCheckInterval: Int32?

    public var healthCheckReq: String?

    public var healthyThreshold: Int32?

    public var listenerPort: Int32?

    public var loadBalancerId: String?

    public var scheduler: String?

    public var unhealthyThreshold: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipTransmit != nil {
            map["EipTransmit"] = self.eipTransmit!
        }
        if self.establishedTimeout != nil {
            map["EstablishedTimeout"] = self.establishedTimeout!
        }
        if self.healthCheckConnectPort != nil {
            map["HealthCheckConnectPort"] = self.healthCheckConnectPort!
        }
        if self.healthCheckConnectTimeout != nil {
            map["HealthCheckConnectTimeout"] = self.healthCheckConnectTimeout!
        }
        if self.healthCheckExp != nil {
            map["HealthCheckExp"] = self.healthCheckExp!
        }
        if self.healthCheckInterval != nil {
            map["HealthCheckInterval"] = self.healthCheckInterval!
        }
        if self.healthCheckReq != nil {
            map["HealthCheckReq"] = self.healthCheckReq!
        }
        if self.healthyThreshold != nil {
            map["HealthyThreshold"] = self.healthyThreshold!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        if self.scheduler != nil {
            map["Scheduler"] = self.scheduler!
        }
        if self.unhealthyThreshold != nil {
            map["UnhealthyThreshold"] = self.unhealthyThreshold!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipTransmit") {
            self.eipTransmit = dict["EipTransmit"] as! String
        }
        if dict.keys.contains("EstablishedTimeout") {
            self.establishedTimeout = dict["EstablishedTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectPort") {
            self.healthCheckConnectPort = dict["HealthCheckConnectPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckConnectTimeout") {
            self.healthCheckConnectTimeout = dict["HealthCheckConnectTimeout"] as! Int32
        }
        if dict.keys.contains("HealthCheckExp") {
            self.healthCheckExp = dict["HealthCheckExp"] as! String
        }
        if dict.keys.contains("HealthCheckInterval") {
            self.healthCheckInterval = dict["HealthCheckInterval"] as! Int32
        }
        if dict.keys.contains("HealthCheckReq") {
            self.healthCheckReq = dict["HealthCheckReq"] as! String
        }
        if dict.keys.contains("HealthyThreshold") {
            self.healthyThreshold = dict["HealthyThreshold"] as! Int32
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
        if dict.keys.contains("Scheduler") {
            self.scheduler = dict["Scheduler"] as! String
        }
        if dict.keys.contains("UnhealthyThreshold") {
            self.unhealthyThreshold = dict["UnhealthyThreshold"] as! Int32
        }
    }
}

public class SetLoadBalancerUDPListenerAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLoadBalancerUDPListenerAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLoadBalancerUDPListenerAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLoadBalancerUDPListenerAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
    }
}

public class StartEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class StartInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartInstancesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class StartInstancesShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class StartInstancesResponseBody : Tea.TeaModel {
    public var instanceResponses: [InstanceOperateResponse]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            var tmp : [Any] = []
            for k in self.instanceResponses! {
                tmp.append(k.toMap())
            }
            map["InstanceResponses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") {
            var tmp : [InstanceOperateResponse] = []
            for v in dict["InstanceResponses"] as! [Any] {
                var model = InstanceOperateResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceResponses = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartLoadBalancerListenerRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("ListenerProtocol") {
            self.listenerProtocol = dict["ListenerProtocol"] as! String
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class StartLoadBalancerListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartLoadBalancerListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartLoadBalancerListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartLoadBalancerListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartSnatIpForSnatEntryRequest : Tea.TeaModel {
    public var snatEntryId: String?

    public var snatIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
    }
}

public class StartSnatIpForSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartSnatIpForSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartSnatIpForSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartSnatIpForSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopEpnInstanceRequest : Tea.TeaModel {
    public var EPNInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.EPNInstanceId != nil {
            map["EPNInstanceId"] = self.EPNInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EPNInstanceId") {
            self.EPNInstanceId = dict["EPNInstanceId"] as! String
        }
    }
}

public class StopEpnInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopEpnInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopEpnInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopEpnInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopInstanceRequest : Tea.TeaModel {
    public var forceStop: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceStop") {
            self.forceStop = dict["ForceStop"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class StopInstanceResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopInstancesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class StopInstancesShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
    }
}

public class StopInstancesResponseBody : Tea.TeaModel {
    public var instanceResponses: [InstanceOperateResponse]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            var tmp : [Any] = []
            for k in self.instanceResponses! {
                tmp.append(k.toMap())
            }
            map["InstanceResponses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") {
            var tmp : [InstanceOperateResponse] = []
            for v in dict["InstanceResponses"] as! [Any] {
                var model = InstanceOperateResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instanceResponses = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopLoadBalancerListenerRequest : Tea.TeaModel {
    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var loadBalancerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalancerId != nil {
            map["LoadBalancerId"] = self.loadBalancerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("ListenerProtocol") {
            self.listenerProtocol = dict["ListenerProtocol"] as! String
        }
        if dict.keys.contains("LoadBalancerId") {
            self.loadBalancerId = dict["LoadBalancerId"] as! String
        }
    }
}

public class StopLoadBalancerListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopLoadBalancerListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopLoadBalancerListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopLoadBalancerListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopSnatIpForSnatEntryRequest : Tea.TeaModel {
    public var snatEntryId: String?

    public var snatIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.snatEntryId != nil {
            map["SnatEntryId"] = self.snatEntryId!
        }
        if self.snatIp != nil {
            map["SnatIp"] = self.snatIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SnatEntryId") {
            self.snatEntryId = dict["SnatEntryId"] as! String
        }
        if dict.keys.contains("SnatIp") {
            self.snatIp = dict["SnatIp"] as! String
        }
    }
}

public class StopSnatIpForSnatEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopSnatIpForSnatEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopSnatIpForSnatEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopSnatIpForSnatEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnAssociateEnsEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
    }
}

public class UnAssociateEnsEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnAssociateEnsEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnAssociateEnsEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnAssociateEnsEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassignPrivateIpAddressesRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var privateIpAddress: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! [String]
        }
    }
}

public class UnassignPrivateIpAddressesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassignPrivateIpAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassignPrivateIpAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassignPrivateIpAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateHaVipRequest : Tea.TeaModel {
    public var haVipId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class UnassociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateNetworkAclRequest : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var networkAclId: String?

    public var resource: [UnassociateNetworkAclRequest.Resource]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAclId != nil {
            map["NetworkAclId"] = self.networkAclId!
        }
        if self.resource != nil {
            var tmp : [Any] = []
            for k in self.resource! {
                tmp.append(k.toMap())
            }
            map["Resource"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAclId") {
            self.networkAclId = dict["NetworkAclId"] as! String
        }
        if dict.keys.contains("Resource") {
            var tmp : [UnassociateNetworkAclRequest.Resource] = []
            for v in dict["Resource"] as! [Any] {
                var model = UnassociateNetworkAclRequest.Resource()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resource = tmp
        }
    }
}

public class UnassociateNetworkAclResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateNetworkAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateNetworkAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateNetworkAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnloadRegionSDGRequest : Tea.TeaModel {
    public var destinationRegionIds: [String]?

    public var namespaces: [String]?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationRegionIds != nil {
            map["DestinationRegionIds"] = self.destinationRegionIds!
        }
        if self.namespaces != nil {
            map["Namespaces"] = self.namespaces!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationRegionIds") {
            self.destinationRegionIds = dict["DestinationRegionIds"] as! [String]
        }
        if dict.keys.contains("Namespaces") {
            self.namespaces = dict["Namespaces"] as! [String]
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class UnloadRegionSDGShrinkRequest : Tea.TeaModel {
    public var destinationRegionIdsShrink: String?

    public var namespacesShrink: String?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationRegionIdsShrink != nil {
            map["DestinationRegionIds"] = self.destinationRegionIdsShrink!
        }
        if self.namespacesShrink != nil {
            map["Namespaces"] = self.namespacesShrink!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationRegionIds") {
            self.destinationRegionIdsShrink = dict["DestinationRegionIds"] as! String
        }
        if dict.keys.contains("Namespaces") {
            self.namespacesShrink = dict["Namespaces"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class UnloadRegionSDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var destinationRegionId: String?

                public var errorMessage: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destinationRegionId != nil {
                        map["DestinationRegionId"] = self.destinationRegionId!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DestinationRegionId") {
                        self.destinationRegionId = dict["DestinationRegionId"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [UnloadRegionSDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [UnloadRegionSDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = UnloadRegionSDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: UnloadRegionSDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = UnloadRegionSDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: UnloadRegionSDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UnloadRegionSDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnloadRegionSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnloadRegionSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnloadRegionSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnmountInstanceSDGRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class UnmountInstanceSDGShrinkRequest : Tea.TeaModel {
    public var instanceIdsShrink: String?

    public var SDGId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.SDGId != nil {
            map["SDGId"] = self.SDGId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIdsShrink = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("SDGId") {
            self.SDGId = dict["SDGId"] as! String
        }
    }
}

public class UnmountInstanceSDGResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class FailedItems : Tea.TeaModel {
                public var errMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMessage != nil {
                        map["ErrMessage"] = self.errMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMessage") {
                        self.errMessage = dict["ErrMessage"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public var failedCount: Int64?

            public var failedItems: [UnmountInstanceSDGResponseBody.Data.Result.FailedItems]?

            public var successCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.failedItems != nil {
                    var tmp : [Any] = []
                    for k in self.failedItems! {
                        tmp.append(k.toMap())
                    }
                    map["FailedItems"] = tmp
                }
                if self.successCount != nil {
                    map["SuccessCount"] = self.successCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedCount") {
                    self.failedCount = dict["FailedCount"] as! Int64
                }
                if dict.keys.contains("FailedItems") {
                    var tmp : [UnmountInstanceSDGResponseBody.Data.Result.FailedItems] = []
                    for v in dict["FailedItems"] as! [Any] {
                        var model = UnmountInstanceSDGResponseBody.Data.Result.FailedItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.failedItems = tmp
                }
                if dict.keys.contains("SuccessCount") {
                    self.successCount = dict["SuccessCount"] as! Int64
                }
            }
        }
        public var message: String?

        public var result: UnmountInstanceSDGResponseBody.Data.Result?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") {
                var model = UnmountInstanceSDGResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var data: UnmountInstanceSDGResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = UnmountInstanceSDGResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnmountInstanceSDGResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnmountInstanceSDGResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnmountInstanceSDGResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEnsSaleControlRequest : Tea.TeaModel {
    public class SaleControls : Tea.TeaModel {
        public class ConditionControls : Tea.TeaModel {
            public var conditionControlModuleCode: String?

            public var conditionControlModuleValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conditionControlModuleCode != nil {
                    map["ConditionControlModuleCode"] = self.conditionControlModuleCode!
                }
                if self.conditionControlModuleValue != nil {
                    map["ConditionControlModuleValue"] = self.conditionControlModuleValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConditionControlModuleCode") {
                    self.conditionControlModuleCode = dict["ConditionControlModuleCode"] as! String
                }
                if dict.keys.contains("ConditionControlModuleValue") {
                    self.conditionControlModuleValue = dict["ConditionControlModuleValue"] as! String
                }
            }
        }
        public class ModuleValue : Tea.TeaModel {
            public var moduleMaxValue: String?

            public var moduleMinValue: String?

            public var moduleValue: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.moduleMaxValue != nil {
                    map["ModuleMaxValue"] = self.moduleMaxValue!
                }
                if self.moduleMinValue != nil {
                    map["ModuleMinValue"] = self.moduleMinValue!
                }
                if self.moduleValue != nil {
                    map["ModuleValue"] = self.moduleValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ModuleMaxValue") {
                    self.moduleMaxValue = dict["ModuleMaxValue"] as! String
                }
                if dict.keys.contains("ModuleMinValue") {
                    self.moduleMinValue = dict["ModuleMinValue"] as! String
                }
                if dict.keys.contains("ModuleValue") {
                    self.moduleValue = dict["ModuleValue"] as! [String]
                }
            }
        }
        public var conditionControls: [UpdateEnsSaleControlRequest.SaleControls.ConditionControls]?

        public var description_: String?

        public var moduleCode: String?

        public var moduleValue: UpdateEnsSaleControlRequest.SaleControls.ModuleValue?

        public var operator_: String?

        public var orderType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.moduleValue?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditionControls != nil {
                var tmp : [Any] = []
                for k in self.conditionControls! {
                    tmp.append(k.toMap())
                }
                map["ConditionControls"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.moduleCode != nil {
                map["ModuleCode"] = self.moduleCode!
            }
            if self.moduleValue != nil {
                map["ModuleValue"] = self.moduleValue?.toMap()
            }
            if self.operator_ != nil {
                map["Operator"] = self.operator_!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConditionControls") {
                var tmp : [UpdateEnsSaleControlRequest.SaleControls.ConditionControls] = []
                for v in dict["ConditionControls"] as! [Any] {
                    var model = UpdateEnsSaleControlRequest.SaleControls.ConditionControls()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.conditionControls = tmp
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModuleCode") {
                self.moduleCode = dict["ModuleCode"] as! String
            }
            if dict.keys.contains("ModuleValue") {
                var model = UpdateEnsSaleControlRequest.SaleControls.ModuleValue()
                model.fromMap(dict["ModuleValue"] as! [String: Any])
                self.moduleValue = model
            }
            if dict.keys.contains("Operator") {
                self.operator_ = dict["Operator"] as! String
            }
            if dict.keys.contains("OrderType") {
                self.orderType = dict["OrderType"] as! String
            }
        }
    }
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var saleControls: [UpdateEnsSaleControlRequest.SaleControls]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.saleControls != nil {
            var tmp : [Any] = []
            for k in self.saleControls! {
                tmp.append(k.toMap())
            }
            map["SaleControls"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("SaleControls") {
            var tmp : [UpdateEnsSaleControlRequest.SaleControls] = []
            for v in dict["SaleControls"] as! [Any] {
                var model = UpdateEnsSaleControlRequest.SaleControls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.saleControls = tmp
        }
    }
}

public class UpdateEnsSaleControlShrinkRequest : Tea.TeaModel {
    public var aliUidAccount: String?

    public var commodityCode: String?

    public var customAccount: String?

    public var saleControlsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUidAccount != nil {
            map["AliUidAccount"] = self.aliUidAccount!
        }
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.customAccount != nil {
            map["CustomAccount"] = self.customAccount!
        }
        if self.saleControlsShrink != nil {
            map["SaleControls"] = self.saleControlsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUidAccount") {
            self.aliUidAccount = dict["AliUidAccount"] as! String
        }
        if dict.keys.contains("CommodityCode") {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CustomAccount") {
            self.customAccount = dict["CustomAccount"] as! String
        }
        if dict.keys.contains("SaleControls") {
            self.saleControlsShrink = dict["SaleControls"] as! String
        }
    }
}

public class UpdateEnsSaleControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEnsSaleControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEnsSaleControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEnsSaleControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeAICInstanceImageRequest : Tea.TeaModel {
    public var imageId: String?

    public var serverIds: [String]?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.serverIds != nil {
            map["ServerIds"] = self.serverIds!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ServerIds") {
            self.serverIds = dict["ServerIds"] as! [String]
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpgradeAICInstanceImageShrinkRequest : Tea.TeaModel {
    public var imageId: String?

    public var serverIdsShrink: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.serverIdsShrink != nil {
            map["ServerIds"] = self.serverIdsShrink!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ServerIds") {
            self.serverIdsShrink = dict["ServerIds"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpgradeAICInstanceImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpgradeAICInstanceImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeAICInstanceImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeAICInstanceImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var template: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int32
        }
    }
}

public class UpgradeApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class UpgradeApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
