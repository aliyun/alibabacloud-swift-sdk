import Foundation
import Tea
import TeaUtils
import AlibabaCloudOssSdk
import AlibabacloudOpenPlatform20191219
import AlibabaCloudOSSUtil
import TeaFileForm
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class Catalog : Tea.TeaModel {
    public var comment: String?

    public var createTime: Int64?

    public var id: String?

    public var modifyTime: Int64?

    public var name: String?

    public var parentMetaEntityId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.modifyTime != nil {
            map["ModifyTime"] = self.modifyTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["ModifyTime"] as? Int64 {
            self.modifyTime = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class Column : Tea.TeaModel {
    public class BusinessMetadata : Tea.TeaModel {
        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
        }
    }
    public var businessMetadata: Column.BusinessMetadata?

    public var comment: String?

    public var foreignKey: Bool?

    public var id: String?

    public var name: String?

    public var partitionKey: Bool?

    public var position: Int32?

    public var primaryKey: Bool?

    public var tableId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.businessMetadata?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessMetadata != nil {
            map["BusinessMetadata"] = self.businessMetadata?.toMap()
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.foreignKey != nil {
            map["ForeignKey"] = self.foreignKey!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.partitionKey != nil {
            map["PartitionKey"] = self.partitionKey!
        }
        if self.position != nil {
            map["Position"] = self.position!
        }
        if self.primaryKey != nil {
            map["PrimaryKey"] = self.primaryKey!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessMetadata"] as? [String: Any?] {
            var model = Column.BusinessMetadata()
            model.fromMap(value)
            self.businessMetadata = model
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["ForeignKey"] as? Bool {
            self.foreignKey = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PartitionKey"] as? Bool {
            self.partitionKey = value
        }
        if let value = dict["Position"] as? Int32 {
            self.position = value
        }
        if let value = dict["PrimaryKey"] as? Bool {
            self.primaryKey = value
        }
        if let value = dict["TableId"] as? String {
            self.tableId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CrawlerType : Tea.TeaModel {
    public class SupportedEntityTypes : Tea.TeaModel {
        public var optional_: Bool?

        public var parentSubType: String?

        public var subType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.optional_ != nil {
                map["Optional"] = self.optional_!
            }
            if self.parentSubType != nil {
                map["ParentSubType"] = self.parentSubType!
            }
            if self.subType != nil {
                map["SubType"] = self.subType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Optional"] as? Bool {
                self.optional_ = value
            }
            if let value = dict["ParentSubType"] as? String {
                self.parentSubType = value
            }
            if let value = dict["SubType"] as? String {
                self.subType = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var displayName: String?

    public var supportedEntityTypes: [CrawlerType.SupportedEntityTypes]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.supportedEntityTypes != nil {
            var tmp : [Any] = []
            for k in self.supportedEntityTypes! {
                tmp.append(k.toMap())
            }
            map["SupportedEntityTypes"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DisplayName"] as? String {
            self.displayName = value
        }
        if let value = dict["SupportedEntityTypes"] as? [Any?] {
            var tmp : [CrawlerType.SupportedEntityTypes] = []
            for v in value {
                if v != nil {
                    var model = CrawlerType.SupportedEntityTypes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.supportedEntityTypes = tmp
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DataQualityEvaluationTask : Tea.TeaModel {
    public class Hooks : Tea.TeaModel {
        public var condition: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Condition"] as? String {
                self.condition = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class Notifications : Tea.TeaModel {
        public class Notifications : Tea.TeaModel {
            public class NotificationChannels : Tea.TeaModel {
                public var channels: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Channels"] as? [String] {
                        self.channels = value
                    }
                }
            }
            public class NotificationReceivers : Tea.TeaModel {
                public var extension_: String?

                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Extension"] as? String {
                        self.extension_ = value
                    }
                    if let value = dict["ReceiverType"] as? String {
                        self.receiverType = value
                    }
                    if let value = dict["ReceiverValues"] as? [String] {
                        self.receiverValues = value
                    }
                }
            }
            public var notificationChannels: [DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels]?

            public var notificationReceivers: [DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notificationChannels != nil {
                    var tmp : [Any] = []
                    for k in self.notificationChannels! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationChannels"] = tmp
                }
                if self.notificationReceivers != nil {
                    var tmp : [Any] = []
                    for k in self.notificationReceivers! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationReceivers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NotificationChannels"] as? [Any?] {
                    var tmp : [DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels] = []
                    for v in value {
                        if v != nil {
                            var model = DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notificationChannels = tmp
                }
                if let value = dict["NotificationReceivers"] as? [Any?] {
                    var tmp : [DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers] = []
                    for v in value {
                        if v != nil {
                            var model = DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notificationReceivers = tmp
                }
            }
        }
        public var condition: String?

        public var notifications: [DataQualityEvaluationTask.Notifications.Notifications]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.notifications != nil {
                var tmp : [Any] = []
                for k in self.notifications! {
                    tmp.append(k.toMap())
                }
                map["Notifications"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Condition"] as? String {
                self.condition = value
            }
            if let value = dict["Notifications"] as? [Any?] {
                var tmp : [DataQualityEvaluationTask.Notifications.Notifications] = []
                for v in value {
                    if v != nil {
                        var model = DataQualityEvaluationTask.Notifications.Notifications()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notifications = tmp
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DatabaseType"] as? String {
                self.databaseType = value
            }
            if let value = dict["PartitionSpec"] as? String {
                self.partitionSpec = value
            }
            if let value = dict["TableGuid"] as? String {
                self.tableGuid = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class Trigger : Tea.TeaModel {
        public var taskIds: [Int64]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TaskIds"] as? [Int64] {
                self.taskIds = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var dataSourceId: Int64?

    public var description_: String?

    public var hooks: [DataQualityEvaluationTask.Hooks]?

    public var id: Int64?

    public var name: String?

    public var notifications: [DataQualityEvaluationTask.Notifications]?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var target: DataQualityEvaluationTask.Target?

    public var tenantId: Int64?

    public var trigger: DataQualityEvaluationTask.Trigger?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.target?.validate()
        try self.trigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooks != nil {
            var tmp : [Any] = []
            for k in self.hooks! {
                tmp.append(k.toMap())
            }
            map["Hooks"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifications != nil {
            var tmp : [Any] = []
            for k in self.notifications! {
                tmp.append(k.toMap())
            }
            map["Notifications"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.trigger != nil {
            map["Trigger"] = self.trigger?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Hooks"] as? [Any?] {
            var tmp : [DataQualityEvaluationTask.Hooks] = []
            for v in value {
                if v != nil {
                    var model = DataQualityEvaluationTask.Hooks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hooks = tmp
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Notifications"] as? [Any?] {
            var tmp : [DataQualityEvaluationTask.Notifications] = []
            for v in value {
                if v != nil {
                    var model = DataQualityEvaluationTask.Notifications()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.notifications = tmp
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeConf"] as? String {
            self.runtimeConf = value
        }
        if let value = dict["Target"] as? [String: Any?] {
            var model = DataQualityEvaluationTask.Target()
            model.fromMap(value)
            self.target = model
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
        if let value = dict["Trigger"] as? [String: Any?] {
            var model = DataQualityEvaluationTask.Trigger()
            model.fromMap(value)
            self.trigger = model
        }
    }
}

public class DataQualityEvaluationTaskInstance : Tea.TeaModel {
    public class Task : Tea.TeaModel {
        public class Hooks : Tea.TeaModel {
            public var condition: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Condition"] as? String {
                    self.condition = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class Notifications : Tea.TeaModel {
            public class Notifications : Tea.TeaModel {
                public class NotificationChannels : Tea.TeaModel {
                    public var channels: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Channels"] as? [String] {
                            self.channels = value
                        }
                    }
                }
                public class NotificationReceivers : Tea.TeaModel {
                    public var extension_: String?

                    public var receiverType: String?

                    public var receiverValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extension_ != nil {
                            map["Extension"] = self.extension_!
                        }
                        if self.receiverType != nil {
                            map["ReceiverType"] = self.receiverType!
                        }
                        if self.receiverValues != nil {
                            map["ReceiverValues"] = self.receiverValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Extension"] as? String {
                            self.extension_ = value
                        }
                        if let value = dict["ReceiverType"] as? String {
                            self.receiverType = value
                        }
                        if let value = dict["ReceiverValues"] as? [String] {
                            self.receiverValues = value
                        }
                    }
                }
                public var notificationChannels: [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels]?

                public var notificationReceivers: [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.notificationChannels != nil {
                        var tmp : [Any] = []
                        for k in self.notificationChannels! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationChannels"] = tmp
                    }
                    if self.notificationReceivers != nil {
                        var tmp : [Any] = []
                        for k in self.notificationReceivers! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationReceivers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NotificationChannels"] as? [Any?] {
                        var tmp : [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels] = []
                        for v in value {
                            if v != nil {
                                var model = DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notificationChannels = tmp
                    }
                    if let value = dict["NotificationReceivers"] as? [Any?] {
                        var tmp : [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers] = []
                        for v in value {
                            if v != nil {
                                var model = DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notificationReceivers = tmp
                    }
                }
            }
            public var condition: String?

            public var notifications: [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.notifications != nil {
                    var tmp : [Any] = []
                    for k in self.notifications! {
                        tmp.append(k.toMap())
                    }
                    map["Notifications"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Condition"] as? String {
                    self.condition = value
                }
                if let value = dict["Notifications"] as? [Any?] {
                    var tmp : [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications] = []
                    for v in value {
                        if v != nil {
                            var model = DataQualityEvaluationTaskInstance.Task.Notifications.Notifications()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notifications = tmp
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var databaseType: String?

            public var partitionSpec: String?

            public var tableGuid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseType != nil {
                    map["DatabaseType"] = self.databaseType!
                }
                if self.partitionSpec != nil {
                    map["PartitionSpec"] = self.partitionSpec!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DatabaseType"] as? String {
                    self.databaseType = value
                }
                if let value = dict["PartitionSpec"] as? String {
                    self.partitionSpec = value
                }
                if let value = dict["TableGuid"] as? String {
                    self.tableGuid = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public var taskIds: [Int64]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskIds != nil {
                    map["TaskIds"] = self.taskIds!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TaskIds"] as? [Int64] {
                    self.taskIds = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var dataSourceId: Int64?

        public var hooks: [DataQualityEvaluationTaskInstance.Task.Hooks]?

        public var id: Int64?

        public var name: String?

        public var notifications: [DataQualityEvaluationTaskInstance.Task.Notifications]?

        public var projectId: Int64?

        public var runtimeConf: String?

        public var target: DataQualityEvaluationTaskInstance.Task.Target?

        public var tenantId: Int64?

        public var trigger: DataQualityEvaluationTaskInstance.Task.Trigger?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.target?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceId != nil {
                map["DataSourceId"] = self.dataSourceId!
            }
            if self.hooks != nil {
                var tmp : [Any] = []
                for k in self.hooks! {
                    tmp.append(k.toMap())
                }
                map["Hooks"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifications != nil {
                var tmp : [Any] = []
                for k in self.notifications! {
                    tmp.append(k.toMap())
                }
                map["Notifications"] = tmp
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.runtimeConf != nil {
                map["RuntimeConf"] = self.runtimeConf!
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSourceId"] as? Int64 {
                self.dataSourceId = value
            }
            if let value = dict["Hooks"] as? [Any?] {
                var tmp : [DataQualityEvaluationTaskInstance.Task.Hooks] = []
                for v in value {
                    if v != nil {
                        var model = DataQualityEvaluationTaskInstance.Task.Hooks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hooks = tmp
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Notifications"] as? [Any?] {
                var tmp : [DataQualityEvaluationTaskInstance.Task.Notifications] = []
                for v in value {
                    if v != nil {
                        var model = DataQualityEvaluationTaskInstance.Task.Notifications()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notifications = tmp
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["RuntimeConf"] as? String {
                self.runtimeConf = value
            }
            if let value = dict["Target"] as? [String: Any?] {
                var model = DataQualityEvaluationTaskInstance.Task.Target()
                model.fromMap(value)
                self.target = model
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = DataQualityEvaluationTaskInstance.Task.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
        }
    }
    public var createTime: Int64?

    public var finishTime: Int64?

    public var id: Int64?

    public var status: String?

    public var task: DataQualityEvaluationTaskInstance.Task?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.task?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.finishTime != nil {
            map["FinishTime"] = self.finishTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.task != nil {
            map["Task"] = self.task?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["FinishTime"] as? Int64 {
            self.finishTime = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Task"] as? [String: Any?] {
            var model = DataQualityEvaluationTaskInstance.Task()
            model.fromMap(value)
            self.task = model
        }
    }
}

public class DataQualityResult : Tea.TeaModel {
    public class Details : Tea.TeaModel {
        public var checkedValue: String?

        public var referencedValue: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkedValue != nil {
                map["CheckedValue"] = self.checkedValue!
            }
            if self.referencedValue != nil {
                map["ReferencedValue"] = self.referencedValue!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CheckedValue"] as? String {
                self.checkedValue = value
            }
            if let value = dict["ReferencedValue"] as? String {
                self.referencedValue = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public class Rule : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public class Thresholds : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public class Expected : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public class Warned : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var critical: DataQualityResult.Rule.CheckingConfig.Thresholds.Critical?

                public var expected: DataQualityResult.Rule.CheckingConfig.Thresholds.Expected?

                public var warned: DataQualityResult.Rule.CheckingConfig.Thresholds.Warned?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.expected?.validate()
                    try self.warned?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.expected != nil {
                        map["Expected"] = self.expected?.toMap()
                    }
                    if self.warned != nil {
                        map["Warned"] = self.warned?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Critical"] as? [String: Any?] {
                        var model = DataQualityResult.Rule.CheckingConfig.Thresholds.Critical()
                        model.fromMap(value)
                        self.critical = model
                    }
                    if let value = dict["Expected"] as? [String: Any?] {
                        var model = DataQualityResult.Rule.CheckingConfig.Thresholds.Expected()
                        model.fromMap(value)
                        self.expected = model
                    }
                    if let value = dict["Warned"] as? [String: Any?] {
                        var model = DataQualityResult.Rule.CheckingConfig.Thresholds.Warned()
                        model.fromMap(value)
                        self.warned = model
                    }
                }
            }
            public var referencedSamplesFilter: String?

            public var thresholds: DataQualityResult.Rule.CheckingConfig.Thresholds?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.thresholds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.thresholds != nil {
                    map["Thresholds"] = self.thresholds?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReferencedSamplesFilter"] as? String {
                    self.referencedSamplesFilter = value
                }
                if let value = dict["Thresholds"] as? [String: Any?] {
                    var model = DataQualityResult.Rule.CheckingConfig.Thresholds()
                    model.fromMap(value)
                    self.thresholds = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class ErrorHandlers : Tea.TeaModel {
            public var errorDataFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorDataFilter != nil {
                    map["ErrorDataFilter"] = self.errorDataFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorDataFilter"] as? String {
                    self.errorDataFilter = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var samplingFilter: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.samplingFilter != nil {
                    map["SamplingFilter"] = self.samplingFilter!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Metric"] as? String {
                    self.metric = value
                }
                if let value = dict["MetricParameters"] as? String {
                    self.metricParameters = value
                }
                if let value = dict["SamplingFilter"] as? String {
                    self.samplingFilter = value
                }
                if let value = dict["SettingConfig"] as? String {
                    self.settingConfig = value
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var databaseType: String?

            public var partitionSpec: String?

            public var tableGuid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseType != nil {
                    map["DatabaseType"] = self.databaseType!
                }
                if self.partitionSpec != nil {
                    map["PartitionSpec"] = self.partitionSpec!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DatabaseType"] as? String {
                    self.databaseType = value
                }
                if let value = dict["PartitionSpec"] as? String {
                    self.partitionSpec = value
                }
                if let value = dict["TableGuid"] as? String {
                    self.tableGuid = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var checkingConfig: DataQualityResult.Rule.CheckingConfig?

        public var description_: String?

        public var enabled: Bool?

        public var errorHandlers: [DataQualityResult.Rule.ErrorHandlers]?

        public var id: Int64?

        public var name: String?

        public var projectId: Int64?

        public var samplingConfig: DataQualityResult.Rule.SamplingConfig?

        public var severity: String?

        public var target: DataQualityResult.Rule.Target?

        public var templateCode: String?

        public var tenantId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.errorHandlers != nil {
                var tmp : [Any] = []
                for k in self.errorHandlers! {
                    tmp.append(k.toMap())
                }
                map["ErrorHandlers"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.templateCode != nil {
                map["TemplateCode"] = self.templateCode!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CheckingConfig"] as? [String: Any?] {
                var model = DataQualityResult.Rule.CheckingConfig()
                model.fromMap(value)
                self.checkingConfig = model
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["ErrorHandlers"] as? [Any?] {
                var tmp : [DataQualityResult.Rule.ErrorHandlers] = []
                for v in value {
                    if v != nil {
                        var model = DataQualityResult.Rule.ErrorHandlers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.errorHandlers = tmp
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["SamplingConfig"] as? [String: Any?] {
                var model = DataQualityResult.Rule.SamplingConfig()
                model.fromMap(value)
                self.samplingConfig = model
            }
            if let value = dict["Severity"] as? String {
                self.severity = value
            }
            if let value = dict["Target"] as? [String: Any?] {
                var model = DataQualityResult.Rule.Target()
                model.fromMap(value)
                self.target = model
            }
            if let value = dict["TemplateCode"] as? String {
                self.templateCode = value
            }
            if let value = dict["TenantId"] as? Int64 {
                self.tenantId = value
            }
        }
    }
    public var details: [DataQualityResult.Details]?

    public var id: Int64?

    public var rule: DataQualityResult.Rule?

    public var sample: String?

    public var status: String?

    public var taskInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.rule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.details != nil {
            var tmp : [Any] = []
            for k in self.details! {
                tmp.append(k.toMap())
            }
            map["Details"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.rule != nil {
            map["Rule"] = self.rule?.toMap()
        }
        if self.sample != nil {
            map["Sample"] = self.sample!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskInstanceId != nil {
            map["TaskInstanceId"] = self.taskInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Details"] as? [Any?] {
            var tmp : [DataQualityResult.Details] = []
            for v in value {
                if v != nil {
                    var model = DataQualityResult.Details()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.details = tmp
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Rule"] as? [String: Any?] {
            var model = DataQualityResult.Rule()
            model.fromMap(value)
            self.rule = model
        }
        if let value = dict["Sample"] as? String {
            self.sample = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TaskInstanceId"] as? Int64 {
            self.taskInstanceId = value
        }
    }
}

public class DataQualityRule : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public class Thresholds : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["Operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Expected : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["Operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Warned : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["Operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var critical: DataQualityRule.CheckingConfig.Thresholds.Critical?

            public var expected: DataQualityRule.CheckingConfig.Thresholds.Expected?

            public var warned: DataQualityRule.CheckingConfig.Thresholds.Warned?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.expected?.validate()
                try self.warned?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.expected != nil {
                    map["Expected"] = self.expected?.toMap()
                }
                if self.warned != nil {
                    map["Warned"] = self.warned?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Critical"] as? [String: Any?] {
                    var model = DataQualityRule.CheckingConfig.Thresholds.Critical()
                    model.fromMap(value)
                    self.critical = model
                }
                if let value = dict["Expected"] as? [String: Any?] {
                    var model = DataQualityRule.CheckingConfig.Thresholds.Expected()
                    model.fromMap(value)
                    self.expected = model
                }
                if let value = dict["Warned"] as? [String: Any?] {
                    var model = DataQualityRule.CheckingConfig.Thresholds.Warned()
                    model.fromMap(value)
                    self.warned = model
                }
            }
        }
        public var referencedSamplesFilter: String?

        public var thresholds: DataQualityRule.CheckingConfig.Thresholds?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.thresholds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.thresholds != nil {
                map["Thresholds"] = self.thresholds?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReferencedSamplesFilter"] as? String {
                self.referencedSamplesFilter = value
            }
            if let value = dict["Thresholds"] as? [String: Any?] {
                var model = DataQualityRule.CheckingConfig.Thresholds()
                model.fromMap(value)
                self.thresholds = model
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class ErrorHandlers : Tea.TeaModel {
        public var errorDataFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorDataFilter != nil {
                map["ErrorDataFilter"] = self.errorDataFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorDataFilter"] as? String {
                self.errorDataFilter = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var samplingFilter: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.samplingFilter != nil {
                map["SamplingFilter"] = self.samplingFilter!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Metric"] as? String {
                self.metric = value
            }
            if let value = dict["MetricParameters"] as? String {
                self.metricParameters = value
            }
            if let value = dict["SamplingFilter"] as? String {
                self.samplingFilter = value
            }
            if let value = dict["SettingConfig"] as? String {
                self.settingConfig = value
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DatabaseType"] as? String {
                self.databaseType = value
            }
            if let value = dict["PartitionSpec"] as? String {
                self.partitionSpec = value
            }
            if let value = dict["TableGuid"] as? String {
                self.tableGuid = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var checkingConfig: DataQualityRule.CheckingConfig?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlers: [DataQualityRule.ErrorHandlers]?

    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: DataQualityRule.SamplingConfig?

    public var severity: String?

    public var target: DataQualityRule.Target?

    public var templateCode: String?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
        try self.target?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlers != nil {
            var tmp : [Any] = []
            for k in self.errorHandlers! {
                tmp.append(k.toMap())
            }
            map["ErrorHandlers"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? [String: Any?] {
            var model = DataQualityRule.CheckingConfig()
            model.fromMap(value)
            self.checkingConfig = model
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["ErrorHandlers"] as? [Any?] {
            var tmp : [DataQualityRule.ErrorHandlers] = []
            for v in value {
                if v != nil {
                    var model = DataQualityRule.ErrorHandlers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.errorHandlers = tmp
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? [String: Any?] {
            var model = DataQualityRule.SamplingConfig()
            model.fromMap(value)
            self.samplingConfig = model
        }
        if let value = dict["Severity"] as? String {
            self.severity = value
        }
        if let value = dict["Target"] as? [String: Any?] {
            var model = DataQualityRule.Target()
            model.fromMap(value)
            self.target = model
        }
        if let value = dict["TemplateCode"] as? String {
            self.templateCode = value
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
    }
}

public class DataQualityRuleTemplate : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public var referencedSamplesFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReferencedSamplesFilter"] as? String {
                self.referencedSamplesFilter = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Metric"] as? String {
                self.metric = value
            }
            if let value = dict["MetricParameters"] as? String {
                self.metricParameters = value
            }
            if let value = dict["SettingConfig"] as? String {
                self.settingConfig = value
            }
        }
    }
    public var checkingConfig: DataQualityRuleTemplate.CheckingConfig?

    public var code: String?

    public var directoryPath: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: DataQualityRuleTemplate.SamplingConfig?

    public var tenantId: Int64?

    public var visibleScope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.visibleScope != nil {
            map["VisibleScope"] = self.visibleScope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? [String: Any?] {
            var model = DataQualityRuleTemplate.CheckingConfig()
            model.fromMap(value)
            self.checkingConfig = model
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["DirectoryPath"] as? String {
            self.directoryPath = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? [String: Any?] {
            var model = DataQualityRuleTemplate.SamplingConfig()
            model.fromMap(value)
            self.samplingConfig = model
        }
        if let value = dict["TenantId"] as? Int64 {
            self.tenantId = value
        }
        if let value = dict["VisibleScope"] as? String {
            self.visibleScope = value
        }
    }
}

public class Database : Tea.TeaModel {
    public var comment: String?

    public var createTime: Int64?

    public var id: String?

    public var locationUri: String?

    public var modifyTime: Int64?

    public var name: String?

    public var parentMetaEntityId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.locationUri != nil {
            map["LocationUri"] = self.locationUri!
        }
        if self.modifyTime != nil {
            map["ModifyTime"] = self.modifyTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["LocationUri"] as? String {
            self.locationUri = value
        }
        if let value = dict["ModifyTime"] as? Int64 {
            self.modifyTime = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
    }
}

public class LineageEntity : Tea.TeaModel {
    public var attributes: [String: String]?

    public var id: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Attributes"] as? [String: String] {
            self.attributes = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class LineageRelationship : Tea.TeaModel {
    public var createTime: Int64?

    public var dstEntity: LineageEntity?

    public var id: String?

    public var srcEntity: LineageEntity?

    public var task: LineageTask?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dstEntity?.validate()
        try self.srcEntity?.validate()
        try self.task?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dstEntity != nil {
            map["DstEntity"] = self.dstEntity?.toMap()
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.srcEntity != nil {
            map["SrcEntity"] = self.srcEntity?.toMap()
        }
        if self.task != nil {
            map["Task"] = self.task?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["DstEntity"] as? [String: Any?] {
            var model = LineageEntity()
            model.fromMap(value)
            self.dstEntity = model
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["SrcEntity"] as? [String: Any?] {
            var model = LineageEntity()
            model.fromMap(value)
            self.srcEntity = model
        }
        if let value = dict["Task"] as? [String: Any?] {
            var model = LineageTask()
            model.fromMap(value)
            self.task = model
        }
    }
}

public class LineageTask : Tea.TeaModel {
    public var attributes: [String: String]?

    public var id: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Attributes"] as? [String: String] {
            self.attributes = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class Partition : Tea.TeaModel {
    public var createTime: Int64?

    public var dataSize: Int64?

    public var modifyTime: Int64?

    public var name: String?

    public var recordCount: Int64?

    public var tableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dataSize != nil {
            map["DataSize"] = self.dataSize!
        }
        if self.modifyTime != nil {
            map["ModifyTime"] = self.modifyTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.recordCount != nil {
            map["RecordCount"] = self.recordCount!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["DataSize"] as? Int64 {
            self.dataSize = value
        }
        if let value = dict["ModifyTime"] as? Int64 {
            self.modifyTime = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["RecordCount"] as? Int64 {
            self.recordCount = value
        }
        if let value = dict["TableId"] as? String {
            self.tableId = value
        }
    }
}

public class Schema : Tea.TeaModel {
    public var comment: String?

    public var createTime: Int64?

    public var id: String?

    public var modifyTime: Int64?

    public var name: String?

    public var parentMetaEntityId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.modifyTime != nil {
            map["ModifyTime"] = self.modifyTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["ModifyTime"] as? Int64 {
            self.modifyTime = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class Table : Tea.TeaModel {
    public class BusinessMetadata : Tea.TeaModel {
        public class Categories : Tea.TeaModel {
            public var id: String?

            public var name: String?

            public var parentId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ParentId"] as? String {
                    self.parentId = value
                }
            }
        }
        public class Extension_ : Tea.TeaModel {
            public var envType: String?

            public var favorCount: Int64?

            public var projectId: Int64?

            public var readCount: Int64?

            public var viewCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.favorCount != nil {
                    map["FavorCount"] = self.favorCount!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.readCount != nil {
                    map["ReadCount"] = self.readCount!
                }
                if self.viewCount != nil {
                    map["ViewCount"] = self.viewCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["FavorCount"] as? Int64 {
                    self.favorCount = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["ReadCount"] as? Int64 {
                    self.readCount = value
                }
                if let value = dict["ViewCount"] as? Int64 {
                    self.viewCount = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class UpstreamTasks : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var categories: [[Table.BusinessMetadata.Categories]]?

        public var extension_: Table.BusinessMetadata.Extension_?

        public var readme: String?

        public var tags: [Table.BusinessMetadata.Tags]?

        public var upstreamTasks: [Table.BusinessMetadata.UpstreamTasks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extension_?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    var l1 : [Any] = []
                    for k1 in k {
                        l1.append(k1.toMap())
                    }
                    tmp.append(l1)
                }
                map["Categories"] = tmp
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_?.toMap()
            }
            if self.readme != nil {
                map["Readme"] = self.readme!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.upstreamTasks != nil {
                var tmp : [Any] = []
                for k in self.upstreamTasks! {
                    tmp.append(k.toMap())
                }
                map["UpstreamTasks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Categories"] as? [Any?] {
                var tmp : [[Table.BusinessMetadata.Categories]] = []
                for v in value {
                    if v != nil {
                        var l1 : [Table.BusinessMetadata.Categories] = []
                        for v1 in v as! [Any?] {
                            if v1 != nil {
                                var model = Table.BusinessMetadata.Categories()
                                if v1 != nil {
                                    model.fromMap(v1 as? [String: Any?])
                                }
                                l1.append(model)
                            }
                        }
                        tmp.append(l1)
                    }
                }
                self.categories = tmp
            }
            if let value = dict["Extension"] as? [String: Any?] {
                var model = Table.BusinessMetadata.Extension_()
                model.fromMap(value)
                self.extension_ = model
            }
            if let value = dict["Readme"] as? String {
                self.readme = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [Table.BusinessMetadata.Tags] = []
                for v in value {
                    if v != nil {
                        var model = Table.BusinessMetadata.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["UpstreamTasks"] as? [Any?] {
                var tmp : [Table.BusinessMetadata.UpstreamTasks] = []
                for v in value {
                    if v != nil {
                        var model = Table.BusinessMetadata.UpstreamTasks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.upstreamTasks = tmp
            }
        }
    }
    public class TechnicalMetadata : Tea.TeaModel {
        public var compressed: Bool?

        public var inputFormat: String?

        public var location: String?

        public var outputFormat: String?

        public var owner: String?

        public var parameters: [String: String]?

        public var serializationLibrary: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.compressed != nil {
                map["Compressed"] = self.compressed!
            }
            if self.inputFormat != nil {
                map["InputFormat"] = self.inputFormat!
            }
            if self.location != nil {
                map["Location"] = self.location!
            }
            if self.outputFormat != nil {
                map["OutputFormat"] = self.outputFormat!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.parameters != nil {
                map["Parameters"] = self.parameters!
            }
            if self.serializationLibrary != nil {
                map["SerializationLibrary"] = self.serializationLibrary!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Compressed"] as? Bool {
                self.compressed = value
            }
            if let value = dict["InputFormat"] as? String {
                self.inputFormat = value
            }
            if let value = dict["Location"] as? String {
                self.location = value
            }
            if let value = dict["OutputFormat"] as? String {
                self.outputFormat = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Parameters"] as? [String: String] {
                self.parameters = value
            }
            if let value = dict["SerializationLibrary"] as? String {
                self.serializationLibrary = value
            }
        }
    }
    public var businessMetadata: Table.BusinessMetadata?

    public var comment: String?

    public var createTime: Int64?

    public var id: String?

    public var modifyTime: Int64?

    public var name: String?

    public var parentMetaEntityId: String?

    public var partitionKeys: [String]?

    public var tableType: String?

    public var technicalMetadata: Table.TechnicalMetadata?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.businessMetadata?.validate()
        try self.technicalMetadata?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessMetadata != nil {
            map["BusinessMetadata"] = self.businessMetadata?.toMap()
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.modifyTime != nil {
            map["ModifyTime"] = self.modifyTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.partitionKeys != nil {
            map["PartitionKeys"] = self.partitionKeys!
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        if self.technicalMetadata != nil {
            map["TechnicalMetadata"] = self.technicalMetadata?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BusinessMetadata"] as? [String: Any?] {
            var model = Table.BusinessMetadata()
            model.fromMap(value)
            self.businessMetadata = model
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["ModifyTime"] as? Int64 {
            self.modifyTime = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["PartitionKeys"] as? [String] {
            self.partitionKeys = value
        }
        if let value = dict["TableType"] as? String {
            self.tableType = value
        }
        if let value = dict["TechnicalMetadata"] as? [String: Any?] {
            var model = Table.TechnicalMetadata()
            model.fromMap(value)
            self.technicalMetadata = model
        }
    }
}

public class SuccessInfoValue : Tea.TeaModel {
    public var success: Bool?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
    }
}

public class AbolishPipelineRunRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class AbolishPipelineRunResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AbolishPipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbolishPipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AbolishPipelineRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddEntityIntoMetaCollectionRequest : Tea.TeaModel {
    public var id: String?

    public var metaCollectionId: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.metaCollectionId != nil {
            map["MetaCollectionId"] = self.metaCollectionId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["MetaCollectionId"] as? String {
            self.metaCollectionId = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class AddEntityIntoMetaCollectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddEntityIntoMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEntityIntoMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddEntityIntoMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AssociateProjectToResourceGroupRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class AssociateProjectToResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AssociateProjectToResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateProjectToResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AssociateProjectToResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachDataQualityRulesToEvaluationTaskRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityRuleIds: [Int64]?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityRuleIds != nil {
            map["DataQualityRuleIds"] = self.dataQualityRuleIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityEvaluationTaskId"] as? Int64 {
            self.dataQualityEvaluationTaskId = value
        }
        if let value = dict["DataQualityRuleIds"] as? [Int64] {
            self.dataQualityRuleIds = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class AttachDataQualityRulesToEvaluationTaskShrinkRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityRuleIdsShrink: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityRuleIdsShrink != nil {
            map["DataQualityRuleIds"] = self.dataQualityRuleIdsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityEvaluationTaskId"] as? Int64 {
            self.dataQualityEvaluationTaskId = value
        }
        if let value = dict["DataQualityRuleIds"] as? String {
            self.dataQualityRuleIdsShrink = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class AttachDataQualityRulesToEvaluationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class AttachDataQualityRulesToEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDataQualityRulesToEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachDataQualityRulesToEvaluationTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BatchUpdateTasksRequest : Tea.TeaModel {
    public class Tasks : Tea.TeaModel {
        public class DataSource : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class RuntimeResource : Tea.TeaModel {
            public var cu: String?

            public var image: String?

            public var resourceGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cu != nil {
                    map["Cu"] = self.cu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cu"] as? String {
                    self.cu = value
                }
                if let value = dict["Image"] as? String {
                    self.image = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public var cron: String?

            public var endTime: String?

            public var recurrence: String?

            public var startTime: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cron != nil {
                    map["Cron"] = self.cron!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.recurrence != nil {
                    map["Recurrence"] = self.recurrence!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cron"] as? String {
                    self.cron = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["Recurrence"] as? String {
                    self.recurrence = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var dataSource: BatchUpdateTasksRequest.Tasks.DataSource?

        public var description_: String?

        public var envType: String?

        public var id: Int64?

        public var name: String?

        public var owner: String?

        public var rerunInterval: Int32?

        public var rerunMode: String?

        public var rerunTimes: Int32?

        public var runtimeResource: BatchUpdateTasksRequest.Tasks.RuntimeResource?

        public var tags: [BatchUpdateTasksRequest.Tasks.Tags]?

        public var timeout: Int32?

        public var trigger: BatchUpdateTasksRequest.Tasks.Trigger?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSource?.validate()
            try self.runtimeResource?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.rerunInterval != nil {
                map["RerunInterval"] = self.rerunInterval!
            }
            if self.rerunMode != nil {
                map["RerunMode"] = self.rerunMode!
            }
            if self.rerunTimes != nil {
                map["RerunTimes"] = self.rerunTimes!
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource?.toMap()
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSource"] as? [String: Any?] {
                var model = BatchUpdateTasksRequest.Tasks.DataSource()
                model.fromMap(value)
                self.dataSource = model
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EnvType"] as? String {
                self.envType = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["RerunInterval"] as? Int32 {
                self.rerunInterval = value
            }
            if let value = dict["RerunMode"] as? String {
                self.rerunMode = value
            }
            if let value = dict["RerunTimes"] as? Int32 {
                self.rerunTimes = value
            }
            if let value = dict["RuntimeResource"] as? [String: Any?] {
                var model = BatchUpdateTasksRequest.Tasks.RuntimeResource()
                model.fromMap(value)
                self.runtimeResource = model
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [BatchUpdateTasksRequest.Tasks.Tags] = []
                for v in value {
                    if v != nil {
                        var model = BatchUpdateTasksRequest.Tasks.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["Timeout"] as? Int32 {
                self.timeout = value
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = BatchUpdateTasksRequest.Tasks.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
        }
    }
    public var comment: String?

    public var tasks: [BatchUpdateTasksRequest.Tasks]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.tasks != nil {
            var tmp : [Any] = []
            for k in self.tasks! {
                tmp.append(k.toMap())
            }
            map["Tasks"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Tasks"] as? [Any?] {
            var tmp : [BatchUpdateTasksRequest.Tasks] = []
            for v in value {
                if v != nil {
                    var model = BatchUpdateTasksRequest.Tasks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tasks = tmp
        }
    }
}

public class BatchUpdateTasksShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var tasksShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.tasksShrink != nil {
            map["Tasks"] = self.tasksShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Tasks"] as? String {
            self.tasksShrink = value
        }
    }
}

public class BatchUpdateTasksResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessInfo"] as? [String: Any?] {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class BatchUpdateTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchUpdateTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BatchUpdateTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CloneDataSourceRequest : Tea.TeaModel {
    public var cloneDataSourceName: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloneDataSourceName != nil {
            map["CloneDataSourceName"] = self.cloneDataSourceName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CloneDataSourceName"] as? String {
            self.cloneDataSourceName = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class CloneDataSourceResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CloneDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CloneDataSourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAlertRuleRequest : Tea.TeaModel {
    public class Notification : Tea.TeaModel {
        public class Receivers : Tea.TeaModel {
            public var extension_: String?

            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Extension"] as? String {
                    self.extension_ = value
                }
                if let value = dict["ReceiverType"] as? String {
                    self.receiverType = value
                }
                if let value = dict["ReceiverValues"] as? [String] {
                    self.receiverValues = value
                }
            }
        }
        public var channels: [String]?

        public var intervalInMinutes: Int32?

        public var maximum: Int32?

        public var receivers: [CreateAlertRuleRequest.Notification.Receivers]?

        public var silenceEndTime: String?

        public var silenceStartTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channels != nil {
                map["Channels"] = self.channels!
            }
            if self.intervalInMinutes != nil {
                map["IntervalInMinutes"] = self.intervalInMinutes!
            }
            if self.maximum != nil {
                map["Maximum"] = self.maximum!
            }
            if self.receivers != nil {
                var tmp : [Any] = []
                for k in self.receivers! {
                    tmp.append(k.toMap())
                }
                map["Receivers"] = tmp
            }
            if self.silenceEndTime != nil {
                map["SilenceEndTime"] = self.silenceEndTime!
            }
            if self.silenceStartTime != nil {
                map["SilenceStartTime"] = self.silenceStartTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Channels"] as? [String] {
                self.channels = value
            }
            if let value = dict["IntervalInMinutes"] as? Int32 {
                self.intervalInMinutes = value
            }
            if let value = dict["Maximum"] as? Int32 {
                self.maximum = value
            }
            if let value = dict["Receivers"] as? [Any?] {
                var tmp : [CreateAlertRuleRequest.Notification.Receivers] = []
                for v in value {
                    if v != nil {
                        var model = CreateAlertRuleRequest.Notification.Receivers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.receivers = tmp
            }
            if let value = dict["SilenceEndTime"] as? String {
                self.silenceEndTime = value
            }
            if let value = dict["SilenceStartTime"] as? String {
                self.silenceStartTime = value
            }
        }
    }
    public class TriggerCondition : Tea.TeaModel {
        public class Extension_ : Tea.TeaModel {
            public class CycleUnfinished : Tea.TeaModel {
                public class CycleAndTime : Tea.TeaModel {
                    public var cycleId: Int32?

                    public var time: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleId != nil {
                            map["CycleId"] = self.cycleId!
                        }
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CycleId"] as? Int32 {
                            self.cycleId = value
                        }
                        if let value = dict["Time"] as? String {
                            self.time = value
                        }
                    }
                }
                public var cycleAndTime: [CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleAndTime != nil {
                        var tmp : [Any] = []
                        for k in self.cycleAndTime! {
                            tmp.append(k.toMap())
                        }
                        map["CycleAndTime"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CycleAndTime"] as? [Any?] {
                        var tmp : [CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime] = []
                        for v in value {
                            if v != nil {
                                var model = CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.cycleAndTime = tmp
                    }
                }
            }
            public class Error : Tea.TeaModel {
                public var autoRerunAlertEnabled: Bool?

                public var streamTaskIds: [Int64]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoRerunAlertEnabled != nil {
                        map["AutoRerunAlertEnabled"] = self.autoRerunAlertEnabled!
                    }
                    if self.streamTaskIds != nil {
                        map["StreamTaskIds"] = self.streamTaskIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AutoRerunAlertEnabled"] as? Bool {
                        self.autoRerunAlertEnabled = value
                    }
                    if let value = dict["StreamTaskIds"] as? [Int64] {
                        self.streamTaskIds = value
                    }
                }
            }
            public class InstanceErrorCount : Tea.TeaModel {
                public var count: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Count"] as? Int32 {
                        self.count = value
                    }
                }
            }
            public class InstanceErrorPercentage : Tea.TeaModel {
                public var percentage: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Percentage"] as? Int32 {
                        self.percentage = value
                    }
                }
            }
            public class InstanceTransferFluctuate : Tea.TeaModel {
                public var percentage: Int32?

                public var trend: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    if self.trend != nil {
                        map["Trend"] = self.trend!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Percentage"] as? Int32 {
                        self.percentage = value
                    }
                    if let value = dict["Trend"] as? String {
                        self.trend = value
                    }
                }
            }
            public class Timeout : Tea.TeaModel {
                public var timeoutInMinutes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.timeoutInMinutes != nil {
                        map["TimeoutInMinutes"] = self.timeoutInMinutes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TimeoutInMinutes"] as? Int32 {
                        self.timeoutInMinutes = value
                    }
                }
            }
            public class UnFinished : Tea.TeaModel {
                public var unFinishedTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.unFinishedTime != nil {
                        map["UnFinishedTime"] = self.unFinishedTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["UnFinishedTime"] as? String {
                        self.unFinishedTime = value
                    }
                }
            }
            public var cycleUnfinished: CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished?

            public var error: CreateAlertRuleRequest.TriggerCondition.Extension_.Error?

            public var instanceErrorCount: CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorCount?

            public var instanceErrorPercentage: CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorPercentage?

            public var instanceTransferFluctuate: CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceTransferFluctuate?

            public var timeout: CreateAlertRuleRequest.TriggerCondition.Extension_.Timeout?

            public var unFinished: CreateAlertRuleRequest.TriggerCondition.Extension_.UnFinished?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cycleUnfinished?.validate()
                try self.error?.validate()
                try self.instanceErrorCount?.validate()
                try self.instanceErrorPercentage?.validate()
                try self.instanceTransferFluctuate?.validate()
                try self.timeout?.validate()
                try self.unFinished?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleUnfinished != nil {
                    map["CycleUnfinished"] = self.cycleUnfinished?.toMap()
                }
                if self.error != nil {
                    map["Error"] = self.error?.toMap()
                }
                if self.instanceErrorCount != nil {
                    map["InstanceErrorCount"] = self.instanceErrorCount?.toMap()
                }
                if self.instanceErrorPercentage != nil {
                    map["InstanceErrorPercentage"] = self.instanceErrorPercentage?.toMap()
                }
                if self.instanceTransferFluctuate != nil {
                    map["InstanceTransferFluctuate"] = self.instanceTransferFluctuate?.toMap()
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout?.toMap()
                }
                if self.unFinished != nil {
                    map["UnFinished"] = self.unFinished?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CycleUnfinished"] as? [String: Any?] {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished()
                    model.fromMap(value)
                    self.cycleUnfinished = model
                }
                if let value = dict["Error"] as? [String: Any?] {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.Error()
                    model.fromMap(value)
                    self.error = model
                }
                if let value = dict["InstanceErrorCount"] as? [String: Any?] {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorCount()
                    model.fromMap(value)
                    self.instanceErrorCount = model
                }
                if let value = dict["InstanceErrorPercentage"] as? [String: Any?] {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorPercentage()
                    model.fromMap(value)
                    self.instanceErrorPercentage = model
                }
                if let value = dict["InstanceTransferFluctuate"] as? [String: Any?] {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceTransferFluctuate()
                    model.fromMap(value)
                    self.instanceTransferFluctuate = model
                }
                if let value = dict["Timeout"] as? [String: Any?] {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.Timeout()
                    model.fromMap(value)
                    self.timeout = model
                }
                if let value = dict["UnFinished"] as? [String: Any?] {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.UnFinished()
                    model.fromMap(value)
                    self.unFinished = model
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var allowTasks: [Int64]?

            public var ids: [Int64]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowTasks != nil {
                    map["AllowTasks"] = self.allowTasks!
                }
                if self.ids != nil {
                    map["Ids"] = self.ids!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllowTasks"] as? [Int64] {
                    self.allowTasks = value
                }
                if let value = dict["Ids"] as? [Int64] {
                    self.ids = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var extension_: CreateAlertRuleRequest.TriggerCondition.Extension_?

        public var target: CreateAlertRuleRequest.TriggerCondition.Target?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extension_?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_?.toMap()
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extension"] as? [String: Any?] {
                var model = CreateAlertRuleRequest.TriggerCondition.Extension_()
                model.fromMap(value)
                self.extension_ = model
            }
            if let value = dict["Target"] as? [String: Any?] {
                var model = CreateAlertRuleRequest.TriggerCondition.Target()
                model.fromMap(value)
                self.target = model
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var enabled: Bool?

    public var name: String?

    public var notification: CreateAlertRuleRequest.Notification?

    public var owner: String?

    public var triggerCondition: CreateAlertRuleRequest.TriggerCondition?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notification?.validate()
        try self.triggerCondition?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notification != nil {
            map["Notification"] = self.notification?.toMap()
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.triggerCondition != nil {
            map["TriggerCondition"] = self.triggerCondition?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Notification"] as? [String: Any?] {
            var model = CreateAlertRuleRequest.Notification()
            model.fromMap(value)
            self.notification = model
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["TriggerCondition"] as? [String: Any?] {
            var model = CreateAlertRuleRequest.TriggerCondition()
            model.fromMap(value)
            self.triggerCondition = model
        }
    }
}

public class CreateAlertRuleShrinkRequest : Tea.TeaModel {
    public var enabled: Bool?

    public var name: String?

    public var notificationShrink: String?

    public var owner: String?

    public var triggerConditionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationShrink != nil {
            map["Notification"] = self.notificationShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.triggerConditionShrink != nil {
            map["TriggerCondition"] = self.triggerConditionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Notification"] as? String {
            self.notificationShrink = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["TriggerCondition"] as? String {
            self.triggerConditionShrink = value
        }
    }
}

public class CreateAlertRuleResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAlertRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDIAlarmRuleRequest : Tea.TeaModel {
    public class NotificationSettings : Tea.TeaModel {
        public class NotificationChannels : Tea.TeaModel {
            public var channels: [String]?

            public var severity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Channels"] as? [String] {
                    self.channels = value
                }
                if let value = dict["Severity"] as? String {
                    self.severity = value
                }
            }
        }
        public class NotificationReceivers : Tea.TeaModel {
            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReceiverType"] as? String {
                    self.receiverType = value
                }
                if let value = dict["ReceiverValues"] as? [String] {
                    self.receiverValues = value
                }
            }
        }
        public var inhibitionInterval: Int32?

        public var muteInterval: Int32?

        public var notificationChannels: [CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels]?

        public var notificationReceivers: [CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inhibitionInterval != nil {
                map["InhibitionInterval"] = self.inhibitionInterval!
            }
            if self.muteInterval != nil {
                map["MuteInterval"] = self.muteInterval!
            }
            if self.notificationChannels != nil {
                var tmp : [Any] = []
                for k in self.notificationChannels! {
                    tmp.append(k.toMap())
                }
                map["NotificationChannels"] = tmp
            }
            if self.notificationReceivers != nil {
                var tmp : [Any] = []
                for k in self.notificationReceivers! {
                    tmp.append(k.toMap())
                }
                map["NotificationReceivers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InhibitionInterval"] as? Int32 {
                self.inhibitionInterval = value
            }
            if let value = dict["MuteInterval"] as? Int32 {
                self.muteInterval = value
            }
            if let value = dict["NotificationChannels"] as? [Any?] {
                var tmp : [CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notificationChannels = tmp
            }
            if let value = dict["NotificationReceivers"] as? [Any?] {
                var tmp : [CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notificationReceivers = tmp
            }
        }
    }
    public class TriggerConditions : Tea.TeaModel {
        public var ddlReportTags: [String]?

        public var ddlTypes: [String]?

        public var duration: Int64?

        public var severity: String?

        public var threshold: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ddlReportTags != nil {
                map["DdlReportTags"] = self.ddlReportTags!
            }
            if self.ddlTypes != nil {
                map["DdlTypes"] = self.ddlTypes!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DdlReportTags"] as? [String] {
                self.ddlReportTags = value
            }
            if let value = dict["DdlTypes"] as? [String] {
                self.ddlTypes = value
            }
            if let value = dict["Duration"] as? Int64 {
                self.duration = value
            }
            if let value = dict["Severity"] as? String {
                self.severity = value
            }
            if let value = dict["Threshold"] as? Int64 {
                self.threshold = value
            }
        }
    }
    public var clientToken: String?

    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var name: String?

    public var notificationSettings: CreateDIAlarmRuleRequest.NotificationSettings?

    public var triggerConditions: [CreateDIAlarmRuleRequest.TriggerConditions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationSettings != nil {
            map["NotificationSettings"] = self.notificationSettings?.toMap()
        }
        if self.triggerConditions != nil {
            var tmp : [Any] = []
            for k in self.triggerConditions! {
                tmp.append(k.toMap())
            }
            map["TriggerConditions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NotificationSettings"] as? [String: Any?] {
            var model = CreateDIAlarmRuleRequest.NotificationSettings()
            model.fromMap(value)
            self.notificationSettings = model
        }
        if let value = dict["TriggerConditions"] as? [Any?] {
            var tmp : [CreateDIAlarmRuleRequest.TriggerConditions] = []
            for v in value {
                if v != nil {
                    var model = CreateDIAlarmRuleRequest.TriggerConditions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.triggerConditions = tmp
        }
    }
}

public class CreateDIAlarmRuleShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var name: String?

    public var notificationSettingsShrink: String?

    public var triggerConditionsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationSettingsShrink != nil {
            map["NotificationSettings"] = self.notificationSettingsShrink!
        }
        if self.triggerConditionsShrink != nil {
            map["TriggerConditions"] = self.triggerConditionsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NotificationSettings"] as? String {
            self.notificationSettingsShrink = value
        }
        if let value = dict["TriggerConditions"] as? String {
            self.triggerConditionsShrink = value
        }
    }
}

public class CreateDIAlarmRuleResponseBody : Tea.TeaModel {
    public var DIAlarmRuleId: String?

    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? String {
            self.DIAlarmRuleId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDIAlarmRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDIJobRequest : Tea.TeaModel {
    public class DestinationDataSourceSettings : Tea.TeaModel {
        public var dataSourceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceName != nil {
                map["DataSourceName"] = self.dataSourceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSourceName"] as? String {
                self.dataSourceName = value
            }
        }
    }
    public class JobSettings : Tea.TeaModel {
        public class ColumnDataTypeSettings : Tea.TeaModel {
            public var destinationDataType: String?

            public var sourceDataType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDataType != nil {
                    map["DestinationDataType"] = self.destinationDataType!
                }
                if self.sourceDataType != nil {
                    map["SourceDataType"] = self.sourceDataType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DestinationDataType"] as? String {
                    self.destinationDataType = value
                }
                if let value = dict["SourceDataType"] as? String {
                    self.sourceDataType = value
                }
            }
        }
        public class CycleScheduleSettings : Tea.TeaModel {
            public var cycleMigrationType: String?

            public var scheduleParameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleMigrationType != nil {
                    map["CycleMigrationType"] = self.cycleMigrationType!
                }
                if self.scheduleParameters != nil {
                    map["ScheduleParameters"] = self.scheduleParameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CycleMigrationType"] as? String {
                    self.cycleMigrationType = value
                }
                if let value = dict["ScheduleParameters"] as? String {
                    self.scheduleParameters = value
                }
            }
        }
        public class DdlHandlingSettings : Tea.TeaModel {
            public var action: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class RuntimeSettings : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var channelSettings: String?

        public var columnDataTypeSettings: [CreateDIJobRequest.JobSettings.ColumnDataTypeSettings]?

        public var cycleScheduleSettings: CreateDIJobRequest.JobSettings.CycleScheduleSettings?

        public var ddlHandlingSettings: [CreateDIJobRequest.JobSettings.DdlHandlingSettings]?

        public var runtimeSettings: [CreateDIJobRequest.JobSettings.RuntimeSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cycleScheduleSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelSettings != nil {
                map["ChannelSettings"] = self.channelSettings!
            }
            if self.columnDataTypeSettings != nil {
                var tmp : [Any] = []
                for k in self.columnDataTypeSettings! {
                    tmp.append(k.toMap())
                }
                map["ColumnDataTypeSettings"] = tmp
            }
            if self.cycleScheduleSettings != nil {
                map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
            }
            if self.ddlHandlingSettings != nil {
                var tmp : [Any] = []
                for k in self.ddlHandlingSettings! {
                    tmp.append(k.toMap())
                }
                map["DdlHandlingSettings"] = tmp
            }
            if self.runtimeSettings != nil {
                var tmp : [Any] = []
                for k in self.runtimeSettings! {
                    tmp.append(k.toMap())
                }
                map["RuntimeSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChannelSettings"] as? String {
                self.channelSettings = value
            }
            if let value = dict["ColumnDataTypeSettings"] as? [Any?] {
                var tmp : [CreateDIJobRequest.JobSettings.ColumnDataTypeSettings] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.JobSettings.ColumnDataTypeSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.columnDataTypeSettings = tmp
            }
            if let value = dict["CycleScheduleSettings"] as? [String: Any?] {
                var model = CreateDIJobRequest.JobSettings.CycleScheduleSettings()
                model.fromMap(value)
                self.cycleScheduleSettings = model
            }
            if let value = dict["DdlHandlingSettings"] as? [Any?] {
                var tmp : [CreateDIJobRequest.JobSettings.DdlHandlingSettings] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.JobSettings.DdlHandlingSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ddlHandlingSettings = tmp
            }
            if let value = dict["RuntimeSettings"] as? [Any?] {
                var tmp : [CreateDIJobRequest.JobSettings.RuntimeSettings] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.JobSettings.RuntimeSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.runtimeSettings = tmp
            }
        }
    }
    public class ResourceSettings : Tea.TeaModel {
        public class OfflineResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RequestedCu"] as? Double {
                    self.requestedCu = value
                }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public class RealtimeResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RequestedCu"] as? Double {
                    self.requestedCu = value
                }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public class ScheduleResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RequestedCu"] as? Double {
                    self.requestedCu = value
                }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public var offlineResourceSettings: CreateDIJobRequest.ResourceSettings.OfflineResourceSettings?

        public var realtimeResourceSettings: CreateDIJobRequest.ResourceSettings.RealtimeResourceSettings?

        public var scheduleResourceSettings: CreateDIJobRequest.ResourceSettings.ScheduleResourceSettings?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.offlineResourceSettings?.validate()
            try self.realtimeResourceSettings?.validate()
            try self.scheduleResourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.offlineResourceSettings != nil {
                map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
            }
            if self.realtimeResourceSettings != nil {
                map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
            }
            if self.scheduleResourceSettings != nil {
                map["ScheduleResourceSettings"] = self.scheduleResourceSettings?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OfflineResourceSettings"] as? [String: Any?] {
                var model = CreateDIJobRequest.ResourceSettings.OfflineResourceSettings()
                model.fromMap(value)
                self.offlineResourceSettings = model
            }
            if let value = dict["RealtimeResourceSettings"] as? [String: Any?] {
                var model = CreateDIJobRequest.ResourceSettings.RealtimeResourceSettings()
                model.fromMap(value)
                self.realtimeResourceSettings = model
            }
            if let value = dict["ScheduleResourceSettings"] as? [String: Any?] {
                var model = CreateDIJobRequest.ResourceSettings.ScheduleResourceSettings()
                model.fromMap(value)
                self.scheduleResourceSettings = model
            }
        }
    }
    public class SourceDataSourceSettings : Tea.TeaModel {
        public class DataSourceProperties : Tea.TeaModel {
            public var encoding: String?

            public var timezone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.timezone != nil {
                    map["Timezone"] = self.timezone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Encoding"] as? String {
                    self.encoding = value
                }
                if let value = dict["Timezone"] as? String {
                    self.timezone = value
                }
            }
        }
        public var dataSourceName: String?

        public var dataSourceProperties: CreateDIJobRequest.SourceDataSourceSettings.DataSourceProperties?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSourceProperties?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceName != nil {
                map["DataSourceName"] = self.dataSourceName!
            }
            if self.dataSourceProperties != nil {
                map["DataSourceProperties"] = self.dataSourceProperties?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSourceName"] as? String {
                self.dataSourceName = value
            }
            if let value = dict["DataSourceProperties"] as? [String: Any?] {
                var model = CreateDIJobRequest.SourceDataSourceSettings.DataSourceProperties()
                model.fromMap(value)
                self.dataSourceProperties = model
            }
        }
    }
    public class TableMappings : Tea.TeaModel {
        public class SourceObjectSelectionRules : Tea.TeaModel {
            public var action: String?

            public var expression: String?

            public var expressionType: String?

            public var objectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.expressionType != nil {
                    map["ExpressionType"] = self.expressionType!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["Expression"] as? String {
                    self.expression = value
                }
                if let value = dict["ExpressionType"] as? String {
                    self.expressionType = value
                }
                if let value = dict["ObjectType"] as? String {
                    self.objectType = value
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RuleActionType"] as? String {
                    self.ruleActionType = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["RuleTargetType"] as? String {
                    self.ruleTargetType = value
                }
            }
        }
        public var sourceObjectSelectionRules: [CreateDIJobRequest.TableMappings.SourceObjectSelectionRules]?

        public var transformationRules: [CreateDIJobRequest.TableMappings.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceObjectSelectionRules != nil {
                var tmp : [Any] = []
                for k in self.sourceObjectSelectionRules! {
                    tmp.append(k.toMap())
                }
                map["SourceObjectSelectionRules"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SourceObjectSelectionRules"] as? [Any?] {
                var tmp : [CreateDIJobRequest.TableMappings.SourceObjectSelectionRules] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.TableMappings.SourceObjectSelectionRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sourceObjectSelectionRules = tmp
            }
            if let value = dict["TransformationRules"] as? [Any?] {
                var tmp : [CreateDIJobRequest.TableMappings.TransformationRules] = []
                for v in value {
                    if v != nil {
                        var model = CreateDIJobRequest.TableMappings.TransformationRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.transformationRules = tmp
            }
        }
    }
    public class TransformationRules : Tea.TeaModel {
        public var ruleActionType: String?

        public var ruleExpression: String?

        public var ruleName: String?

        public var ruleTargetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleActionType != nil {
                map["RuleActionType"] = self.ruleActionType!
            }
            if self.ruleExpression != nil {
                map["RuleExpression"] = self.ruleExpression!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleTargetType != nil {
                map["RuleTargetType"] = self.ruleTargetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RuleActionType"] as? String {
                self.ruleActionType = value
            }
            if let value = dict["RuleExpression"] as? String {
                self.ruleExpression = value
            }
            if let value = dict["RuleName"] as? String {
                self.ruleName = value
            }
            if let value = dict["RuleTargetType"] as? String {
                self.ruleTargetType = value
            }
        }
    }
    public var description_: String?

    public var destinationDataSourceSettings: [CreateDIJobRequest.DestinationDataSourceSettings]?

    public var destinationDataSourceType: String?

    public var jobName: String?

    public var jobSettings: CreateDIJobRequest.JobSettings?

    public var jobType: String?

    public var migrationType: String?

    public var name: String?

    public var projectId: Int64?

    public var resourceSettings: CreateDIJobRequest.ResourceSettings?

    public var sourceDataSourceSettings: [CreateDIJobRequest.SourceDataSourceSettings]?

    public var sourceDataSourceType: String?

    public var tableMappings: [CreateDIJobRequest.TableMappings]?

    public var transformationRules: [CreateDIJobRequest.TransformationRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobSettings?.validate()
        try self.resourceSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationDataSourceSettings != nil {
            var tmp : [Any] = []
            for k in self.destinationDataSourceSettings! {
                tmp.append(k.toMap())
            }
            map["DestinationDataSourceSettings"] = tmp
        }
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobSettings != nil {
            map["JobSettings"] = self.jobSettings?.toMap()
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettings != nil {
            map["ResourceSettings"] = self.resourceSettings?.toMap()
        }
        if self.sourceDataSourceSettings != nil {
            var tmp : [Any] = []
            for k in self.sourceDataSourceSettings! {
                tmp.append(k.toMap())
            }
            map["SourceDataSourceSettings"] = tmp
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        if self.tableMappings != nil {
            var tmp : [Any] = []
            for k in self.tableMappings! {
                tmp.append(k.toMap())
            }
            map["TableMappings"] = tmp
        }
        if self.transformationRules != nil {
            var tmp : [Any] = []
            for k in self.transformationRules! {
                tmp.append(k.toMap())
            }
            map["TransformationRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestinationDataSourceSettings"] as? [Any?] {
            var tmp : [CreateDIJobRequest.DestinationDataSourceSettings] = []
            for v in value {
                if v != nil {
                    var model = CreateDIJobRequest.DestinationDataSourceSettings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.destinationDataSourceSettings = tmp
        }
        if let value = dict["DestinationDataSourceType"] as? String {
            self.destinationDataSourceType = value
        }
        if let value = dict["JobName"] as? String {
            self.jobName = value
        }
        if let value = dict["JobSettings"] as? [String: Any?] {
            var model = CreateDIJobRequest.JobSettings()
            model.fromMap(value)
            self.jobSettings = model
        }
        if let value = dict["JobType"] as? String {
            self.jobType = value
        }
        if let value = dict["MigrationType"] as? String {
            self.migrationType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceSettings"] as? [String: Any?] {
            var model = CreateDIJobRequest.ResourceSettings()
            model.fromMap(value)
            self.resourceSettings = model
        }
        if let value = dict["SourceDataSourceSettings"] as? [Any?] {
            var tmp : [CreateDIJobRequest.SourceDataSourceSettings] = []
            for v in value {
                if v != nil {
                    var model = CreateDIJobRequest.SourceDataSourceSettings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.sourceDataSourceSettings = tmp
        }
        if let value = dict["SourceDataSourceType"] as? String {
            self.sourceDataSourceType = value
        }
        if let value = dict["TableMappings"] as? [Any?] {
            var tmp : [CreateDIJobRequest.TableMappings] = []
            for v in value {
                if v != nil {
                    var model = CreateDIJobRequest.TableMappings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tableMappings = tmp
        }
        if let value = dict["TransformationRules"] as? [Any?] {
            var tmp : [CreateDIJobRequest.TransformationRules] = []
            for v in value {
                if v != nil {
                    var model = CreateDIJobRequest.TransformationRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.transformationRules = tmp
        }
    }
}

public class CreateDIJobShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var destinationDataSourceSettingsShrink: String?

    public var destinationDataSourceType: String?

    public var jobName: String?

    public var jobSettingsShrink: String?

    public var jobType: String?

    public var migrationType: String?

    public var name: String?

    public var projectId: Int64?

    public var resourceSettingsShrink: String?

    public var sourceDataSourceSettingsShrink: String?

    public var sourceDataSourceType: String?

    public var tableMappingsShrink: String?

    public var transformationRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationDataSourceSettingsShrink != nil {
            map["DestinationDataSourceSettings"] = self.destinationDataSourceSettingsShrink!
        }
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobSettingsShrink != nil {
            map["JobSettings"] = self.jobSettingsShrink!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettingsShrink != nil {
            map["ResourceSettings"] = self.resourceSettingsShrink!
        }
        if self.sourceDataSourceSettingsShrink != nil {
            map["SourceDataSourceSettings"] = self.sourceDataSourceSettingsShrink!
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        if self.tableMappingsShrink != nil {
            map["TableMappings"] = self.tableMappingsShrink!
        }
        if self.transformationRulesShrink != nil {
            map["TransformationRules"] = self.transformationRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DestinationDataSourceSettings"] as? String {
            self.destinationDataSourceSettingsShrink = value
        }
        if let value = dict["DestinationDataSourceType"] as? String {
            self.destinationDataSourceType = value
        }
        if let value = dict["JobName"] as? String {
            self.jobName = value
        }
        if let value = dict["JobSettings"] as? String {
            self.jobSettingsShrink = value
        }
        if let value = dict["JobType"] as? String {
            self.jobType = value
        }
        if let value = dict["MigrationType"] as? String {
            self.migrationType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceSettings"] as? String {
            self.resourceSettingsShrink = value
        }
        if let value = dict["SourceDataSourceSettings"] as? String {
            self.sourceDataSourceSettingsShrink = value
        }
        if let value = dict["SourceDataSourceType"] as? String {
            self.sourceDataSourceType = value
        }
        if let value = dict["TableMappings"] as? String {
            self.tableMappingsShrink = value
        }
        if let value = dict["TransformationRules"] as? String {
            self.transformationRulesShrink = value
        }
    }
}

public class CreateDIJobResponseBody : Tea.TeaModel {
    public var DIJobId: Int64?

    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataAssetTagRequest : Tea.TeaModel {
    public var description_: String?

    public var key: String?

    public var managers: [String]?

    public var valueType: String?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.managers != nil {
            map["Managers"] = self.managers!
        }
        if self.valueType != nil {
            map["ValueType"] = self.valueType!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["Managers"] as? [String] {
            self.managers = value
        }
        if let value = dict["ValueType"] as? String {
            self.valueType = value
        }
        if let value = dict["Values"] as? [String] {
            self.values = value
        }
    }
}

public class CreateDataAssetTagShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var key: String?

    public var managersShrink: String?

    public var valueType: String?

    public var valuesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.managersShrink != nil {
            map["Managers"] = self.managersShrink!
        }
        if self.valueType != nil {
            map["ValueType"] = self.valueType!
        }
        if self.valuesShrink != nil {
            map["Values"] = self.valuesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["Managers"] as? String {
            self.managersShrink = value
        }
        if let value = dict["ValueType"] as? String {
            self.valueType = value
        }
        if let value = dict["Values"] as? String {
            self.valuesShrink = value
        }
    }
}

public class CreateDataAssetTagResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateDataAssetTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataAssetTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataAssetTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataQualityEvaluationTaskRequest : Tea.TeaModel {
    public class DataQualityRules : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public class Thresholds : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Expression"] as? String {
                            self.expression = value
                        }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public class Expected : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Expression"] as? String {
                            self.expression = value
                        }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public class Warned : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Expression"] as? String {
                            self.expression = value
                        }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var critical: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Critical?

                public var expected: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Expected?

                public var warned: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Warned?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.expected?.validate()
                    try self.warned?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.expected != nil {
                        map["Expected"] = self.expected?.toMap()
                    }
                    if self.warned != nil {
                        map["Warned"] = self.warned?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Critical"] as? [String: Any?] {
                        var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Critical()
                        model.fromMap(value)
                        self.critical = model
                    }
                    if let value = dict["Expected"] as? [String: Any?] {
                        var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Expected()
                        model.fromMap(value)
                        self.expected = model
                    }
                    if let value = dict["Warned"] as? [String: Any?] {
                        var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Warned()
                        model.fromMap(value)
                        self.warned = model
                    }
                }
            }
            public var referencedSamplesFilter: String?

            public var thresholds: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.thresholds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.thresholds != nil {
                    map["Thresholds"] = self.thresholds?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReferencedSamplesFilter"] as? String {
                    self.referencedSamplesFilter = value
                }
                if let value = dict["Thresholds"] as? [String: Any?] {
                    var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds()
                    model.fromMap(value)
                    self.thresholds = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class ErrorHandlers : Tea.TeaModel {
            public var errorDataFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorDataFilter != nil {
                    map["ErrorDataFilter"] = self.errorDataFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorDataFilter"] as? String {
                    self.errorDataFilter = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var samplingFilter: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.samplingFilter != nil {
                    map["SamplingFilter"] = self.samplingFilter!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Metric"] as? String {
                    self.metric = value
                }
                if let value = dict["MetricParameters"] as? String {
                    self.metricParameters = value
                }
                if let value = dict["SamplingFilter"] as? String {
                    self.samplingFilter = value
                }
                if let value = dict["SettingConfig"] as? String {
                    self.settingConfig = value
                }
            }
        }
        public var checkingConfig: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig?

        public var description_: String?

        public var enabled: Bool?

        public var errorHandlers: [CreateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers]?

        public var id: Int64?

        public var name: String?

        public var samplingConfig: CreateDataQualityEvaluationTaskRequest.DataQualityRules.SamplingConfig?

        public var severity: String?

        public var templateCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.errorHandlers != nil {
                var tmp : [Any] = []
                for k in self.errorHandlers! {
                    tmp.append(k.toMap())
                }
                map["ErrorHandlers"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.templateCode != nil {
                map["TemplateCode"] = self.templateCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CheckingConfig"] as? [String: Any?] {
                var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig()
                model.fromMap(value)
                self.checkingConfig = model
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["ErrorHandlers"] as? [Any?] {
                var tmp : [CreateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers] = []
                for v in value {
                    if v != nil {
                        var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.errorHandlers = tmp
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["SamplingConfig"] as? [String: Any?] {
                var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.SamplingConfig()
                model.fromMap(value)
                self.samplingConfig = model
            }
            if let value = dict["Severity"] as? String {
                self.severity = value
            }
            if let value = dict["TemplateCode"] as? String {
                self.templateCode = value
            }
        }
    }
    public class Hooks : Tea.TeaModel {
        public var condition: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Condition"] as? String {
                self.condition = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class Notifications : Tea.TeaModel {
        public class Notifications : Tea.TeaModel {
            public class NotificationChannels : Tea.TeaModel {
                public var channels: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Channels"] as? [String] {
                        self.channels = value
                    }
                }
            }
            public class NotificationReceivers : Tea.TeaModel {
                public var extension_: String?

                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Extension"] as? String {
                        self.extension_ = value
                    }
                    if let value = dict["ReceiverType"] as? String {
                        self.receiverType = value
                    }
                    if let value = dict["ReceiverValues"] as? [String] {
                        self.receiverValues = value
                    }
                }
            }
            public var notificationChannels: [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels]?

            public var notificationReceivers: [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notificationChannels != nil {
                    var tmp : [Any] = []
                    for k in self.notificationChannels! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationChannels"] = tmp
                }
                if self.notificationReceivers != nil {
                    var tmp : [Any] = []
                    for k in self.notificationReceivers! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationReceivers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NotificationChannels"] as? [Any?] {
                    var tmp : [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels] = []
                    for v in value {
                        if v != nil {
                            var model = CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notificationChannels = tmp
                }
                if let value = dict["NotificationReceivers"] as? [Any?] {
                    var tmp : [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers] = []
                    for v in value {
                        if v != nil {
                            var model = CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notificationReceivers = tmp
                }
            }
        }
        public var condition: String?

        public var notifications: [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.notifications != nil {
                var tmp : [Any] = []
                for k in self.notifications! {
                    tmp.append(k.toMap())
                }
                map["Notifications"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Condition"] as? String {
                self.condition = value
            }
            if let value = dict["Notifications"] as? [Any?] {
                var tmp : [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications] = []
                for v in value {
                    if v != nil {
                        var model = CreateDataQualityEvaluationTaskRequest.Notifications.Notifications()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notifications = tmp
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DatabaseType"] as? String {
                self.databaseType = value
            }
            if let value = dict["PartitionSpec"] as? String {
                self.partitionSpec = value
            }
            if let value = dict["TableGuid"] as? String {
                self.tableGuid = value
            }
        }
    }
    public class Trigger : Tea.TeaModel {
        public var taskIds: [Int64]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TaskIds"] as? [Int64] {
                self.taskIds = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var dataQualityRules: [CreateDataQualityEvaluationTaskRequest.DataQualityRules]?

    public var dataSourceId: Int64?

    public var description_: String?

    public var hooks: [CreateDataQualityEvaluationTaskRequest.Hooks]?

    public var name: String?

    public var notifications: CreateDataQualityEvaluationTaskRequest.Notifications?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var target: CreateDataQualityEvaluationTaskRequest.Target?

    public var trigger: CreateDataQualityEvaluationTaskRequest.Trigger?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifications?.validate()
        try self.target?.validate()
        try self.trigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRules != nil {
            var tmp : [Any] = []
            for k in self.dataQualityRules! {
                tmp.append(k.toMap())
            }
            map["DataQualityRules"] = tmp
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooks != nil {
            var tmp : [Any] = []
            for k in self.hooks! {
                tmp.append(k.toMap())
            }
            map["Hooks"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifications != nil {
            map["Notifications"] = self.notifications?.toMap()
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.trigger != nil {
            map["Trigger"] = self.trigger?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityRules"] as? [Any?] {
            var tmp : [CreateDataQualityEvaluationTaskRequest.DataQualityRules] = []
            for v in value {
                if v != nil {
                    var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataQualityRules = tmp
        }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Hooks"] as? [Any?] {
            var tmp : [CreateDataQualityEvaluationTaskRequest.Hooks] = []
            for v in value {
                if v != nil {
                    var model = CreateDataQualityEvaluationTaskRequest.Hooks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hooks = tmp
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Notifications"] as? [String: Any?] {
            var model = CreateDataQualityEvaluationTaskRequest.Notifications()
            model.fromMap(value)
            self.notifications = model
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeConf"] as? String {
            self.runtimeConf = value
        }
        if let value = dict["Target"] as? [String: Any?] {
            var model = CreateDataQualityEvaluationTaskRequest.Target()
            model.fromMap(value)
            self.target = model
        }
        if let value = dict["Trigger"] as? [String: Any?] {
            var model = CreateDataQualityEvaluationTaskRequest.Trigger()
            model.fromMap(value)
            self.trigger = model
        }
    }
}

public class CreateDataQualityEvaluationTaskShrinkRequest : Tea.TeaModel {
    public var dataQualityRulesShrink: String?

    public var dataSourceId: Int64?

    public var description_: String?

    public var hooksShrink: String?

    public var name: String?

    public var notificationsShrink: String?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var targetShrink: String?

    public var triggerShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRulesShrink != nil {
            map["DataQualityRules"] = self.dataQualityRulesShrink!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooksShrink != nil {
            map["Hooks"] = self.hooksShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationsShrink != nil {
            map["Notifications"] = self.notificationsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.targetShrink != nil {
            map["Target"] = self.targetShrink!
        }
        if self.triggerShrink != nil {
            map["Trigger"] = self.triggerShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityRules"] as? String {
            self.dataQualityRulesShrink = value
        }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Hooks"] as? String {
            self.hooksShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Notifications"] as? String {
            self.notificationsShrink = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeConf"] as? String {
            self.runtimeConf = value
        }
        if let value = dict["Target"] as? String {
            self.targetShrink = value
        }
        if let value = dict["Trigger"] as? String {
            self.triggerShrink = value
        }
    }
}

public class CreateDataQualityEvaluationTaskResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDataQualityEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataQualityEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataQualityEvaluationTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataQualityEvaluationTaskInstanceRequest : Tea.TeaModel {
    public class RuntimeResource : Tea.TeaModel {
        public var cu: Double?

        public var resourceGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cu != nil {
                map["Cu"] = self.cu!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cu"] as? Double {
                self.cu = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
        }
    }
    public var dataQualityEvaluationTaskId: Int64?

    public var parameters: String?

    public var projectId: Int64?

    public var runtimeResource: CreateDataQualityEvaluationTaskInstanceRequest.RuntimeResource?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.runtimeResource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityEvaluationTaskId"] as? Int64 {
            self.dataQualityEvaluationTaskId = value
        }
        if let value = dict["Parameters"] as? String {
            self.parameters = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeResource"] as? [String: Any?] {
            var model = CreateDataQualityEvaluationTaskInstanceRequest.RuntimeResource()
            model.fromMap(value)
            self.runtimeResource = model
        }
    }
}

public class CreateDataQualityEvaluationTaskInstanceShrinkRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var parameters: String?

    public var projectId: Int64?

    public var runtimeResourceShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResourceShrink != nil {
            map["RuntimeResource"] = self.runtimeResourceShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityEvaluationTaskId"] as? Int64 {
            self.dataQualityEvaluationTaskId = value
        }
        if let value = dict["Parameters"] as? String {
            self.parameters = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeResource"] as? String {
            self.runtimeResourceShrink = value
        }
    }
}

public class CreateDataQualityEvaluationTaskInstanceResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDataQualityEvaluationTaskInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataQualityEvaluationTaskInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataQualityEvaluationTaskInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataQualityRuleRequest : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public class Thresholds : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["Operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Expected : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["Operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Warned : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["Operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var critical: CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Critical?

            public var expected: CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Expected?

            public var warned: CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Warned?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.expected?.validate()
                try self.warned?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.expected != nil {
                    map["Expected"] = self.expected?.toMap()
                }
                if self.warned != nil {
                    map["Warned"] = self.warned?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Critical"] as? [String: Any?] {
                    var model = CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Critical()
                    model.fromMap(value)
                    self.critical = model
                }
                if let value = dict["Expected"] as? [String: Any?] {
                    var model = CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Expected()
                    model.fromMap(value)
                    self.expected = model
                }
                if let value = dict["Warned"] as? [String: Any?] {
                    var model = CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Warned()
                    model.fromMap(value)
                    self.warned = model
                }
            }
        }
        public var referencedSamplesFilter: String?

        public var thresholds: CreateDataQualityRuleRequest.CheckingConfig.Thresholds?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.thresholds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.thresholds != nil {
                map["Thresholds"] = self.thresholds?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReferencedSamplesFilter"] as? String {
                self.referencedSamplesFilter = value
            }
            if let value = dict["Thresholds"] as? [String: Any?] {
                var model = CreateDataQualityRuleRequest.CheckingConfig.Thresholds()
                model.fromMap(value)
                self.thresholds = model
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class ErrorHandlers : Tea.TeaModel {
        public var errorDataFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorDataFilter != nil {
                map["ErrorDataFilter"] = self.errorDataFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorDataFilter"] as? String {
                self.errorDataFilter = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var samplingFilter: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.samplingFilter != nil {
                map["SamplingFilter"] = self.samplingFilter!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Metric"] as? String {
                self.metric = value
            }
            if let value = dict["MetricParameters"] as? String {
                self.metricParameters = value
            }
            if let value = dict["SamplingFilter"] as? String {
                self.samplingFilter = value
            }
            if let value = dict["SettingConfig"] as? String {
                self.settingConfig = value
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DatabaseType"] as? String {
                self.databaseType = value
            }
            if let value = dict["PartitionSpec"] as? String {
                self.partitionSpec = value
            }
            if let value = dict["TableGuid"] as? String {
                self.tableGuid = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var checkingConfig: CreateDataQualityRuleRequest.CheckingConfig?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlers: [CreateDataQualityRuleRequest.ErrorHandlers]?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: CreateDataQualityRuleRequest.SamplingConfig?

    public var severity: String?

    public var target: CreateDataQualityRuleRequest.Target?

    public var templateCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
        try self.target?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlers != nil {
            var tmp : [Any] = []
            for k in self.errorHandlers! {
                tmp.append(k.toMap())
            }
            map["ErrorHandlers"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? [String: Any?] {
            var model = CreateDataQualityRuleRequest.CheckingConfig()
            model.fromMap(value)
            self.checkingConfig = model
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["ErrorHandlers"] as? [Any?] {
            var tmp : [CreateDataQualityRuleRequest.ErrorHandlers] = []
            for v in value {
                if v != nil {
                    var model = CreateDataQualityRuleRequest.ErrorHandlers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.errorHandlers = tmp
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? [String: Any?] {
            var model = CreateDataQualityRuleRequest.SamplingConfig()
            model.fromMap(value)
            self.samplingConfig = model
        }
        if let value = dict["Severity"] as? String {
            self.severity = value
        }
        if let value = dict["Target"] as? [String: Any?] {
            var model = CreateDataQualityRuleRequest.Target()
            model.fromMap(value)
            self.target = model
        }
        if let value = dict["TemplateCode"] as? String {
            self.templateCode = value
        }
    }
}

public class CreateDataQualityRuleShrinkRequest : Tea.TeaModel {
    public var checkingConfigShrink: String?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlersShrink: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfigShrink: String?

    public var severity: String?

    public var targetShrink: String?

    public var templateCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfigShrink != nil {
            map["CheckingConfig"] = self.checkingConfigShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlersShrink != nil {
            map["ErrorHandlers"] = self.errorHandlersShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfigShrink != nil {
            map["SamplingConfig"] = self.samplingConfigShrink!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.targetShrink != nil {
            map["Target"] = self.targetShrink!
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? String {
            self.checkingConfigShrink = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["ErrorHandlers"] as? String {
            self.errorHandlersShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? String {
            self.samplingConfigShrink = value
        }
        if let value = dict["Severity"] as? String {
            self.severity = value
        }
        if let value = dict["Target"] as? String {
            self.targetShrink = value
        }
        if let value = dict["TemplateCode"] as? String {
            self.templateCode = value
        }
    }
}

public class CreateDataQualityRuleResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDataQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataQualityRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataQualityRuleTemplateRequest : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public var referencedSamplesFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReferencedSamplesFilter"] as? String {
                self.referencedSamplesFilter = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Metric"] as? String {
                self.metric = value
            }
            if let value = dict["MetricParameters"] as? String {
                self.metricParameters = value
            }
            if let value = dict["SettingConfig"] as? String {
                self.settingConfig = value
            }
        }
    }
    public var checkingConfig: CreateDataQualityRuleTemplateRequest.CheckingConfig?

    public var directoryPath: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: CreateDataQualityRuleTemplateRequest.SamplingConfig?

    public var visibleScope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        if self.visibleScope != nil {
            map["VisibleScope"] = self.visibleScope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? [String: Any?] {
            var model = CreateDataQualityRuleTemplateRequest.CheckingConfig()
            model.fromMap(value)
            self.checkingConfig = model
        }
        if let value = dict["DirectoryPath"] as? String {
            self.directoryPath = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? [String: Any?] {
            var model = CreateDataQualityRuleTemplateRequest.SamplingConfig()
            model.fromMap(value)
            self.samplingConfig = model
        }
        if let value = dict["VisibleScope"] as? String {
            self.visibleScope = value
        }
    }
}

public class CreateDataQualityRuleTemplateShrinkRequest : Tea.TeaModel {
    public var checkingConfigShrink: String?

    public var directoryPath: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfigShrink: String?

    public var visibleScope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfigShrink != nil {
            map["CheckingConfig"] = self.checkingConfigShrink!
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfigShrink != nil {
            map["SamplingConfig"] = self.samplingConfigShrink!
        }
        if self.visibleScope != nil {
            map["VisibleScope"] = self.visibleScope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? String {
            self.checkingConfigShrink = value
        }
        if let value = dict["DirectoryPath"] as? String {
            self.directoryPath = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? String {
            self.samplingConfigShrink = value
        }
        if let value = dict["VisibleScope"] as? String {
            self.visibleScope = value
        }
    }
}

public class CreateDataQualityRuleTemplateResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDataQualityRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataQualityRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataQualityRuleTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataSourceRequest : Tea.TeaModel {
    public var connectionProperties: String?

    public var connectionPropertiesMode: String?

    public var description_: String?

    public var name: String?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionProperties != nil {
            map["ConnectionProperties"] = self.connectionProperties!
        }
        if self.connectionPropertiesMode != nil {
            map["ConnectionPropertiesMode"] = self.connectionPropertiesMode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionProperties"] as? String {
            self.connectionProperties = value
        }
        if let value = dict["ConnectionPropertiesMode"] as? String {
            self.connectionPropertiesMode = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreateDataSourceResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataSourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataSourceSharedRuleRequest : Tea.TeaModel {
    public var dataSourceId: Int64?

    public var envType: String?

    public var sharedUser: String?

    public var targetProjectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.sharedUser != nil {
            map["SharedUser"] = self.sharedUser!
        }
        if self.targetProjectId != nil {
            map["TargetProjectId"] = self.targetProjectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["SharedUser"] as? String {
            self.sharedUser = value
        }
        if let value = dict["TargetProjectId"] as? Int64 {
            self.targetProjectId = value
        }
    }
}

public class CreateDataSourceSharedRuleResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDataSourceSharedRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataSourceSharedRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataSourceSharedRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateFunctionRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class CreateFunctionResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateFunctionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLineageRelationshipRequest : Tea.TeaModel {
    public var dstEntity: LineageEntity?

    public var srcEntity: LineageEntity?

    public var task: LineageTask?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dstEntity?.validate()
        try self.srcEntity?.validate()
        try self.task?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dstEntity != nil {
            map["DstEntity"] = self.dstEntity?.toMap()
        }
        if self.srcEntity != nil {
            map["SrcEntity"] = self.srcEntity?.toMap()
        }
        if self.task != nil {
            map["Task"] = self.task?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DstEntity"] as? [String: Any?] {
            var model = LineageEntity()
            model.fromMap(value)
            self.dstEntity = model
        }
        if let value = dict["SrcEntity"] as? [String: Any?] {
            var model = LineageEntity()
            model.fromMap(value)
            self.srcEntity = model
        }
        if let value = dict["Task"] as? [String: Any?] {
            var model = LineageTask()
            model.fromMap(value)
            self.task = model
        }
    }
}

public class CreateLineageRelationshipShrinkRequest : Tea.TeaModel {
    public var dstEntityShrink: String?

    public var srcEntityShrink: String?

    public var taskShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dstEntityShrink != nil {
            map["DstEntity"] = self.dstEntityShrink!
        }
        if self.srcEntityShrink != nil {
            map["SrcEntity"] = self.srcEntityShrink!
        }
        if self.taskShrink != nil {
            map["Task"] = self.taskShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DstEntity"] as? String {
            self.dstEntityShrink = value
        }
        if let value = dict["SrcEntity"] as? String {
            self.srcEntityShrink = value
        }
        if let value = dict["Task"] as? String {
            self.taskShrink = value
        }
    }
}

public class CreateLineageRelationshipResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateLineageRelationshipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLineageRelationshipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLineageRelationshipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateMetaCollectionRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var parentId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ParentId"] as? String {
            self.parentId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreateMetaCollectionResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNetworkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var resourceGroupId: String?

    public var vpcId: String?

    public var vswitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vswitchId != nil {
            map["VswitchId"] = self.vswitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VswitchId"] as? String {
            self.vswitchId = value
        }
    }
}

public class CreateNetworkResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNodeRequest : Tea.TeaModel {
    public var containerId: Int64?

    public var projectId: Int64?

    public var scene: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ContainerId"] as? Int64 {
            self.containerId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Scene"] as? String {
            self.scene = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class CreateNodeResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePipelineRunRequest : Tea.TeaModel {
    public var description_: String?

    public var objectIds: [String]?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.objectIds != nil {
            map["ObjectIds"] = self.objectIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ObjectIds"] as? [String] {
            self.objectIds = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreatePipelineRunShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var objectIdsShrink: String?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.objectIdsShrink != nil {
            map["ObjectIds"] = self.objectIdsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["ObjectIds"] as? String {
            self.objectIdsShrink = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreatePipelineRunResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePipelineRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateProjectRequest : Tea.TeaModel {
    public class AliyunResourceTags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTags: [CreateProjectRequest.AliyunResourceTags]?

    public var description_: String?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var displayName: String?

    public var name: String?

    public var paiTaskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTags != nil {
            var tmp : [Any] = []
            for k in self.aliyunResourceTags! {
                tmp.append(k.toMap())
            }
            map["AliyunResourceTags"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunResourceGroupId"] as? String {
            self.aliyunResourceGroupId = value
        }
        if let value = dict["AliyunResourceTags"] as? [Any?] {
            var tmp : [CreateProjectRequest.AliyunResourceTags] = []
            for v in value {
                if v != nil {
                    var model = CreateProjectRequest.AliyunResourceTags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.aliyunResourceTags = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DevEnvironmentEnabled"] as? Bool {
            self.devEnvironmentEnabled = value
        }
        if let value = dict["DevRoleDisabled"] as? Bool {
            self.devRoleDisabled = value
        }
        if let value = dict["DisplayName"] as? String {
            self.displayName = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PaiTaskEnabled"] as? Bool {
            self.paiTaskEnabled = value
        }
    }
}

public class CreateProjectShrinkRequest : Tea.TeaModel {
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTagsShrink: String?

    public var description_: String?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var displayName: String?

    public var name: String?

    public var paiTaskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTagsShrink != nil {
            map["AliyunResourceTags"] = self.aliyunResourceTagsShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunResourceGroupId"] as? String {
            self.aliyunResourceGroupId = value
        }
        if let value = dict["AliyunResourceTags"] as? String {
            self.aliyunResourceTagsShrink = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DevEnvironmentEnabled"] as? Bool {
            self.devEnvironmentEnabled = value
        }
        if let value = dict["DevRoleDisabled"] as? Bool {
            self.devRoleDisabled = value
        }
        if let value = dict["DisplayName"] as? String {
            self.displayName = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PaiTaskEnabled"] as? Bool {
            self.paiTaskEnabled = value
        }
    }
}

public class CreateProjectResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateProjectMemberRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodes: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodes != nil {
            map["RoleCodes"] = self.roleCodes!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCodes"] as? [String] {
            self.roleCodes = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class CreateProjectMemberShrinkRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodesShrink: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodesShrink != nil {
            map["RoleCodes"] = self.roleCodesShrink!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCodes"] as? String {
            self.roleCodesShrink = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class CreateProjectMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateProjectMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateResourceRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var resourceFile: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceFile != nil {
            map["ResourceFile"] = self.resourceFile!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceFile"] as? String {
            self.resourceFile = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class CreateResourceAdvanceRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var resourceFileObject: InputStream?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceFileObject != nil {
            map["ResourceFile"] = self.resourceFileObject!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceFile"] as? InputStream {
            self.resourceFileObject = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class CreateResourceResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateResourceGroupRequest : Tea.TeaModel {
    public class AliyunResourceTags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTags: [CreateResourceGroupRequest.AliyunResourceTags]?

    public var autoRenewEnabled: Bool?

    public var clientToken: String?

    public var name: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public var paymentType: String?

    public var remark: String?

    public var spec: Int32?

    public var vpcId: String?

    public var vswitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTags != nil {
            var tmp : [Any] = []
            for k in self.aliyunResourceTags! {
                tmp.append(k.toMap())
            }
            map["AliyunResourceTags"] = tmp
        }
        if self.autoRenewEnabled != nil {
            map["AutoRenewEnabled"] = self.autoRenewEnabled!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vswitchId != nil {
            map["VswitchId"] = self.vswitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunResourceGroupId"] as? String {
            self.aliyunResourceGroupId = value
        }
        if let value = dict["AliyunResourceTags"] as? [Any?] {
            var tmp : [CreateResourceGroupRequest.AliyunResourceTags] = []
            for v in value {
                if v != nil {
                    var model = CreateResourceGroupRequest.AliyunResourceTags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.aliyunResourceTags = tmp
        }
        if let value = dict["AutoRenewEnabled"] as? Bool {
            self.autoRenewEnabled = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PaymentDuration"] as? Int32 {
            self.paymentDuration = value
        }
        if let value = dict["PaymentDurationUnit"] as? String {
            self.paymentDurationUnit = value
        }
        if let value = dict["PaymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["Spec"] as? Int32 {
            self.spec = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VswitchId"] as? String {
            self.vswitchId = value
        }
    }
}

public class CreateResourceGroupShrinkRequest : Tea.TeaModel {
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTagsShrink: String?

    public var autoRenewEnabled: Bool?

    public var clientToken: String?

    public var name: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public var paymentType: String?

    public var remark: String?

    public var spec: Int32?

    public var vpcId: String?

    public var vswitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTagsShrink != nil {
            map["AliyunResourceTags"] = self.aliyunResourceTagsShrink!
        }
        if self.autoRenewEnabled != nil {
            map["AutoRenewEnabled"] = self.autoRenewEnabled!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vswitchId != nil {
            map["VswitchId"] = self.vswitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunResourceGroupId"] as? String {
            self.aliyunResourceGroupId = value
        }
        if let value = dict["AliyunResourceTags"] as? String {
            self.aliyunResourceTagsShrink = value
        }
        if let value = dict["AutoRenewEnabled"] as? Bool {
            self.autoRenewEnabled = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PaymentDuration"] as? Int32 {
            self.paymentDuration = value
        }
        if let value = dict["PaymentDurationUnit"] as? String {
            self.paymentDurationUnit = value
        }
        if let value = dict["PaymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
        if let value = dict["Spec"] as? Int32 {
            self.spec = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VswitchId"] as? String {
            self.vswitchId = value
        }
    }
}

public class CreateResourceGroupResponseBody : Tea.TeaModel {
    public class ResourceGroupOrder : Tea.TeaModel {
        public var id: String?

        public var orderId: Int64?

        public var orderInstanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.orderInstanceId != nil {
                map["OrderInstanceId"] = self.orderInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["OrderId"] as? Int64 {
                self.orderId = value
            }
            if let value = dict["OrderInstanceId"] as? String {
                self.orderInstanceId = value
            }
        }
    }
    public var requestId: String?

    public var resourceGroupOrder: CreateResourceGroupResponseBody.ResourceGroupOrder?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceGroupOrder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupOrder != nil {
            map["ResourceGroupOrder"] = self.resourceGroupOrder?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupOrder"] as? [String: Any?] {
            var model = CreateResourceGroupResponseBody.ResourceGroupOrder()
            model.fromMap(value)
            self.resourceGroupOrder = model
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRouteRequest : Tea.TeaModel {
    public var destinationCidr: String?

    public var networkId: Int64?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidr != nil {
            map["DestinationCidr"] = self.destinationCidr!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationCidr"] as? String {
            self.destinationCidr = value
        }
        if let value = dict["NetworkId"] as? Int64 {
            self.networkId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class CreateRouteResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRouteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWorkflowDefinitionRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class CreateWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateWorkflowDefinitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWorkflowInstancesRequest : Tea.TeaModel {
    public class DefaultRunProperties : Tea.TeaModel {
        public class Alert : Tea.TeaModel {
            public var noticeType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.noticeType != nil {
                    map["NoticeType"] = self.noticeType!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NoticeType"] as? String {
                    self.noticeType = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class Analysis : Tea.TeaModel {
            public var blocked: Bool?

            public var enabled: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blocked != nil {
                    map["Blocked"] = self.blocked!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Blocked"] as? Bool {
                    self.blocked = value
                }
                if let value = dict["Enabled"] as? Bool {
                    self.enabled = value
                }
            }
        }
        public class RunPolicy : Tea.TeaModel {
            public var endTime: String?

            public var immediately: Bool?

            public var startTime: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.immediately != nil {
                    map["Immediately"] = self.immediately!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["Immediately"] as? Bool {
                    self.immediately = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var alert: CreateWorkflowInstancesRequest.DefaultRunProperties.Alert?

        public var analysis: CreateWorkflowInstancesRequest.DefaultRunProperties.Analysis?

        public var excludeProjectIds: [Int64]?

        public var excludeTaskIds: [Int64]?

        public var includeProjectIds: [Int64]?

        public var includeTaskIds: [Int64]?

        public var mode: String?

        public var order: String?

        public var parallelism: Int32?

        public var rootTaskIds: [Int64]?

        public var runPolicy: CreateWorkflowInstancesRequest.DefaultRunProperties.RunPolicy?

        public var runtimeResource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alert?.validate()
            try self.analysis?.validate()
            try self.runPolicy?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alert != nil {
                map["Alert"] = self.alert?.toMap()
            }
            if self.analysis != nil {
                map["Analysis"] = self.analysis?.toMap()
            }
            if self.excludeProjectIds != nil {
                map["ExcludeProjectIds"] = self.excludeProjectIds!
            }
            if self.excludeTaskIds != nil {
                map["ExcludeTaskIds"] = self.excludeTaskIds!
            }
            if self.includeProjectIds != nil {
                map["IncludeProjectIds"] = self.includeProjectIds!
            }
            if self.includeTaskIds != nil {
                map["IncludeTaskIds"] = self.includeTaskIds!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.order != nil {
                map["Order"] = self.order!
            }
            if self.parallelism != nil {
                map["Parallelism"] = self.parallelism!
            }
            if self.rootTaskIds != nil {
                map["RootTaskIds"] = self.rootTaskIds!
            }
            if self.runPolicy != nil {
                map["RunPolicy"] = self.runPolicy?.toMap()
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Alert"] as? [String: Any?] {
                var model = CreateWorkflowInstancesRequest.DefaultRunProperties.Alert()
                model.fromMap(value)
                self.alert = model
            }
            if let value = dict["Analysis"] as? [String: Any?] {
                var model = CreateWorkflowInstancesRequest.DefaultRunProperties.Analysis()
                model.fromMap(value)
                self.analysis = model
            }
            if let value = dict["ExcludeProjectIds"] as? [Int64] {
                self.excludeProjectIds = value
            }
            if let value = dict["ExcludeTaskIds"] as? [Int64] {
                self.excludeTaskIds = value
            }
            if let value = dict["IncludeProjectIds"] as? [Int64] {
                self.includeProjectIds = value
            }
            if let value = dict["IncludeTaskIds"] as? [Int64] {
                self.includeTaskIds = value
            }
            if let value = dict["Mode"] as? String {
                self.mode = value
            }
            if let value = dict["Order"] as? String {
                self.order = value
            }
            if let value = dict["Parallelism"] as? Int32 {
                self.parallelism = value
            }
            if let value = dict["RootTaskIds"] as? [Int64] {
                self.rootTaskIds = value
            }
            if let value = dict["RunPolicy"] as? [String: Any?] {
                var model = CreateWorkflowInstancesRequest.DefaultRunProperties.RunPolicy()
                model.fromMap(value)
                self.runPolicy = model
            }
            if let value = dict["RuntimeResource"] as? String {
                self.runtimeResource = value
            }
        }
    }
    public class Periods : Tea.TeaModel {
        public class BizDates : Tea.TeaModel {
            public var endBizDate: String?

            public var startBizDate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endBizDate != nil {
                    map["EndBizDate"] = self.endBizDate!
                }
                if self.startBizDate != nil {
                    map["StartBizDate"] = self.startBizDate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EndBizDate"] as? String {
                    self.endBizDate = value
                }
                if let value = dict["StartBizDate"] as? String {
                    self.startBizDate = value
                }
            }
        }
        public var bizDates: [CreateWorkflowInstancesRequest.Periods.BizDates]?

        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizDates != nil {
                var tmp : [Any] = []
                for k in self.bizDates! {
                    tmp.append(k.toMap())
                }
                map["BizDates"] = tmp
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BizDates"] as? [Any?] {
                var tmp : [CreateWorkflowInstancesRequest.Periods.BizDates] = []
                for v in value {
                    if v != nil {
                        var model = CreateWorkflowInstancesRequest.Periods.BizDates()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.bizDates = tmp
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
        }
    }
    public var autoStartEnabled: Bool?

    public var comment: String?

    public var defaultRunProperties: CreateWorkflowInstancesRequest.DefaultRunProperties?

    public var envType: String?

    public var name: String?

    public var periods: CreateWorkflowInstancesRequest.Periods?

    public var projectId: Int64?

    public var taskParameters: String?

    public var type: String?

    public var workflowId: Int64?

    public var workflowParameters: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.defaultRunProperties?.validate()
        try self.periods?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStartEnabled != nil {
            map["AutoStartEnabled"] = self.autoStartEnabled!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.defaultRunProperties != nil {
            map["DefaultRunProperties"] = self.defaultRunProperties?.toMap()
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.periods != nil {
            map["Periods"] = self.periods?.toMap()
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskParameters != nil {
            map["TaskParameters"] = self.taskParameters!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        if self.workflowParameters != nil {
            map["WorkflowParameters"] = self.workflowParameters!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoStartEnabled"] as? Bool {
            self.autoStartEnabled = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["DefaultRunProperties"] as? [String: Any?] {
            var model = CreateWorkflowInstancesRequest.DefaultRunProperties()
            model.fromMap(value)
            self.defaultRunProperties = model
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Periods"] as? [String: Any?] {
            var model = CreateWorkflowInstancesRequest.Periods()
            model.fromMap(value)
            self.periods = model
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskParameters"] as? String {
            self.taskParameters = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["WorkflowId"] as? Int64 {
            self.workflowId = value
        }
        if let value = dict["WorkflowParameters"] as? String {
            self.workflowParameters = value
        }
    }
}

public class CreateWorkflowInstancesShrinkRequest : Tea.TeaModel {
    public var autoStartEnabled: Bool?

    public var comment: String?

    public var defaultRunPropertiesShrink: String?

    public var envType: String?

    public var name: String?

    public var periodsShrink: String?

    public var projectId: Int64?

    public var taskParameters: String?

    public var type: String?

    public var workflowId: Int64?

    public var workflowParameters: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStartEnabled != nil {
            map["AutoStartEnabled"] = self.autoStartEnabled!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.defaultRunPropertiesShrink != nil {
            map["DefaultRunProperties"] = self.defaultRunPropertiesShrink!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.periodsShrink != nil {
            map["Periods"] = self.periodsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.taskParameters != nil {
            map["TaskParameters"] = self.taskParameters!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        if self.workflowParameters != nil {
            map["WorkflowParameters"] = self.workflowParameters!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoStartEnabled"] as? Bool {
            self.autoStartEnabled = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["DefaultRunProperties"] as? String {
            self.defaultRunPropertiesShrink = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Periods"] as? String {
            self.periodsShrink = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TaskParameters"] as? String {
            self.taskParameters = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["WorkflowId"] as? Int64 {
            self.workflowId = value
        }
        if let value = dict["WorkflowParameters"] as? String {
            self.workflowParameters = value
        }
    }
}

public class CreateWorkflowInstancesResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperationId"] as? String {
            self.operationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateWorkflowInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkflowInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateWorkflowInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAlertRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteAlertRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAlertRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCertificateRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCertificateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDIAlarmRuleRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var DIJobId: Int64?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? Int64 {
            self.DIAlarmRuleId = value
        }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteDIAlarmRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDIAlarmRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataAssetTagRequest : Tea.TeaModel {
    public var key: String?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["Values"] as? [String] {
            self.values = value
        }
    }
}

public class DeleteDataAssetTagShrinkRequest : Tea.TeaModel {
    public var key: String?

    public var valuesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.valuesShrink != nil {
            map["Values"] = self.valuesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["Values"] as? String {
            self.valuesShrink = value
        }
    }
}

public class DeleteDataAssetTagResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDataAssetTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataAssetTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataAssetTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataQualityEvaluationTaskRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteDataQualityEvaluationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDataQualityEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataQualityEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataQualityEvaluationTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataQualityRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteDataQualityRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDataQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataQualityRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataQualityRuleTemplateRequest : Tea.TeaModel {
    public var code: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteDataQualityRuleTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDataQualityRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataQualityRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataQualityRuleTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataSourceRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteDataSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataSourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataSourceSharedRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteDataSourceSharedRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteDataSourceSharedRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourceSharedRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataSourceSharedRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFunctionRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteFunctionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFunctionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLineageRelationshipRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class DeleteLineageRelationshipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteLineageRelationshipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLineageRelationshipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLineageRelationshipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteMetaCollectionRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class DeleteMetaCollectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNetworkRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNodeRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteProjectRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteProjectMemberRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class DeleteProjectMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteProjectMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteResourceRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteResourceGroupRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class DeleteResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRouteRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteRouteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRouteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteTaskRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class DeleteTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteWorkflowRequest : Tea.TeaModel {
    public var clientUniqueCode: String?

    public var envType: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientUniqueCode != nil {
            map["ClientUniqueCode"] = self.clientUniqueCode!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientUniqueCode"] as? String {
            self.clientUniqueCode = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteWorkflowResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteWorkflowResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DeleteWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteWorkflowDefinitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachDataQualityRulesFromEvaluationTaskRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityRuleIds: [Int64]?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityRuleIds != nil {
            map["DataQualityRuleIds"] = self.dataQualityRuleIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityEvaluationTaskId"] as? Int64 {
            self.dataQualityEvaluationTaskId = value
        }
        if let value = dict["DataQualityRuleIds"] as? [Int64] {
            self.dataQualityRuleIds = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DetachDataQualityRulesFromEvaluationTaskShrinkRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityRuleIdsShrink: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityRuleIdsShrink != nil {
            map["DataQualityRuleIds"] = self.dataQualityRuleIdsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityEvaluationTaskId"] as? Int64 {
            self.dataQualityEvaluationTaskId = value
        }
        if let value = dict["DataQualityRuleIds"] as? String {
            self.dataQualityRuleIdsShrink = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class DetachDataQualityRulesFromEvaluationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DetachDataQualityRulesFromEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDataQualityRulesFromEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachDataQualityRulesFromEvaluationTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DissociateProjectFromResourceGroupRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class DissociateProjectFromResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DissociateProjectFromResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateProjectFromResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DissociateProjectFromResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExecPipelineRunStageRequest : Tea.TeaModel {
    public var code: String?

    public var id: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ExecPipelineRunStageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ExecPipelineRunStageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecPipelineRunStageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExecPipelineRunStageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExecuteAdhocWorkflowInstanceRequest : Tea.TeaModel {
    public class Tasks : Tea.TeaModel {
        public class DataSource : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class Dependencies : Tea.TeaModel {
            public var upstreamOutput: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.upstreamOutput != nil {
                    map["UpstreamOutput"] = self.upstreamOutput!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["UpstreamOutput"] as? String {
                    self.upstreamOutput = value
                }
            }
        }
        public class Inputs : Tea.TeaModel {
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var variables: [ExecuteAdhocWorkflowInstanceRequest.Tasks.Inputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Variables"] as? [Any?] {
                    var tmp : [ExecuteAdhocWorkflowInstanceRequest.Tasks.Inputs.Variables] = []
                    for v in value {
                        if v != nil {
                            var model = ExecuteAdhocWorkflowInstanceRequest.Tasks.Inputs.Variables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.variables = tmp
                }
            }
        }
        public class Outputs : Tea.TeaModel {
            public class TaskOutputs : Tea.TeaModel {
                public var output: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Output"] as? String {
                        self.output = value
                    }
                }
            }
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var taskOutputs: [ExecuteAdhocWorkflowInstanceRequest.Tasks.Outputs.TaskOutputs]?

            public var variables: [ExecuteAdhocWorkflowInstanceRequest.Tasks.Outputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskOutputs != nil {
                    var tmp : [Any] = []
                    for k in self.taskOutputs! {
                        tmp.append(k.toMap())
                    }
                    map["TaskOutputs"] = tmp
                }
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TaskOutputs"] as? [Any?] {
                    var tmp : [ExecuteAdhocWorkflowInstanceRequest.Tasks.Outputs.TaskOutputs] = []
                    for v in value {
                        if v != nil {
                            var model = ExecuteAdhocWorkflowInstanceRequest.Tasks.Outputs.TaskOutputs()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.taskOutputs = tmp
                }
                if let value = dict["Variables"] as? [Any?] {
                    var tmp : [ExecuteAdhocWorkflowInstanceRequest.Tasks.Outputs.Variables] = []
                    for v in value {
                        if v != nil {
                            var model = ExecuteAdhocWorkflowInstanceRequest.Tasks.Outputs.Variables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.variables = tmp
                }
            }
        }
        public class RuntimeResource : Tea.TeaModel {
            public var cu: String?

            public var image: String?

            public var resourceGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cu != nil {
                    map["Cu"] = self.cu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cu"] as? String {
                    self.cu = value
                }
                if let value = dict["Image"] as? String {
                    self.image = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
            }
        }
        public class Script : Tea.TeaModel {
            public var content: String?

            public var parameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["Parameters"] as? String {
                    self.parameters = value
                }
            }
        }
        public var clientUniqueCode: String?

        public var dataSource: ExecuteAdhocWorkflowInstanceRequest.Tasks.DataSource?

        public var dependencies: [ExecuteAdhocWorkflowInstanceRequest.Tasks.Dependencies]?

        public var inputs: ExecuteAdhocWorkflowInstanceRequest.Tasks.Inputs?

        public var name: String?

        public var outputs: ExecuteAdhocWorkflowInstanceRequest.Tasks.Outputs?

        public var owner: String?

        public var runtimeResource: ExecuteAdhocWorkflowInstanceRequest.Tasks.RuntimeResource?

        public var script: ExecuteAdhocWorkflowInstanceRequest.Tasks.Script?

        public var timeout: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSource?.validate()
            try self.inputs?.validate()
            try self.outputs?.validate()
            try self.runtimeResource?.validate()
            try self.script?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientUniqueCode != nil {
                map["ClientUniqueCode"] = self.clientUniqueCode!
            }
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource?.toMap()
            }
            if self.dependencies != nil {
                var tmp : [Any] = []
                for k in self.dependencies! {
                    tmp.append(k.toMap())
                }
                map["Dependencies"] = tmp
            }
            if self.inputs != nil {
                map["Inputs"] = self.inputs?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputs != nil {
                map["Outputs"] = self.outputs?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource?.toMap()
            }
            if self.script != nil {
                map["Script"] = self.script?.toMap()
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClientUniqueCode"] as? String {
                self.clientUniqueCode = value
            }
            if let value = dict["DataSource"] as? [String: Any?] {
                var model = ExecuteAdhocWorkflowInstanceRequest.Tasks.DataSource()
                model.fromMap(value)
                self.dataSource = model
            }
            if let value = dict["Dependencies"] as? [Any?] {
                var tmp : [ExecuteAdhocWorkflowInstanceRequest.Tasks.Dependencies] = []
                for v in value {
                    if v != nil {
                        var model = ExecuteAdhocWorkflowInstanceRequest.Tasks.Dependencies()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dependencies = tmp
            }
            if let value = dict["Inputs"] as? [String: Any?] {
                var model = ExecuteAdhocWorkflowInstanceRequest.Tasks.Inputs()
                model.fromMap(value)
                self.inputs = model
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Outputs"] as? [String: Any?] {
                var model = ExecuteAdhocWorkflowInstanceRequest.Tasks.Outputs()
                model.fromMap(value)
                self.outputs = model
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["RuntimeResource"] as? [String: Any?] {
                var model = ExecuteAdhocWorkflowInstanceRequest.Tasks.RuntimeResource()
                model.fromMap(value)
                self.runtimeResource = model
            }
            if let value = dict["Script"] as? [String: Any?] {
                var model = ExecuteAdhocWorkflowInstanceRequest.Tasks.Script()
                model.fromMap(value)
                self.script = model
            }
            if let value = dict["Timeout"] as? Int32 {
                self.timeout = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var bizDate: Int64?

    public var envType: String?

    public var name: String?

    public var owner: String?

    public var projectId: Int64?

    public var tasks: [ExecuteAdhocWorkflowInstanceRequest.Tasks]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tasks != nil {
            var tmp : [Any] = []
            for k in self.tasks! {
                tmp.append(k.toMap())
            }
            map["Tasks"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizDate"] as? Int64 {
            self.bizDate = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Tasks"] as? [Any?] {
            var tmp : [ExecuteAdhocWorkflowInstanceRequest.Tasks] = []
            for v in value {
                if v != nil {
                    var model = ExecuteAdhocWorkflowInstanceRequest.Tasks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tasks = tmp
        }
    }
}

public class ExecuteAdhocWorkflowInstanceShrinkRequest : Tea.TeaModel {
    public var bizDate: Int64?

    public var envType: String?

    public var name: String?

    public var owner: String?

    public var projectId: Int64?

    public var tasksShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tasksShrink != nil {
            map["Tasks"] = self.tasksShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizDate"] as? Int64 {
            self.bizDate = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Tasks"] as? String {
            self.tasksShrink = value
        }
    }
}

public class ExecuteAdhocWorkflowInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var workflowInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["WorkflowInstanceId"] as? Int64 {
            self.workflowInstanceId = value
        }
    }
}

public class ExecuteAdhocWorkflowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteAdhocWorkflowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExecuteAdhocWorkflowInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAlertRuleRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class GetAlertRuleResponseBody : Tea.TeaModel {
    public class AlertRule : Tea.TeaModel {
        public class Notification : Tea.TeaModel {
            public class Receivers : Tea.TeaModel {
                public var extension_: String?

                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Extension"] as? String {
                        self.extension_ = value
                    }
                    if let value = dict["ReceiverType"] as? String {
                        self.receiverType = value
                    }
                    if let value = dict["ReceiverValues"] as? [String] {
                        self.receiverValues = value
                    }
                }
            }
            public var channels: [String]?

            public var intervalInMinutes: Int32?

            public var maximum: Int32?

            public var receivers: [GetAlertRuleResponseBody.AlertRule.Notification.Receivers]?

            public var silenceEndTime: String?

            public var silenceStartTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.intervalInMinutes != nil {
                    map["IntervalInMinutes"] = self.intervalInMinutes!
                }
                if self.maximum != nil {
                    map["Maximum"] = self.maximum!
                }
                if self.receivers != nil {
                    var tmp : [Any] = []
                    for k in self.receivers! {
                        tmp.append(k.toMap())
                    }
                    map["Receivers"] = tmp
                }
                if self.silenceEndTime != nil {
                    map["SilenceEndTime"] = self.silenceEndTime!
                }
                if self.silenceStartTime != nil {
                    map["SilenceStartTime"] = self.silenceStartTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Channels"] as? [String] {
                    self.channels = value
                }
                if let value = dict["IntervalInMinutes"] as? Int32 {
                    self.intervalInMinutes = value
                }
                if let value = dict["Maximum"] as? Int32 {
                    self.maximum = value
                }
                if let value = dict["Receivers"] as? [Any?] {
                    var tmp : [GetAlertRuleResponseBody.AlertRule.Notification.Receivers] = []
                    for v in value {
                        if v != nil {
                            var model = GetAlertRuleResponseBody.AlertRule.Notification.Receivers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.receivers = tmp
                }
                if let value = dict["SilenceEndTime"] as? String {
                    self.silenceEndTime = value
                }
                if let value = dict["SilenceStartTime"] as? String {
                    self.silenceStartTime = value
                }
            }
        }
        public class TriggerCondition : Tea.TeaModel {
            public class Extension_ : Tea.TeaModel {
                public class CycleUnfinished : Tea.TeaModel {
                    public class CycleAndTime : Tea.TeaModel {
                        public var cycleId: Int32?

                        public var time: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.cycleId != nil {
                                map["CycleId"] = self.cycleId!
                            }
                            if self.time != nil {
                                map["Time"] = self.time!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["CycleId"] as? Int32 {
                                self.cycleId = value
                            }
                            if let value = dict["Time"] as? String {
                                self.time = value
                            }
                        }
                    }
                    public var cycleAndTime: [GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleAndTime != nil {
                            var tmp : [Any] = []
                            for k in self.cycleAndTime! {
                                tmp.append(k.toMap())
                            }
                            map["CycleAndTime"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CycleAndTime"] as? [Any?] {
                            var tmp : [GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime] = []
                            for v in value {
                                if v != nil {
                                    var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.cycleAndTime = tmp
                        }
                    }
                }
                public class Error : Tea.TeaModel {
                    public var autoRerunAlertEnabled: Bool?

                    public var streamTaskIds: [Int64]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.autoRerunAlertEnabled != nil {
                            map["AutoRerunAlertEnabled"] = self.autoRerunAlertEnabled!
                        }
                        if self.streamTaskIds != nil {
                            map["StreamTaskIds"] = self.streamTaskIds!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AutoRerunAlertEnabled"] as? Bool {
                            self.autoRerunAlertEnabled = value
                        }
                        if let value = dict["StreamTaskIds"] as? [Int64] {
                            self.streamTaskIds = value
                        }
                    }
                }
                public class InstanceErrorCount : Tea.TeaModel {
                    public var count: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Count"] as? Int32 {
                            self.count = value
                        }
                    }
                }
                public class InstanceErrorPercentage : Tea.TeaModel {
                    public var percentage: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.percentage != nil {
                            map["Percentage"] = self.percentage!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Percentage"] as? Int32 {
                            self.percentage = value
                        }
                    }
                }
                public class InstanceTransferFluctuate : Tea.TeaModel {
                    public var percentage: Int32?

                    public var trend: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.percentage != nil {
                            map["Percentage"] = self.percentage!
                        }
                        if self.trend != nil {
                            map["Trend"] = self.trend!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Percentage"] as? Int32 {
                            self.percentage = value
                        }
                        if let value = dict["Trend"] as? String {
                            self.trend = value
                        }
                    }
                }
                public class Timeout : Tea.TeaModel {
                    public var timeoutInMinutes: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timeoutInMinutes != nil {
                            map["TimeoutInMinutes"] = self.timeoutInMinutes!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TimeoutInMinutes"] as? Int32 {
                            self.timeoutInMinutes = value
                        }
                    }
                }
                public class UnFinished : Tea.TeaModel {
                    public var unFinishedTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.unFinishedTime != nil {
                            map["UnFinishedTime"] = self.unFinishedTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["UnFinishedTime"] as? String {
                            self.unFinishedTime = value
                        }
                    }
                }
                public var cycleUnfinished: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished?

                public var error: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.Error?

                public var instanceErrorCount: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceErrorCount?

                public var instanceErrorPercentage: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceErrorPercentage?

                public var instanceTransferFluctuate: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceTransferFluctuate?

                public var timeout: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.Timeout?

                public var unFinished: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.UnFinished?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.cycleUnfinished?.validate()
                    try self.error?.validate()
                    try self.instanceErrorCount?.validate()
                    try self.instanceErrorPercentage?.validate()
                    try self.instanceTransferFluctuate?.validate()
                    try self.timeout?.validate()
                    try self.unFinished?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleUnfinished != nil {
                        map["CycleUnfinished"] = self.cycleUnfinished?.toMap()
                    }
                    if self.error != nil {
                        map["Error"] = self.error?.toMap()
                    }
                    if self.instanceErrorCount != nil {
                        map["InstanceErrorCount"] = self.instanceErrorCount?.toMap()
                    }
                    if self.instanceErrorPercentage != nil {
                        map["InstanceErrorPercentage"] = self.instanceErrorPercentage?.toMap()
                    }
                    if self.instanceTransferFluctuate != nil {
                        map["InstanceTransferFluctuate"] = self.instanceTransferFluctuate?.toMap()
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout?.toMap()
                    }
                    if self.unFinished != nil {
                        map["UnFinished"] = self.unFinished?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CycleUnfinished"] as? [String: Any?] {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished()
                        model.fromMap(value)
                        self.cycleUnfinished = model
                    }
                    if let value = dict["Error"] as? [String: Any?] {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.Error()
                        model.fromMap(value)
                        self.error = model
                    }
                    if let value = dict["InstanceErrorCount"] as? [String: Any?] {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceErrorCount()
                        model.fromMap(value)
                        self.instanceErrorCount = model
                    }
                    if let value = dict["InstanceErrorPercentage"] as? [String: Any?] {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceErrorPercentage()
                        model.fromMap(value)
                        self.instanceErrorPercentage = model
                    }
                    if let value = dict["InstanceTransferFluctuate"] as? [String: Any?] {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceTransferFluctuate()
                        model.fromMap(value)
                        self.instanceTransferFluctuate = model
                    }
                    if let value = dict["Timeout"] as? [String: Any?] {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.Timeout()
                        model.fromMap(value)
                        self.timeout = model
                    }
                    if let value = dict["UnFinished"] as? [String: Any?] {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.UnFinished()
                        model.fromMap(value)
                        self.unFinished = model
                    }
                }
            }
            public class Target : Tea.TeaModel {
                public var allowTasks: [Int64]?

                public var ids: [Int64]?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allowTasks != nil {
                        map["AllowTasks"] = self.allowTasks!
                    }
                    if self.ids != nil {
                        map["Ids"] = self.ids!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllowTasks"] as? [Int64] {
                        self.allowTasks = value
                    }
                    if let value = dict["Ids"] as? [Int64] {
                        self.ids = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var extension_: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_?

            public var target: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Target?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.extension_?.validate()
                try self.target?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extension_ != nil {
                    map["Extension"] = self.extension_?.toMap()
                }
                if self.target != nil {
                    map["Target"] = self.target?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Extension"] as? [String: Any?] {
                    var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_()
                    model.fromMap(value)
                    self.extension_ = model
                }
                if let value = dict["Target"] as? [String: Any?] {
                    var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Target()
                    model.fromMap(value)
                    self.target = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var enabled: Bool?

        public var id: Int64?

        public var name: String?

        public var notification: GetAlertRuleResponseBody.AlertRule.Notification?

        public var owner: String?

        public var triggerCondition: GetAlertRuleResponseBody.AlertRule.TriggerCondition?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notification?.validate()
            try self.triggerCondition?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notification != nil {
                map["Notification"] = self.notification?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.triggerCondition != nil {
                map["TriggerCondition"] = self.triggerCondition?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Notification"] as? [String: Any?] {
                var model = GetAlertRuleResponseBody.AlertRule.Notification()
                model.fromMap(value)
                self.notification = model
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["TriggerCondition"] as? [String: Any?] {
                var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition()
                model.fromMap(value)
                self.triggerCondition = model
            }
        }
    }
    public var alertRule: GetAlertRuleResponseBody.AlertRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertRule != nil {
            map["AlertRule"] = self.alertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlertRule"] as? [String: Any?] {
            var model = GetAlertRuleResponseBody.AlertRule()
            model.fromMap(value)
            self.alertRule = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAlertRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCatalogRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class GetCatalogResponseBody : Tea.TeaModel {
    public var catalog: Catalog?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.catalog?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalog != nil {
            map["Catalog"] = self.catalog?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Catalog"] as? [String: Any?] {
            var model = Catalog()
            model.fromMap(value)
            self.catalog = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetCatalogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCatalogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCatalogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCertificateRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetCertificateResponseBody : Tea.TeaModel {
    public class Certificate : Tea.TeaModel {
        public var createTime: Int64?

        public var createUser: String?

        public var description_: String?

        public var fileSizeInBytes: Int64?

        public var id: Int64?

        public var name: String?

        public var projectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.fileSizeInBytes != nil {
                map["FileSizeInBytes"] = self.fileSizeInBytes!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["FileSizeInBytes"] as? Int64 {
                self.fileSizeInBytes = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
        }
    }
    public var certificate: GetCertificateResponseBody.Certificate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certificate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificate != nil {
            map["Certificate"] = self.certificate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Certificate"] as? [String: Any?] {
            var model = GetCertificateResponseBody.Certificate()
            model.fromMap(value)
            self.certificate = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCertificateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetColumnRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class GetColumnResponseBody : Tea.TeaModel {
    public var column: Column?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.column?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.column != nil {
            map["Column"] = self.column?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Column"] as? [String: Any?] {
            var model = Column()
            model.fromMap(value)
            self.column = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetColumnResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetColumnResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetColumnResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCreateWorkflowInstancesResultRequest : Tea.TeaModel {
    public var operationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OperationId"] as? String {
            self.operationId = value
        }
    }
}

public class GetCreateWorkflowInstancesResultResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var failureMessage: String?

        public var status: String?

        public var workflowInstanceIds: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failureMessage != nil {
                map["FailureMessage"] = self.failureMessage!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.workflowInstanceIds != nil {
                map["WorkflowInstanceIds"] = self.workflowInstanceIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FailureMessage"] as? String {
                self.failureMessage = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["WorkflowInstanceIds"] as? [Int64] {
                self.workflowInstanceIds = value
            }
        }
    }
    public var requestId: String?

    public var result: GetCreateWorkflowInstancesResultResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = GetCreateWorkflowInstancesResultResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class GetCreateWorkflowInstancesResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCreateWorkflowInstancesResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCreateWorkflowInstancesResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var id: Int64?

    public var projectId: Int64?

    public var withDetails: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.withDetails != nil {
            map["WithDetails"] = self.withDetails!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["WithDetails"] as? Bool {
            self.withDetails = value
        }
    }
}

public class GetDIJobResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DestinationDataSourceSettings : Tea.TeaModel {
            public var dataSourceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataSourceName"] as? String {
                    self.dataSourceName = value
                }
            }
        }
        public class JobSettings : Tea.TeaModel {
            public class ColumnDataTypeSettings : Tea.TeaModel {
                public var destinationDataType: String?

                public var sourceDataType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destinationDataType != nil {
                        map["DestinationDataType"] = self.destinationDataType!
                    }
                    if self.sourceDataType != nil {
                        map["SourceDataType"] = self.sourceDataType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DestinationDataType"] as? String {
                        self.destinationDataType = value
                    }
                    if let value = dict["SourceDataType"] as? String {
                        self.sourceDataType = value
                    }
                }
            }
            public class CycleScheduleSettings : Tea.TeaModel {
                public var cycleMigrationType: String?

                public var scheduleParameters: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleMigrationType != nil {
                        map["CycleMigrationType"] = self.cycleMigrationType!
                    }
                    if self.scheduleParameters != nil {
                        map["ScheduleParameters"] = self.scheduleParameters!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CycleMigrationType"] as? String {
                        self.cycleMigrationType = value
                    }
                    if let value = dict["ScheduleParameters"] as? String {
                        self.scheduleParameters = value
                    }
                }
            }
            public class DdlHandlingSettings : Tea.TeaModel {
                public var action: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["Action"] = self.action!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Action"] as? String {
                        self.action = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class RuntimeSettings : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var channelSettings: String?

            public var columnDataTypeSettings: [GetDIJobResponseBody.PagingInfo.JobSettings.ColumnDataTypeSettings]?

            public var cycleScheduleSettings: GetDIJobResponseBody.PagingInfo.JobSettings.CycleScheduleSettings?

            public var ddlHandlingSettings: [GetDIJobResponseBody.PagingInfo.JobSettings.DdlHandlingSettings]?

            public var runtimeSettings: [GetDIJobResponseBody.PagingInfo.JobSettings.RuntimeSettings]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cycleScheduleSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelSettings != nil {
                    map["ChannelSettings"] = self.channelSettings!
                }
                if self.columnDataTypeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.columnDataTypeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["ColumnDataTypeSettings"] = tmp
                }
                if self.cycleScheduleSettings != nil {
                    map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
                }
                if self.ddlHandlingSettings != nil {
                    var tmp : [Any] = []
                    for k in self.ddlHandlingSettings! {
                        tmp.append(k.toMap())
                    }
                    map["DdlHandlingSettings"] = tmp
                }
                if self.runtimeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.runtimeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["RuntimeSettings"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChannelSettings"] as? String {
                    self.channelSettings = value
                }
                if let value = dict["ColumnDataTypeSettings"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.PagingInfo.JobSettings.ColumnDataTypeSettings] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.PagingInfo.JobSettings.ColumnDataTypeSettings()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.columnDataTypeSettings = tmp
                }
                if let value = dict["CycleScheduleSettings"] as? [String: Any?] {
                    var model = GetDIJobResponseBody.PagingInfo.JobSettings.CycleScheduleSettings()
                    model.fromMap(value)
                    self.cycleScheduleSettings = model
                }
                if let value = dict["DdlHandlingSettings"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.PagingInfo.JobSettings.DdlHandlingSettings] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.PagingInfo.JobSettings.DdlHandlingSettings()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ddlHandlingSettings = tmp
                }
                if let value = dict["RuntimeSettings"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.PagingInfo.JobSettings.RuntimeSettings] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.PagingInfo.JobSettings.RuntimeSettings()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.runtimeSettings = tmp
                }
            }
        }
        public class ResourceSettings : Tea.TeaModel {
            public class OfflineResourceSettings : Tea.TeaModel {
                public var requestedCu: Double?

                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestedCu != nil {
                        map["RequestedCu"] = self.requestedCu!
                    }
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RequestedCu"] as? Double {
                        self.requestedCu = value
                    }
                    if let value = dict["ResourceGroupIdentifier"] as? String {
                        self.resourceGroupIdentifier = value
                    }
                }
            }
            public class RealtimeResourceSettings : Tea.TeaModel {
                public var requestedCu: Double?

                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestedCu != nil {
                        map["RequestedCu"] = self.requestedCu!
                    }
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RequestedCu"] as? Double {
                        self.requestedCu = value
                    }
                    if let value = dict["ResourceGroupIdentifier"] as? String {
                        self.resourceGroupIdentifier = value
                    }
                }
            }
            public class ScheduleResourceSettings : Tea.TeaModel {
                public var requestedCu: Double?

                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestedCu != nil {
                        map["RequestedCu"] = self.requestedCu!
                    }
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RequestedCu"] as? Double {
                        self.requestedCu = value
                    }
                    if let value = dict["ResourceGroupIdentifier"] as? String {
                        self.resourceGroupIdentifier = value
                    }
                }
            }
            public var offlineResourceSettings: GetDIJobResponseBody.PagingInfo.ResourceSettings.OfflineResourceSettings?

            public var realtimeResourceSettings: GetDIJobResponseBody.PagingInfo.ResourceSettings.RealtimeResourceSettings?

            public var scheduleResourceSettings: GetDIJobResponseBody.PagingInfo.ResourceSettings.ScheduleResourceSettings?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.offlineResourceSettings?.validate()
                try self.realtimeResourceSettings?.validate()
                try self.scheduleResourceSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.offlineResourceSettings != nil {
                    map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
                }
                if self.realtimeResourceSettings != nil {
                    map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
                }
                if self.scheduleResourceSettings != nil {
                    map["ScheduleResourceSettings"] = self.scheduleResourceSettings?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OfflineResourceSettings"] as? [String: Any?] {
                    var model = GetDIJobResponseBody.PagingInfo.ResourceSettings.OfflineResourceSettings()
                    model.fromMap(value)
                    self.offlineResourceSettings = model
                }
                if let value = dict["RealtimeResourceSettings"] as? [String: Any?] {
                    var model = GetDIJobResponseBody.PagingInfo.ResourceSettings.RealtimeResourceSettings()
                    model.fromMap(value)
                    self.realtimeResourceSettings = model
                }
                if let value = dict["ScheduleResourceSettings"] as? [String: Any?] {
                    var model = GetDIJobResponseBody.PagingInfo.ResourceSettings.ScheduleResourceSettings()
                    model.fromMap(value)
                    self.scheduleResourceSettings = model
                }
            }
        }
        public class SourceDataSourceSettings : Tea.TeaModel {
            public class DataSourceProperties : Tea.TeaModel {
                public var encoding: String?

                public var timezone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Encoding"] as? String {
                        self.encoding = value
                    }
                    if let value = dict["Timezone"] as? String {
                        self.timezone = value
                    }
                }
            }
            public var dataSourceName: String?

            public var dataSourceProperties: GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings.DataSourceProperties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSourceProperties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.dataSourceProperties != nil {
                    map["DataSourceProperties"] = self.dataSourceProperties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataSourceName"] as? String {
                    self.dataSourceName = value
                }
                if let value = dict["DataSourceProperties"] as? [String: Any?] {
                    var model = GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings.DataSourceProperties()
                    model.fromMap(value)
                    self.dataSourceProperties = model
                }
            }
        }
        public class TableMappings : Tea.TeaModel {
            public class SourceObjectSelectionRules : Tea.TeaModel {
                public var action: String?

                public var expression: String?

                public var expressionType: String?

                public var objectType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["Action"] = self.action!
                    }
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.expressionType != nil {
                        map["ExpressionType"] = self.expressionType!
                    }
                    if self.objectType != nil {
                        map["ObjectType"] = self.objectType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Action"] as? String {
                        self.action = value
                    }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["ExpressionType"] as? String {
                        self.expressionType = value
                    }
                    if let value = dict["ObjectType"] as? String {
                        self.objectType = value
                    }
                }
            }
            public class TransformationRules : Tea.TeaModel {
                public var ruleActionType: String?

                public var ruleName: String?

                public var ruleTargetType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleActionType != nil {
                        map["RuleActionType"] = self.ruleActionType!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    if self.ruleTargetType != nil {
                        map["RuleTargetType"] = self.ruleTargetType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RuleActionType"] as? String {
                        self.ruleActionType = value
                    }
                    if let value = dict["RuleName"] as? String {
                        self.ruleName = value
                    }
                    if let value = dict["RuleTargetType"] as? String {
                        self.ruleTargetType = value
                    }
                }
            }
            public var sourceObjectSelectionRules: [GetDIJobResponseBody.PagingInfo.TableMappings.SourceObjectSelectionRules]?

            public var transformationRules: [GetDIJobResponseBody.PagingInfo.TableMappings.TransformationRules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceObjectSelectionRules != nil {
                    var tmp : [Any] = []
                    for k in self.sourceObjectSelectionRules! {
                        tmp.append(k.toMap())
                    }
                    map["SourceObjectSelectionRules"] = tmp
                }
                if self.transformationRules != nil {
                    var tmp : [Any] = []
                    for k in self.transformationRules! {
                        tmp.append(k.toMap())
                    }
                    map["TransformationRules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SourceObjectSelectionRules"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.PagingInfo.TableMappings.SourceObjectSelectionRules] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.PagingInfo.TableMappings.SourceObjectSelectionRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sourceObjectSelectionRules = tmp
                }
                if let value = dict["TransformationRules"] as? [Any?] {
                    var tmp : [GetDIJobResponseBody.PagingInfo.TableMappings.TransformationRules] = []
                    for v in value {
                        if v != nil {
                            var model = GetDIJobResponseBody.PagingInfo.TableMappings.TransformationRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.transformationRules = tmp
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleExpression: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleExpression != nil {
                    map["RuleExpression"] = self.ruleExpression!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RuleActionType"] as? String {
                    self.ruleActionType = value
                }
                if let value = dict["RuleExpression"] as? String {
                    self.ruleExpression = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["RuleTargetType"] as? String {
                    self.ruleTargetType = value
                }
            }
        }
        public var DIJobId: String?

        public var description_: String?

        public var destinationDataSourceSettings: [GetDIJobResponseBody.PagingInfo.DestinationDataSourceSettings]?

        public var destinationDataSourceType: String?

        public var id: Int64?

        public var jobName: String?

        public var jobSettings: GetDIJobResponseBody.PagingInfo.JobSettings?

        public var jobStatus: String?

        public var jobType: String?

        public var migrationType: String?

        public var projectId: Int64?

        public var resourceSettings: GetDIJobResponseBody.PagingInfo.ResourceSettings?

        public var sourceDataSourceSettings: [GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings]?

        public var sourceDataSourceType: String?

        public var tableMappings: [GetDIJobResponseBody.PagingInfo.TableMappings]?

        public var transformationRules: [GetDIJobResponseBody.PagingInfo.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.jobSettings?.validate()
            try self.resourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobId != nil {
                map["DIJobId"] = self.DIJobId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationDataSourceSettings != nil {
                var tmp : [Any] = []
                for k in self.destinationDataSourceSettings! {
                    tmp.append(k.toMap())
                }
                map["DestinationDataSourceSettings"] = tmp
            }
            if self.destinationDataSourceType != nil {
                map["DestinationDataSourceType"] = self.destinationDataSourceType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.jobSettings != nil {
                map["JobSettings"] = self.jobSettings?.toMap()
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.migrationType != nil {
                map["MigrationType"] = self.migrationType!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.resourceSettings != nil {
                map["ResourceSettings"] = self.resourceSettings?.toMap()
            }
            if self.sourceDataSourceSettings != nil {
                var tmp : [Any] = []
                for k in self.sourceDataSourceSettings! {
                    tmp.append(k.toMap())
                }
                map["SourceDataSourceSettings"] = tmp
            }
            if self.sourceDataSourceType != nil {
                map["SourceDataSourceType"] = self.sourceDataSourceType!
            }
            if self.tableMappings != nil {
                var tmp : [Any] = []
                for k in self.tableMappings! {
                    tmp.append(k.toMap())
                }
                map["TableMappings"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DIJobId"] as? String {
                self.DIJobId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DestinationDataSourceSettings"] as? [Any?] {
                var tmp : [GetDIJobResponseBody.PagingInfo.DestinationDataSourceSettings] = []
                for v in value {
                    if v != nil {
                        var model = GetDIJobResponseBody.PagingInfo.DestinationDataSourceSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.destinationDataSourceSettings = tmp
            }
            if let value = dict["DestinationDataSourceType"] as? String {
                self.destinationDataSourceType = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["JobName"] as? String {
                self.jobName = value
            }
            if let value = dict["JobSettings"] as? [String: Any?] {
                var model = GetDIJobResponseBody.PagingInfo.JobSettings()
                model.fromMap(value)
                self.jobSettings = model
            }
            if let value = dict["JobStatus"] as? String {
                self.jobStatus = value
            }
            if let value = dict["JobType"] as? String {
                self.jobType = value
            }
            if let value = dict["MigrationType"] as? String {
                self.migrationType = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["ResourceSettings"] as? [String: Any?] {
                var model = GetDIJobResponseBody.PagingInfo.ResourceSettings()
                model.fromMap(value)
                self.resourceSettings = model
            }
            if let value = dict["SourceDataSourceSettings"] as? [Any?] {
                var tmp : [GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings] = []
                for v in value {
                    if v != nil {
                        var model = GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sourceDataSourceSettings = tmp
            }
            if let value = dict["SourceDataSourceType"] as? String {
                self.sourceDataSourceType = value
            }
            if let value = dict["TableMappings"] as? [Any?] {
                var tmp : [GetDIJobResponseBody.PagingInfo.TableMappings] = []
                for v in value {
                    if v != nil {
                        var model = GetDIJobResponseBody.PagingInfo.TableMappings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tableMappings = tmp
            }
            if let value = dict["TransformationRules"] as? [Any?] {
                var tmp : [GetDIJobResponseBody.PagingInfo.TransformationRules] = []
                for v in value {
                    if v != nil {
                        var model = GetDIJobResponseBody.PagingInfo.TransformationRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.transformationRules = tmp
            }
        }
    }
    public var pagingInfo: GetDIJobResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = GetDIJobResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDIJobLogRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var failoverId: Int64?

    public var id: Int64?

    public var instanceId: Int64?

    public var nodeType: String?

    public var pageNumber: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.failoverId != nil {
            map["FailoverId"] = self.failoverId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeType != nil {
            map["NodeType"] = self.nodeType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["FailoverId"] as? Int64 {
            self.failoverId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["NodeType"] as? String {
            self.nodeType = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
    }
}

public class GetDIJobLogResponseBody : Tea.TeaModel {
    public var log: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.log != nil {
            map["Log"] = self.log!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Log"] as? String {
            self.log = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDIJobLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDIJobLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDIJobLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataQualityEvaluationTaskRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetDataQualityEvaluationTaskResponseBody : Tea.TeaModel {
    public class DataQualityEvaluationTask : Tea.TeaModel {
        public class Hooks : Tea.TeaModel {
            public var condition: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Condition"] as? String {
                    self.condition = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class Notifications : Tea.TeaModel {
            public class Notifications : Tea.TeaModel {
                public class NotificationChannels : Tea.TeaModel {
                    public var channels: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Channels"] as? [String] {
                            self.channels = value
                        }
                    }
                }
                public class NotificationReceivers : Tea.TeaModel {
                    public var extension_: String?

                    public var receiverType: String?

                    public var receiverValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extension_ != nil {
                            map["Extension"] = self.extension_!
                        }
                        if self.receiverType != nil {
                            map["ReceiverType"] = self.receiverType!
                        }
                        if self.receiverValues != nil {
                            map["ReceiverValues"] = self.receiverValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Extension"] as? String {
                            self.extension_ = value
                        }
                        if let value = dict["ReceiverType"] as? String {
                            self.receiverType = value
                        }
                        if let value = dict["ReceiverValues"] as? [String] {
                            self.receiverValues = value
                        }
                    }
                }
                public var notificationChannels: [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels]?

                public var notificationReceivers: [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.notificationChannels != nil {
                        var tmp : [Any] = []
                        for k in self.notificationChannels! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationChannels"] = tmp
                    }
                    if self.notificationReceivers != nil {
                        var tmp : [Any] = []
                        for k in self.notificationReceivers! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationReceivers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NotificationChannels"] as? [Any?] {
                        var tmp : [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels] = []
                        for v in value {
                            if v != nil {
                                var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notificationChannels = tmp
                    }
                    if let value = dict["NotificationReceivers"] as? [Any?] {
                        var tmp : [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers] = []
                        for v in value {
                            if v != nil {
                                var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notificationReceivers = tmp
                    }
                }
            }
            public var condition: String?

            public var notifications: [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.notifications != nil {
                    var tmp : [Any] = []
                    for k in self.notifications! {
                        tmp.append(k.toMap())
                    }
                    map["Notifications"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Condition"] as? String {
                    self.condition = value
                }
                if let value = dict["Notifications"] as? [Any?] {
                    var tmp : [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notifications = tmp
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var databaseType: String?

            public var partitionSpec: String?

            public var tableGuid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseType != nil {
                    map["DatabaseType"] = self.databaseType!
                }
                if self.partitionSpec != nil {
                    map["PartitionSpec"] = self.partitionSpec!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DatabaseType"] as? String {
                    self.databaseType = value
                }
                if let value = dict["PartitionSpec"] as? String {
                    self.partitionSpec = value
                }
                if let value = dict["TableGuid"] as? String {
                    self.tableGuid = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public var taskIds: [Int64]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskIds != nil {
                    map["TaskIds"] = self.taskIds!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TaskIds"] as? [Int64] {
                    self.taskIds = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var dataSourceId: Int64?

        public var description_: String?

        public var hooks: [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Hooks]?

        public var id: Int64?

        public var name: String?

        public var notifications: GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications?

        public var projectId: Int64?

        public var runtimeConf: String?

        public var target: GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Target?

        public var trigger: GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Trigger?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notifications?.validate()
            try self.target?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceId != nil {
                map["DataSourceId"] = self.dataSourceId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.hooks != nil {
                var tmp : [Any] = []
                for k in self.hooks! {
                    tmp.append(k.toMap())
                }
                map["Hooks"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifications != nil {
                map["Notifications"] = self.notifications?.toMap()
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.runtimeConf != nil {
                map["RuntimeConf"] = self.runtimeConf!
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSourceId"] as? Int64 {
                self.dataSourceId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Hooks"] as? [Any?] {
                var tmp : [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Hooks] = []
                for v in value {
                    if v != nil {
                        var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Hooks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hooks = tmp
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Notifications"] as? [String: Any?] {
                var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications()
                model.fromMap(value)
                self.notifications = model
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["RuntimeConf"] as? String {
                self.runtimeConf = value
            }
            if let value = dict["Target"] as? [String: Any?] {
                var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Target()
                model.fromMap(value)
                self.target = model
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
        }
    }
    public var dataQualityEvaluationTask: GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataQualityEvaluationTask?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTask != nil {
            map["DataQualityEvaluationTask"] = self.dataQualityEvaluationTask?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityEvaluationTask"] as? [String: Any?] {
            var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask()
            model.fromMap(value)
            self.dataQualityEvaluationTask = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDataQualityEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataQualityEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataQualityEvaluationTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataQualityEvaluationTaskInstanceRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetDataQualityEvaluationTaskInstanceResponseBody : Tea.TeaModel {
    public class DataQualityEvaluationTaskInstance : Tea.TeaModel {
        public class Results : Tea.TeaModel {
            public class Details : Tea.TeaModel {
                public var checkedValue: String?

                public var referencedValue: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkedValue != nil {
                        map["CheckedValue"] = self.checkedValue!
                    }
                    if self.referencedValue != nil {
                        map["ReferencedValue"] = self.referencedValue!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CheckedValue"] as? String {
                        self.checkedValue = value
                    }
                    if let value = dict["ReferencedValue"] as? String {
                        self.referencedValue = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public class Rule : Tea.TeaModel {
                public class CheckingConfig : Tea.TeaModel {
                    public class Thresholds : Tea.TeaModel {
                        public class Critical : Tea.TeaModel {
                            public var expression: String?

                            public var operator_: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.expression != nil {
                                    map["Expression"] = self.expression!
                                }
                                if self.operator_ != nil {
                                    map["Operator"] = self.operator_!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Expression"] as? String {
                                    self.expression = value
                                }
                                if let value = dict["Operator"] as? String {
                                    self.operator_ = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public class Expected : Tea.TeaModel {
                            public var expression: String?

                            public var operator_: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.expression != nil {
                                    map["Expression"] = self.expression!
                                }
                                if self.operator_ != nil {
                                    map["Operator"] = self.operator_!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Expression"] as? String {
                                    self.expression = value
                                }
                                if let value = dict["Operator"] as? String {
                                    self.operator_ = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public class Warned : Tea.TeaModel {
                            public var expression: String?

                            public var operator_: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.expression != nil {
                                    map["Expression"] = self.expression!
                                }
                                if self.operator_ != nil {
                                    map["Operator"] = self.operator_!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Expression"] as? String {
                                    self.expression = value
                                }
                                if let value = dict["Operator"] as? String {
                                    self.operator_ = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public var critical: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig.Thresholds.Critical?

                        public var expected: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig.Thresholds.Expected?

                        public var warned: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig.Thresholds.Warned?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.critical?.validate()
                            try self.expected?.validate()
                            try self.warned?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.critical != nil {
                                map["Critical"] = self.critical?.toMap()
                            }
                            if self.expected != nil {
                                map["Expected"] = self.expected?.toMap()
                            }
                            if self.warned != nil {
                                map["Warned"] = self.warned?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Critical"] as? [String: Any?] {
                                var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig.Thresholds.Critical()
                                model.fromMap(value)
                                self.critical = model
                            }
                            if let value = dict["Expected"] as? [String: Any?] {
                                var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig.Thresholds.Expected()
                                model.fromMap(value)
                                self.expected = model
                            }
                            if let value = dict["Warned"] as? [String: Any?] {
                                var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig.Thresholds.Warned()
                                model.fromMap(value)
                                self.warned = model
                            }
                        }
                    }
                    public var referencedSamplesFilter: String?

                    public var thresholds: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig.Thresholds?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.thresholds?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.referencedSamplesFilter != nil {
                            map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                        }
                        if self.thresholds != nil {
                            map["Thresholds"] = self.thresholds?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ReferencedSamplesFilter"] as? String {
                            self.referencedSamplesFilter = value
                        }
                        if let value = dict["Thresholds"] as? [String: Any?] {
                            var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig.Thresholds()
                            model.fromMap(value)
                            self.thresholds = model
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public class ErrorHandlers : Tea.TeaModel {
                    public var errorDataFilter: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorDataFilter != nil {
                            map["ErrorDataFilter"] = self.errorDataFilter!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ErrorDataFilter"] as? String {
                            self.errorDataFilter = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public class SamplingConfig : Tea.TeaModel {
                    public var metric: String?

                    public var metricParameters: String?

                    public var samplingFilter: String?

                    public var settingConfig: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.metric != nil {
                            map["Metric"] = self.metric!
                        }
                        if self.metricParameters != nil {
                            map["MetricParameters"] = self.metricParameters!
                        }
                        if self.samplingFilter != nil {
                            map["SamplingFilter"] = self.samplingFilter!
                        }
                        if self.settingConfig != nil {
                            map["SettingConfig"] = self.settingConfig!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Metric"] as? String {
                            self.metric = value
                        }
                        if let value = dict["MetricParameters"] as? String {
                            self.metricParameters = value
                        }
                        if let value = dict["SamplingFilter"] as? String {
                            self.samplingFilter = value
                        }
                        if let value = dict["SettingConfig"] as? String {
                            self.settingConfig = value
                        }
                    }
                }
                public class Target : Tea.TeaModel {
                    public var databaseType: String?

                    public var tableGuid: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.databaseType != nil {
                            map["DatabaseType"] = self.databaseType!
                        }
                        if self.tableGuid != nil {
                            map["TableGuid"] = self.tableGuid!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DatabaseType"] as? String {
                            self.databaseType = value
                        }
                        if let value = dict["TableGuid"] as? String {
                            self.tableGuid = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var checkingConfig: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig?

                public var description_: String?

                public var enabled: Bool?

                public var errorHandlers: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.ErrorHandlers]?

                public var id: Int64?

                public var name: String?

                public var projectId: Int64?

                public var samplingConfig: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.SamplingConfig?

                public var severity: String?

                public var target: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.Target?

                public var templateCode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.checkingConfig?.validate()
                    try self.samplingConfig?.validate()
                    try self.target?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkingConfig != nil {
                        map["CheckingConfig"] = self.checkingConfig?.toMap()
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.enabled != nil {
                        map["Enabled"] = self.enabled!
                    }
                    if self.errorHandlers != nil {
                        var tmp : [Any] = []
                        for k in self.errorHandlers! {
                            tmp.append(k.toMap())
                        }
                        map["ErrorHandlers"] = tmp
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.samplingConfig != nil {
                        map["SamplingConfig"] = self.samplingConfig?.toMap()
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    if self.target != nil {
                        map["Target"] = self.target?.toMap()
                    }
                    if self.templateCode != nil {
                        map["TemplateCode"] = self.templateCode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CheckingConfig"] as? [String: Any?] {
                        var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.CheckingConfig()
                        model.fromMap(value)
                        self.checkingConfig = model
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["Enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["ErrorHandlers"] as? [Any?] {
                        var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.ErrorHandlers] = []
                        for v in value {
                            if v != nil {
                                var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.ErrorHandlers()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.errorHandlers = tmp
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["SamplingConfig"] as? [String: Any?] {
                        var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.SamplingConfig()
                        model.fromMap(value)
                        self.samplingConfig = model
                    }
                    if let value = dict["Severity"] as? String {
                        self.severity = value
                    }
                    if let value = dict["Target"] as? [String: Any?] {
                        var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule.Target()
                        model.fromMap(value)
                        self.target = model
                    }
                    if let value = dict["TemplateCode"] as? String {
                        self.templateCode = value
                    }
                }
            }
            public var createTime: Int64?

            public var details: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Details]?

            public var id: Int64?

            public var rule: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule?

            public var sample: String?

            public var status: String?

            public var taskInstanceId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.rule?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.details != nil {
                    var tmp : [Any] = []
                    for k in self.details! {
                        tmp.append(k.toMap())
                    }
                    map["Details"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.rule != nil {
                    map["Rule"] = self.rule?.toMap()
                }
                if self.sample != nil {
                    map["Sample"] = self.sample!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskInstanceId != nil {
                    map["TaskInstanceId"] = self.taskInstanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Details"] as? [Any?] {
                    var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Details] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Details()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.details = tmp
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Rule"] as? [String: Any?] {
                    var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results.Rule()
                    model.fromMap(value)
                    self.rule = model
                }
                if let value = dict["Sample"] as? String {
                    self.sample = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TaskInstanceId"] as? Int64 {
                    self.taskInstanceId = value
                }
            }
        }
        public class Task : Tea.TeaModel {
            public class Hooks : Tea.TeaModel {
                public var condition: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class Notifications : Tea.TeaModel {
                public class Notifications : Tea.TeaModel {
                    public class NotificationChannels : Tea.TeaModel {
                        public var channels: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Channels"] as? [String] {
                                self.channels = value
                            }
                        }
                    }
                    public class NotificationReceivers : Tea.TeaModel {
                        public var extension_: String?

                        public var receiverType: String?

                        public var receiverValues: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extension_ != nil {
                                map["Extension"] = self.extension_!
                            }
                            if self.receiverType != nil {
                                map["ReceiverType"] = self.receiverType!
                            }
                            if self.receiverValues != nil {
                                map["ReceiverValues"] = self.receiverValues!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Extension"] as? String {
                                self.extension_ = value
                            }
                            if let value = dict["ReceiverType"] as? String {
                                self.receiverType = value
                            }
                            if let value = dict["ReceiverValues"] as? [String] {
                                self.receiverValues = value
                            }
                        }
                    }
                    public var notificationChannels: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels]?

                    public var notificationReceivers: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.notificationChannels != nil {
                            var tmp : [Any] = []
                            for k in self.notificationChannels! {
                                tmp.append(k.toMap())
                            }
                            map["NotificationChannels"] = tmp
                        }
                        if self.notificationReceivers != nil {
                            var tmp : [Any] = []
                            for k in self.notificationReceivers! {
                                tmp.append(k.toMap())
                            }
                            map["NotificationReceivers"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["NotificationChannels"] as? [Any?] {
                            var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels] = []
                            for v in value {
                                if v != nil {
                                    var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.notificationChannels = tmp
                        }
                        if let value = dict["NotificationReceivers"] as? [Any?] {
                            var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers] = []
                            for v in value {
                                if v != nil {
                                    var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.notificationReceivers = tmp
                        }
                    }
                }
                public var condition: String?

                public var notifications: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.notifications != nil {
                        var tmp : [Any] = []
                        for k in self.notifications! {
                            tmp.append(k.toMap())
                        }
                        map["Notifications"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["Notifications"] as? [Any?] {
                        var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications] = []
                        for v in value {
                            if v != nil {
                                var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notifications = tmp
                    }
                }
            }
            public class Target : Tea.TeaModel {
                public var databaseType: String?

                public var partitionSpec: String?

                public var tableGuid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseType != nil {
                        map["DatabaseType"] = self.databaseType!
                    }
                    if self.partitionSpec != nil {
                        map["PartitionSpec"] = self.partitionSpec!
                    }
                    if self.tableGuid != nil {
                        map["TableGuid"] = self.tableGuid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DatabaseType"] as? String {
                        self.databaseType = value
                    }
                    if let value = dict["PartitionSpec"] as? String {
                        self.partitionSpec = value
                    }
                    if let value = dict["TableGuid"] as? String {
                        self.tableGuid = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var taskIds: [Int64]?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.taskIds != nil {
                        map["TaskIds"] = self.taskIds!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TaskIds"] as? [Int64] {
                        self.taskIds = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var description_: String?

            public var hooks: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Hooks]?

            public var id: Int64?

            public var name: String?

            public var notifications: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications?

            public var projectId: Int64?

            public var runtimeConf: String?

            public var target: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Target?

            public var trigger: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Trigger?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notifications?.validate()
                try self.target?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hooks != nil {
                    var tmp : [Any] = []
                    for k in self.hooks! {
                        tmp.append(k.toMap())
                    }
                    map["Hooks"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifications != nil {
                    map["Notifications"] = self.notifications?.toMap()
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.runtimeConf != nil {
                    map["RuntimeConf"] = self.runtimeConf!
                }
                if self.target != nil {
                    map["Target"] = self.target?.toMap()
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Hooks"] as? [Any?] {
                    var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Hooks] = []
                    for v in value {
                        if v != nil {
                            var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Hooks()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.hooks = tmp
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Notifications"] as? [String: Any?] {
                    var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications()
                    model.fromMap(value)
                    self.notifications = model
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RuntimeConf"] as? String {
                    self.runtimeConf = value
                }
                if let value = dict["Target"] as? [String: Any?] {
                    var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Target()
                    model.fromMap(value)
                    self.target = model
                }
                if let value = dict["Trigger"] as? [String: Any?] {
                    var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Trigger()
                    model.fromMap(value)
                    self.trigger = model
                }
            }
        }
        public var createTime: Int64?

        public var finishTime: Int64?

        public var id: Int64?

        public var parameters: String?

        public var projectId: Int64?

        public var results: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results]?

        public var status: String?

        public var task: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task?

        public var triggerContext: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.task?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.parameters != nil {
                map["Parameters"] = self.parameters!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.results != nil {
                var tmp : [Any] = []
                for k in self.results! {
                    tmp.append(k.toMap())
                }
                map["Results"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.task != nil {
                map["Task"] = self.task?.toMap()
            }
            if self.triggerContext != nil {
                map["TriggerContext"] = self.triggerContext!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["FinishTime"] as? Int64 {
                self.finishTime = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Parameters"] as? String {
                self.parameters = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Results"] as? [Any?] {
                var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results] = []
                for v in value {
                    if v != nil {
                        var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Results()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.results = tmp
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Task"] as? [String: Any?] {
                var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task()
                model.fromMap(value)
                self.task = model
            }
            if let value = dict["TriggerContext"] as? String {
                self.triggerContext = value
            }
        }
    }
    public var dataQualityEvaluationTaskInstance: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataQualityEvaluationTaskInstance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskInstance != nil {
            map["DataQualityEvaluationTaskInstance"] = self.dataQualityEvaluationTaskInstance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityEvaluationTaskInstance"] as? [String: Any?] {
            var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance()
            model.fromMap(value)
            self.dataQualityEvaluationTaskInstance = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDataQualityEvaluationTaskInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataQualityEvaluationTaskInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataQualityEvaluationTaskInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataQualityRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetDataQualityRuleResponseBody : Tea.TeaModel {
    public class DataQualityRule : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public class Thresholds : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Expression"] as? String {
                            self.expression = value
                        }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public class Expected : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Expression"] as? String {
                            self.expression = value
                        }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public class Warned : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Expression"] as? String {
                            self.expression = value
                        }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var critical: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Critical?

                public var expected: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Expected?

                public var warned: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Warned?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.expected?.validate()
                    try self.warned?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.expected != nil {
                        map["Expected"] = self.expected?.toMap()
                    }
                    if self.warned != nil {
                        map["Warned"] = self.warned?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Critical"] as? [String: Any?] {
                        var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Critical()
                        model.fromMap(value)
                        self.critical = model
                    }
                    if let value = dict["Expected"] as? [String: Any?] {
                        var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Expected()
                        model.fromMap(value)
                        self.expected = model
                    }
                    if let value = dict["Warned"] as? [String: Any?] {
                        var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Warned()
                        model.fromMap(value)
                        self.warned = model
                    }
                }
            }
            public var referencedSamplesFilter: String?

            public var thresholds: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.thresholds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.thresholds != nil {
                    map["Thresholds"] = self.thresholds?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReferencedSamplesFilter"] as? String {
                    self.referencedSamplesFilter = value
                }
                if let value = dict["Thresholds"] as? [String: Any?] {
                    var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds()
                    model.fromMap(value)
                    self.thresholds = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class ErrorHandlers : Tea.TeaModel {
            public var errorDataFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorDataFilter != nil {
                    map["ErrorDataFilter"] = self.errorDataFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorDataFilter"] as? String {
                    self.errorDataFilter = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var samplingFilter: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.samplingFilter != nil {
                    map["SamplingFilter"] = self.samplingFilter!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Metric"] as? String {
                    self.metric = value
                }
                if let value = dict["MetricParameters"] as? String {
                    self.metricParameters = value
                }
                if let value = dict["SamplingFilter"] as? String {
                    self.samplingFilter = value
                }
                if let value = dict["SettingConfig"] as? String {
                    self.settingConfig = value
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var databaseType: String?

            public var partitionSpec: String?

            public var tableGuid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseType != nil {
                    map["DatabaseType"] = self.databaseType!
                }
                if self.partitionSpec != nil {
                    map["PartitionSpec"] = self.partitionSpec!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DatabaseType"] as? String {
                    self.databaseType = value
                }
                if let value = dict["PartitionSpec"] as? String {
                    self.partitionSpec = value
                }
                if let value = dict["TableGuid"] as? String {
                    self.tableGuid = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var checkingConfig: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig?

        public var description_: String?

        public var enabled: Bool?

        public var errorHandlers: [GetDataQualityRuleResponseBody.DataQualityRule.ErrorHandlers]?

        public var id: Int64?

        public var name: String?

        public var projectId: Int64?

        public var samplingConfig: GetDataQualityRuleResponseBody.DataQualityRule.SamplingConfig?

        public var severity: String?

        public var target: GetDataQualityRuleResponseBody.DataQualityRule.Target?

        public var templateCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.errorHandlers != nil {
                var tmp : [Any] = []
                for k in self.errorHandlers! {
                    tmp.append(k.toMap())
                }
                map["ErrorHandlers"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.templateCode != nil {
                map["TemplateCode"] = self.templateCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CheckingConfig"] as? [String: Any?] {
                var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig()
                model.fromMap(value)
                self.checkingConfig = model
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["ErrorHandlers"] as? [Any?] {
                var tmp : [GetDataQualityRuleResponseBody.DataQualityRule.ErrorHandlers] = []
                for v in value {
                    if v != nil {
                        var model = GetDataQualityRuleResponseBody.DataQualityRule.ErrorHandlers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.errorHandlers = tmp
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["SamplingConfig"] as? [String: Any?] {
                var model = GetDataQualityRuleResponseBody.DataQualityRule.SamplingConfig()
                model.fromMap(value)
                self.samplingConfig = model
            }
            if let value = dict["Severity"] as? String {
                self.severity = value
            }
            if let value = dict["Target"] as? [String: Any?] {
                var model = GetDataQualityRuleResponseBody.DataQualityRule.Target()
                model.fromMap(value)
                self.target = model
            }
            if let value = dict["TemplateCode"] as? String {
                self.templateCode = value
            }
        }
    }
    public var dataQualityRule: GetDataQualityRuleResponseBody.DataQualityRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataQualityRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRule != nil {
            map["DataQualityRule"] = self.dataQualityRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityRule"] as? [String: Any?] {
            var model = GetDataQualityRuleResponseBody.DataQualityRule()
            model.fromMap(value)
            self.dataQualityRule = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDataQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataQualityRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataQualityRuleTemplateRequest : Tea.TeaModel {
    public var code: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
    }
}

public class GetDataQualityRuleTemplateResponseBody : Tea.TeaModel {
    public class DataQualityRuleTemplate : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public var referencedSamplesFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReferencedSamplesFilter"] as? String {
                    self.referencedSamplesFilter = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Metric"] as? String {
                    self.metric = value
                }
                if let value = dict["MetricParameters"] as? String {
                    self.metricParameters = value
                }
                if let value = dict["SettingConfig"] as? String {
                    self.settingConfig = value
                }
            }
        }
        public var checkingConfig: GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate.CheckingConfig?

        public var code: String?

        public var directoryPath: String?

        public var name: String?

        public var projectId: Int64?

        public var samplingConfig: GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate.SamplingConfig?

        public var visibleScope: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.directoryPath != nil {
                map["DirectoryPath"] = self.directoryPath!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.visibleScope != nil {
                map["VisibleScope"] = self.visibleScope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CheckingConfig"] as? [String: Any?] {
                var model = GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate.CheckingConfig()
                model.fromMap(value)
                self.checkingConfig = model
            }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["DirectoryPath"] as? String {
                self.directoryPath = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["SamplingConfig"] as? [String: Any?] {
                var model = GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate.SamplingConfig()
                model.fromMap(value)
                self.samplingConfig = model
            }
            if let value = dict["VisibleScope"] as? String {
                self.visibleScope = value
            }
        }
    }
    public var dataQualityRuleTemplate: GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataQualityRuleTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRuleTemplate != nil {
            map["DataQualityRuleTemplate"] = self.dataQualityRuleTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityRuleTemplate"] as? [String: Any?] {
            var model = GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate()
            model.fromMap(value)
            self.dataQualityRuleTemplate = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDataQualityRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataQualityRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataQualityRuleTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDataSourceRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetDataSourceResponseBody : Tea.TeaModel {
    public class DataSource : Tea.TeaModel {
        public var connectionProperties: Any?

        public var connectionPropertiesMode: String?

        public var createTime: Int64?

        public var createUser: String?

        public var description_: String?

        public var id: Int64?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var name: String?

        public var projectId: Int64?

        public var qualifiedName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionProperties != nil {
                map["ConnectionProperties"] = self.connectionProperties!
            }
            if self.connectionPropertiesMode != nil {
                map["ConnectionPropertiesMode"] = self.connectionPropertiesMode!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.qualifiedName != nil {
                map["QualifiedName"] = self.qualifiedName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnectionProperties"] as? Any {
                self.connectionProperties = value
            }
            if let value = dict["ConnectionPropertiesMode"] as? String {
                self.connectionPropertiesMode = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["ModifyUser"] as? String {
                self.modifyUser = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["QualifiedName"] as? String {
                self.qualifiedName = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var dataSource: GetDataSourceResponseBody.DataSource?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataSource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSource"] as? [String: Any?] {
            var model = GetDataSourceResponseBody.DataSource()
            model.fromMap(value)
            self.dataSource = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDataSourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDatabaseRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class GetDatabaseResponseBody : Tea.TeaModel {
    public var database: Database?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.database?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Database"] as? [String: Any?] {
            var model = Database()
            model.fromMap(value)
            self.database = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDatabaseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFunctionRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetFunctionResponseBody : Tea.TeaModel {
    public class Function : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var modifyTime: Int64?

        public var name: String?

        public var owner: String?

        public var projectId: Int64?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Spec"] as? String {
                self.spec = value
            }
        }
    }
    public var function: GetFunctionResponseBody.Function?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.function?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.function != nil {
            map["Function"] = self.function?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Function"] as? [String: Any?] {
            var model = GetFunctionResponseBody.Function()
            model.fromMap(value)
            self.function = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFunctionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetJobStatusRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
    }
}

public class GetJobStatusResponseBody : Tea.TeaModel {
    public class JobStatus : Tea.TeaModel {
        public var completed: String?

        public var createTime: String?

        public var error: String?

        public var jobId: String?

        public var jobType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completed != nil {
                map["Completed"] = self.completed!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Completed"] as? String {
                self.completed = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["Error"] as? String {
                self.error = value
            }
            if let value = dict["JobId"] as? String {
                self.jobId = value
            }
            if let value = dict["JobType"] as? String {
                self.jobType = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var jobStatus: GetJobStatusResponseBody.JobStatus?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobStatus != nil {
            map["JobStatus"] = self.jobStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobStatus"] as? [String: Any?] {
            var model = GetJobStatusResponseBody.JobStatus()
            model.fromMap(value)
            self.jobStatus = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetJobStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetJobStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetJobStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetLineageRelationshipRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class GetLineageRelationshipResponseBody : Tea.TeaModel {
    public var lineageRelationship: LineageRelationship?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.lineageRelationship?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lineageRelationship != nil {
            map["LineageRelationship"] = self.lineageRelationship?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LineageRelationship"] as? [String: Any?] {
            var model = LineageRelationship()
            model.fromMap(value)
            self.lineageRelationship = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetLineageRelationshipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLineageRelationshipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetLineageRelationshipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMetaCollectionRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class GetMetaCollectionResponseBody : Tea.TeaModel {
    public class MetaCollection : Tea.TeaModel {
        public var administrators: [Int64]?

        public var createTime: Int64?

        public var createUser: String?

        public var description_: String?

        public var id: String?

        public var modifyTime: Int64?

        public var name: String?

        public var parentId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.administrators != nil {
                map["Administrators"] = self.administrators!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Administrators"] as? [Int64] {
                self.administrators = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ParentId"] as? String {
                self.parentId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var metaCollection: GetMetaCollectionResponseBody.MetaCollection?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.metaCollection?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metaCollection != nil {
            map["MetaCollection"] = self.metaCollection?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MetaCollection"] as? [String: Any?] {
            var model = GetMetaCollectionResponseBody.MetaCollection()
            model.fromMap(value)
            self.metaCollection = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNetworkRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetNetworkResponseBody : Tea.TeaModel {
    public class Network : Tea.TeaModel {
        public var createTime: Int64?

        public var createUser: String?

        public var id: Int64?

        public var resourceGroupId: String?

        public var securityGroupId: String?

        public var status: String?

        public var vpcId: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["VswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public var network: GetNetworkResponseBody.Network?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.network?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.network != nil {
            map["Network"] = self.network?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Network"] as? [String: Any?] {
            var model = GetNetworkResponseBody.Network()
            model.fromMap(value)
            self.network = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNodeRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetNodeResponseBody : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var modifyTime: Int64?

        public var name: String?

        public var owner: String?

        public var projectId: Int64?

        public var spec: String?

        public var taskId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Spec"] as? String {
                self.spec = value
            }
            if let value = dict["TaskId"] as? Int64 {
                self.taskId = value
            }
        }
    }
    public var node: GetNodeResponseBody.Node?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.node?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.node != nil {
            map["Node"] = self.node?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Node"] as? [String: Any?] {
            var model = GetNodeResponseBody.Node()
            model.fromMap(value)
            self.node = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPartitionRequest : Tea.TeaModel {
    public var name: String?

    public var tableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["TableId"] as? String {
            self.tableId = value
        }
    }
}

public class GetPartitionResponseBody : Tea.TeaModel {
    public var partition: Partition?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.partition?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.partition != nil {
            map["Partition"] = self.partition?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Partition"] as? [String: Any?] {
            var model = Partition()
            model.fromMap(value)
            self.partition = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPartitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPartitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPartitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPipelineRunRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetPipelineRunResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public class Stages : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var detail: [String: Any]?

            public var message: String?

            public var name: String?

            public var status: String?

            public var step: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.detail != nil {
                    map["Detail"] = self.detail!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.step != nil {
                    map["Step"] = self.step!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Detail"] as? [String: Any] {
                    self.detail = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Step"] as? Int32 {
                    self.step = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var createTime: Int64?

        public var creator: String?

        public var id: String?

        public var message: String?

        public var modifyTime: Int64?

        public var projectId: Int64?

        public var stages: [GetPipelineRunResponseBody.Pipeline.Stages]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.stages != nil {
                var tmp : [Any] = []
                for k in self.stages! {
                    tmp.append(k.toMap())
                }
                map["Stages"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Creator"] as? String {
                self.creator = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Stages"] as? [Any?] {
                var tmp : [GetPipelineRunResponseBody.Pipeline.Stages] = []
                for v in value {
                    if v != nil {
                        var model = GetPipelineRunResponseBody.Pipeline.Stages()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.stages = tmp
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var pipeline: GetPipelineRunResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Pipeline"] as? [String: Any?] {
            var model = GetPipelineRunResponseBody.Pipeline()
            model.fromMap(value)
            self.pipeline = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPipelineRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetProjectRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public class AliyunResourceTags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var aliyunResourceGroupId: String?

        public var aliyunResourceTags: [GetProjectResponseBody.Project.AliyunResourceTags]?

        public var description_: String?

        public var devEnvironmentEnabled: Bool?

        public var devRoleDisabled: Bool?

        public var displayName: String?

        public var id: Int64?

        public var name: String?

        public var owner: String?

        public var paiTaskEnabled: Bool?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunResourceGroupId != nil {
                map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
            }
            if self.aliyunResourceTags != nil {
                var tmp : [Any] = []
                for k in self.aliyunResourceTags! {
                    tmp.append(k.toMap())
                }
                map["AliyunResourceTags"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.devEnvironmentEnabled != nil {
                map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
            }
            if self.devRoleDisabled != nil {
                map["DevRoleDisabled"] = self.devRoleDisabled!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.paiTaskEnabled != nil {
                map["PaiTaskEnabled"] = self.paiTaskEnabled!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliyunResourceGroupId"] as? String {
                self.aliyunResourceGroupId = value
            }
            if let value = dict["AliyunResourceTags"] as? [Any?] {
                var tmp : [GetProjectResponseBody.Project.AliyunResourceTags] = []
                for v in value {
                    if v != nil {
                        var model = GetProjectResponseBody.Project.AliyunResourceTags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.aliyunResourceTags = tmp
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DevEnvironmentEnabled"] as? Bool {
                self.devEnvironmentEnabled = value
            }
            if let value = dict["DevRoleDisabled"] as? Bool {
                self.devRoleDisabled = value
            }
            if let value = dict["DisplayName"] as? String {
                self.displayName = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["PaiTaskEnabled"] as? Bool {
                self.paiTaskEnabled = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var project: GetProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Project"] as? [String: Any?] {
            var model = GetProjectResponseBody.Project()
            model.fromMap(value)
            self.project = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetProjectMemberRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GetProjectMemberResponseBody : Tea.TeaModel {
    public class ProjectMember : Tea.TeaModel {
        public class Roles : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var projectId: Int64?

        public var roles: [GetProjectMemberResponseBody.ProjectMember.Roles]?

        public var status: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.roles != nil {
                var tmp : [Any] = []
                for k in self.roles! {
                    tmp.append(k.toMap())
                }
                map["Roles"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Roles"] as? [Any?] {
                var tmp : [GetProjectMemberResponseBody.ProjectMember.Roles] = []
                for v in value {
                    if v != nil {
                        var model = GetProjectMemberResponseBody.ProjectMember.Roles()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.roles = tmp
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var projectMember: GetProjectMemberResponseBody.ProjectMember?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projectMember?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectMember != nil {
            map["ProjectMember"] = self.projectMember?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectMember"] as? [String: Any?] {
            var model = GetProjectMemberResponseBody.ProjectMember()
            model.fromMap(value)
            self.projectMember = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetProjectMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetProjectRoleRequest : Tea.TeaModel {
    public var code: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetProjectRoleResponseBody : Tea.TeaModel {
    public class ProjectRole : Tea.TeaModel {
        public var code: String?

        public var name: String?

        public var projectId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var projectRole: GetProjectRoleResponseBody.ProjectRole?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projectRole?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectRole != nil {
            map["ProjectRole"] = self.projectRole?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectRole"] as? [String: Any?] {
            var model = GetProjectRoleResponseBody.ProjectRole()
            model.fromMap(value)
            self.projectRole = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetProjectRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetProjectRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetResourceRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetResourceResponseBody : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var modifyTime: Int64?

        public var name: String?

        public var owner: String?

        public var projectId: Int64?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Spec"] as? String {
                self.spec = value
            }
        }
    }
    public var requestId: String?

    public var resource: GetResourceResponseBody.Resource?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Resource"] as? [String: Any?] {
            var model = GetResourceResponseBody.Resource()
            model.fromMap(value)
            self.resource = model
        }
    }
}

public class GetResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetResourceGroupRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class GetResourceGroupResponseBody : Tea.TeaModel {
    public class ResourceGroup : Tea.TeaModel {
        public class AliyunResourceTags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Spec : Tea.TeaModel {
            public var amount: Int32?

            public var standard: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.standard != nil {
                    map["Standard"] = self.standard!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["Standard"] as? String {
                    self.standard = value
                }
            }
        }
        public var aliyunResourceGroupId: String?

        public var aliyunResourceTags: [GetResourceGroupResponseBody.ResourceGroup.AliyunResourceTags]?

        public var createTime: Int64?

        public var createUser: String?

        public var defaultVpcId: String?

        public var defaultVswitchId: String?

        public var id: String?

        public var name: String?

        public var orderInstanceId: String?

        public var paymentType: String?

        public var remark: String?

        public var resourceGroupType: String?

        public var spec: GetResourceGroupResponseBody.ResourceGroup.Spec?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.spec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunResourceGroupId != nil {
                map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
            }
            if self.aliyunResourceTags != nil {
                var tmp : [Any] = []
                for k in self.aliyunResourceTags! {
                    tmp.append(k.toMap())
                }
                map["AliyunResourceTags"] = tmp
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.defaultVpcId != nil {
                map["DefaultVpcId"] = self.defaultVpcId!
            }
            if self.defaultVswitchId != nil {
                map["DefaultVswitchId"] = self.defaultVswitchId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.orderInstanceId != nil {
                map["OrderInstanceId"] = self.orderInstanceId!
            }
            if self.paymentType != nil {
                map["PaymentType"] = self.paymentType!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.resourceGroupType != nil {
                map["ResourceGroupType"] = self.resourceGroupType!
            }
            if self.spec != nil {
                map["Spec"] = self.spec?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliyunResourceGroupId"] as? String {
                self.aliyunResourceGroupId = value
            }
            if let value = dict["AliyunResourceTags"] as? [Any?] {
                var tmp : [GetResourceGroupResponseBody.ResourceGroup.AliyunResourceTags] = []
                for v in value {
                    if v != nil {
                        var model = GetResourceGroupResponseBody.ResourceGroup.AliyunResourceTags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.aliyunResourceTags = tmp
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["DefaultVpcId"] as? String {
                self.defaultVpcId = value
            }
            if let value = dict["DefaultVswitchId"] as? String {
                self.defaultVswitchId = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["OrderInstanceId"] as? String {
                self.orderInstanceId = value
            }
            if let value = dict["PaymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["Remark"] as? String {
                self.remark = value
            }
            if let value = dict["ResourceGroupType"] as? String {
                self.resourceGroupType = value
            }
            if let value = dict["Spec"] as? [String: Any?] {
                var model = GetResourceGroupResponseBody.ResourceGroup.Spec()
                model.fromMap(value)
                self.spec = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var resourceGroup: GetResourceGroupResponseBody.ResourceGroup?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroup"] as? [String: Any?] {
            var model = GetResourceGroupResponseBody.ResourceGroup()
            model.fromMap(value)
            self.resourceGroup = model
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRouteRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetRouteResponseBody : Tea.TeaModel {
    public class Route : Tea.TeaModel {
        public var createTime: Int64?

        public var destinationCidr: String?

        public var id: Int64?

        public var networkId: Int64?

        public var resourceGroupId: String?

        public var resourceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.destinationCidr != nil {
                map["DestinationCidr"] = self.destinationCidr!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DestinationCidr"] as? String {
                self.destinationCidr = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["NetworkId"] as? Int64 {
                self.networkId = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
        }
    }
    public var requestId: String?

    public var route: GetRouteResponseBody.Route?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.route?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.route != nil {
            map["Route"] = self.route?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Route"] as? [String: Any?] {
            var model = GetRouteResponseBody.Route()
            model.fromMap(value)
            self.route = model
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRouteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSchemaRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class GetSchemaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var schema: Schema?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.schema?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Schema"] as? [String: Any?] {
            var model = Schema()
            model.fromMap(value)
            self.schema = model
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetSchemaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSchemaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSchemaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTableRequest : Tea.TeaModel {
    public var id: String?

    public var includeBusinessMetadata: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.includeBusinessMetadata != nil {
            map["IncludeBusinessMetadata"] = self.includeBusinessMetadata!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["IncludeBusinessMetadata"] as? Bool {
            self.includeBusinessMetadata = value
        }
    }
}

public class GetTableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public var table: Table?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.table?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.table != nil {
            map["Table"] = self.table?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["Table"] as? [String: Any?] {
            var model = Table()
            model.fromMap(value)
            self.table = model
        }
    }
}

public class GetTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTaskRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class GetTaskResponseBody : Tea.TeaModel {
    public class Task : Tea.TeaModel {
        public class DataSource : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class Dependencies : Tea.TeaModel {
            public var type: String?

            public var upstreamOutput: String?

            public var upstreamTaskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.upstreamOutput != nil {
                    map["UpstreamOutput"] = self.upstreamOutput!
                }
                if self.upstreamTaskId != nil {
                    map["UpstreamTaskId"] = self.upstreamTaskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpstreamOutput"] as? String {
                    self.upstreamOutput = value
                }
                if let value = dict["UpstreamTaskId"] as? String {
                    self.upstreamTaskId = value
                }
            }
        }
        public class Inputs : Tea.TeaModel {
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var variables: [GetTaskResponseBody.Task.Inputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Variables"] as? [Any?] {
                    var tmp : [GetTaskResponseBody.Task.Inputs.Variables] = []
                    for v in value {
                        if v != nil {
                            var model = GetTaskResponseBody.Task.Inputs.Variables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.variables = tmp
                }
            }
        }
        public class Outputs : Tea.TeaModel {
            public class TaskOutputs : Tea.TeaModel {
                public var output: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Output"] as? String {
                        self.output = value
                    }
                }
            }
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var taskOutputs: [GetTaskResponseBody.Task.Outputs.TaskOutputs]?

            public var variables: [GetTaskResponseBody.Task.Outputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskOutputs != nil {
                    var tmp : [Any] = []
                    for k in self.taskOutputs! {
                        tmp.append(k.toMap())
                    }
                    map["TaskOutputs"] = tmp
                }
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TaskOutputs"] as? [Any?] {
                    var tmp : [GetTaskResponseBody.Task.Outputs.TaskOutputs] = []
                    for v in value {
                        if v != nil {
                            var model = GetTaskResponseBody.Task.Outputs.TaskOutputs()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.taskOutputs = tmp
                }
                if let value = dict["Variables"] as? [Any?] {
                    var tmp : [GetTaskResponseBody.Task.Outputs.Variables] = []
                    for v in value {
                        if v != nil {
                            var model = GetTaskResponseBody.Task.Outputs.Variables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.variables = tmp
                }
            }
        }
        public class RuntimeResource : Tea.TeaModel {
            public var cu: String?

            public var image: String?

            public var resourceGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cu != nil {
                    map["Cu"] = self.cu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cu"] as? String {
                    self.cu = value
                }
                if let value = dict["Image"] as? String {
                    self.image = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
            }
        }
        public class Script : Tea.TeaModel {
            public var content: String?

            public var parameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["Parameters"] as? String {
                    self.parameters = value
                }
            }
        }
        public class SubTasks : Tea.TeaModel {
            public class SubTasks : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                    }
                }
                public class RuntimeResource : Tea.TeaModel {
                    public var cu: String?

                    public var image: String?

                    public var resourceGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cu != nil {
                            map["Cu"] = self.cu!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.resourceGroupId != nil {
                            map["ResourceGroupId"] = self.resourceGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Cu"] as? String {
                            self.cu = value
                        }
                        if let value = dict["Image"] as? String {
                            self.image = value
                        }
                        if let value = dict["ResourceGroupId"] as? String {
                            self.resourceGroupId = value
                        }
                    }
                }
                public class Trigger : Tea.TeaModel {
                    public var cron: String?

                    public var endTime: String?

                    public var recurrence: String?

                    public var startTime: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cron != nil {
                            map["Cron"] = self.cron!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.recurrence != nil {
                            map["Recurrence"] = self.recurrence!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Cron"] as? String {
                            self.cron = value
                        }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["Recurrence"] as? String {
                            self.recurrence = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var baselineId: Int64?

                public var createTime: Int64?

                public var createUser: String?

                public var dataSource: GetTaskResponseBody.Task.SubTasks.SubTasks.DataSource?

                public var description_: String?

                public var envType: String?

                public var id: Int64?

                public var modifyTime: Int64?

                public var modifyUser: String?

                public var name: String?

                public var owner: String?

                public var priority: Int32?

                public var projectEnv: String?

                public var projectId: Int64?

                public var rerunInterval: Int32?

                public var rerunMode: String?

                public var rerunTimes: Int32?

                public var runtimeResource: GetTaskResponseBody.Task.SubTasks.SubTasks.RuntimeResource?

                public var timeout: Int32?

                public var trigger: GetTaskResponseBody.Task.SubTasks.SubTasks.Trigger?

                public var type: String?

                public var workflowId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.dataSource?.validate()
                    try self.runtimeResource?.validate()
                    try self.trigger?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.baselineId != nil {
                        map["BaselineId"] = self.baselineId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.createUser != nil {
                        map["CreateUser"] = self.createUser!
                    }
                    if self.dataSource != nil {
                        map["DataSource"] = self.dataSource?.toMap()
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.modifyUser != nil {
                        map["ModifyUser"] = self.modifyUser!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.projectEnv != nil {
                        map["ProjectEnv"] = self.projectEnv!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.rerunInterval != nil {
                        map["RerunInterval"] = self.rerunInterval!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.rerunTimes != nil {
                        map["RerunTimes"] = self.rerunTimes!
                    }
                    if self.runtimeResource != nil {
                        map["RuntimeResource"] = self.runtimeResource?.toMap()
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.trigger != nil {
                        map["Trigger"] = self.trigger?.toMap()
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.workflowId != nil {
                        map["WorkflowId"] = self.workflowId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BaselineId"] as? Int64 {
                        self.baselineId = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["CreateUser"] as? String {
                        self.createUser = value
                    }
                    if let value = dict["DataSource"] as? [String: Any?] {
                        var model = GetTaskResponseBody.Task.SubTasks.SubTasks.DataSource()
                        model.fromMap(value)
                        self.dataSource = model
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["EnvType"] as? String {
                        self.envType = value
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["ModifyTime"] as? Int64 {
                        self.modifyTime = value
                    }
                    if let value = dict["ModifyUser"] as? String {
                        self.modifyUser = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Owner"] as? String {
                        self.owner = value
                    }
                    if let value = dict["Priority"] as? Int32 {
                        self.priority = value
                    }
                    if let value = dict["ProjectEnv"] as? String {
                        self.projectEnv = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["RerunInterval"] as? Int32 {
                        self.rerunInterval = value
                    }
                    if let value = dict["RerunMode"] as? String {
                        self.rerunMode = value
                    }
                    if let value = dict["RerunTimes"] as? Int32 {
                        self.rerunTimes = value
                    }
                    if let value = dict["RuntimeResource"] as? [String: Any?] {
                        var model = GetTaskResponseBody.Task.SubTasks.SubTasks.RuntimeResource()
                        model.fromMap(value)
                        self.runtimeResource = model
                    }
                    if let value = dict["Timeout"] as? Int32 {
                        self.timeout = value
                    }
                    if let value = dict["Trigger"] as? [String: Any?] {
                        var model = GetTaskResponseBody.Task.SubTasks.SubTasks.Trigger()
                        model.fromMap(value)
                        self.trigger = model
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["WorkflowId"] as? Int64 {
                        self.workflowId = value
                    }
                }
            }
            public var subTasks: [GetTaskResponseBody.Task.SubTasks.SubTasks]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.subTasks != nil {
                    var tmp : [Any] = []
                    for k in self.subTasks! {
                        tmp.append(k.toMap())
                    }
                    map["SubTasks"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SubTasks"] as? [Any?] {
                    var tmp : [GetTaskResponseBody.Task.SubTasks.SubTasks] = []
                    for v in value {
                        if v != nil {
                            var model = GetTaskResponseBody.Task.SubTasks.SubTasks()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.subTasks = tmp
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public var cron: String?

            public var endTime: String?

            public var recurrence: String?

            public var startTime: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cron != nil {
                    map["Cron"] = self.cron!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.recurrence != nil {
                    map["Recurrence"] = self.recurrence!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cron"] as? String {
                    self.cron = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["Recurrence"] as? String {
                    self.recurrence = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var baselineId: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var dataSource: GetTaskResponseBody.Task.DataSource?

        public var dependencies: [GetTaskResponseBody.Task.Dependencies]?

        public var description_: String?

        public var envType: String?

        public var id: Int64?

        public var inputs: GetTaskResponseBody.Task.Inputs?

        public var instanceMode: String?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var name: String?

        public var outputs: GetTaskResponseBody.Task.Outputs?

        public var owner: String?

        public var priority: Int32?

        public var projectEnv: String?

        public var projectId: Int64?

        public var rerunInterval: Int32?

        public var rerunMode: String?

        public var rerunTimes: Int32?

        public var runtimeResource: GetTaskResponseBody.Task.RuntimeResource?

        public var script: GetTaskResponseBody.Task.Script?

        public var subTasks: GetTaskResponseBody.Task.SubTasks?

        public var tags: [GetTaskResponseBody.Task.Tags]?

        public var timeout: Int32?

        public var trigger: GetTaskResponseBody.Task.Trigger?

        public var type: String?

        public var workflowId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSource?.validate()
            try self.inputs?.validate()
            try self.outputs?.validate()
            try self.runtimeResource?.validate()
            try self.script?.validate()
            try self.subTasks?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource?.toMap()
            }
            if self.dependencies != nil {
                var tmp : [Any] = []
                for k in self.dependencies! {
                    tmp.append(k.toMap())
                }
                map["Dependencies"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.inputs != nil {
                map["Inputs"] = self.inputs?.toMap()
            }
            if self.instanceMode != nil {
                map["InstanceMode"] = self.instanceMode!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputs != nil {
                map["Outputs"] = self.outputs?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectEnv != nil {
                map["ProjectEnv"] = self.projectEnv!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.rerunInterval != nil {
                map["RerunInterval"] = self.rerunInterval!
            }
            if self.rerunMode != nil {
                map["RerunMode"] = self.rerunMode!
            }
            if self.rerunTimes != nil {
                map["RerunTimes"] = self.rerunTimes!
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource?.toMap()
            }
            if self.script != nil {
                map["Script"] = self.script?.toMap()
            }
            if self.subTasks != nil {
                map["SubTasks"] = self.subTasks?.toMap()
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.workflowId != nil {
                map["WorkflowId"] = self.workflowId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BaselineId"] as? Int64 {
                self.baselineId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["DataSource"] as? [String: Any?] {
                var model = GetTaskResponseBody.Task.DataSource()
                model.fromMap(value)
                self.dataSource = model
            }
            if let value = dict["Dependencies"] as? [Any?] {
                var tmp : [GetTaskResponseBody.Task.Dependencies] = []
                for v in value {
                    if v != nil {
                        var model = GetTaskResponseBody.Task.Dependencies()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dependencies = tmp
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EnvType"] as? String {
                self.envType = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Inputs"] as? [String: Any?] {
                var model = GetTaskResponseBody.Task.Inputs()
                model.fromMap(value)
                self.inputs = model
            }
            if let value = dict["InstanceMode"] as? String {
                self.instanceMode = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["ModifyUser"] as? String {
                self.modifyUser = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Outputs"] as? [String: Any?] {
                var model = GetTaskResponseBody.Task.Outputs()
                model.fromMap(value)
                self.outputs = model
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["ProjectEnv"] as? String {
                self.projectEnv = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["RerunInterval"] as? Int32 {
                self.rerunInterval = value
            }
            if let value = dict["RerunMode"] as? String {
                self.rerunMode = value
            }
            if let value = dict["RerunTimes"] as? Int32 {
                self.rerunTimes = value
            }
            if let value = dict["RuntimeResource"] as? [String: Any?] {
                var model = GetTaskResponseBody.Task.RuntimeResource()
                model.fromMap(value)
                self.runtimeResource = model
            }
            if let value = dict["Script"] as? [String: Any?] {
                var model = GetTaskResponseBody.Task.Script()
                model.fromMap(value)
                self.script = model
            }
            if let value = dict["SubTasks"] as? [String: Any?] {
                var model = GetTaskResponseBody.Task.SubTasks()
                model.fromMap(value)
                self.subTasks = model
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetTaskResponseBody.Task.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetTaskResponseBody.Task.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["Timeout"] as? Int32 {
                self.timeout = value
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = GetTaskResponseBody.Task.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["WorkflowId"] as? Int64 {
                self.workflowId = value
            }
        }
    }
    public var requestId: String?

    public var task: GetTaskResponseBody.Task?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.task?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.task != nil {
            map["Task"] = self.task?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Task"] as? [String: Any?] {
            var model = GetTaskResponseBody.Task()
            model.fromMap(value)
            self.task = model
        }
    }
}

public class GetTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTaskInstanceRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetTaskInstanceResponseBody : Tea.TeaModel {
    public class TaskInstance : Tea.TeaModel {
        public class DataSource : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class Inputs : Tea.TeaModel {
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var variables: [GetTaskInstanceResponseBody.TaskInstance.Inputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Variables"] as? [Any?] {
                    var tmp : [GetTaskInstanceResponseBody.TaskInstance.Inputs.Variables] = []
                    for v in value {
                        if v != nil {
                            var model = GetTaskInstanceResponseBody.TaskInstance.Inputs.Variables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.variables = tmp
                }
            }
        }
        public class Outputs : Tea.TeaModel {
            public class TaskOutputs : Tea.TeaModel {
                public var output: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Output"] as? String {
                        self.output = value
                    }
                }
            }
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var taskOutputs: [GetTaskInstanceResponseBody.TaskInstance.Outputs.TaskOutputs]?

            public var variables: [GetTaskInstanceResponseBody.TaskInstance.Outputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskOutputs != nil {
                    var tmp : [Any] = []
                    for k in self.taskOutputs! {
                        tmp.append(k.toMap())
                    }
                    map["TaskOutputs"] = tmp
                }
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TaskOutputs"] as? [Any?] {
                    var tmp : [GetTaskInstanceResponseBody.TaskInstance.Outputs.TaskOutputs] = []
                    for v in value {
                        if v != nil {
                            var model = GetTaskInstanceResponseBody.TaskInstance.Outputs.TaskOutputs()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.taskOutputs = tmp
                }
                if let value = dict["Variables"] as? [Any?] {
                    var tmp : [GetTaskInstanceResponseBody.TaskInstance.Outputs.Variables] = []
                    for v in value {
                        if v != nil {
                            var model = GetTaskInstanceResponseBody.TaskInstance.Outputs.Variables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.variables = tmp
                }
            }
        }
        public class Runtime : Tea.TeaModel {
            public var gateway: String?

            public var processId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gateway != nil {
                    map["Gateway"] = self.gateway!
                }
                if self.processId != nil {
                    map["ProcessId"] = self.processId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Gateway"] as? String {
                    self.gateway = value
                }
                if let value = dict["ProcessId"] as? String {
                    self.processId = value
                }
            }
        }
        public class RuntimeResource : Tea.TeaModel {
            public var cu: String?

            public var image: String?

            public var resourceGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cu != nil {
                    map["Cu"] = self.cu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cu"] as? String {
                    self.cu = value
                }
                if let value = dict["Image"] as? String {
                    self.image = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
            }
        }
        public class Script : Tea.TeaModel {
            public var content: String?

            public var parameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["Parameters"] as? String {
                    self.parameters = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var baselineId: Int64?

        public var bizdate: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var dataSource: GetTaskInstanceResponseBody.TaskInstance.DataSource?

        public var description_: String?

        public var finishedTime: Int64?

        public var id: Int64?

        public var inputs: GetTaskInstanceResponseBody.TaskInstance.Inputs?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var outputs: GetTaskInstanceResponseBody.TaskInstance.Outputs?

        public var owner: String?

        public var periodNumber: Int32?

        public var priority: Int32?

        public var projectEnv: String?

        public var projectId: Int64?

        public var rerunMode: String?

        public var runNumber: Int32?

        public var runtime: GetTaskInstanceResponseBody.TaskInstance.Runtime?

        public var runtimeResource: GetTaskInstanceResponseBody.TaskInstance.RuntimeResource?

        public var script: GetTaskInstanceResponseBody.TaskInstance.Script?

        public var startedTime: Int64?

        public var status: String?

        public var tags: [GetTaskInstanceResponseBody.TaskInstance.Tags]?

        public var taskId: Int64?

        public var taskName: String?

        public var taskType: String?

        public var timeout: Int32?

        public var triggerRecurrence: String?

        public var triggerTime: Int64?

        public var triggerType: String?

        public var workflowId: Int64?

        public var workflowInstanceId: Int64?

        public var workflowInstanceType: String?

        public var workflowName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSource?.validate()
            try self.inputs?.validate()
            try self.outputs?.validate()
            try self.runtime?.validate()
            try self.runtimeResource?.validate()
            try self.script?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.finishedTime != nil {
                map["FinishedTime"] = self.finishedTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.inputs != nil {
                map["Inputs"] = self.inputs?.toMap()
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.outputs != nil {
                map["Outputs"] = self.outputs?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.periodNumber != nil {
                map["PeriodNumber"] = self.periodNumber!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectEnv != nil {
                map["ProjectEnv"] = self.projectEnv!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.rerunMode != nil {
                map["RerunMode"] = self.rerunMode!
            }
            if self.runNumber != nil {
                map["RunNumber"] = self.runNumber!
            }
            if self.runtime != nil {
                map["Runtime"] = self.runtime?.toMap()
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource?.toMap()
            }
            if self.script != nil {
                map["Script"] = self.script?.toMap()
            }
            if self.startedTime != nil {
                map["StartedTime"] = self.startedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.triggerRecurrence != nil {
                map["TriggerRecurrence"] = self.triggerRecurrence!
            }
            if self.triggerTime != nil {
                map["TriggerTime"] = self.triggerTime!
            }
            if self.triggerType != nil {
                map["TriggerType"] = self.triggerType!
            }
            if self.workflowId != nil {
                map["WorkflowId"] = self.workflowId!
            }
            if self.workflowInstanceId != nil {
                map["WorkflowInstanceId"] = self.workflowInstanceId!
            }
            if self.workflowInstanceType != nil {
                map["WorkflowInstanceType"] = self.workflowInstanceType!
            }
            if self.workflowName != nil {
                map["WorkflowName"] = self.workflowName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BaselineId"] as? Int64 {
                self.baselineId = value
            }
            if let value = dict["Bizdate"] as? Int64 {
                self.bizdate = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["DataSource"] as? [String: Any?] {
                var model = GetTaskInstanceResponseBody.TaskInstance.DataSource()
                model.fromMap(value)
                self.dataSource = model
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["FinishedTime"] as? Int64 {
                self.finishedTime = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Inputs"] as? [String: Any?] {
                var model = GetTaskInstanceResponseBody.TaskInstance.Inputs()
                model.fromMap(value)
                self.inputs = model
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["ModifyUser"] as? String {
                self.modifyUser = value
            }
            if let value = dict["Outputs"] as? [String: Any?] {
                var model = GetTaskInstanceResponseBody.TaskInstance.Outputs()
                model.fromMap(value)
                self.outputs = model
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["PeriodNumber"] as? Int32 {
                self.periodNumber = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["ProjectEnv"] as? String {
                self.projectEnv = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["RerunMode"] as? String {
                self.rerunMode = value
            }
            if let value = dict["RunNumber"] as? Int32 {
                self.runNumber = value
            }
            if let value = dict["Runtime"] as? [String: Any?] {
                var model = GetTaskInstanceResponseBody.TaskInstance.Runtime()
                model.fromMap(value)
                self.runtime = model
            }
            if let value = dict["RuntimeResource"] as? [String: Any?] {
                var model = GetTaskInstanceResponseBody.TaskInstance.RuntimeResource()
                model.fromMap(value)
                self.runtimeResource = model
            }
            if let value = dict["Script"] as? [String: Any?] {
                var model = GetTaskInstanceResponseBody.TaskInstance.Script()
                model.fromMap(value)
                self.script = model
            }
            if let value = dict["StartedTime"] as? Int64 {
                self.startedTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetTaskInstanceResponseBody.TaskInstance.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetTaskInstanceResponseBody.TaskInstance.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TaskId"] as? Int64 {
                self.taskId = value
            }
            if let value = dict["TaskName"] as? String {
                self.taskName = value
            }
            if let value = dict["TaskType"] as? String {
                self.taskType = value
            }
            if let value = dict["Timeout"] as? Int32 {
                self.timeout = value
            }
            if let value = dict["TriggerRecurrence"] as? String {
                self.triggerRecurrence = value
            }
            if let value = dict["TriggerTime"] as? Int64 {
                self.triggerTime = value
            }
            if let value = dict["TriggerType"] as? String {
                self.triggerType = value
            }
            if let value = dict["WorkflowId"] as? Int64 {
                self.workflowId = value
            }
            if let value = dict["WorkflowInstanceId"] as? Int64 {
                self.workflowInstanceId = value
            }
            if let value = dict["WorkflowInstanceType"] as? String {
                self.workflowInstanceType = value
            }
            if let value = dict["WorkflowName"] as? String {
                self.workflowName = value
            }
        }
    }
    public var requestId: String?

    public var taskInstance: GetTaskInstanceResponseBody.TaskInstance?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInstance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInstance != nil {
            map["TaskInstance"] = self.taskInstance?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskInstance"] as? [String: Any?] {
            var model = GetTaskInstanceResponseBody.TaskInstance()
            model.fromMap(value)
            self.taskInstance = model
        }
    }
}

public class GetTaskInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTaskInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTaskInstanceLogRequest : Tea.TeaModel {
    public var id: Int64?

    public var runNumber: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.runNumber != nil {
            map["RunNumber"] = self.runNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RunNumber"] as? Int32 {
            self.runNumber = value
        }
    }
}

public class GetTaskInstanceLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskInstanceLog: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInstanceLog != nil {
            map["TaskInstanceLog"] = self.taskInstanceLog!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskInstanceLog"] as? String {
            self.taskInstanceLog = value
        }
    }
}

public class GetTaskInstanceLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskInstanceLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTaskInstanceLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkflowRequest : Tea.TeaModel {
    public var envType: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetWorkflowResponseBody : Tea.TeaModel {
    public class Workflow : Tea.TeaModel {
        public class Dependencies : Tea.TeaModel {
            public var type: String?

            public var upstreamOutput: String?

            public var upstreamTaskId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.upstreamOutput != nil {
                    map["UpstreamOutput"] = self.upstreamOutput!
                }
                if self.upstreamTaskId != nil {
                    map["UpstreamTaskId"] = self.upstreamTaskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpstreamOutput"] as? String {
                    self.upstreamOutput = value
                }
                if let value = dict["UpstreamTaskId"] as? Int64 {
                    self.upstreamTaskId = value
                }
            }
        }
        public class Outputs : Tea.TeaModel {
            public class TaskOutputs : Tea.TeaModel {
                public var output: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Output"] as? String {
                        self.output = value
                    }
                }
            }
            public var taskOutputs: [GetWorkflowResponseBody.Workflow.Outputs.TaskOutputs]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskOutputs != nil {
                    var tmp : [Any] = []
                    for k in self.taskOutputs! {
                        tmp.append(k.toMap())
                    }
                    map["TaskOutputs"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TaskOutputs"] as? [Any?] {
                    var tmp : [GetWorkflowResponseBody.Workflow.Outputs.TaskOutputs] = []
                    for v in value {
                        if v != nil {
                            var model = GetWorkflowResponseBody.Workflow.Outputs.TaskOutputs()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.taskOutputs = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Tasks : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cu"] as? String {
                        self.cu = value
                    }
                    if let value = dict["Image"] as? String {
                        self.image = value
                    }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public var baselineId: Int64?

            public var clientUniqueCode: String?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: GetWorkflowResponseBody.Workflow.Tasks.DataSource?

            public var description_: String?

            public var envType: String?

            public var id: Int64?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var name: String?

            public var owner: String?

            public var priority: Int32?

            public var projectId: Int64?

            public var rerunInterval: Int32?

            public var rerunMode: String?

            public var rerunTimes: Int32?

            public var runtimeResource: GetWorkflowResponseBody.Workflow.Tasks.RuntimeResource?

            public var timeout: Int32?

            public var triggerRecurrence: String?

            public var type: String?

            public var workflowId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtimeResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.clientUniqueCode != nil {
                    map["ClientUniqueCode"] = self.clientUniqueCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunInterval != nil {
                    map["RerunInterval"] = self.rerunInterval!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.rerunTimes != nil {
                    map["RerunTimes"] = self.rerunTimes!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.triggerRecurrence != nil {
                    map["TriggerRecurrence"] = self.triggerRecurrence!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["ClientUniqueCode"] as? String {
                    self.clientUniqueCode = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = GetWorkflowResponseBody.Workflow.Tasks.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RerunInterval"] as? Int32 {
                    self.rerunInterval = value
                }
                if let value = dict["RerunMode"] as? String {
                    self.rerunMode = value
                }
                if let value = dict["RerunTimes"] as? Int32 {
                    self.rerunTimes = value
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = GetWorkflowResponseBody.Workflow.Tasks.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["TriggerRecurrence"] as? String {
                    self.triggerRecurrence = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["WorkflowId"] as? Int64 {
                    self.workflowId = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public var cron: String?

            public var endTime: String?

            public var recurrence: String?

            public var startTime: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cron != nil {
                    map["Cron"] = self.cron!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.recurrence != nil {
                    map["Recurrence"] = self.recurrence!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cron"] as? String {
                    self.cron = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["Recurrence"] as? String {
                    self.recurrence = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var clientUniqueCode: String?

        public var createTime: Int64?

        public var createUser: String?

        public var dependencies: [GetWorkflowResponseBody.Workflow.Dependencies]?

        public var description_: String?

        public var envType: String?

        public var id: Int64?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var name: String?

        public var outputs: GetWorkflowResponseBody.Workflow.Outputs?

        public var owner: String?

        public var parameters: String?

        public var projectId: Int64?

        public var tags: [GetWorkflowResponseBody.Workflow.Tags]?

        public var tasks: [GetWorkflowResponseBody.Workflow.Tasks]?

        public var trigger: GetWorkflowResponseBody.Workflow.Trigger?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputs?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientUniqueCode != nil {
                map["ClientUniqueCode"] = self.clientUniqueCode!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.dependencies != nil {
                var tmp : [Any] = []
                for k in self.dependencies! {
                    tmp.append(k.toMap())
                }
                map["Dependencies"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputs != nil {
                map["Outputs"] = self.outputs?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.parameters != nil {
                map["Parameters"] = self.parameters!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tasks != nil {
                var tmp : [Any] = []
                for k in self.tasks! {
                    tmp.append(k.toMap())
                }
                map["Tasks"] = tmp
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClientUniqueCode"] as? String {
                self.clientUniqueCode = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["Dependencies"] as? [Any?] {
                var tmp : [GetWorkflowResponseBody.Workflow.Dependencies] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkflowResponseBody.Workflow.Dependencies()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dependencies = tmp
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EnvType"] as? String {
                self.envType = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["ModifyUser"] as? String {
                self.modifyUser = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Outputs"] as? [String: Any?] {
                var model = GetWorkflowResponseBody.Workflow.Outputs()
                model.fromMap(value)
                self.outputs = model
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["Parameters"] as? String {
                self.parameters = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [GetWorkflowResponseBody.Workflow.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkflowResponseBody.Workflow.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["Tasks"] as? [Any?] {
                var tmp : [GetWorkflowResponseBody.Workflow.Tasks] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkflowResponseBody.Workflow.Tasks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tasks = tmp
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = GetWorkflowResponseBody.Workflow.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
        }
    }
    public var requestId: String?

    public var workflow: GetWorkflowResponseBody.Workflow?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflow != nil {
            map["Workflow"] = self.workflow?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Workflow"] as? [String: Any?] {
            var model = GetWorkflowResponseBody.Workflow()
            model.fromMap(value)
            self.workflow = model
        }
    }
}

public class GetWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkflowResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: Int64?

    public var includeScriptContent: Bool?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.includeScriptContent != nil {
            map["IncludeScriptContent"] = self.includeScriptContent!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["IncludeScriptContent"] as? Bool {
            self.includeScriptContent = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class GetWorkflowDefinitionResponseBody : Tea.TeaModel {
    public class WorkflowDefinition : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var modifyTime: Int64?

        public var name: String?

        public var owner: String?

        public var projectId: Int64?

        public var spec: String?

        public var workflowId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.workflowId != nil {
                map["WorkflowId"] = self.workflowId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["Spec"] as? String {
                self.spec = value
            }
            if let value = dict["WorkflowId"] as? Int64 {
                self.workflowId = value
            }
        }
    }
    public var requestId: String?

    public var workflowDefinition: GetWorkflowDefinitionResponseBody.WorkflowDefinition?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflowDefinition?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflowDefinition != nil {
            map["WorkflowDefinition"] = self.workflowDefinition?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["WorkflowDefinition"] as? [String: Any?] {
            var model = GetWorkflowDefinitionResponseBody.WorkflowDefinition()
            model.fromMap(value)
            self.workflowDefinition = model
        }
    }
}

public class GetWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkflowDefinitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkflowInstanceRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetWorkflowInstanceResponseBody : Tea.TeaModel {
    public class WorkflowInstance : Tea.TeaModel {
        public var bizDate: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var envType: String?

        public var finishedTime: Int64?

        public var id: Int64?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var name: String?

        public var projectId: Int64?

        public var startedTime: Int64?

        public var status: String?

        public var type: String?

        public var workflowId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizDate != nil {
                map["BizDate"] = self.bizDate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.finishedTime != nil {
                map["FinishedTime"] = self.finishedTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.startedTime != nil {
                map["StartedTime"] = self.startedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.workflowId != nil {
                map["WorkflowId"] = self.workflowId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BizDate"] as? Int64 {
                self.bizDate = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["EnvType"] as? String {
                self.envType = value
            }
            if let value = dict["FinishedTime"] as? Int64 {
                self.finishedTime = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["ModifyUser"] as? String {
                self.modifyUser = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ProjectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["StartedTime"] as? Int64 {
                self.startedTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["WorkflowId"] as? Int64 {
                self.workflowId = value
            }
        }
    }
    public var requestId: String?

    public var workflowInstance: GetWorkflowInstanceResponseBody.WorkflowInstance?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflowInstance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflowInstance != nil {
            map["WorkflowInstance"] = self.workflowInstance?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["WorkflowInstance"] as? [String: Any?] {
            var model = GetWorkflowInstanceResponseBody.WorkflowInstance()
            model.fromMap(value)
            self.workflowInstance = model
        }
    }
}

public class GetWorkflowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkflowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkflowInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GrantMemberProjectRolesRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodes: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodes != nil {
            map["RoleCodes"] = self.roleCodes!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCodes"] as? [String] {
            self.roleCodes = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GrantMemberProjectRolesShrinkRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodesShrink: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodesShrink != nil {
            map["RoleCodes"] = self.roleCodesShrink!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCodes"] as? String {
            self.roleCodesShrink = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GrantMemberProjectRolesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GrantMemberProjectRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantMemberProjectRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GrantMemberProjectRolesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ImportCertificateRequest : Tea.TeaModel {
    public var certificateFile: String?

    public var description_: String?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateFile != nil {
            map["CertificateFile"] = self.certificateFile!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertificateFile"] as? String {
            self.certificateFile = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ImportCertificateAdvanceRequest : Tea.TeaModel {
    public var certificateFileObject: InputStream?

    public var description_: String?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateFileObject != nil {
            map["CertificateFile"] = self.certificateFileObject!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertificateFile"] as? InputStream {
            self.certificateFileObject = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ImportCertificateResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ImportCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ImportCertificateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ImportWorkflowDefinitionRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class ImportWorkflowDefinitionResponseBody : Tea.TeaModel {
    public class AsyncJob : Tea.TeaModel {
        public var completed: Bool?

        public var createTime: Int64?

        public var error: String?

        public var id: String?

        public var progress: Int32?

        public var response: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completed != nil {
                map["Completed"] = self.completed!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.response != nil {
                map["Response"] = self.response!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Completed"] as? Bool {
                self.completed = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Error"] as? String {
                self.error = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Progress"] as? Int32 {
                self.progress = value
            }
            if let value = dict["Response"] as? String {
                self.response = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var asyncJob: ImportWorkflowDefinitionResponseBody.AsyncJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.asyncJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncJob != nil {
            map["AsyncJob"] = self.asyncJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AsyncJob"] as? [String: Any?] {
            var model = ImportWorkflowDefinitionResponseBody.AsyncJob()
            model.fromMap(value)
            self.asyncJob = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ImportWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ImportWorkflowDefinitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAlertRulesRequest : Tea.TeaModel {
    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int64?

    public var receiver: String?

    public var taskIds: [Int64]?

    public var types: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.receiver != nil {
            map["Receiver"] = self.receiver!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["Receiver"] as? String {
            self.receiver = value
        }
        if let value = dict["TaskIds"] as? [Int64] {
            self.taskIds = value
        }
        if let value = dict["Types"] as? [String] {
            self.types = value
        }
    }
}

public class ListAlertRulesShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int64?

    public var receiver: String?

    public var taskIdsShrink: String?

    public var typesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.receiver != nil {
            map["Receiver"] = self.receiver!
        }
        if self.taskIdsShrink != nil {
            map["TaskIds"] = self.taskIdsShrink!
        }
        if self.typesShrink != nil {
            map["Types"] = self.typesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["Receiver"] as? String {
            self.receiver = value
        }
        if let value = dict["TaskIds"] as? String {
            self.taskIdsShrink = value
        }
        if let value = dict["Types"] as? String {
            self.typesShrink = value
        }
    }
}

public class ListAlertRulesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class AlertRules : Tea.TeaModel {
            public class TriggerCondition : Tea.TeaModel {
                public class Extension_ : Tea.TeaModel {
                    public class CycleUnfinished : Tea.TeaModel {
                        public class CycleAndTime : Tea.TeaModel {
                            public var cycleId: Int32?

                            public var time: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.cycleId != nil {
                                    map["CycleId"] = self.cycleId!
                                }
                                if self.time != nil {
                                    map["Time"] = self.time!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["CycleId"] as? Int32 {
                                    self.cycleId = value
                                }
                                if let value = dict["Time"] as? String {
                                    self.time = value
                                }
                            }
                        }
                        public var cycleAndTime: [ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.cycleAndTime != nil {
                                var tmp : [Any] = []
                                for k in self.cycleAndTime! {
                                    tmp.append(k.toMap())
                                }
                                map["CycleAndTime"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["CycleAndTime"] as? [Any?] {
                                var tmp : [ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime] = []
                                for v in value {
                                    if v != nil {
                                        var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.cycleAndTime = tmp
                            }
                        }
                    }
                    public class Error : Tea.TeaModel {
                        public var autoRerunAlertEnabled: Bool?

                        public var streamTaskIds: [Int64]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.autoRerunAlertEnabled != nil {
                                map["AutoRerunAlertEnabled"] = self.autoRerunAlertEnabled!
                            }
                            if self.streamTaskIds != nil {
                                map["StreamTaskIds"] = self.streamTaskIds!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["AutoRerunAlertEnabled"] as? Bool {
                                self.autoRerunAlertEnabled = value
                            }
                            if let value = dict["StreamTaskIds"] as? [Int64] {
                                self.streamTaskIds = value
                            }
                        }
                    }
                    public class InstanceErrorCount : Tea.TeaModel {
                        public var count: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Count"] as? Int32 {
                                self.count = value
                            }
                        }
                    }
                    public class InstanceErrorPercentage : Tea.TeaModel {
                        public var percentage: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.percentage != nil {
                                map["Percentage"] = self.percentage!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Percentage"] as? Int32 {
                                self.percentage = value
                            }
                        }
                    }
                    public class InstanceTransferFluctuate : Tea.TeaModel {
                        public var percentage: Int32?

                        public var trend: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.percentage != nil {
                                map["Percentage"] = self.percentage!
                            }
                            if self.trend != nil {
                                map["Trend"] = self.trend!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Percentage"] as? Int32 {
                                self.percentage = value
                            }
                            if let value = dict["Trend"] as? String {
                                self.trend = value
                            }
                        }
                    }
                    public class Timeout : Tea.TeaModel {
                        public var timeoutInMinutes: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.timeoutInMinutes != nil {
                                map["TimeoutInMinutes"] = self.timeoutInMinutes!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["TimeoutInMinutes"] as? Int32 {
                                self.timeoutInMinutes = value
                            }
                        }
                    }
                    public class UnFinished : Tea.TeaModel {
                        public var unFinishedTime: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.unFinishedTime != nil {
                                map["UnFinishedTime"] = self.unFinishedTime!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["UnFinishedTime"] as? String {
                                self.unFinishedTime = value
                            }
                        }
                    }
                    public var cycleUnfinished: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished?

                    public var error: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.Error?

                    public var instanceErrorCount: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceErrorCount?

                    public var instanceErrorPercentage: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceErrorPercentage?

                    public var instanceTransferFluctuate: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceTransferFluctuate?

                    public var timeout: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.Timeout?

                    public var unFinished: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.UnFinished?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.cycleUnfinished?.validate()
                        try self.error?.validate()
                        try self.instanceErrorCount?.validate()
                        try self.instanceErrorPercentage?.validate()
                        try self.instanceTransferFluctuate?.validate()
                        try self.timeout?.validate()
                        try self.unFinished?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleUnfinished != nil {
                            map["CycleUnfinished"] = self.cycleUnfinished?.toMap()
                        }
                        if self.error != nil {
                            map["Error"] = self.error?.toMap()
                        }
                        if self.instanceErrorCount != nil {
                            map["InstanceErrorCount"] = self.instanceErrorCount?.toMap()
                        }
                        if self.instanceErrorPercentage != nil {
                            map["InstanceErrorPercentage"] = self.instanceErrorPercentage?.toMap()
                        }
                        if self.instanceTransferFluctuate != nil {
                            map["InstanceTransferFluctuate"] = self.instanceTransferFluctuate?.toMap()
                        }
                        if self.timeout != nil {
                            map["Timeout"] = self.timeout?.toMap()
                        }
                        if self.unFinished != nil {
                            map["UnFinished"] = self.unFinished?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CycleUnfinished"] as? [String: Any?] {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished()
                            model.fromMap(value)
                            self.cycleUnfinished = model
                        }
                        if let value = dict["Error"] as? [String: Any?] {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.Error()
                            model.fromMap(value)
                            self.error = model
                        }
                        if let value = dict["InstanceErrorCount"] as? [String: Any?] {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceErrorCount()
                            model.fromMap(value)
                            self.instanceErrorCount = model
                        }
                        if let value = dict["InstanceErrorPercentage"] as? [String: Any?] {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceErrorPercentage()
                            model.fromMap(value)
                            self.instanceErrorPercentage = model
                        }
                        if let value = dict["InstanceTransferFluctuate"] as? [String: Any?] {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceTransferFluctuate()
                            model.fromMap(value)
                            self.instanceTransferFluctuate = model
                        }
                        if let value = dict["Timeout"] as? [String: Any?] {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.Timeout()
                            model.fromMap(value)
                            self.timeout = model
                        }
                        if let value = dict["UnFinished"] as? [String: Any?] {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.UnFinished()
                            model.fromMap(value)
                            self.unFinished = model
                        }
                    }
                }
                public class Target : Tea.TeaModel {
                    public var allowTasks: [Int64]?

                    public var ids: [Int64]?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowTasks != nil {
                            map["AllowTasks"] = self.allowTasks!
                        }
                        if self.ids != nil {
                            map["Ids"] = self.ids!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AllowTasks"] as? [Int64] {
                            self.allowTasks = value
                        }
                        if let value = dict["Ids"] as? [Int64] {
                            self.ids = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var extension_: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_?

                public var target: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Target?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.extension_?.validate()
                    try self.target?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_?.toMap()
                    }
                    if self.target != nil {
                        map["Target"] = self.target?.toMap()
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Extension"] as? [String: Any?] {
                        var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_()
                        model.fromMap(value)
                        self.extension_ = model
                    }
                    if let value = dict["Target"] as? [String: Any?] {
                        var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Target()
                        model.fromMap(value)
                        self.target = model
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var enabled: Bool?

            public var id: Int64?

            public var name: String?

            public var owner: String?

            public var triggerCondition: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.triggerCondition?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.triggerCondition != nil {
                    map["TriggerCondition"] = self.triggerCondition?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["TriggerCondition"] as? [String: Any?] {
                    var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition()
                    model.fromMap(value)
                    self.triggerCondition = model
                }
            }
        }
        public var alertRules: [ListAlertRulesResponseBody.PagingInfo.AlertRules]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertRules != nil {
                var tmp : [Any] = []
                for k in self.alertRules! {
                    tmp.append(k.toMap())
                }
                map["AlertRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlertRules"] as? [Any?] {
                var tmp : [ListAlertRulesResponseBody.PagingInfo.AlertRules] = []
                for v in value {
                    if v != nil {
                        var model = ListAlertRulesResponseBody.PagingInfo.AlertRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.alertRules = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListAlertRulesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListAlertRulesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAlertRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCatalogsRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentMetaEntityId: String?

    public var sortBy: String?

    public var types: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Types"] as? [String] {
            self.types = value
        }
    }
}

public class ListCatalogsShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentMetaEntityId: String?

    public var sortBy: String?

    public var typesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.typesShrink != nil {
            map["Types"] = self.typesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Types"] as? String {
            self.typesShrink = value
        }
    }
}

public class ListCatalogsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public var catalogs: [Catalog]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.catalogs != nil {
                var tmp : [Any] = []
                for k in self.catalogs! {
                    tmp.append(k.toMap())
                }
                map["Catalogs"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Catalogs"] as? [Any?] {
                var tmp : [Catalog] = []
                for v in value {
                    if v != nil {
                        var model = Catalog()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.catalogs = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListCatalogsResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListCatalogsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListCatalogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCatalogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCatalogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCertificatesRequest : Tea.TeaModel {
    public var createUser: String?

    public var endCreateTime: Int64?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sortBy: String?

    public var startCreateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createUser != nil {
            map["CreateUser"] = self.createUser!
        }
        if self.endCreateTime != nil {
            map["EndCreateTime"] = self.endCreateTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.startCreateTime != nil {
            map["StartCreateTime"] = self.startCreateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateUser"] as? String {
            self.createUser = value
        }
        if let value = dict["EndCreateTime"] as? Int64 {
            self.endCreateTime = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["StartCreateTime"] as? Int64 {
            self.startCreateTime = value
        }
    }
}

public class ListCertificatesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Certificates : Tea.TeaModel {
            public var createTime: Int64?

            public var createUser: String?

            public var description_: String?

            public var fileSizeInBytes: Int64?

            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.fileSizeInBytes != nil {
                    map["FileSizeInBytes"] = self.fileSizeInBytes!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["FileSizeInBytes"] as? Int64 {
                    self.fileSizeInBytes = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var certificates: [ListCertificatesResponseBody.PagingInfo.Certificates]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certificates != nil {
                var tmp : [Any] = []
                for k in self.certificates! {
                    tmp.append(k.toMap())
                }
                map["Certificates"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Certificates"] as? [Any?] {
                var tmp : [ListCertificatesResponseBody.PagingInfo.Certificates] = []
                for v in value {
                    if v != nil {
                        var model = ListCertificatesResponseBody.PagingInfo.Certificates()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.certificates = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListCertificatesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListCertificatesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListCertificatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCertificatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCertificatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListColumnsRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var tableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TableId"] as? String {
            self.tableId = value
        }
    }
}

public class ListColumnsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public var columns: [Column]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columns != nil {
                var tmp : [Any] = []
                for k in self.columns! {
                    tmp.append(k.toMap())
                }
                map["Columns"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Columns"] as? [Any?] {
                var tmp : [Column] = []
                for v in value {
                    if v != nil {
                        var model = Column()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.columns = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListColumnsResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListColumnsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListColumnsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCrawlerTypesResponseBody : Tea.TeaModel {
    public var crawlerTypes: [CrawlerType]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.crawlerTypes != nil {
            var tmp : [Any] = []
            for k in self.crawlerTypes! {
                tmp.append(k.toMap())
            }
            map["CrawlerTypes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CrawlerTypes"] as? [Any?] {
            var tmp : [CrawlerType] = []
            for v in value {
                if v != nil {
                    var model = CrawlerType()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.crawlerTypes = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListCrawlerTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCrawlerTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCrawlerTypesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDIAlarmRulesRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var jobId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? Int64 {
            self.DIAlarmRuleId = value
        }
        if let value = dict["JobId"] as? Int64 {
            self.jobId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListDIAlarmRulesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DIJobAlarmRules : Tea.TeaModel {
            public class NotificationSettings : Tea.TeaModel {
                public class NotificationChannels : Tea.TeaModel {
                    public var channels: [String]?

                    public var severity: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Channels"] as? [String] {
                            self.channels = value
                        }
                        if let value = dict["Severity"] as? String {
                            self.severity = value
                        }
                    }
                }
                public class NotificationReceivers : Tea.TeaModel {
                    public var receiverType: String?

                    public var receiverValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.receiverType != nil {
                            map["ReceiverType"] = self.receiverType!
                        }
                        if self.receiverValues != nil {
                            map["ReceiverValues"] = self.receiverValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ReceiverType"] as? String {
                            self.receiverType = value
                        }
                        if let value = dict["ReceiverValues"] as? [String] {
                            self.receiverValues = value
                        }
                    }
                }
                public var inhibitionInterval: Int64?

                public var muteInterval: Int64?

                public var notificationChannels: [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationChannels]?

                public var notificationReceivers: [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationReceivers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inhibitionInterval != nil {
                        map["InhibitionInterval"] = self.inhibitionInterval!
                    }
                    if self.muteInterval != nil {
                        map["MuteInterval"] = self.muteInterval!
                    }
                    if self.notificationChannels != nil {
                        var tmp : [Any] = []
                        for k in self.notificationChannels! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationChannels"] = tmp
                    }
                    if self.notificationReceivers != nil {
                        var tmp : [Any] = []
                        for k in self.notificationReceivers! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationReceivers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InhibitionInterval"] as? Int64 {
                        self.inhibitionInterval = value
                    }
                    if let value = dict["MuteInterval"] as? Int64 {
                        self.muteInterval = value
                    }
                    if let value = dict["NotificationChannels"] as? [Any?] {
                        var tmp : [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationChannels] = []
                        for v in value {
                            if v != nil {
                                var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationChannels()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notificationChannels = tmp
                    }
                    if let value = dict["NotificationReceivers"] as? [Any?] {
                        var tmp : [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationReceivers] = []
                        for v in value {
                            if v != nil {
                                var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationReceivers()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notificationReceivers = tmp
                    }
                }
            }
            public class TriggerConditions : Tea.TeaModel {
                public var ddlReportTags: [String]?

                public var ddlTypes: [String]?

                public var duration: Int64?

                public var severity: String?

                public var threshold: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ddlReportTags != nil {
                        map["DdlReportTags"] = self.ddlReportTags!
                    }
                    if self.ddlTypes != nil {
                        map["DdlTypes"] = self.ddlTypes!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DdlReportTags"] as? [String] {
                        self.ddlReportTags = value
                    }
                    if let value = dict["DdlTypes"] as? [String] {
                        self.ddlTypes = value
                    }
                    if let value = dict["Duration"] as? Int64 {
                        self.duration = value
                    }
                    if let value = dict["Severity"] as? String {
                        self.severity = value
                    }
                    if let value = dict["Threshold"] as? Int64 {
                        self.threshold = value
                    }
                }
            }
            public var DIAlarmRuleId: Int64?

            public var DIJobId: Int64?

            public var description_: String?

            public var enabled: Bool?

            public var id: Int64?

            public var metricType: String?

            public var name: String?

            public var notificationSettings: ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings?

            public var triggerConditions: [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.TriggerConditions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notificationSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DIAlarmRuleId != nil {
                    map["DIAlarmRuleId"] = self.DIAlarmRuleId!
                }
                if self.DIJobId != nil {
                    map["DIJobId"] = self.DIJobId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.metricType != nil {
                    map["MetricType"] = self.metricType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notificationSettings != nil {
                    map["NotificationSettings"] = self.notificationSettings?.toMap()
                }
                if self.triggerConditions != nil {
                    var tmp : [Any] = []
                    for k in self.triggerConditions! {
                        tmp.append(k.toMap())
                    }
                    map["TriggerConditions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DIAlarmRuleId"] as? Int64 {
                    self.DIAlarmRuleId = value
                }
                if let value = dict["DIJobId"] as? Int64 {
                    self.DIJobId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["MetricType"] as? String {
                    self.metricType = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NotificationSettings"] as? [String: Any?] {
                    var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings()
                    model.fromMap(value)
                    self.notificationSettings = model
                }
                if let value = dict["TriggerConditions"] as? [Any?] {
                    var tmp : [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.TriggerConditions] = []
                    for v in value {
                        if v != nil {
                            var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.TriggerConditions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.triggerConditions = tmp
                }
            }
        }
        public var DIJobAlarmRules: [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobAlarmRules != nil {
                var tmp : [Any] = []
                for k in self.DIJobAlarmRules! {
                    tmp.append(k.toMap())
                }
                map["DIJobAlarmRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DIJobAlarmRules"] as? [Any?] {
                var tmp : [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules] = []
                for v in value {
                    if v != nil {
                        var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DIJobAlarmRules = tmp
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDIAlarmRulesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDIAlarmRulesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDIAlarmRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIAlarmRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDIAlarmRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDIJobEventsRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var endTime: Int64?

    public var eventType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["EventType"] as? String {
            self.eventType = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class ListDIJobEventsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DIJobEvent : Tea.TeaModel {
            public var action: String?

            public var channels: String?

            public var createTime: String?

            public var detail: String?

            public var dstSql: String?

            public var dstTable: String?

            public var failoverMessage: String?

            public var id: String?

            public var severity: String?

            public var srcSql: String?

            public var srcTable: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.detail != nil {
                    map["Detail"] = self.detail!
                }
                if self.dstSql != nil {
                    map["DstSql"] = self.dstSql!
                }
                if self.dstTable != nil {
                    map["DstTable"] = self.dstTable!
                }
                if self.failoverMessage != nil {
                    map["FailoverMessage"] = self.failoverMessage!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.srcSql != nil {
                    map["SrcSql"] = self.srcSql!
                }
                if self.srcTable != nil {
                    map["SrcTable"] = self.srcTable!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["Channels"] as? String {
                    self.channels = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Detail"] as? String {
                    self.detail = value
                }
                if let value = dict["DstSql"] as? String {
                    self.dstSql = value
                }
                if let value = dict["DstTable"] as? String {
                    self.dstTable = value
                }
                if let value = dict["FailoverMessage"] as? String {
                    self.failoverMessage = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Severity"] as? String {
                    self.severity = value
                }
                if let value = dict["SrcSql"] as? String {
                    self.srcSql = value
                }
                if let value = dict["SrcTable"] as? String {
                    self.srcTable = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var DIJobEvent: [ListDIJobEventsResponseBody.PagingInfo.DIJobEvent]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobEvent != nil {
                var tmp : [Any] = []
                for k in self.DIJobEvent! {
                    tmp.append(k.toMap())
                }
                map["DIJobEvent"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DIJobEvent"] as? [Any?] {
                var tmp : [ListDIJobEventsResponseBody.PagingInfo.DIJobEvent] = []
                for v in value {
                    if v != nil {
                        var model = ListDIJobEventsResponseBody.PagingInfo.DIJobEvent()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DIJobEvent = tmp
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDIJobEventsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDIJobEventsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDIJobEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDIJobEventsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDIJobMetricsRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var endTime: Int64?

    public var metricName: [String]?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["MetricName"] as? [String] {
            self.metricName = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class ListDIJobMetricsShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var endTime: Int64?

    public var metricNameShrink: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.metricNameShrink != nil {
            map["MetricName"] = self.metricNameShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["MetricName"] as? String {
            self.metricNameShrink = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class ListDIJobMetricsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class JobMetrics : Tea.TeaModel {
            public class SeriesList : Tea.TeaModel {
                public var time: Int64?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Time"] as? Int64 {
                        self.time = value
                    }
                    if let value = dict["Value"] as? Double {
                        self.value = value
                    }
                }
            }
            public var name: String?

            public var seriesList: [ListDIJobMetricsResponseBody.PagingInfo.JobMetrics.SeriesList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.seriesList != nil {
                    var tmp : [Any] = []
                    for k in self.seriesList! {
                        tmp.append(k.toMap())
                    }
                    map["SeriesList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["SeriesList"] as? [Any?] {
                    var tmp : [ListDIJobMetricsResponseBody.PagingInfo.JobMetrics.SeriesList] = []
                    for v in value {
                        if v != nil {
                            var model = ListDIJobMetricsResponseBody.PagingInfo.JobMetrics.SeriesList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.seriesList = tmp
                }
            }
        }
        public var jobMetrics: [ListDIJobMetricsResponseBody.PagingInfo.JobMetrics]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobMetrics != nil {
                var tmp : [Any] = []
                for k in self.jobMetrics! {
                    tmp.append(k.toMap())
                }
                map["JobMetrics"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["JobMetrics"] as? [Any?] {
                var tmp : [ListDIJobMetricsResponseBody.PagingInfo.JobMetrics] = []
                for v in value {
                    if v != nil {
                        var model = ListDIJobMetricsResponseBody.PagingInfo.JobMetrics()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.jobMetrics = tmp
            }
        }
    }
    public var pagingInfo: ListDIJobMetricsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDIJobMetricsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDIJobMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDIJobMetricsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDIJobRunDetailsRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var instanceId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var sourceDataSourceName: String?

    public var sourceDatabaseName: String?

    public var sourceSchemaName: String?

    public var sourceTableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sourceDataSourceName != nil {
            map["SourceDataSourceName"] = self.sourceDataSourceName!
        }
        if self.sourceDatabaseName != nil {
            map["SourceDatabaseName"] = self.sourceDatabaseName!
        }
        if self.sourceSchemaName != nil {
            map["SourceSchemaName"] = self.sourceSchemaName!
        }
        if self.sourceTableName != nil {
            map["SourceTableName"] = self.sourceTableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["SourceDataSourceName"] as? String {
            self.sourceDataSourceName = value
        }
        if let value = dict["SourceDatabaseName"] as? String {
            self.sourceDatabaseName = value
        }
        if let value = dict["SourceSchemaName"] as? String {
            self.sourceSchemaName = value
        }
        if let value = dict["SourceTableName"] as? String {
            self.sourceTableName = value
        }
    }
}

public class ListDIJobRunDetailsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class JobRunInfos : Tea.TeaModel {
            public var destinationDatabaseName: String?

            public var destinationDatasourceName: String?

            public var destinationSchemaName: String?

            public var destinationTableName: String?

            public var fullMigrationErrorMessage: String?

            public var fullMigrationStatus: String?

            public var offlineErrorRecords: Int64?

            public var offlineTotalBytes: Int64?

            public var offlineTotalRecords: Int64?

            public var realtimeMigrationErrorMessage: String?

            public var realtimeMigrationStatus: String?

            public var sourceDatabaseName: String?

            public var sourceDatasourceName: String?

            public var sourceSchemaName: String?

            public var sourceTableName: String?

            public var structureMigrationErrorMessage: String?

            public var structureMigrationStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDatabaseName != nil {
                    map["DestinationDatabaseName"] = self.destinationDatabaseName!
                }
                if self.destinationDatasourceName != nil {
                    map["DestinationDatasourceName"] = self.destinationDatasourceName!
                }
                if self.destinationSchemaName != nil {
                    map["DestinationSchemaName"] = self.destinationSchemaName!
                }
                if self.destinationTableName != nil {
                    map["DestinationTableName"] = self.destinationTableName!
                }
                if self.fullMigrationErrorMessage != nil {
                    map["FullMigrationErrorMessage"] = self.fullMigrationErrorMessage!
                }
                if self.fullMigrationStatus != nil {
                    map["FullMigrationStatus"] = self.fullMigrationStatus!
                }
                if self.offlineErrorRecords != nil {
                    map["OfflineErrorRecords"] = self.offlineErrorRecords!
                }
                if self.offlineTotalBytes != nil {
                    map["OfflineTotalBytes"] = self.offlineTotalBytes!
                }
                if self.offlineTotalRecords != nil {
                    map["OfflineTotalRecords"] = self.offlineTotalRecords!
                }
                if self.realtimeMigrationErrorMessage != nil {
                    map["RealtimeMigrationErrorMessage"] = self.realtimeMigrationErrorMessage!
                }
                if self.realtimeMigrationStatus != nil {
                    map["RealtimeMigrationStatus"] = self.realtimeMigrationStatus!
                }
                if self.sourceDatabaseName != nil {
                    map["SourceDatabaseName"] = self.sourceDatabaseName!
                }
                if self.sourceDatasourceName != nil {
                    map["SourceDatasourceName"] = self.sourceDatasourceName!
                }
                if self.sourceSchemaName != nil {
                    map["SourceSchemaName"] = self.sourceSchemaName!
                }
                if self.sourceTableName != nil {
                    map["SourceTableName"] = self.sourceTableName!
                }
                if self.structureMigrationErrorMessage != nil {
                    map["StructureMigrationErrorMessage"] = self.structureMigrationErrorMessage!
                }
                if self.structureMigrationStatus != nil {
                    map["StructureMigrationStatus"] = self.structureMigrationStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DestinationDatabaseName"] as? String {
                    self.destinationDatabaseName = value
                }
                if let value = dict["DestinationDatasourceName"] as? String {
                    self.destinationDatasourceName = value
                }
                if let value = dict["DestinationSchemaName"] as? String {
                    self.destinationSchemaName = value
                }
                if let value = dict["DestinationTableName"] as? String {
                    self.destinationTableName = value
                }
                if let value = dict["FullMigrationErrorMessage"] as? String {
                    self.fullMigrationErrorMessage = value
                }
                if let value = dict["FullMigrationStatus"] as? String {
                    self.fullMigrationStatus = value
                }
                if let value = dict["OfflineErrorRecords"] as? Int64 {
                    self.offlineErrorRecords = value
                }
                if let value = dict["OfflineTotalBytes"] as? Int64 {
                    self.offlineTotalBytes = value
                }
                if let value = dict["OfflineTotalRecords"] as? Int64 {
                    self.offlineTotalRecords = value
                }
                if let value = dict["RealtimeMigrationErrorMessage"] as? String {
                    self.realtimeMigrationErrorMessage = value
                }
                if let value = dict["RealtimeMigrationStatus"] as? String {
                    self.realtimeMigrationStatus = value
                }
                if let value = dict["SourceDatabaseName"] as? String {
                    self.sourceDatabaseName = value
                }
                if let value = dict["SourceDatasourceName"] as? String {
                    self.sourceDatasourceName = value
                }
                if let value = dict["SourceSchemaName"] as? String {
                    self.sourceSchemaName = value
                }
                if let value = dict["SourceTableName"] as? String {
                    self.sourceTableName = value
                }
                if let value = dict["StructureMigrationErrorMessage"] as? String {
                    self.structureMigrationErrorMessage = value
                }
                if let value = dict["StructureMigrationStatus"] as? String {
                    self.structureMigrationStatus = value
                }
            }
        }
        public var jobRunInfos: [ListDIJobRunDetailsResponseBody.PagingInfo.JobRunInfos]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobRunInfos != nil {
                var tmp : [Any] = []
                for k in self.jobRunInfos! {
                    tmp.append(k.toMap())
                }
                map["JobRunInfos"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["JobRunInfos"] as? [Any?] {
                var tmp : [ListDIJobRunDetailsResponseBody.PagingInfo.JobRunInfos] = []
                for v in value {
                    if v != nil {
                        var model = ListDIJobRunDetailsResponseBody.PagingInfo.JobRunInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.jobRunInfos = tmp
            }
            if let value = dict["PageNumber"] as? String {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? String {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? String {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDIJobRunDetailsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDIJobRunDetailsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDIJobRunDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobRunDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDIJobRunDetailsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDIJobsRequest : Tea.TeaModel {
    public var destinationDataSourceType: String?

    public var migrationType: String?

    public var name: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var projectId: Int64?

    public var sourceDataSourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationDataSourceType"] as? String {
            self.destinationDataSourceType = value
        }
        if let value = dict["MigrationType"] as? String {
            self.migrationType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SourceDataSourceType"] as? String {
            self.sourceDataSourceType = value
        }
    }
}

public class ListDIJobsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DIJobs : Tea.TeaModel {
            public var DIJobId: Int64?

            public var destinationDataSourceType: String?

            public var id: Int64?

            public var jobName: String?

            public var jobStatus: String?

            public var migrationType: String?

            public var projectId: Int64?

            public var sourceDataSourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DIJobId != nil {
                    map["DIJobId"] = self.DIJobId!
                }
                if self.destinationDataSourceType != nil {
                    map["DestinationDataSourceType"] = self.destinationDataSourceType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.jobName != nil {
                    map["JobName"] = self.jobName!
                }
                if self.jobStatus != nil {
                    map["JobStatus"] = self.jobStatus!
                }
                if self.migrationType != nil {
                    map["MigrationType"] = self.migrationType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sourceDataSourceType != nil {
                    map["SourceDataSourceType"] = self.sourceDataSourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DIJobId"] as? Int64 {
                    self.DIJobId = value
                }
                if let value = dict["DestinationDataSourceType"] as? String {
                    self.destinationDataSourceType = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["JobName"] as? String {
                    self.jobName = value
                }
                if let value = dict["JobStatus"] as? String {
                    self.jobStatus = value
                }
                if let value = dict["MigrationType"] as? String {
                    self.migrationType = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["SourceDataSourceType"] as? String {
                    self.sourceDataSourceType = value
                }
            }
        }
        public var DIJobs: [ListDIJobsResponseBody.PagingInfo.DIJobs]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobs != nil {
                var tmp : [Any] = []
                for k in self.DIJobs! {
                    tmp.append(k.toMap())
                }
                map["DIJobs"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DIJobs"] as? [Any?] {
                var tmp : [ListDIJobsResponseBody.PagingInfo.DIJobs] = []
                for v in value {
                    if v != nil {
                        var model = ListDIJobsResponseBody.PagingInfo.DIJobs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DIJobs = tmp
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDIJobsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDIJobsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDIJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDIJobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataAssetTagsRequest : Tea.TeaModel {
    public var category: String?

    public var key: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Category"] as? String {
            self.category = value
        }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListDataAssetTagsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataAssetTags : Tea.TeaModel {
            public var category: String?

            public var createTime: Int64?

            public var createUser: String?

            public var description_: String?

            public var key: String?

            public var managers: [String]?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var valueType: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.managers != nil {
                    map["Managers"] = self.managers!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.valueType != nil {
                    map["ValueType"] = self.valueType!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Managers"] as? [String] {
                    self.managers = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["ValueType"] as? String {
                    self.valueType = value
                }
                if let value = dict["Values"] as? [String] {
                    self.values = value
                }
            }
        }
        public var dataAssetTags: [ListDataAssetTagsResponseBody.PagingInfo.DataAssetTags]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataAssetTags != nil {
                var tmp : [Any] = []
                for k in self.dataAssetTags! {
                    tmp.append(k.toMap())
                }
                map["DataAssetTags"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataAssetTags"] as? [Any?] {
                var tmp : [ListDataAssetTagsResponseBody.PagingInfo.DataAssetTags] = []
                for v in value {
                    if v != nil {
                        var model = ListDataAssetTagsResponseBody.PagingInfo.DataAssetTags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataAssetTags = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDataAssetTagsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDataAssetTagsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataAssetTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataAssetTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataAssetTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataAssetsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dataAssetIds: [String]?

    public var dataAssetType: String?

    public var envType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tags: [ListDataAssetsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataAssetIds != nil {
            map["DataAssetIds"] = self.dataAssetIds!
        }
        if self.dataAssetType != nil {
            map["DataAssetType"] = self.dataAssetType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataAssetIds"] as? [String] {
            self.dataAssetIds = value
        }
        if let value = dict["DataAssetType"] as? String {
            self.dataAssetType = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [ListDataAssetsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = ListDataAssetsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class ListDataAssetsShrinkRequest : Tea.TeaModel {
    public var dataAssetIdsShrink: String?

    public var dataAssetType: String?

    public var envType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataAssetIdsShrink != nil {
            map["DataAssetIds"] = self.dataAssetIdsShrink!
        }
        if self.dataAssetType != nil {
            map["DataAssetType"] = self.dataAssetType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataAssetIds"] as? String {
            self.dataAssetIdsShrink = value
        }
        if let value = dict["DataAssetType"] as? String {
            self.dataAssetType = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
    }
}

public class ListDataAssetsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataAssets : Tea.TeaModel {
            public class DataAssetTagMappings : Tea.TeaModel {
                public var autoTraceEnabled: Bool?

                public var creator: String?

                public var dataAssetId: String?

                public var key: String?

                public var tagSource: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoTraceEnabled != nil {
                        map["AutoTraceEnabled"] = self.autoTraceEnabled!
                    }
                    if self.creator != nil {
                        map["Creator"] = self.creator!
                    }
                    if self.dataAssetId != nil {
                        map["DataAssetId"] = self.dataAssetId!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.tagSource != nil {
                        map["TagSource"] = self.tagSource!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AutoTraceEnabled"] as? Bool {
                        self.autoTraceEnabled = value
                    }
                    if let value = dict["Creator"] as? String {
                        self.creator = value
                    }
                    if let value = dict["DataAssetId"] as? String {
                        self.dataAssetId = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["TagSource"] as? String {
                        self.tagSource = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var dataAssetTagMappings: [ListDataAssetsResponseBody.PagingInfo.DataAssets.DataAssetTagMappings]?

            public var envType: String?

            public var id: String?

            public var name: String?

            public var projectId: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataAssetTagMappings != nil {
                    var tmp : [Any] = []
                    for k in self.dataAssetTagMappings! {
                        tmp.append(k.toMap())
                    }
                    map["DataAssetTagMappings"] = tmp
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataAssetTagMappings"] as? [Any?] {
                    var tmp : [ListDataAssetsResponseBody.PagingInfo.DataAssets.DataAssetTagMappings] = []
                    for v in value {
                        if v != nil {
                            var model = ListDataAssetsResponseBody.PagingInfo.DataAssets.DataAssetTagMappings()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.dataAssetTagMappings = tmp
                }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var dataAssets: [ListDataAssetsResponseBody.PagingInfo.DataAssets]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataAssets != nil {
                var tmp : [Any] = []
                for k in self.dataAssets! {
                    tmp.append(k.toMap())
                }
                map["DataAssets"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataAssets"] as? [Any?] {
                var tmp : [ListDataAssetsResponseBody.PagingInfo.DataAssets] = []
                for v in value {
                    if v != nil {
                        var model = ListDataAssetsResponseBody.PagingInfo.DataAssets()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataAssets = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDataAssetsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDataAssetsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataAssetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataAssetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataAssetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataQualityEvaluationTaskInstancesRequest : Tea.TeaModel {
    public var bizdateFrom: String?

    public var bizdateTo: String?

    public var createTimeFrom: Int64?

    public var createTimeTo: Int64?

    public var dataQualityEvaluationTaskId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tableGuid: String?

    public var triggerClient: String?

    public var triggerClientId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdateFrom != nil {
            map["BizdateFrom"] = self.bizdateFrom!
        }
        if self.bizdateTo != nil {
            map["BizdateTo"] = self.bizdateTo!
        }
        if self.createTimeFrom != nil {
            map["CreateTimeFrom"] = self.createTimeFrom!
        }
        if self.createTimeTo != nil {
            map["CreateTimeTo"] = self.createTimeTo!
        }
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.triggerClient != nil {
            map["TriggerClient"] = self.triggerClient!
        }
        if self.triggerClientId != nil {
            map["TriggerClientId"] = self.triggerClientId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizdateFrom"] as? String {
            self.bizdateFrom = value
        }
        if let value = dict["BizdateTo"] as? String {
            self.bizdateTo = value
        }
        if let value = dict["CreateTimeFrom"] as? Int64 {
            self.createTimeFrom = value
        }
        if let value = dict["CreateTimeTo"] as? Int64 {
            self.createTimeTo = value
        }
        if let value = dict["DataQualityEvaluationTaskId"] as? Int64 {
            self.dataQualityEvaluationTaskId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
        if let value = dict["TriggerClient"] as? String {
            self.triggerClient = value
        }
        if let value = dict["TriggerClientId"] as? String {
            self.triggerClientId = value
        }
    }
}

public class ListDataQualityEvaluationTaskInstancesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityEvaluationTaskInstances : Tea.TeaModel {
            public class Task : Tea.TeaModel {
                public class Hooks : Tea.TeaModel {
                    public var condition: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.condition != nil {
                            map["Condition"] = self.condition!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Condition"] as? String {
                            self.condition = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public class Notifications : Tea.TeaModel {
                    public class Notifications : Tea.TeaModel {
                        public class NofiticationReceivers : Tea.TeaModel {
                            public var extension_: String?

                            public var receiverType: String?

                            public var receiverValues: [String]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.extension_ != nil {
                                    map["Extension"] = self.extension_!
                                }
                                if self.receiverType != nil {
                                    map["ReceiverType"] = self.receiverType!
                                }
                                if self.receiverValues != nil {
                                    map["ReceiverValues"] = self.receiverValues!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Extension"] as? String {
                                    self.extension_ = value
                                }
                                if let value = dict["ReceiverType"] as? String {
                                    self.receiverType = value
                                }
                                if let value = dict["ReceiverValues"] as? [String] {
                                    self.receiverValues = value
                                }
                            }
                        }
                        public class NotificationChannels : Tea.TeaModel {
                            public var channels: [String]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Channels"] as? [String] {
                                    self.channels = value
                                }
                            }
                        }
                        public var nofiticationReceivers: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NofiticationReceivers]?

                        public var notificationChannels: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NotificationChannels]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.nofiticationReceivers != nil {
                                var tmp : [Any] = []
                                for k in self.nofiticationReceivers! {
                                    tmp.append(k.toMap())
                                }
                                map["NofiticationReceivers"] = tmp
                            }
                            if self.notificationChannels != nil {
                                var tmp : [Any] = []
                                for k in self.notificationChannels! {
                                    tmp.append(k.toMap())
                                }
                                map["NotificationChannels"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["NofiticationReceivers"] as? [Any?] {
                                var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NofiticationReceivers] = []
                                for v in value {
                                    if v != nil {
                                        var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NofiticationReceivers()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.nofiticationReceivers = tmp
                            }
                            if let value = dict["NotificationChannels"] as? [Any?] {
                                var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NotificationChannels] = []
                                for v in value {
                                    if v != nil {
                                        var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NotificationChannels()
                                        if v != nil {
                                            model.fromMap(v as? [String: Any?])
                                        }
                                        tmp.append(model)
                                    }
                                }
                                self.notificationChannels = tmp
                            }
                        }
                    }
                    public var condition: String?

                    public var notifications: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.condition != nil {
                            map["Condition"] = self.condition!
                        }
                        if self.notifications != nil {
                            var tmp : [Any] = []
                            for k in self.notifications! {
                                tmp.append(k.toMap())
                            }
                            map["Notifications"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Condition"] as? String {
                            self.condition = value
                        }
                        if let value = dict["Notifications"] as? [Any?] {
                            var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications] = []
                            for v in value {
                                if v != nil {
                                    var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.notifications = tmp
                        }
                    }
                }
                public class Target : Tea.TeaModel {
                    public var databaseType: String?

                    public var partitionSpec: String?

                    public var tableGuid: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.databaseType != nil {
                            map["DatabaseType"] = self.databaseType!
                        }
                        if self.partitionSpec != nil {
                            map["PartitionSpec"] = self.partitionSpec!
                        }
                        if self.tableGuid != nil {
                            map["TableGuid"] = self.tableGuid!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DatabaseType"] as? String {
                            self.databaseType = value
                        }
                        if let value = dict["PartitionSpec"] as? String {
                            self.partitionSpec = value
                        }
                        if let value = dict["TableGuid"] as? String {
                            self.tableGuid = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public class Trigger : Tea.TeaModel {
                    public var taskIds: [Int64]?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.taskIds != nil {
                            map["TaskIds"] = self.taskIds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TaskIds"] as? [Int64] {
                            self.taskIds = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var description_: String?

                public var hooks: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Hooks]?

                public var id: Int64?

                public var name: String?

                public var notifications: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications?

                public var projectId: Int64?

                public var runtimeConf: String?

                public var target: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Target?

                public var trigger: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Trigger?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.notifications?.validate()
                    try self.target?.validate()
                    try self.trigger?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.hooks != nil {
                        var tmp : [Any] = []
                        for k in self.hooks! {
                            tmp.append(k.toMap())
                        }
                        map["Hooks"] = tmp
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.notifications != nil {
                        map["Notifications"] = self.notifications?.toMap()
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.runtimeConf != nil {
                        map["RuntimeConf"] = self.runtimeConf!
                    }
                    if self.target != nil {
                        map["Target"] = self.target?.toMap()
                    }
                    if self.trigger != nil {
                        map["Trigger"] = self.trigger?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["Hooks"] as? [Any?] {
                        var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Hooks] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Hooks()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.hooks = tmp
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Notifications"] as? [String: Any?] {
                        var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications()
                        model.fromMap(value)
                        self.notifications = model
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["RuntimeConf"] as? String {
                        self.runtimeConf = value
                    }
                    if let value = dict["Target"] as? [String: Any?] {
                        var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Target()
                        model.fromMap(value)
                        self.target = model
                    }
                    if let value = dict["Trigger"] as? [String: Any?] {
                        var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Trigger()
                        model.fromMap(value)
                        self.trigger = model
                    }
                }
            }
            public var createTime: Int64?

            public var finishTime: Int64?

            public var id: Int64?

            public var parameters: String?

            public var projectId: Int64?

            public var status: String?

            public var task: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task?

            public var triggerContext: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.task?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.task != nil {
                    map["Task"] = self.task?.toMap()
                }
                if self.triggerContext != nil {
                    map["TriggerContext"] = self.triggerContext!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["FinishTime"] as? Int64 {
                    self.finishTime = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Parameters"] as? String {
                    self.parameters = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Task"] as? [String: Any?] {
                    var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task()
                    model.fromMap(value)
                    self.task = model
                }
                if let value = dict["TriggerContext"] as? String {
                    self.triggerContext = value
                }
            }
        }
        public var dataQualityEvaluationTaskInstances: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityEvaluationTaskInstances != nil {
                var tmp : [Any] = []
                for k in self.dataQualityEvaluationTaskInstances! {
                    tmp.append(k.toMap())
                }
                map["DataQualityEvaluationTaskInstances"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataQualityEvaluationTaskInstances"] as? [Any?] {
                var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances] = []
                for v in value {
                    if v != nil {
                        var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataQualityEvaluationTaskInstances = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataQualityEvaluationTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityEvaluationTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataQualityEvaluationTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataQualityEvaluationTasksRequest : Tea.TeaModel {
    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class ListDataQualityEvaluationTasksResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityEvaluationTasks : Tea.TeaModel {
            public class Hooks : Tea.TeaModel {
                public var condition: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class Notifications : Tea.TeaModel {
                public class Notifications : Tea.TeaModel {
                    public class NotificationChannels : Tea.TeaModel {
                        public var channels: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Channels"] as? [String] {
                                self.channels = value
                            }
                        }
                    }
                    public class NotificationReceivers : Tea.TeaModel {
                        public var extension_: String?

                        public var receiverType: String?

                        public var receiverValues: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extension_ != nil {
                                map["Extension"] = self.extension_!
                            }
                            if self.receiverType != nil {
                                map["ReceiverType"] = self.receiverType!
                            }
                            if self.receiverValues != nil {
                                map["ReceiverValues"] = self.receiverValues!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Extension"] as? String {
                                self.extension_ = value
                            }
                            if let value = dict["ReceiverType"] as? String {
                                self.receiverType = value
                            }
                            if let value = dict["ReceiverValues"] as? [String] {
                                self.receiverValues = value
                            }
                        }
                    }
                    public var notificationChannels: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationChannels]?

                    public var notificationReceivers: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationReceivers]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.notificationChannels != nil {
                            var tmp : [Any] = []
                            for k in self.notificationChannels! {
                                tmp.append(k.toMap())
                            }
                            map["NotificationChannels"] = tmp
                        }
                        if self.notificationReceivers != nil {
                            var tmp : [Any] = []
                            for k in self.notificationReceivers! {
                                tmp.append(k.toMap())
                            }
                            map["NotificationReceivers"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["NotificationChannels"] as? [Any?] {
                            var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationChannels] = []
                            for v in value {
                                if v != nil {
                                    var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationChannels()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.notificationChannels = tmp
                        }
                        if let value = dict["NotificationReceivers"] as? [Any?] {
                            var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationReceivers] = []
                            for v in value {
                                if v != nil {
                                    var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationReceivers()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.notificationReceivers = tmp
                        }
                    }
                }
                public var condition: String?

                public var notifications: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.notifications != nil {
                        var tmp : [Any] = []
                        for k in self.notifications! {
                            tmp.append(k.toMap())
                        }
                        map["Notifications"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["Notifications"] as? [Any?] {
                        var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.notifications = tmp
                    }
                }
            }
            public class Target : Tea.TeaModel {
                public var databaseType: String?

                public var partitionSpec: String?

                public var tableGuid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseType != nil {
                        map["DatabaseType"] = self.databaseType!
                    }
                    if self.partitionSpec != nil {
                        map["PartitionSpec"] = self.partitionSpec!
                    }
                    if self.tableGuid != nil {
                        map["TableGuid"] = self.tableGuid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DatabaseType"] as? String {
                        self.databaseType = value
                    }
                    if let value = dict["PartitionSpec"] as? String {
                        self.partitionSpec = value
                    }
                    if let value = dict["TableGuid"] as? String {
                        self.tableGuid = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var taskIds: [Int64]?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.taskIds != nil {
                        map["TaskIds"] = self.taskIds!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TaskIds"] as? [Int64] {
                        self.taskIds = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var dataSourceId: Int64?

            public var description_: String?

            public var hooks: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Hooks]?

            public var id: Int64?

            public var name: String?

            public var notifications: ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications?

            public var projectId: Int64?

            public var runtimeConf: String?

            public var target: ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Target?

            public var trigger: ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Trigger?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notifications?.validate()
                try self.target?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceId != nil {
                    map["DataSourceId"] = self.dataSourceId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hooks != nil {
                    var tmp : [Any] = []
                    for k in self.hooks! {
                        tmp.append(k.toMap())
                    }
                    map["Hooks"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifications != nil {
                    map["Notifications"] = self.notifications?.toMap()
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.runtimeConf != nil {
                    map["RuntimeConf"] = self.runtimeConf!
                }
                if self.target != nil {
                    map["Target"] = self.target?.toMap()
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataSourceId"] as? Int64 {
                    self.dataSourceId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Hooks"] as? [Any?] {
                    var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Hooks] = []
                    for v in value {
                        if v != nil {
                            var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Hooks()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.hooks = tmp
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Notifications"] as? [String: Any?] {
                    var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications()
                    model.fromMap(value)
                    self.notifications = model
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RuntimeConf"] as? String {
                    self.runtimeConf = value
                }
                if let value = dict["Target"] as? [String: Any?] {
                    var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Target()
                    model.fromMap(value)
                    self.target = model
                }
                if let value = dict["Trigger"] as? [String: Any?] {
                    var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Trigger()
                    model.fromMap(value)
                    self.trigger = model
                }
            }
        }
        public var dataQualityEvaluationTasks: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityEvaluationTasks != nil {
                var tmp : [Any] = []
                for k in self.dataQualityEvaluationTasks! {
                    tmp.append(k.toMap())
                }
                map["DataQualityEvaluationTasks"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataQualityEvaluationTasks"] as? [Any?] {
                var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks] = []
                for v in value {
                    if v != nil {
                        var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataQualityEvaluationTasks = tmp
            }
            if let value = dict["PageNumber"] as? String {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? String {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? String {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDataQualityEvaluationTasksResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataQualityEvaluationTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityEvaluationTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataQualityEvaluationTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataQualityResultsRequest : Tea.TeaModel {
    public var bizdateFrom: String?

    public var bizdateTo: String?

    public var createTimeFrom: Int64?

    public var createTimeTo: Int64?

    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityEvaluationTaskInstanceId: Int64?

    public var dataQualityRuleId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdateFrom != nil {
            map["BizdateFrom"] = self.bizdateFrom!
        }
        if self.bizdateTo != nil {
            map["BizdateTo"] = self.bizdateTo!
        }
        if self.createTimeFrom != nil {
            map["CreateTimeFrom"] = self.createTimeFrom!
        }
        if self.createTimeTo != nil {
            map["CreateTimeTo"] = self.createTimeTo!
        }
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityEvaluationTaskInstanceId != nil {
            map["DataQualityEvaluationTaskInstanceId"] = self.dataQualityEvaluationTaskInstanceId!
        }
        if self.dataQualityRuleId != nil {
            map["DataQualityRuleId"] = self.dataQualityRuleId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizdateFrom"] as? String {
            self.bizdateFrom = value
        }
        if let value = dict["BizdateTo"] as? String {
            self.bizdateTo = value
        }
        if let value = dict["CreateTimeFrom"] as? Int64 {
            self.createTimeFrom = value
        }
        if let value = dict["CreateTimeTo"] as? Int64 {
            self.createTimeTo = value
        }
        if let value = dict["DataQualityEvaluationTaskId"] as? Int64 {
            self.dataQualityEvaluationTaskId = value
        }
        if let value = dict["DataQualityEvaluationTaskInstanceId"] as? Int64 {
            self.dataQualityEvaluationTaskInstanceId = value
        }
        if let value = dict["DataQualityRuleId"] as? Int64 {
            self.dataQualityRuleId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListDataQualityResultsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityResults : Tea.TeaModel {
            public class Details : Tea.TeaModel {
                public var checkedValue: String?

                public var referencedValue: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkedValue != nil {
                        map["CheckedValue"] = self.checkedValue!
                    }
                    if self.referencedValue != nil {
                        map["ReferencedValue"] = self.referencedValue!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CheckedValue"] as? String {
                        self.checkedValue = value
                    }
                    if let value = dict["ReferencedValue"] as? String {
                        self.referencedValue = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                }
            }
            public class Rule : Tea.TeaModel {
                public class CheckingConfig : Tea.TeaModel {
                    public class Thresholds : Tea.TeaModel {
                        public class Critical : Tea.TeaModel {
                            public var expression: String?

                            public var operator_: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.expression != nil {
                                    map["Expression"] = self.expression!
                                }
                                if self.operator_ != nil {
                                    map["Operator"] = self.operator_!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Expression"] as? String {
                                    self.expression = value
                                }
                                if let value = dict["Operator"] as? String {
                                    self.operator_ = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public class Expected : Tea.TeaModel {
                            public var expression: String?

                            public var operator_: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.expression != nil {
                                    map["Expression"] = self.expression!
                                }
                                if self.operator_ != nil {
                                    map["Operator"] = self.operator_!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Expression"] as? String {
                                    self.expression = value
                                }
                                if let value = dict["Operator"] as? String {
                                    self.operator_ = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public class Warned : Tea.TeaModel {
                            public var expression: String?

                            public var operator_: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.expression != nil {
                                    map["Expression"] = self.expression!
                                }
                                if self.operator_ != nil {
                                    map["Operator"] = self.operator_!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["Expression"] as? String {
                                    self.expression = value
                                }
                                if let value = dict["Operator"] as? String {
                                    self.operator_ = value
                                }
                                if let value = dict["Value"] as? String {
                                    self.value = value
                                }
                            }
                        }
                        public var critical: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Critical?

                        public var expected: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Expected?

                        public var warned: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Warned?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.critical?.validate()
                            try self.expected?.validate()
                            try self.warned?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.critical != nil {
                                map["Critical"] = self.critical?.toMap()
                            }
                            if self.expected != nil {
                                map["Expected"] = self.expected?.toMap()
                            }
                            if self.warned != nil {
                                map["Warned"] = self.warned?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Critical"] as? [String: Any?] {
                                var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Critical()
                                model.fromMap(value)
                                self.critical = model
                            }
                            if let value = dict["Expected"] as? [String: Any?] {
                                var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Expected()
                                model.fromMap(value)
                                self.expected = model
                            }
                            if let value = dict["Warned"] as? [String: Any?] {
                                var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Warned()
                                model.fromMap(value)
                                self.warned = model
                            }
                        }
                    }
                    public var referencedSamplesFilter: String?

                    public var thresholds: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.thresholds?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.referencedSamplesFilter != nil {
                            map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                        }
                        if self.thresholds != nil {
                            map["Thresholds"] = self.thresholds?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ReferencedSamplesFilter"] as? String {
                            self.referencedSamplesFilter = value
                        }
                        if let value = dict["Thresholds"] as? [String: Any?] {
                            var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds()
                            model.fromMap(value)
                            self.thresholds = model
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public class ErrorHandlers : Tea.TeaModel {
                    public var errorDataFilter: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorDataFilter != nil {
                            map["ErrorDataFilter"] = self.errorDataFilter!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ErrorDataFilter"] as? String {
                            self.errorDataFilter = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public class SamplingConfig : Tea.TeaModel {
                    public var metric: String?

                    public var metricParameters: String?

                    public var samplingFilter: String?

                    public var settingConfig: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.metric != nil {
                            map["Metric"] = self.metric!
                        }
                        if self.metricParameters != nil {
                            map["MetricParameters"] = self.metricParameters!
                        }
                        if self.samplingFilter != nil {
                            map["SamplingFilter"] = self.samplingFilter!
                        }
                        if self.settingConfig != nil {
                            map["SettingConfig"] = self.settingConfig!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Metric"] as? String {
                            self.metric = value
                        }
                        if let value = dict["MetricParameters"] as? String {
                            self.metricParameters = value
                        }
                        if let value = dict["SamplingFilter"] as? String {
                            self.samplingFilter = value
                        }
                        if let value = dict["SettingConfig"] as? String {
                            self.settingConfig = value
                        }
                    }
                }
                public class Target : Tea.TeaModel {
                    public var databaseType: String?

                    public var tableGuid: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.databaseType != nil {
                            map["DatabaseType"] = self.databaseType!
                        }
                        if self.tableGuid != nil {
                            map["TableGuid"] = self.tableGuid!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["DatabaseType"] as? String {
                            self.databaseType = value
                        }
                        if let value = dict["TableGuid"] as? String {
                            self.tableGuid = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var checkingConfig: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig?

                public var description_: String?

                public var enabled: Bool?

                public var errorHandlers: [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.ErrorHandlers]?

                public var id: Int64?

                public var name: String?

                public var projectId: Int64?

                public var samplingConfig: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.SamplingConfig?

                public var severity: String?

                public var target: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.Target?

                public var templateCode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.checkingConfig?.validate()
                    try self.samplingConfig?.validate()
                    try self.target?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkingConfig != nil {
                        map["CheckingConfig"] = self.checkingConfig?.toMap()
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.enabled != nil {
                        map["Enabled"] = self.enabled!
                    }
                    if self.errorHandlers != nil {
                        var tmp : [Any] = []
                        for k in self.errorHandlers! {
                            tmp.append(k.toMap())
                        }
                        map["ErrorHandlers"] = tmp
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.samplingConfig != nil {
                        map["SamplingConfig"] = self.samplingConfig?.toMap()
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    if self.target != nil {
                        map["Target"] = self.target?.toMap()
                    }
                    if self.templateCode != nil {
                        map["TemplateCode"] = self.templateCode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CheckingConfig"] as? [String: Any?] {
                        var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig()
                        model.fromMap(value)
                        self.checkingConfig = model
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["Enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["ErrorHandlers"] as? [Any?] {
                        var tmp : [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.ErrorHandlers] = []
                        for v in value {
                            if v != nil {
                                var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.ErrorHandlers()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.errorHandlers = tmp
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["SamplingConfig"] as? [String: Any?] {
                        var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.SamplingConfig()
                        model.fromMap(value)
                        self.samplingConfig = model
                    }
                    if let value = dict["Severity"] as? String {
                        self.severity = value
                    }
                    if let value = dict["Target"] as? [String: Any?] {
                        var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.Target()
                        model.fromMap(value)
                        self.target = model
                    }
                    if let value = dict["TemplateCode"] as? String {
                        self.templateCode = value
                    }
                }
            }
            public var createTime: Int64?

            public var details: [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Details]?

            public var id: Int64?

            public var rule: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule?

            public var sample: String?

            public var status: String?

            public var taskInstanceId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.rule?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.details != nil {
                    var tmp : [Any] = []
                    for k in self.details! {
                        tmp.append(k.toMap())
                    }
                    map["Details"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.rule != nil {
                    map["Rule"] = self.rule?.toMap()
                }
                if self.sample != nil {
                    map["Sample"] = self.sample!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskInstanceId != nil {
                    map["TaskInstanceId"] = self.taskInstanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Details"] as? [Any?] {
                    var tmp : [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Details] = []
                    for v in value {
                        if v != nil {
                            var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Details()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.details = tmp
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Rule"] as? [String: Any?] {
                    var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule()
                    model.fromMap(value)
                    self.rule = model
                }
                if let value = dict["Sample"] as? String {
                    self.sample = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TaskInstanceId"] as? Int64 {
                    self.taskInstanceId = value
                }
            }
        }
        public var dataQualityResults: [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityResults != nil {
                var tmp : [Any] = []
                for k in self.dataQualityResults! {
                    tmp.append(k.toMap())
                }
                map["DataQualityResults"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataQualityResults"] as? [Any?] {
                var tmp : [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults] = []
                for v in value {
                    if v != nil {
                        var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataQualityResults = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDataQualityResultsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDataQualityResultsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataQualityResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataQualityResultsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataQualityRuleTemplatesRequest : Tea.TeaModel {
    public var creationSource: String?

    public var directoryPath: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationSource != nil {
            map["CreationSource"] = self.creationSource!
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreationSource"] as? String {
            self.creationSource = value
        }
        if let value = dict["DirectoryPath"] as? String {
            self.directoryPath = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListDataQualityRuleTemplatesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityRuleTemplates : Tea.TeaModel {
            public class CheckingConfig : Tea.TeaModel {
                public var referencedSamplesFilter: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.referencedSamplesFilter != nil {
                        map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReferencedSamplesFilter"] as? String {
                        self.referencedSamplesFilter = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class SamplingConfig : Tea.TeaModel {
                public var metric: String?

                public var metricParameters: String?

                public var settingConfig: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metric != nil {
                        map["Metric"] = self.metric!
                    }
                    if self.metricParameters != nil {
                        map["MetricParameters"] = self.metricParameters!
                    }
                    if self.settingConfig != nil {
                        map["SettingConfig"] = self.settingConfig!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Metric"] as? String {
                        self.metric = value
                    }
                    if let value = dict["MetricParameters"] as? String {
                        self.metricParameters = value
                    }
                    if let value = dict["SettingConfig"] as? String {
                        self.settingConfig = value
                    }
                }
            }
            public var checkingConfig: ListDataQualityRuleTemplatesResponseBody.PagingInfo.DataQualityRuleTemplates.CheckingConfig?

            public var code: String?

            public var directoryPath: String?

            public var name: String?

            public var projectId: Int64?

            public var samplingConfig: ListDataQualityRuleTemplatesResponseBody.PagingInfo.DataQualityRuleTemplates.SamplingConfig?

            public var visibleScope: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkingConfig?.validate()
                try self.samplingConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkingConfig != nil {
                    map["CheckingConfig"] = self.checkingConfig?.toMap()
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.directoryPath != nil {
                    map["DirectoryPath"] = self.directoryPath!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.samplingConfig != nil {
                    map["SamplingConfig"] = self.samplingConfig?.toMap()
                }
                if self.visibleScope != nil {
                    map["VisibleScope"] = self.visibleScope!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CheckingConfig"] as? [String: Any?] {
                    var model = ListDataQualityRuleTemplatesResponseBody.PagingInfo.DataQualityRuleTemplates.CheckingConfig()
                    model.fromMap(value)
                    self.checkingConfig = model
                }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["DirectoryPath"] as? String {
                    self.directoryPath = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["SamplingConfig"] as? [String: Any?] {
                    var model = ListDataQualityRuleTemplatesResponseBody.PagingInfo.DataQualityRuleTemplates.SamplingConfig()
                    model.fromMap(value)
                    self.samplingConfig = model
                }
                if let value = dict["VisibleScope"] as? String {
                    self.visibleScope = value
                }
            }
        }
        public var dataQualityRuleTemplates: [ListDataQualityRuleTemplatesResponseBody.PagingInfo.DataQualityRuleTemplates]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityRuleTemplates != nil {
                var tmp : [Any] = []
                for k in self.dataQualityRuleTemplates! {
                    tmp.append(k.toMap())
                }
                map["DataQualityRuleTemplates"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataQualityRuleTemplates"] as? [Any?] {
                var tmp : [ListDataQualityRuleTemplatesResponseBody.PagingInfo.DataQualityRuleTemplates] = []
                for v in value {
                    if v != nil {
                        var model = ListDataQualityRuleTemplatesResponseBody.PagingInfo.DataQualityRuleTemplates()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataQualityRuleTemplates = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDataQualityRuleTemplatesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDataQualityRuleTemplatesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataQualityRuleTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityRuleTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataQualityRuleTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataQualityRulesRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityEvaluationTaskId"] as? Int64 {
            self.dataQualityEvaluationTaskId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["TableGuid"] as? String {
            self.tableGuid = value
        }
    }
}

public class ListDataQualityRulesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityRules : Tea.TeaModel {
            public class CheckingConfig : Tea.TeaModel {
                public class Thresholds : Tea.TeaModel {
                    public class Critical : Tea.TeaModel {
                        public var expression: String?

                        public var operator_: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.expression != nil {
                                map["Expression"] = self.expression!
                            }
                            if self.operator_ != nil {
                                map["Operator"] = self.operator_!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Expression"] as? String {
                                self.expression = value
                            }
                            if let value = dict["Operator"] as? String {
                                self.operator_ = value
                            }
                            if let value = dict["Value"] as? String {
                                self.value = value
                            }
                        }
                    }
                    public class Expected : Tea.TeaModel {
                        public var expression: String?

                        public var operator_: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.expression != nil {
                                map["Expression"] = self.expression!
                            }
                            if self.operator_ != nil {
                                map["Operator"] = self.operator_!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Expression"] as? String {
                                self.expression = value
                            }
                            if let value = dict["Operator"] as? String {
                                self.operator_ = value
                            }
                            if let value = dict["Value"] as? String {
                                self.value = value
                            }
                        }
                    }
                    public class Warned : Tea.TeaModel {
                        public var expression: String?

                        public var operator_: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.expression != nil {
                                map["Expression"] = self.expression!
                            }
                            if self.operator_ != nil {
                                map["Operator"] = self.operator_!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Expression"] as? String {
                                self.expression = value
                            }
                            if let value = dict["Operator"] as? String {
                                self.operator_ = value
                            }
                            if let value = dict["Value"] as? String {
                                self.value = value
                            }
                        }
                    }
                    public var critical: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Critical?

                    public var expected: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Expected?

                    public var warned: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Warned?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.critical?.validate()
                        try self.expected?.validate()
                        try self.warned?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.critical != nil {
                            map["Critical"] = self.critical?.toMap()
                        }
                        if self.expected != nil {
                            map["Expected"] = self.expected?.toMap()
                        }
                        if self.warned != nil {
                            map["Warned"] = self.warned?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Critical"] as? [String: Any?] {
                            var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Critical()
                            model.fromMap(value)
                            self.critical = model
                        }
                        if let value = dict["Expected"] as? [String: Any?] {
                            var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Expected()
                            model.fromMap(value)
                            self.expected = model
                        }
                        if let value = dict["Warned"] as? [String: Any?] {
                            var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Warned()
                            model.fromMap(value)
                            self.warned = model
                        }
                    }
                }
                public var referencedSamplesFilter: String?

                public var thresholds: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.thresholds?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.referencedSamplesFilter != nil {
                        map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                    }
                    if self.thresholds != nil {
                        map["Thresholds"] = self.thresholds?.toMap()
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ReferencedSamplesFilter"] as? String {
                        self.referencedSamplesFilter = value
                    }
                    if let value = dict["Thresholds"] as? [String: Any?] {
                        var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds()
                        model.fromMap(value)
                        self.thresholds = model
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class ErrorHandlers : Tea.TeaModel {
                public var errorDataFilter: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorDataFilter != nil {
                        map["ErrorDataFilter"] = self.errorDataFilter!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ErrorDataFilter"] as? String {
                        self.errorDataFilter = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class SamplingConfig : Tea.TeaModel {
                public var metric: String?

                public var metricParameters: String?

                public var samplingFilter: String?

                public var settingConfig: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metric != nil {
                        map["Metric"] = self.metric!
                    }
                    if self.metricParameters != nil {
                        map["MetricParameters"] = self.metricParameters!
                    }
                    if self.samplingFilter != nil {
                        map["SamplingFilter"] = self.samplingFilter!
                    }
                    if self.settingConfig != nil {
                        map["SettingConfig"] = self.settingConfig!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Metric"] as? String {
                        self.metric = value
                    }
                    if let value = dict["MetricParameters"] as? String {
                        self.metricParameters = value
                    }
                    if let value = dict["SamplingFilter"] as? String {
                        self.samplingFilter = value
                    }
                    if let value = dict["SettingConfig"] as? String {
                        self.settingConfig = value
                    }
                }
            }
            public class Target : Tea.TeaModel {
                public var databaseType: String?

                public var tableGuid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseType != nil {
                        map["DatabaseType"] = self.databaseType!
                    }
                    if self.tableGuid != nil {
                        map["TableGuid"] = self.tableGuid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DatabaseType"] as? String {
                        self.databaseType = value
                    }
                    if let value = dict["TableGuid"] as? String {
                        self.tableGuid = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var checkingConfig: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig?

            public var description_: String?

            public var enabled: Bool?

            public var errorHandlers: [ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.ErrorHandlers]?

            public var id: Int64?

            public var name: String?

            public var projectId: Int64?

            public var samplingConfig: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.SamplingConfig?

            public var severity: String?

            public var target: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.Target?

            public var templateCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkingConfig?.validate()
                try self.samplingConfig?.validate()
                try self.target?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkingConfig != nil {
                    map["CheckingConfig"] = self.checkingConfig?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.errorHandlers != nil {
                    var tmp : [Any] = []
                    for k in self.errorHandlers! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorHandlers"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.samplingConfig != nil {
                    map["SamplingConfig"] = self.samplingConfig?.toMap()
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.target != nil {
                    map["Target"] = self.target?.toMap()
                }
                if self.templateCode != nil {
                    map["TemplateCode"] = self.templateCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CheckingConfig"] as? [String: Any?] {
                    var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig()
                    model.fromMap(value)
                    self.checkingConfig = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["ErrorHandlers"] as? [Any?] {
                    var tmp : [ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.ErrorHandlers] = []
                    for v in value {
                        if v != nil {
                            var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.ErrorHandlers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.errorHandlers = tmp
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["SamplingConfig"] as? [String: Any?] {
                    var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.SamplingConfig()
                    model.fromMap(value)
                    self.samplingConfig = model
                }
                if let value = dict["Severity"] as? String {
                    self.severity = value
                }
                if let value = dict["Target"] as? [String: Any?] {
                    var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.Target()
                    model.fromMap(value)
                    self.target = model
                }
                if let value = dict["TemplateCode"] as? String {
                    self.templateCode = value
                }
            }
        }
        public var dataQualityRules: [ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityRules != nil {
                var tmp : [Any] = []
                for k in self.dataQualityRules! {
                    tmp.append(k.toMap())
                }
                map["DataQualityRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataQualityRules"] as? [Any?] {
                var tmp : [ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules] = []
                for v in value {
                    if v != nil {
                        var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataQualityRules = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDataQualityRulesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDataQualityRulesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataQualityRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataQualityRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataSourceSharedRulesRequest : Tea.TeaModel {
    public var dataSourceId: Int64?

    public var targetProjectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.targetProjectId != nil {
            map["TargetProjectId"] = self.targetProjectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
        if let value = dict["TargetProjectId"] as? Int64 {
            self.targetProjectId = value
        }
    }
}

public class ListDataSourceSharedRulesResponseBody : Tea.TeaModel {
    public class DataSourceSharedRules : Tea.TeaModel {
        public var createTime: Int64?

        public var createUser: String?

        public var dataSourceId: Int64?

        public var envType: String?

        public var id: Int64?

        public var sharedDataSourceName: String?

        public var sharedUser: String?

        public var sourceProjectId: Int64?

        public var targetProjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.dataSourceId != nil {
                map["DataSourceId"] = self.dataSourceId!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.sharedDataSourceName != nil {
                map["SharedDataSourceName"] = self.sharedDataSourceName!
            }
            if self.sharedUser != nil {
                map["SharedUser"] = self.sharedUser!
            }
            if self.sourceProjectId != nil {
                map["SourceProjectId"] = self.sourceProjectId!
            }
            if self.targetProjectId != nil {
                map["TargetProjectId"] = self.targetProjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreateUser"] as? String {
                self.createUser = value
            }
            if let value = dict["DataSourceId"] as? Int64 {
                self.dataSourceId = value
            }
            if let value = dict["EnvType"] as? String {
                self.envType = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["SharedDataSourceName"] as? String {
                self.sharedDataSourceName = value
            }
            if let value = dict["SharedUser"] as? String {
                self.sharedUser = value
            }
            if let value = dict["SourceProjectId"] as? Int64 {
                self.sourceProjectId = value
            }
            if let value = dict["TargetProjectId"] as? Int64 {
                self.targetProjectId = value
            }
        }
    }
    public var dataSourceSharedRules: [ListDataSourceSharedRulesResponseBody.DataSourceSharedRules]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceSharedRules != nil {
            var tmp : [Any] = []
            for k in self.dataSourceSharedRules! {
                tmp.append(k.toMap())
            }
            map["DataSourceSharedRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceSharedRules"] as? [Any?] {
            var tmp : [ListDataSourceSharedRulesResponseBody.DataSourceSharedRules] = []
            for v in value {
                if v != nil {
                    var model = ListDataSourceSharedRulesResponseBody.DataSourceSharedRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataSourceSharedRules = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataSourceSharedRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataSourceSharedRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataSourceSharedRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataSourcesRequest : Tea.TeaModel {
    public var envType: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sortBy: String?

    public var tags: String?

    public var types: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["Types"] as? [String] {
            self.types = value
        }
    }
}

public class ListDataSourcesShrinkRequest : Tea.TeaModel {
    public var envType: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sortBy: String?

    public var tags: String?

    public var typesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.typesShrink != nil {
            map["Types"] = self.typesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["Types"] as? String {
            self.typesShrink = value
        }
    }
}

public class ListDataSourcesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataSources : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var connectionProperties: Any?

                public var connectionPropertiesMode: String?

                public var createTime: Int64?

                public var createUser: String?

                public var description_: String?

                public var id: Int64?

                public var modifyTime: Int64?

                public var modifyUser: String?

                public var qualifiedName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionProperties != nil {
                        map["ConnectionProperties"] = self.connectionProperties!
                    }
                    if self.connectionPropertiesMode != nil {
                        map["ConnectionPropertiesMode"] = self.connectionPropertiesMode!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.createUser != nil {
                        map["CreateUser"] = self.createUser!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.modifyUser != nil {
                        map["ModifyUser"] = self.modifyUser!
                    }
                    if self.qualifiedName != nil {
                        map["QualifiedName"] = self.qualifiedName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConnectionProperties"] as? Any {
                        self.connectionProperties = value
                    }
                    if let value = dict["ConnectionPropertiesMode"] as? String {
                        self.connectionPropertiesMode = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["CreateUser"] as? String {
                        self.createUser = value
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["ModifyTime"] as? Int64 {
                        self.modifyTime = value
                    }
                    if let value = dict["ModifyUser"] as? String {
                        self.modifyUser = value
                    }
                    if let value = dict["QualifiedName"] as? String {
                        self.qualifiedName = value
                    }
                }
            }
            public var dataSource: [ListDataSourcesResponseBody.PagingInfo.DataSources.DataSource]?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSource != nil {
                    var tmp : [Any] = []
                    for k in self.dataSource! {
                        tmp.append(k.toMap())
                    }
                    map["DataSource"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataSource"] as? [Any?] {
                    var tmp : [ListDataSourcesResponseBody.PagingInfo.DataSources.DataSource] = []
                    for v in value {
                        if v != nil {
                            var model = ListDataSourcesResponseBody.PagingInfo.DataSources.DataSource()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.dataSource = tmp
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var dataSources: [ListDataSourcesResponseBody.PagingInfo.DataSources]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSources != nil {
                var tmp : [Any] = []
                for k in self.dataSources! {
                    tmp.append(k.toMap())
                }
                map["DataSources"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSources"] as? [Any?] {
                var tmp : [ListDataSourcesResponseBody.PagingInfo.DataSources] = []
                for v in value {
                    if v != nil {
                        var model = ListDataSourcesResponseBody.PagingInfo.DataSources()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataSources = tmp
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDataSourcesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDataSourcesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataSourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDatabasesRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentMetaEntityId: String?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
    }
}

public class ListDatabasesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public var databases: [Database]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databases != nil {
                var tmp : [Any] = []
                for k in self.databases! {
                    tmp.append(k.toMap())
                }
                map["Databases"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Databases"] as? [Any?] {
                var tmp : [Database] = []
                for v in value {
                    if v != nil {
                        var model = Database()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.databases = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDatabasesResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDatabasesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDatabasesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDownstreamTaskInstancesRequest : Tea.TeaModel {
    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListDownstreamTaskInstancesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DownstreamTaskInstances : Tea.TeaModel {
            public class TaskInstance : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                    }
                }
                public class Runtime : Tea.TeaModel {
                    public var gateway: String?

                    public var processId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gateway != nil {
                            map["Gateway"] = self.gateway!
                        }
                        if self.processId != nil {
                            map["ProcessId"] = self.processId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Gateway"] as? String {
                            self.gateway = value
                        }
                        if let value = dict["ProcessId"] as? String {
                            self.processId = value
                        }
                    }
                }
                public class RuntimeResource : Tea.TeaModel {
                    public var cu: String?

                    public var image: String?

                    public var resourceGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cu != nil {
                            map["Cu"] = self.cu!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.resourceGroupId != nil {
                            map["ResourceGroupId"] = self.resourceGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Cu"] as? String {
                            self.cu = value
                        }
                        if let value = dict["Image"] as? String {
                            self.image = value
                        }
                        if let value = dict["ResourceGroupId"] as? String {
                            self.resourceGroupId = value
                        }
                    }
                }
                public var baselineId: Int64?

                public var bizdate: Int64?

                public var createTime: Int64?

                public var createUser: String?

                public var dataSource: ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances.TaskInstance.DataSource?

                public var description_: String?

                public var envType: String?

                public var finishedTime: Int64?

                public var id: Int64?

                public var modifyTime: Int64?

                public var modifyUser: String?

                public var owner: String?

                public var periodNumber: Int32?

                public var priority: Int32?

                public var projectId: Int64?

                public var rerunMode: String?

                public var runNumber: Int32?

                public var runtime: ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances.TaskInstance.Runtime?

                public var runtimeResource: ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances.TaskInstance.RuntimeResource?

                public var startedTime: Int64?

                public var status: String?

                public var taskId: Int64?

                public var taskName: String?

                public var taskType: String?

                public var timeout: Int32?

                public var triggerRecurrence: String?

                public var triggerTime: Int64?

                public var triggerType: String?

                public var workflowId: Int64?

                public var workflowInstanceId: Int64?

                public var workflowInstanceType: String?

                public var workflowName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.dataSource?.validate()
                    try self.runtime?.validate()
                    try self.runtimeResource?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.baselineId != nil {
                        map["BaselineId"] = self.baselineId!
                    }
                    if self.bizdate != nil {
                        map["Bizdate"] = self.bizdate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.createUser != nil {
                        map["CreateUser"] = self.createUser!
                    }
                    if self.dataSource != nil {
                        map["DataSource"] = self.dataSource?.toMap()
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.finishedTime != nil {
                        map["FinishedTime"] = self.finishedTime!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.modifyUser != nil {
                        map["ModifyUser"] = self.modifyUser!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.periodNumber != nil {
                        map["PeriodNumber"] = self.periodNumber!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.runNumber != nil {
                        map["RunNumber"] = self.runNumber!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    if self.runtimeResource != nil {
                        map["RuntimeResource"] = self.runtimeResource?.toMap()
                    }
                    if self.startedTime != nil {
                        map["StartedTime"] = self.startedTime!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.taskName != nil {
                        map["TaskName"] = self.taskName!
                    }
                    if self.taskType != nil {
                        map["TaskType"] = self.taskType!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.triggerRecurrence != nil {
                        map["TriggerRecurrence"] = self.triggerRecurrence!
                    }
                    if self.triggerTime != nil {
                        map["TriggerTime"] = self.triggerTime!
                    }
                    if self.triggerType != nil {
                        map["TriggerType"] = self.triggerType!
                    }
                    if self.workflowId != nil {
                        map["WorkflowId"] = self.workflowId!
                    }
                    if self.workflowInstanceId != nil {
                        map["WorkflowInstanceId"] = self.workflowInstanceId!
                    }
                    if self.workflowInstanceType != nil {
                        map["WorkflowInstanceType"] = self.workflowInstanceType!
                    }
                    if self.workflowName != nil {
                        map["WorkflowName"] = self.workflowName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BaselineId"] as? Int64 {
                        self.baselineId = value
                    }
                    if let value = dict["Bizdate"] as? Int64 {
                        self.bizdate = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["CreateUser"] as? String {
                        self.createUser = value
                    }
                    if let value = dict["DataSource"] as? [String: Any?] {
                        var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances.TaskInstance.DataSource()
                        model.fromMap(value)
                        self.dataSource = model
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["EnvType"] as? String {
                        self.envType = value
                    }
                    if let value = dict["FinishedTime"] as? Int64 {
                        self.finishedTime = value
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["ModifyTime"] as? Int64 {
                        self.modifyTime = value
                    }
                    if let value = dict["ModifyUser"] as? String {
                        self.modifyUser = value
                    }
                    if let value = dict["Owner"] as? String {
                        self.owner = value
                    }
                    if let value = dict["PeriodNumber"] as? Int32 {
                        self.periodNumber = value
                    }
                    if let value = dict["Priority"] as? Int32 {
                        self.priority = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["RerunMode"] as? String {
                        self.rerunMode = value
                    }
                    if let value = dict["RunNumber"] as? Int32 {
                        self.runNumber = value
                    }
                    if let value = dict["Runtime"] as? [String: Any?] {
                        var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances.TaskInstance.Runtime()
                        model.fromMap(value)
                        self.runtime = model
                    }
                    if let value = dict["RuntimeResource"] as? [String: Any?] {
                        var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances.TaskInstance.RuntimeResource()
                        model.fromMap(value)
                        self.runtimeResource = model
                    }
                    if let value = dict["StartedTime"] as? Int64 {
                        self.startedTime = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["TaskId"] as? Int64 {
                        self.taskId = value
                    }
                    if let value = dict["TaskName"] as? String {
                        self.taskName = value
                    }
                    if let value = dict["TaskType"] as? String {
                        self.taskType = value
                    }
                    if let value = dict["Timeout"] as? Int32 {
                        self.timeout = value
                    }
                    if let value = dict["TriggerRecurrence"] as? String {
                        self.triggerRecurrence = value
                    }
                    if let value = dict["TriggerTime"] as? Int64 {
                        self.triggerTime = value
                    }
                    if let value = dict["TriggerType"] as? String {
                        self.triggerType = value
                    }
                    if let value = dict["WorkflowId"] as? Int64 {
                        self.workflowId = value
                    }
                    if let value = dict["WorkflowInstanceId"] as? Int64 {
                        self.workflowInstanceId = value
                    }
                    if let value = dict["WorkflowInstanceType"] as? String {
                        self.workflowInstanceType = value
                    }
                    if let value = dict["WorkflowName"] as? String {
                        self.workflowName = value
                    }
                }
            }
            public var dependencyType: String?

            public var taskInstance: ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances.TaskInstance?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.taskInstance?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dependencyType != nil {
                    map["DependencyType"] = self.dependencyType!
                }
                if self.taskInstance != nil {
                    map["TaskInstance"] = self.taskInstance?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DependencyType"] as? String {
                    self.dependencyType = value
                }
                if let value = dict["TaskInstance"] as? [String: Any?] {
                    var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances.TaskInstance()
                    model.fromMap(value)
                    self.taskInstance = model
                }
            }
        }
        public class TaskInstances : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class Runtime : Tea.TeaModel {
                public var gateway: String?

                public var processId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gateway != nil {
                        map["Gateway"] = self.gateway!
                    }
                    if self.processId != nil {
                        map["ProcessId"] = self.processId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Gateway"] as? String {
                        self.gateway = value
                    }
                    if let value = dict["ProcessId"] as? String {
                        self.processId = value
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cu"] as? String {
                        self.cu = value
                    }
                    if let value = dict["Image"] as? String {
                        self.image = value
                    }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public var baselineId: Int64?

            public var bizdate: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource?

            public var description_: String?

            public var envType: String?

            public var finishedTime: Int64?

            public var id: Int64?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var owner: String?

            public var periodNumber: Int32?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunMode: String?

            public var runNumber: Int32?

            public var runtime: ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime?

            public var runtimeResource: ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource?

            public var startedTime: Int64?

            public var status: String?

            public var stepType: String?

            public var taskId: Int64?

            public var taskName: String?

            public var taskType: String?

            public var timeout: Int32?

            public var triggerRecurrence: String?

            public var triggerTime: Int64?

            public var triggerType: String?

            public var workflowId: Int64?

            public var workflowInstanceId: Int64?

            public var workflowInstanceType: String?

            public var workflowName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtime?.validate()
                try self.runtimeResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.periodNumber != nil {
                    map["PeriodNumber"] = self.periodNumber!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.runNumber != nil {
                    map["RunNumber"] = self.runNumber!
                }
                if self.runtime != nil {
                    map["Runtime"] = self.runtime?.toMap()
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.startedTime != nil {
                    map["StartedTime"] = self.startedTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.triggerRecurrence != nil {
                    map["TriggerRecurrence"] = self.triggerRecurrence!
                }
                if self.triggerTime != nil {
                    map["TriggerTime"] = self.triggerTime!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                if self.workflowInstanceId != nil {
                    map["WorkflowInstanceId"] = self.workflowInstanceId!
                }
                if self.workflowInstanceType != nil {
                    map["WorkflowInstanceType"] = self.workflowInstanceType!
                }
                if self.workflowName != nil {
                    map["WorkflowName"] = self.workflowName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["Bizdate"] as? Int64 {
                    self.bizdate = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["FinishedTime"] as? Int64 {
                    self.finishedTime = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["PeriodNumber"] as? Int32 {
                    self.periodNumber = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectEnv"] as? String {
                    self.projectEnv = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RerunMode"] as? String {
                    self.rerunMode = value
                }
                if let value = dict["RunNumber"] as? Int32 {
                    self.runNumber = value
                }
                if let value = dict["Runtime"] as? [String: Any?] {
                    var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime()
                    model.fromMap(value)
                    self.runtime = model
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["StartedTime"] as? Int64 {
                    self.startedTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StepType"] as? String {
                    self.stepType = value
                }
                if let value = dict["TaskId"] as? Int64 {
                    self.taskId = value
                }
                if let value = dict["TaskName"] as? String {
                    self.taskName = value
                }
                if let value = dict["TaskType"] as? String {
                    self.taskType = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["TriggerRecurrence"] as? String {
                    self.triggerRecurrence = value
                }
                if let value = dict["TriggerTime"] as? Int64 {
                    self.triggerTime = value
                }
                if let value = dict["TriggerType"] as? String {
                    self.triggerType = value
                }
                if let value = dict["WorkflowId"] as? Int64 {
                    self.workflowId = value
                }
                if let value = dict["WorkflowInstanceId"] as? Int64 {
                    self.workflowInstanceId = value
                }
                if let value = dict["WorkflowInstanceType"] as? String {
                    self.workflowInstanceType = value
                }
                if let value = dict["WorkflowName"] as? String {
                    self.workflowName = value
                }
            }
        }
        public var downstreamTaskInstances: [ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var taskInstances: [ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downstreamTaskInstances != nil {
                var tmp : [Any] = []
                for k in self.downstreamTaskInstances! {
                    tmp.append(k.toMap())
                }
                map["DownstreamTaskInstances"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.taskInstances != nil {
                var tmp : [Any] = []
                for k in self.taskInstances! {
                    tmp.append(k.toMap())
                }
                map["TaskInstances"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DownstreamTaskInstances"] as? [Any?] {
                var tmp : [ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances] = []
                for v in value {
                    if v != nil {
                        var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.DownstreamTaskInstances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.downstreamTaskInstances = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TaskInstances"] as? [Any?] {
                var tmp : [ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances] = []
                for v in value {
                    if v != nil {
                        var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.taskInstances = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDownstreamTaskInstancesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDownstreamTaskInstancesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDownstreamTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDownstreamTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDownstreamTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDownstreamTasksRequest : Tea.TeaModel {
    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class ListDownstreamTasksResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DownstreamTasks : Tea.TeaModel {
            public class Task : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                    }
                }
                public class RuntimeResource : Tea.TeaModel {
                    public var cu: String?

                    public var image: String?

                    public var resourceGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cu != nil {
                            map["Cu"] = self.cu!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.resourceGroupId != nil {
                            map["ResourceGroupId"] = self.resourceGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Cu"] as? String {
                            self.cu = value
                        }
                        if let value = dict["Image"] as? String {
                            self.image = value
                        }
                        if let value = dict["ResourceGroupId"] as? String {
                            self.resourceGroupId = value
                        }
                    }
                }
                public class Trigger : Tea.TeaModel {
                    public var cron: String?

                    public var endTime: String?

                    public var recurrence: String?

                    public var startTime: String?

                    public var timezone: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cron != nil {
                            map["Cron"] = self.cron!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.recurrence != nil {
                            map["Recurrence"] = self.recurrence!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timezone != nil {
                            map["Timezone"] = self.timezone!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Cron"] as? String {
                            self.cron = value
                        }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["Recurrence"] as? String {
                            self.recurrence = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                        if let value = dict["Timezone"] as? String {
                            self.timezone = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var baselineId: Int64?

                public var createTime: Int64?

                public var createUser: String?

                public var dataSource: ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks.Task.DataSource?

                public var description_: String?

                public var envType: String?

                public var id: Int64?

                public var instanceMode: String?

                public var modifyTime: Int64?

                public var modifyUser: String?

                public var name: String?

                public var owner: String?

                public var priority: Int32?

                public var projectId: Int64?

                public var rerunInterval: Int32?

                public var rerunMode: String?

                public var rerunTimes: Int32?

                public var runtimeResource: ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks.Task.RuntimeResource?

                public var timeout: Int32?

                public var trigger: ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks.Task.Trigger?

                public var type: String?

                public var workflowId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.dataSource?.validate()
                    try self.runtimeResource?.validate()
                    try self.trigger?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.baselineId != nil {
                        map["BaselineId"] = self.baselineId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.createUser != nil {
                        map["CreateUser"] = self.createUser!
                    }
                    if self.dataSource != nil {
                        map["DataSource"] = self.dataSource?.toMap()
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.instanceMode != nil {
                        map["InstanceMode"] = self.instanceMode!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.modifyUser != nil {
                        map["ModifyUser"] = self.modifyUser!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.rerunInterval != nil {
                        map["RerunInterval"] = self.rerunInterval!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.rerunTimes != nil {
                        map["RerunTimes"] = self.rerunTimes!
                    }
                    if self.runtimeResource != nil {
                        map["RuntimeResource"] = self.runtimeResource?.toMap()
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.trigger != nil {
                        map["Trigger"] = self.trigger?.toMap()
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.workflowId != nil {
                        map["WorkflowId"] = self.workflowId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BaselineId"] as? Int64 {
                        self.baselineId = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["CreateUser"] as? String {
                        self.createUser = value
                    }
                    if let value = dict["DataSource"] as? [String: Any?] {
                        var model = ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks.Task.DataSource()
                        model.fromMap(value)
                        self.dataSource = model
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["EnvType"] as? String {
                        self.envType = value
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["InstanceMode"] as? String {
                        self.instanceMode = value
                    }
                    if let value = dict["ModifyTime"] as? Int64 {
                        self.modifyTime = value
                    }
                    if let value = dict["ModifyUser"] as? String {
                        self.modifyUser = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Owner"] as? String {
                        self.owner = value
                    }
                    if let value = dict["Priority"] as? Int32 {
                        self.priority = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["RerunInterval"] as? Int32 {
                        self.rerunInterval = value
                    }
                    if let value = dict["RerunMode"] as? String {
                        self.rerunMode = value
                    }
                    if let value = dict["RerunTimes"] as? Int32 {
                        self.rerunTimes = value
                    }
                    if let value = dict["RuntimeResource"] as? [String: Any?] {
                        var model = ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks.Task.RuntimeResource()
                        model.fromMap(value)
                        self.runtimeResource = model
                    }
                    if let value = dict["Timeout"] as? Int32 {
                        self.timeout = value
                    }
                    if let value = dict["Trigger"] as? [String: Any?] {
                        var model = ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks.Task.Trigger()
                        model.fromMap(value)
                        self.trigger = model
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["WorkflowId"] as? Int64 {
                        self.workflowId = value
                    }
                }
            }
            public var dependencyType: String?

            public var task: ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks.Task?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.task?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dependencyType != nil {
                    map["DependencyType"] = self.dependencyType!
                }
                if self.task != nil {
                    map["Task"] = self.task?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DependencyType"] as? String {
                    self.dependencyType = value
                }
                if let value = dict["Task"] as? [String: Any?] {
                    var model = ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks.Task()
                    model.fromMap(value)
                    self.task = model
                }
            }
        }
        public class Tasks : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cu"] as? String {
                        self.cu = value
                    }
                    if let value = dict["Image"] as? String {
                        self.image = value
                    }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var recurrence: String?

                public var startTime: String?

                public var timezone: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.recurrence != nil {
                        map["Recurrence"] = self.recurrence!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cron"] as? String {
                        self.cron = value
                    }
                    if let value = dict["EndTime"] as? String {
                        self.endTime = value
                    }
                    if let value = dict["Recurrence"] as? String {
                        self.recurrence = value
                    }
                    if let value = dict["StartTime"] as? String {
                        self.startTime = value
                    }
                    if let value = dict["Timezone"] as? String {
                        self.timezone = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var baselineId: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListDownstreamTasksResponseBody.PagingInfo.Tasks.DataSource?

            public var description_: String?

            public var envType: String?

            public var id: Int64?

            public var instanceMode: String?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var name: String?

            public var owner: String?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunInterval: Int32?

            public var rerunMode: String?

            public var rerunTimes: Int32?

            public var runtimeResource: ListDownstreamTasksResponseBody.PagingInfo.Tasks.RuntimeResource?

            public var stepType: String?

            public var timeout: Int32?

            public var trigger: ListDownstreamTasksResponseBody.PagingInfo.Tasks.Trigger?

            public var type: String?

            public var workflowId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtimeResource?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceMode != nil {
                    map["InstanceMode"] = self.instanceMode!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunInterval != nil {
                    map["RerunInterval"] = self.rerunInterval!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.rerunTimes != nil {
                    map["RerunTimes"] = self.rerunTimes!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListDownstreamTasksResponseBody.PagingInfo.Tasks.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["InstanceMode"] as? String {
                    self.instanceMode = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectEnv"] as? String {
                    self.projectEnv = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RerunInterval"] as? Int32 {
                    self.rerunInterval = value
                }
                if let value = dict["RerunMode"] as? String {
                    self.rerunMode = value
                }
                if let value = dict["RerunTimes"] as? Int32 {
                    self.rerunTimes = value
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = ListDownstreamTasksResponseBody.PagingInfo.Tasks.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["StepType"] as? String {
                    self.stepType = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["Trigger"] as? [String: Any?] {
                    var model = ListDownstreamTasksResponseBody.PagingInfo.Tasks.Trigger()
                    model.fromMap(value)
                    self.trigger = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["WorkflowId"] as? Int64 {
                    self.workflowId = value
                }
            }
        }
        public var downstreamTasks: [ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tasks: [ListDownstreamTasksResponseBody.PagingInfo.Tasks]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downstreamTasks != nil {
                var tmp : [Any] = []
                for k in self.downstreamTasks! {
                    tmp.append(k.toMap())
                }
                map["DownstreamTasks"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tasks != nil {
                var tmp : [Any] = []
                for k in self.tasks! {
                    tmp.append(k.toMap())
                }
                map["Tasks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DownstreamTasks"] as? [Any?] {
                var tmp : [ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks] = []
                for v in value {
                    if v != nil {
                        var model = ListDownstreamTasksResponseBody.PagingInfo.DownstreamTasks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.downstreamTasks = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Tasks"] as? [Any?] {
                var tmp : [ListDownstreamTasksResponseBody.PagingInfo.Tasks] = []
                for v in value {
                    if v != nil {
                        var model = ListDownstreamTasksResponseBody.PagingInfo.Tasks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tasks = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListDownstreamTasksResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListDownstreamTasksResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDownstreamTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDownstreamTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDownstreamTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEntitiesInMetaCollectionRequest : Tea.TeaModel {
    public var entityDescription: String?

    public var entityName: String?

    public var entityType: String?

    public var id: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityDescription != nil {
            map["EntityDescription"] = self.entityDescription!
        }
        if self.entityName != nil {
            map["EntityName"] = self.entityName!
        }
        if self.entityType != nil {
            map["EntityType"] = self.entityType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EntityDescription"] as? String {
            self.entityDescription = value
        }
        if let value = dict["EntityName"] as? String {
            self.entityName = value
        }
        if let value = dict["EntityType"] as? String {
            self.entityType = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
    }
}

public class ListEntitiesInMetaCollectionResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Entities : Tea.TeaModel {
            public var comment: String?

            public var createTime: Int64?

            public var description_: String?

            public var id: String?

            public var modifyTime: Int64?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Comment"] as? String {
                    self.comment = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var entities: [ListEntitiesInMetaCollectionResponseBody.PagingInfo.Entities]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entities != nil {
                var tmp : [Any] = []
                for k in self.entities! {
                    tmp.append(k.toMap())
                }
                map["Entities"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Entities"] as? [Any?] {
                var tmp : [ListEntitiesInMetaCollectionResponseBody.PagingInfo.Entities] = []
                for v in value {
                    if v != nil {
                        var model = ListEntitiesInMetaCollectionResponseBody.PagingInfo.Entities()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.entities = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListEntitiesInMetaCollectionResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListEntitiesInMetaCollectionResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListEntitiesInMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEntitiesInMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEntitiesInMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListFunctionsRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ListFunctionsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Functions : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Command"] as? String {
                            self.command = value
                        }
                    }
                }
                public var id: Int64?

                public var path: String?

                public var runtime: ListFunctionsResponseBody.PagingInfo.Functions.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Runtime"] as? [String: Any?] {
                        var model = ListFunctionsResponseBody.PagingInfo.Functions.Script.Runtime()
                        model.fromMap(value)
                        self.runtime = model
                    }
                }
            }
            public var armResource: String?

            public var className: String?

            public var commandDescription: String?

            public var createTime: Int64?

            public var dataSource: ListFunctionsResponseBody.PagingInfo.Functions.DataSource?

            public var databaseName: String?

            public var description_: String?

            public var embeddedCode: String?

            public var embeddedCodeType: String?

            public var embeddedResourceType: String?

            public var exampleDescription: String?

            public var fileResource: String?

            public var id: Int64?

            public var modifyTime: Int64?

            public var name: String?

            public var owner: String?

            public var parameterDescription: String?

            public var projectId: Int64?

            public var returnValueDescription: String?

            public var runtimeResource: ListFunctionsResponseBody.PagingInfo.Functions.RuntimeResource?

            public var script: ListFunctionsResponseBody.PagingInfo.Functions.Script?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtimeResource?.validate()
                try self.script?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.armResource != nil {
                    map["ArmResource"] = self.armResource!
                }
                if self.className != nil {
                    map["ClassName"] = self.className!
                }
                if self.commandDescription != nil {
                    map["CommandDescription"] = self.commandDescription!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.embeddedCode != nil {
                    map["EmbeddedCode"] = self.embeddedCode!
                }
                if self.embeddedCodeType != nil {
                    map["EmbeddedCodeType"] = self.embeddedCodeType!
                }
                if self.embeddedResourceType != nil {
                    map["EmbeddedResourceType"] = self.embeddedResourceType!
                }
                if self.exampleDescription != nil {
                    map["ExampleDescription"] = self.exampleDescription!
                }
                if self.fileResource != nil {
                    map["FileResource"] = self.fileResource!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parameterDescription != nil {
                    map["ParameterDescription"] = self.parameterDescription!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.returnValueDescription != nil {
                    map["ReturnValueDescription"] = self.returnValueDescription!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ArmResource"] as? String {
                    self.armResource = value
                }
                if let value = dict["ClassName"] as? String {
                    self.className = value
                }
                if let value = dict["CommandDescription"] as? String {
                    self.commandDescription = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListFunctionsResponseBody.PagingInfo.Functions.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["DatabaseName"] as? String {
                    self.databaseName = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EmbeddedCode"] as? String {
                    self.embeddedCode = value
                }
                if let value = dict["EmbeddedCodeType"] as? String {
                    self.embeddedCodeType = value
                }
                if let value = dict["EmbeddedResourceType"] as? String {
                    self.embeddedResourceType = value
                }
                if let value = dict["ExampleDescription"] as? String {
                    self.exampleDescription = value
                }
                if let value = dict["FileResource"] as? String {
                    self.fileResource = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ParameterDescription"] as? String {
                    self.parameterDescription = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["ReturnValueDescription"] as? String {
                    self.returnValueDescription = value
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = ListFunctionsResponseBody.PagingInfo.Functions.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["Script"] as? [String: Any?] {
                    var model = ListFunctionsResponseBody.PagingInfo.Functions.Script()
                    model.fromMap(value)
                    self.script = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var functions: [ListFunctionsResponseBody.PagingInfo.Functions]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.functions != nil {
                var tmp : [Any] = []
                for k in self.functions! {
                    tmp.append(k.toMap())
                }
                map["Functions"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Functions"] as? [Any?] {
                var tmp : [ListFunctionsResponseBody.PagingInfo.Functions] = []
                for v in value {
                    if v != nil {
                        var model = ListFunctionsResponseBody.PagingInfo.Functions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.functions = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListFunctionsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListFunctionsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListFunctionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFunctionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListFunctionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLineageRelationshipsRequest : Tea.TeaModel {
    public var dstEntityId: String?

    public var dstEntityName: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var srcEntityId: String?

    public var srcEntityName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dstEntityId != nil {
            map["DstEntityId"] = self.dstEntityId!
        }
        if self.dstEntityName != nil {
            map["DstEntityName"] = self.dstEntityName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.srcEntityId != nil {
            map["SrcEntityId"] = self.srcEntityId!
        }
        if self.srcEntityName != nil {
            map["SrcEntityName"] = self.srcEntityName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DstEntityId"] as? String {
            self.dstEntityId = value
        }
        if let value = dict["DstEntityName"] as? String {
            self.dstEntityName = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["SrcEntityId"] as? String {
            self.srcEntityId = value
        }
        if let value = dict["SrcEntityName"] as? String {
            self.srcEntityName = value
        }
    }
}

public class ListLineageRelationshipsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public var lineageRelationships: [LineageRelationship]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lineageRelationships != nil {
                var tmp : [Any] = []
                for k in self.lineageRelationships! {
                    tmp.append(k.toMap())
                }
                map["LineageRelationships"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LineageRelationships"] as? [Any?] {
                var tmp : [LineageRelationship] = []
                for v in value {
                    if v != nil {
                        var model = LineageRelationship()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.lineageRelationships = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListLineageRelationshipsResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListLineageRelationshipsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListLineageRelationshipsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLineageRelationshipsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLineageRelationshipsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLineagesRequest : Tea.TeaModel {
    public var dstEntityId: String?

    public var dstEntityName: String?

    public var needAttachRelationship: Bool?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var srcEntityId: String?

    public var srcEntityName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dstEntityId != nil {
            map["DstEntityId"] = self.dstEntityId!
        }
        if self.dstEntityName != nil {
            map["DstEntityName"] = self.dstEntityName!
        }
        if self.needAttachRelationship != nil {
            map["NeedAttachRelationship"] = self.needAttachRelationship!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.srcEntityId != nil {
            map["SrcEntityId"] = self.srcEntityId!
        }
        if self.srcEntityName != nil {
            map["SrcEntityName"] = self.srcEntityName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DstEntityId"] as? String {
            self.dstEntityId = value
        }
        if let value = dict["DstEntityName"] as? String {
            self.dstEntityName = value
        }
        if let value = dict["NeedAttachRelationship"] as? Bool {
            self.needAttachRelationship = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["SrcEntityId"] as? String {
            self.srcEntityId = value
        }
        if let value = dict["SrcEntityName"] as? String {
            self.srcEntityName = value
        }
    }
}

public class ListLineagesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Lineages : Tea.TeaModel {
            public var dstEntity: LineageEntity?

            public var relationships: [LineageRelationship]?

            public var srcEntity: LineageEntity?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dstEntity?.validate()
                try self.srcEntity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dstEntity != nil {
                    map["DstEntity"] = self.dstEntity?.toMap()
                }
                if self.relationships != nil {
                    var tmp : [Any] = []
                    for k in self.relationships! {
                        tmp.append(k.toMap())
                    }
                    map["Relationships"] = tmp
                }
                if self.srcEntity != nil {
                    map["SrcEntity"] = self.srcEntity?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DstEntity"] as? [String: Any?] {
                    var model = LineageEntity()
                    model.fromMap(value)
                    self.dstEntity = model
                }
                if let value = dict["Relationships"] as? [Any?] {
                    var tmp : [LineageRelationship] = []
                    for v in value {
                        if v != nil {
                            var model = LineageRelationship()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.relationships = tmp
                }
                if let value = dict["SrcEntity"] as? [String: Any?] {
                    var model = LineageEntity()
                    model.fromMap(value)
                    self.srcEntity = model
                }
            }
        }
        public var lineages: [ListLineagesResponseBody.PagingInfo.Lineages]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lineages != nil {
                var tmp : [Any] = []
                for k in self.lineages! {
                    tmp.append(k.toMap())
                }
                map["Lineages"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Lineages"] as? [Any?] {
                var tmp : [ListLineagesResponseBody.PagingInfo.Lineages] = []
                for v in value {
                    if v != nil {
                        var model = ListLineagesResponseBody.PagingInfo.Lineages()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.lineages = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListLineagesResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListLineagesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListLineagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLineagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLineagesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMetaCollectionsRequest : Tea.TeaModel {
    public var administrator: String?

    public var createUser: String?

    public var description_: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentId: String?

    public var sortBy: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.administrator != nil {
            map["Administrator"] = self.administrator!
        }
        if self.createUser != nil {
            map["CreateUser"] = self.createUser!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Administrator"] as? String {
            self.administrator = value
        }
        if let value = dict["CreateUser"] as? String {
            self.createUser = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentId"] as? String {
            self.parentId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ListMetaCollectionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class MetaCollections : Tea.TeaModel {
            public var administrators: [String]?

            public var createTime: Int64?

            public var createUser: String?

            public var description_: String?

            public var id: String?

            public var modifyTime: Int64?

            public var name: String?

            public var parentId: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.administrators != nil {
                    map["Administrators"] = self.administrators!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Administrators"] as? [String] {
                    self.administrators = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ParentId"] as? String {
                    self.parentId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var metaCollections: [ListMetaCollectionsResponseBody.Data.MetaCollections]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metaCollections != nil {
                var tmp : [Any] = []
                for k in self.metaCollections! {
                    tmp.append(k.toMap())
                }
                map["MetaCollections"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MetaCollections"] as? [Any?] {
                var tmp : [ListMetaCollectionsResponseBody.Data.MetaCollections] = []
                for v in value {
                    if v != nil {
                        var model = ListMetaCollectionsResponseBody.Data.MetaCollections()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.metaCollections = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var data: ListMetaCollectionsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListMetaCollectionsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListMetaCollectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMetaCollectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMetaCollectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNetworksRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
    }
}

public class ListNetworksResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class NetworkList : Tea.TeaModel {
            public var createTime: Int64?

            public var createUser: String?

            public var id: Int64?

            public var resourceGroupId: String?

            public var securityGroupId: String?

            public var status: String?

            public var vpcId: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vswitchId != nil {
                    map["VswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SecurityGroupId"] as? String {
                    self.securityGroupId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["VswitchId"] as? String {
                    self.vswitchId = value
                }
            }
        }
        public var networkList: [ListNetworksResponseBody.PagingInfo.NetworkList]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkList != nil {
                var tmp : [Any] = []
                for k in self.networkList! {
                    tmp.append(k.toMap())
                }
                map["NetworkList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NetworkList"] as? [Any?] {
                var tmp : [ListNetworksResponseBody.PagingInfo.NetworkList] = []
                for v in value {
                    if v != nil {
                        var model = ListNetworksResponseBody.PagingInfo.NetworkList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.networkList = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListNetworksResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListNetworksResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListNetworksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNetworksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNetworksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNodeDependenciesRequest : Tea.TeaModel {
    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class ListNodeDependenciesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class Inputs : Tea.TeaModel {
                public class NodeOutputs : Tea.TeaModel {
                    public var data: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Data"] as? String {
                            self.data = value
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public var guid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.guid != nil {
                            map["Guid"] = self.guid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Guid"] as? String {
                            self.guid = value
                        }
                    }
                }
                public class Variables : Tea.TeaModel {
                    public class Node : Tea.TeaModel {
                        public var output: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.output != nil {
                                map["Output"] = self.output!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Output"] as? String {
                                self.output = value
                            }
                        }
                    }
                    public var artifactType: String?

                    public var id: Int64?

                    public var name: String?

                    public var node: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables.Node?

                    public var scope: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.node?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.artifactType != nil {
                            map["ArtifactType"] = self.artifactType!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.node != nil {
                            map["Node"] = self.node?.toMap()
                        }
                        if self.scope != nil {
                            map["Scope"] = self.scope!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ArtifactType"] as? String {
                            self.artifactType = value
                        }
                        if let value = dict["Id"] as? Int64 {
                            self.id = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Node"] as? [String: Any?] {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables.Node()
                            model.fromMap(value)
                            self.node = model
                        }
                        if let value = dict["Scope"] as? String {
                            self.scope = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var nodeOutputs: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs]?

                public var tables: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Tables]?

                public var variables: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeOutputs != nil {
                        var tmp : [Any] = []
                        for k in self.nodeOutputs! {
                            tmp.append(k.toMap())
                        }
                        map["NodeOutputs"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.variables != nil {
                        var tmp : [Any] = []
                        for k in self.variables! {
                            tmp.append(k.toMap())
                        }
                        map["Variables"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NodeOutputs"] as? [Any?] {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.nodeOutputs = tmp
                    }
                    if let value = dict["Tables"] as? [Any?] {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Tables] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Tables()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tables = tmp
                    }
                    if let value = dict["Variables"] as? [Any?] {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.variables = tmp
                    }
                }
            }
            public class Outputs : Tea.TeaModel {
                public class NodeOutputs : Tea.TeaModel {
                    public var data: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Data"] as? String {
                            self.data = value
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public var guid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.guid != nil {
                            map["Guid"] = self.guid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Guid"] as? String {
                            self.guid = value
                        }
                    }
                }
                public class Variables : Tea.TeaModel {
                    public class Node : Tea.TeaModel {
                        public var output: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.output != nil {
                                map["Output"] = self.output!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Output"] as? String {
                                self.output = value
                            }
                        }
                    }
                    public var artifactType: String?

                    public var id: Int64?

                    public var name: String?

                    public var node: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables.Node?

                    public var scope: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.node?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.artifactType != nil {
                            map["ArtifactType"] = self.artifactType!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.node != nil {
                            map["Node"] = self.node?.toMap()
                        }
                        if self.scope != nil {
                            map["Scope"] = self.scope!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ArtifactType"] as? String {
                            self.artifactType = value
                        }
                        if let value = dict["Id"] as? Int64 {
                            self.id = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Node"] as? [String: Any?] {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables.Node()
                            model.fromMap(value)
                            self.node = model
                        }
                        if let value = dict["Scope"] as? String {
                            self.scope = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var nodeOutputs: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs]?

                public var tables: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Tables]?

                public var variables: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeOutputs != nil {
                        var tmp : [Any] = []
                        for k in self.nodeOutputs! {
                            tmp.append(k.toMap())
                        }
                        map["NodeOutputs"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.variables != nil {
                        var tmp : [Any] = []
                        for k in self.variables! {
                            tmp.append(k.toMap())
                        }
                        map["Variables"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NodeOutputs"] as? [Any?] {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.nodeOutputs = tmp
                    }
                    if let value = dict["Tables"] as? [Any?] {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Tables] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Tables()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tables = tmp
                    }
                    if let value = dict["Variables"] as? [Any?] {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.variables = tmp
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Command"] as? String {
                            self.command = value
                        }
                    }
                }
                public var id: Int64?

                public var path: String?

                public var runtime: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Runtime"] as? [String: Any?] {
                        var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Script.Runtime()
                        model.fromMap(value)
                        self.runtime = model
                    }
                }
            }
            public class Strategy : Tea.TeaModel {
                public var instanceMode: String?

                public var rerunInterval: Int32?

                public var rerunMode: String?

                public var rerunTimes: Int32?

                public var timeout: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceMode != nil {
                        map["InstanceMode"] = self.instanceMode!
                    }
                    if self.rerunInterval != nil {
                        map["RerunInterval"] = self.rerunInterval!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.rerunTimes != nil {
                        map["RerunTimes"] = self.rerunTimes!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceMode"] as? String {
                        self.instanceMode = value
                    }
                    if let value = dict["RerunInterval"] as? Int32 {
                        self.rerunInterval = value
                    }
                    if let value = dict["RerunMode"] as? String {
                        self.rerunMode = value
                    }
                    if let value = dict["RerunTimes"] as? Int32 {
                        self.rerunTimes = value
                    }
                    if let value = dict["Timeout"] as? Int32 {
                        self.timeout = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var id: Int64?

                public var startTime: String?

                public var timezone: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cron"] as? String {
                        self.cron = value
                    }
                    if let value = dict["EndTime"] as? String {
                        self.endTime = value
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["StartTime"] as? String {
                        self.startTime = value
                    }
                    if let value = dict["Timezone"] as? String {
                        self.timezone = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var createTime: Int64?

            public var dataSource: ListNodeDependenciesResponseBody.PagingInfo.Nodes.DataSource?

            public var description_: String?

            public var id: Int64?

            public var inputs: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs?

            public var modifyTime: Int64?

            public var name: String?

            public var outputs: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs?

            public var owner: String?

            public var projectId: Int64?

            public var recurrence: String?

            public var runtimeResource: ListNodeDependenciesResponseBody.PagingInfo.Nodes.RuntimeResource?

            public var script: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Script?

            public var strategy: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Strategy?

            public var tags: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Tags]?

            public var taskId: Int64?

            public var trigger: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Trigger?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.inputs?.validate()
                try self.outputs?.validate()
                try self.runtimeResource?.validate()
                try self.script?.validate()
                try self.strategy?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.inputs != nil {
                    map["Inputs"] = self.inputs?.toMap()
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outputs != nil {
                    map["Outputs"] = self.outputs?.toMap()
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.recurrence != nil {
                    map["Recurrence"] = self.recurrence!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy?.toMap()
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Inputs"] as? [String: Any?] {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs()
                    model.fromMap(value)
                    self.inputs = model
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Outputs"] as? [String: Any?] {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs()
                    model.fromMap(value)
                    self.outputs = model
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Recurrence"] as? String {
                    self.recurrence = value
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["Script"] as? [String: Any?] {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Script()
                    model.fromMap(value)
                    self.script = model
                }
                if let value = dict["Strategy"] as? [String: Any?] {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Strategy()
                    model.fromMap(value)
                    self.strategy = model
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
                if let value = dict["TaskId"] as? Int64 {
                    self.taskId = value
                }
                if let value = dict["Trigger"] as? [String: Any?] {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Trigger()
                    model.fromMap(value)
                    self.trigger = model
                }
            }
        }
        public var nodes: [ListNodeDependenciesResponseBody.PagingInfo.Nodes]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Nodes"] as? [Any?] {
                var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes] = []
                for v in value {
                    if v != nil {
                        var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodes = tmp
            }
            if let value = dict["PageNumber"] as? String {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? String {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? String {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListNodeDependenciesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListNodeDependenciesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListNodeDependenciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodeDependenciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNodeDependenciesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public var containerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var recurrence: String?

    public var rerunMode: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.recurrence != nil {
            map["Recurrence"] = self.recurrence!
        }
        if self.rerunMode != nil {
            map["RerunMode"] = self.rerunMode!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ContainerId"] as? Int64 {
            self.containerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Recurrence"] as? String {
            self.recurrence = value
        }
        if let value = dict["RerunMode"] as? String {
            self.rerunMode = value
        }
        if let value = dict["Scene"] as? String {
            self.scene = value
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class Inputs : Tea.TeaModel {
                public class NodeOutputs : Tea.TeaModel {
                    public var data: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Data"] as? String {
                            self.data = value
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public var guid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.guid != nil {
                            map["Guid"] = self.guid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Guid"] as? String {
                            self.guid = value
                        }
                    }
                }
                public class Variables : Tea.TeaModel {
                    public class Node : Tea.TeaModel {
                        public var output: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.output != nil {
                                map["Output"] = self.output!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Output"] as? String {
                                self.output = value
                            }
                        }
                    }
                    public var artifactType: String?

                    public var id: Int64?

                    public var name: String?

                    public var node: ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables.Node?

                    public var scope: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.node?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.artifactType != nil {
                            map["ArtifactType"] = self.artifactType!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.node != nil {
                            map["Node"] = self.node?.toMap()
                        }
                        if self.scope != nil {
                            map["Scope"] = self.scope!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ArtifactType"] as? String {
                            self.artifactType = value
                        }
                        if let value = dict["Id"] as? Int64 {
                            self.id = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Node"] as? [String: Any?] {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables.Node()
                            model.fromMap(value)
                            self.node = model
                        }
                        if let value = dict["Scope"] as? String {
                            self.scope = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var nodeOutputs: [ListNodesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs]?

                public var tables: [ListNodesResponseBody.PagingInfo.Nodes.Inputs.Tables]?

                public var variables: [ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeOutputs != nil {
                        var tmp : [Any] = []
                        for k in self.nodeOutputs! {
                            tmp.append(k.toMap())
                        }
                        map["NodeOutputs"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.variables != nil {
                        var tmp : [Any] = []
                        for k in self.variables! {
                            tmp.append(k.toMap())
                        }
                        map["Variables"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NodeOutputs"] as? [Any?] {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.nodeOutputs = tmp
                    }
                    if let value = dict["Tables"] as? [Any?] {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Inputs.Tables] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs.Tables()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tables = tmp
                    }
                    if let value = dict["Variables"] as? [Any?] {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.variables = tmp
                    }
                }
            }
            public class Outputs : Tea.TeaModel {
                public class NodeOutputs : Tea.TeaModel {
                    public var data: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Data"] as? String {
                            self.data = value
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public var guid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.guid != nil {
                            map["Guid"] = self.guid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Guid"] as? String {
                            self.guid = value
                        }
                    }
                }
                public class Variables : Tea.TeaModel {
                    public class Node : Tea.TeaModel {
                        public var output: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.output != nil {
                                map["Output"] = self.output!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Output"] as? String {
                                self.output = value
                            }
                        }
                    }
                    public var artifactType: String?

                    public var id: Int64?

                    public var name: String?

                    public var node: ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables.Node?

                    public var scope: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.node?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.artifactType != nil {
                            map["ArtifactType"] = self.artifactType!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.node != nil {
                            map["Node"] = self.node?.toMap()
                        }
                        if self.scope != nil {
                            map["Scope"] = self.scope!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ArtifactType"] as? String {
                            self.artifactType = value
                        }
                        if let value = dict["Id"] as? Int64 {
                            self.id = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Node"] as? [String: Any?] {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables.Node()
                            model.fromMap(value)
                            self.node = model
                        }
                        if let value = dict["Scope"] as? String {
                            self.scope = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var nodeOutputs: [ListNodesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs]?

                public var tables: [ListNodesResponseBody.PagingInfo.Nodes.Outputs.Tables]?

                public var variables: [ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeOutputs != nil {
                        var tmp : [Any] = []
                        for k in self.nodeOutputs! {
                            tmp.append(k.toMap())
                        }
                        map["NodeOutputs"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.variables != nil {
                        var tmp : [Any] = []
                        for k in self.variables! {
                            tmp.append(k.toMap())
                        }
                        map["Variables"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["NodeOutputs"] as? [Any?] {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.nodeOutputs = tmp
                    }
                    if let value = dict["Tables"] as? [Any?] {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Outputs.Tables] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs.Tables()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tables = tmp
                    }
                    if let value = dict["Variables"] as? [Any?] {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables] = []
                        for v in value {
                            if v != nil {
                                var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.variables = tmp
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var resourceGroup: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroup != nil {
                        map["ResourceGroup"] = self.resourceGroup!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourceGroup"] as? String {
                        self.resourceGroup = value
                    }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Command"] as? String {
                            self.command = value
                        }
                    }
                }
                public var id: Int64?

                public var path: String?

                public var runtime: ListNodesResponseBody.PagingInfo.Nodes.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Runtime"] as? [String: Any?] {
                        var model = ListNodesResponseBody.PagingInfo.Nodes.Script.Runtime()
                        model.fromMap(value)
                        self.runtime = model
                    }
                }
            }
            public class Strategy : Tea.TeaModel {
                public var instanceMode: String?

                public var rerunInterval: Int32?

                public var rerunMode: String?

                public var rerunTimes: Int32?

                public var timeout: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceMode != nil {
                        map["InstanceMode"] = self.instanceMode!
                    }
                    if self.rerunInterval != nil {
                        map["RerunInterval"] = self.rerunInterval!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.rerunTimes != nil {
                        map["RerunTimes"] = self.rerunTimes!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["InstanceMode"] as? String {
                        self.instanceMode = value
                    }
                    if let value = dict["RerunInterval"] as? Int32 {
                        self.rerunInterval = value
                    }
                    if let value = dict["RerunMode"] as? String {
                        self.rerunMode = value
                    }
                    if let value = dict["RerunTimes"] as? Int32 {
                        self.rerunTimes = value
                    }
                    if let value = dict["Timeout"] as? Int32 {
                        self.timeout = value
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var id: Int64?

                public var startTime: String?

                public var timezone: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cron"] as? String {
                        self.cron = value
                    }
                    if let value = dict["EndTime"] as? String {
                        self.endTime = value
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["StartTime"] as? String {
                        self.startTime = value
                    }
                    if let value = dict["Timezone"] as? String {
                        self.timezone = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var createTime: Int64?

            public var dataSource: ListNodesResponseBody.PagingInfo.Nodes.DataSource?

            public var description_: String?

            public var id: Int64?

            public var inputs: ListNodesResponseBody.PagingInfo.Nodes.Inputs?

            public var modifyTime: Int64?

            public var name: String?

            public var outputs: ListNodesResponseBody.PagingInfo.Nodes.Outputs?

            public var owner: String?

            public var projectId: Int64?

            public var recurrence: String?

            public var runtimeResource: ListNodesResponseBody.PagingInfo.Nodes.RuntimeResource?

            public var script: ListNodesResponseBody.PagingInfo.Nodes.Script?

            public var strategy: ListNodesResponseBody.PagingInfo.Nodes.Strategy?

            public var tags: [ListNodesResponseBody.PagingInfo.Nodes.Tags]?

            public var taskId: Int64?

            public var trigger: ListNodesResponseBody.PagingInfo.Nodes.Trigger?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.inputs?.validate()
                try self.outputs?.validate()
                try self.runtimeResource?.validate()
                try self.script?.validate()
                try self.strategy?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.inputs != nil {
                    map["Inputs"] = self.inputs?.toMap()
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outputs != nil {
                    map["Outputs"] = self.outputs?.toMap()
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.recurrence != nil {
                    map["Recurrence"] = self.recurrence!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy?.toMap()
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Inputs"] as? [String: Any?] {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs()
                    model.fromMap(value)
                    self.inputs = model
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Outputs"] as? [String: Any?] {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs()
                    model.fromMap(value)
                    self.outputs = model
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Recurrence"] as? String {
                    self.recurrence = value
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["Script"] as? [String: Any?] {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Script()
                    model.fromMap(value)
                    self.script = model
                }
                if let value = dict["Strategy"] as? [String: Any?] {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Strategy()
                    model.fromMap(value)
                    self.strategy = model
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
                if let value = dict["TaskId"] as? Int64 {
                    self.taskId = value
                }
                if let value = dict["Trigger"] as? [String: Any?] {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Trigger()
                    model.fromMap(value)
                    self.trigger = model
                }
            }
        }
        public var nodes: [ListNodesResponseBody.PagingInfo.Nodes]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Nodes"] as? [Any?] {
                var tmp : [ListNodesResponseBody.PagingInfo.Nodes] = []
                for v in value {
                    if v != nil {
                        var model = ListNodesResponseBody.PagingInfo.Nodes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodes = tmp
            }
            if let value = dict["PageNumber"] as? String {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? String {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? String {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListNodesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListNodesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPartitionsRequest : Tea.TeaModel {
    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortBy: String?

    public var tableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.tableId != nil {
            map["TableId"] = self.tableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TableId"] as? String {
            self.tableId = value
        }
    }
}

public class ListPartitionsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var partitionList: [Partition]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.partitionList != nil {
                var tmp : [Any] = []
                for k in self.partitionList! {
                    tmp.append(k.toMap())
                }
                map["PartitionList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["PartitionList"] as? [Any?] {
                var tmp : [Partition] = []
                for v in value {
                    if v != nil {
                        var model = Partition()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.partitionList = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListPartitionsResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListPartitionsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListPartitionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPartitionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPartitionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelineRunsRequest : Tea.TeaModel {
    public var creator: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Creator"] as? String {
            self.creator = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class ListPipelineRunsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class PipelineRuns : Tea.TeaModel {
            public class Stages : Tea.TeaModel {
                public var code: String?

                public var description_: String?

                public var detail: [String: Any]?

                public var message: String?

                public var name: String?

                public var status: String?

                public var step: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.detail != nil {
                        map["Detail"] = self.detail!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Code"] as? String {
                        self.code = value
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["Detail"] as? [String: Any] {
                        self.detail = value
                    }
                    if let value = dict["Message"] as? String {
                        self.message = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["Step"] as? Int32 {
                        self.step = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var createTime: Int64?

            public var creator: String?

            public var id: String?

            public var message: String?

            public var modifyTime: Int64?

            public var projectId: Int64?

            public var stages: [ListPipelineRunsResponseBody.PagingInfo.PipelineRuns.Stages]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.stages != nil {
                    var tmp : [Any] = []
                    for k in self.stages! {
                        tmp.append(k.toMap())
                    }
                    map["Stages"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Creator"] as? String {
                    self.creator = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Stages"] as? [Any?] {
                    var tmp : [ListPipelineRunsResponseBody.PagingInfo.PipelineRuns.Stages] = []
                    for v in value {
                        if v != nil {
                            var model = ListPipelineRunsResponseBody.PagingInfo.PipelineRuns.Stages()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.stages = tmp
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var pipelineRuns: [ListPipelineRunsResponseBody.PagingInfo.PipelineRuns]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.pipelineRuns != nil {
                var tmp : [Any] = []
                for k in self.pipelineRuns! {
                    tmp.append(k.toMap())
                }
                map["PipelineRuns"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["PipelineRuns"] as? [Any?] {
                var tmp : [ListPipelineRunsResponseBody.PagingInfo.PipelineRuns] = []
                for v in value {
                    if v != nil {
                        var model = ListPipelineRunsResponseBody.PagingInfo.PipelineRuns()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.pipelineRuns = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListPipelineRunsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListPipelineRunsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListPipelineRunsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineRunsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelineRunsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectMembersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var roleCodes: [String]?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodes != nil {
            map["RoleCodes"] = self.roleCodes!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCodes"] as? [String] {
            self.roleCodes = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
    }
}

public class ListProjectMembersShrinkRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var roleCodesShrink: String?

    public var userIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodesShrink != nil {
            map["RoleCodes"] = self.roleCodesShrink!
        }
        if self.userIdsShrink != nil {
            map["UserIds"] = self.userIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCodes"] as? String {
            self.roleCodesShrink = value
        }
        if let value = dict["UserIds"] as? String {
            self.userIdsShrink = value
        }
    }
}

public class ListProjectMembersResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class ProjectMembers : Tea.TeaModel {
            public class Roles : Tea.TeaModel {
                public var code: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Code"] as? String {
                        self.code = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var projectId: Int64?

            public var roles: [ListProjectMembersResponseBody.PagingInfo.ProjectMembers.Roles]?

            public var status: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.roles != nil {
                    var tmp : [Any] = []
                    for k in self.roles! {
                        tmp.append(k.toMap())
                    }
                    map["Roles"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Roles"] as? [Any?] {
                    var tmp : [ListProjectMembersResponseBody.PagingInfo.ProjectMembers.Roles] = []
                    for v in value {
                        if v != nil {
                            var model = ListProjectMembersResponseBody.PagingInfo.ProjectMembers.Roles()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.roles = tmp
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var projectMembers: [ListProjectMembersResponseBody.PagingInfo.ProjectMembers]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projectMembers != nil {
                var tmp : [Any] = []
                for k in self.projectMembers! {
                    tmp.append(k.toMap())
                }
                map["ProjectMembers"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["ProjectMembers"] as? [Any?] {
                var tmp : [ListProjectMembersResponseBody.PagingInfo.ProjectMembers] = []
                for v in value {
                    if v != nil {
                        var model = ListProjectMembersResponseBody.PagingInfo.ProjectMembers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.projectMembers = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListProjectMembersResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListProjectMembersResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListProjectMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectMembersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectRolesRequest : Tea.TeaModel {
    public var codes: [String]?

    public var names: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.codes != nil {
            map["Codes"] = self.codes!
        }
        if self.names != nil {
            map["Names"] = self.names!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Codes"] as? [String] {
            self.codes = value
        }
        if let value = dict["Names"] as? [String] {
            self.names = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ListProjectRolesShrinkRequest : Tea.TeaModel {
    public var codesShrink: String?

    public var namesShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.codesShrink != nil {
            map["Codes"] = self.codesShrink!
        }
        if self.namesShrink != nil {
            map["Names"] = self.namesShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Codes"] as? String {
            self.codesShrink = value
        }
        if let value = dict["Names"] as? String {
            self.namesShrink = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ListProjectRolesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class ProjectRoles : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public var projectId: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var pageNumber: String?

        public var pageSize: String?

        public var projectRoles: [ListProjectRolesResponseBody.PagingInfo.ProjectRoles]?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projectRoles != nil {
                var tmp : [Any] = []
                for k in self.projectRoles! {
                    tmp.append(k.toMap())
                }
                map["ProjectRoles"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? String {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? String {
                self.pageSize = value
            }
            if let value = dict["ProjectRoles"] as? [Any?] {
                var tmp : [ListProjectRolesResponseBody.PagingInfo.ProjectRoles] = []
                for v in value {
                    if v != nil {
                        var model = ListProjectRolesResponseBody.PagingInfo.ProjectRoles()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.projectRoles = tmp
            }
            if let value = dict["TotalCount"] as? String {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListProjectRolesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListProjectRolesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListProjectRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectRolesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectsRequest : Tea.TeaModel {
    public class AliyunResourceTags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTags: [ListProjectsRequest.AliyunResourceTags]?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var ids: [Int64]?

    public var names: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var paiTaskEnabled: Bool?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTags != nil {
            var tmp : [Any] = []
            for k in self.aliyunResourceTags! {
                tmp.append(k.toMap())
            }
            map["AliyunResourceTags"] = tmp
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.names != nil {
            map["Names"] = self.names!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunResourceGroupId"] as? String {
            self.aliyunResourceGroupId = value
        }
        if let value = dict["AliyunResourceTags"] as? [Any?] {
            var tmp : [ListProjectsRequest.AliyunResourceTags] = []
            for v in value {
                if v != nil {
                    var model = ListProjectsRequest.AliyunResourceTags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.aliyunResourceTags = tmp
        }
        if let value = dict["DevEnvironmentEnabled"] as? Bool {
            self.devEnvironmentEnabled = value
        }
        if let value = dict["DevRoleDisabled"] as? Bool {
            self.devRoleDisabled = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
        if let value = dict["Names"] as? [String] {
            self.names = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PaiTaskEnabled"] as? Bool {
            self.paiTaskEnabled = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class ListProjectsShrinkRequest : Tea.TeaModel {
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTagsShrink: String?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var idsShrink: String?

    public var namesShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var paiTaskEnabled: Bool?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTagsShrink != nil {
            map["AliyunResourceTags"] = self.aliyunResourceTagsShrink!
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.namesShrink != nil {
            map["Names"] = self.namesShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunResourceGroupId"] as? String {
            self.aliyunResourceGroupId = value
        }
        if let value = dict["AliyunResourceTags"] as? String {
            self.aliyunResourceTagsShrink = value
        }
        if let value = dict["DevEnvironmentEnabled"] as? Bool {
            self.devEnvironmentEnabled = value
        }
        if let value = dict["DevRoleDisabled"] as? Bool {
            self.devRoleDisabled = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
        if let value = dict["Names"] as? String {
            self.namesShrink = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PaiTaskEnabled"] as? Bool {
            self.paiTaskEnabled = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class ListProjectsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Projects : Tea.TeaModel {
            public class AliyunResourceTags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var aliyunResourceGroupId: String?

            public var aliyunResourceTags: [ListProjectsResponseBody.PagingInfo.Projects.AliyunResourceTags]?

            public var description_: String?

            public var devEnvironmentEnabled: Bool?

            public var devRoleDisabled: Bool?

            public var displayName: String?

            public var id: Int64?

            public var name: String?

            public var owner: String?

            public var paiTaskEnabled: Bool?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunResourceGroupId != nil {
                    map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
                }
                if self.aliyunResourceTags != nil {
                    var tmp : [Any] = []
                    for k in self.aliyunResourceTags! {
                        tmp.append(k.toMap())
                    }
                    map["AliyunResourceTags"] = tmp
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.devEnvironmentEnabled != nil {
                    map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
                }
                if self.devRoleDisabled != nil {
                    map["DevRoleDisabled"] = self.devRoleDisabled!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.paiTaskEnabled != nil {
                    map["PaiTaskEnabled"] = self.paiTaskEnabled!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AliyunResourceGroupId"] as? String {
                    self.aliyunResourceGroupId = value
                }
                if let value = dict["AliyunResourceTags"] as? [Any?] {
                    var tmp : [ListProjectsResponseBody.PagingInfo.Projects.AliyunResourceTags] = []
                    for v in value {
                        if v != nil {
                            var model = ListProjectsResponseBody.PagingInfo.Projects.AliyunResourceTags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.aliyunResourceTags = tmp
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DevEnvironmentEnabled"] as? Bool {
                    self.devEnvironmentEnabled = value
                }
                if let value = dict["DevRoleDisabled"] as? Bool {
                    self.devRoleDisabled = value
                }
                if let value = dict["DisplayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["PaiTaskEnabled"] as? Bool {
                    self.paiTaskEnabled = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var projects: [ListProjectsResponseBody.PagingInfo.Projects]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projects != nil {
                var tmp : [Any] = []
                for k in self.projects! {
                    tmp.append(k.toMap())
                }
                map["Projects"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Projects"] as? [Any?] {
                var tmp : [ListProjectsResponseBody.PagingInfo.Projects] = []
                for v in value {
                    if v != nil {
                        var model = ListProjectsResponseBody.PagingInfo.Projects()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.projects = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListProjectsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListProjectsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListResourceGroupsRequest : Tea.TeaModel {
    public class AliyunResourceTags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTags: [ListResourceGroupsRequest.AliyunResourceTags]?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var paymentType: String?

    public var projectId: Int64?

    public var resourceGroupTypes: [String]?

    public var sortBy: String?

    public var statuses: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTags != nil {
            var tmp : [Any] = []
            for k in self.aliyunResourceTags! {
                tmp.append(k.toMap())
            }
            map["AliyunResourceTags"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupTypes != nil {
            map["ResourceGroupTypes"] = self.resourceGroupTypes!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.statuses != nil {
            map["Statuses"] = self.statuses!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunResourceGroupId"] as? String {
            self.aliyunResourceGroupId = value
        }
        if let value = dict["AliyunResourceTags"] as? [Any?] {
            var tmp : [ListResourceGroupsRequest.AliyunResourceTags] = []
            for v in value {
                if v != nil {
                    var model = ListResourceGroupsRequest.AliyunResourceTags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.aliyunResourceTags = tmp
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PaymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceGroupTypes"] as? [String] {
            self.resourceGroupTypes = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Statuses"] as? [String] {
            self.statuses = value
        }
    }
}

public class ListResourceGroupsShrinkRequest : Tea.TeaModel {
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTagsShrink: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var paymentType: String?

    public var projectId: Int64?

    public var resourceGroupTypesShrink: String?

    public var sortBy: String?

    public var statusesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTagsShrink != nil {
            map["AliyunResourceTags"] = self.aliyunResourceTagsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupTypesShrink != nil {
            map["ResourceGroupTypes"] = self.resourceGroupTypesShrink!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.statusesShrink != nil {
            map["Statuses"] = self.statusesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunResourceGroupId"] as? String {
            self.aliyunResourceGroupId = value
        }
        if let value = dict["AliyunResourceTags"] as? String {
            self.aliyunResourceTagsShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PaymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceGroupTypes"] as? String {
            self.resourceGroupTypesShrink = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Statuses"] as? String {
            self.statusesShrink = value
        }
    }
}

public class ListResourceGroupsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class ResourceGroupList : Tea.TeaModel {
            public class AliyunResourceTags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Spec : Tea.TeaModel {
                public var amount: Int32?

                public var standard: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.amount != nil {
                        map["Amount"] = self.amount!
                    }
                    if self.standard != nil {
                        map["Standard"] = self.standard!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Amount"] as? Int32 {
                        self.amount = value
                    }
                    if let value = dict["Standard"] as? String {
                        self.standard = value
                    }
                }
            }
            public var aliyunResourceGroupId: String?

            public var aliyunResourceTags: [ListResourceGroupsResponseBody.PagingInfo.ResourceGroupList.AliyunResourceTags]?

            public var createTime: Int64?

            public var createUser: String?

            public var defaultVpcId: String?

            public var defaultVswicthId: String?

            public var id: String?

            public var name: String?

            public var orderInstanceId: String?

            public var paymentType: String?

            public var remark: String?

            public var resourceGroupType: String?

            public var spec: ListResourceGroupsResponseBody.PagingInfo.ResourceGroupList.Spec?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.spec?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunResourceGroupId != nil {
                    map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
                }
                if self.aliyunResourceTags != nil {
                    var tmp : [Any] = []
                    for k in self.aliyunResourceTags! {
                        tmp.append(k.toMap())
                    }
                    map["AliyunResourceTags"] = tmp
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.defaultVpcId != nil {
                    map["DefaultVpcId"] = self.defaultVpcId!
                }
                if self.defaultVswicthId != nil {
                    map["DefaultVswicthId"] = self.defaultVswicthId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.orderInstanceId != nil {
                    map["OrderInstanceId"] = self.orderInstanceId!
                }
                if self.paymentType != nil {
                    map["PaymentType"] = self.paymentType!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.resourceGroupType != nil {
                    map["ResourceGroupType"] = self.resourceGroupType!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AliyunResourceGroupId"] as? String {
                    self.aliyunResourceGroupId = value
                }
                if let value = dict["AliyunResourceTags"] as? [Any?] {
                    var tmp : [ListResourceGroupsResponseBody.PagingInfo.ResourceGroupList.AliyunResourceTags] = []
                    for v in value {
                        if v != nil {
                            var model = ListResourceGroupsResponseBody.PagingInfo.ResourceGroupList.AliyunResourceTags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.aliyunResourceTags = tmp
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["DefaultVpcId"] as? String {
                    self.defaultVpcId = value
                }
                if let value = dict["DefaultVswicthId"] as? String {
                    self.defaultVswicthId = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["OrderInstanceId"] as? String {
                    self.orderInstanceId = value
                }
                if let value = dict["PaymentType"] as? String {
                    self.paymentType = value
                }
                if let value = dict["Remark"] as? String {
                    self.remark = value
                }
                if let value = dict["ResourceGroupType"] as? String {
                    self.resourceGroupType = value
                }
                if let value = dict["Spec"] as? [String: Any?] {
                    var model = ListResourceGroupsResponseBody.PagingInfo.ResourceGroupList.Spec()
                    model.fromMap(value)
                    self.spec = model
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var resourceGroupList: [ListResourceGroupsResponseBody.PagingInfo.ResourceGroupList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.resourceGroupList != nil {
                var tmp : [Any] = []
                for k in self.resourceGroupList! {
                    tmp.append(k.toMap())
                }
                map["ResourceGroupList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["ResourceGroupList"] as? [Any?] {
                var tmp : [ListResourceGroupsResponseBody.PagingInfo.ResourceGroupList] = []
                for v in value {
                    if v != nil {
                        var model = ListResourceGroupsResponseBody.PagingInfo.ResourceGroupList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resourceGroupList = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListResourceGroupsResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListResourceGroupsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListResourceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListResourceGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListResourcesRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ListResourcesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Resources : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Command"] as? String {
                            self.command = value
                        }
                    }
                }
                public var id: Int64?

                public var path: String?

                public var runtime: ListResourcesResponseBody.PagingInfo.Resources.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Runtime"] as? [String: Any?] {
                        var model = ListResourcesResponseBody.PagingInfo.Resources.Script.Runtime()
                        model.fromMap(value)
                        self.runtime = model
                    }
                }
            }
            public var createTime: Int64?

            public var dataSource: ListResourcesResponseBody.PagingInfo.Resources.DataSource?

            public var id: Int64?

            public var modifyTime: Int64?

            public var name: String?

            public var owner: String?

            public var projectId: Int64?

            public var script: ListResourcesResponseBody.PagingInfo.Resources.Script?

            public var sourcePath: String?

            public var sourceType: String?

            public var targetPath: String?

            public var targetType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.script?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.sourcePath != nil {
                    map["SourcePath"] = self.sourcePath!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.targetPath != nil {
                    map["TargetPath"] = self.targetPath!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListResourcesResponseBody.PagingInfo.Resources.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Script"] as? [String: Any?] {
                    var model = ListResourcesResponseBody.PagingInfo.Resources.Script()
                    model.fromMap(value)
                    self.script = model
                }
                if let value = dict["SourcePath"] as? String {
                    self.sourcePath = value
                }
                if let value = dict["SourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["TargetPath"] as? String {
                    self.targetPath = value
                }
                if let value = dict["TargetType"] as? String {
                    self.targetType = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var resources: [ListResourcesResponseBody.PagingInfo.Resources]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.resources != nil {
                var tmp : [Any] = []
                for k in self.resources! {
                    tmp.append(k.toMap())
                }
                map["Resources"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Resources"] as? [Any?] {
                var tmp : [ListResourcesResponseBody.PagingInfo.Resources] = []
                for v in value {
                    if v != nil {
                        var model = ListResourcesResponseBody.PagingInfo.Resources()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resources = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListResourcesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListResourcesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRoutesRequest : Tea.TeaModel {
    public var networkId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupId: String?

    public var sortBy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkId"] as? Int64 {
            self.networkId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
    }
}

public class ListRoutesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class RouteList : Tea.TeaModel {
            public var createTime: Int64?

            public var destinationCidr: String?

            public var id: Int64?

            public var networkId: Int64?

            public var resourceGroupId: String?

            public var resourceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.destinationCidr != nil {
                    map["DestinationCidr"] = self.destinationCidr!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.networkId != nil {
                    map["NetworkId"] = self.networkId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DestinationCidr"] as? String {
                    self.destinationCidr = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["NetworkId"] as? Int64 {
                    self.networkId = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var routeList: [ListRoutesResponseBody.PagingInfo.RouteList]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.routeList != nil {
                var tmp : [Any] = []
                for k in self.routeList! {
                    tmp.append(k.toMap())
                }
                map["RouteList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["RouteList"] as? [Any?] {
                var tmp : [ListRoutesResponseBody.PagingInfo.RouteList] = []
                for v in value {
                    if v != nil {
                        var model = ListRoutesResponseBody.PagingInfo.RouteList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.routeList = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListRoutesResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListRoutesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListRoutesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRoutesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRoutesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSchemasRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentMetaEntityId: String?

    public var sortBy: String?

    public var types: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Types"] as? [String] {
            self.types = value
        }
    }
}

public class ListSchemasShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentMetaEntityId: String?

    public var sortBy: String?

    public var typesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.typesShrink != nil {
            map["Types"] = self.typesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Types"] as? String {
            self.typesShrink = value
        }
    }
}

public class ListSchemasResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var schemas: [Schema]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.schemas != nil {
                var tmp : [Any] = []
                for k in self.schemas! {
                    tmp.append(k.toMap())
                }
                map["Schemas"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Schemas"] as? [Any?] {
                var tmp : [Schema] = []
                for v in value {
                    if v != nil {
                        var model = Schema()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.schemas = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListSchemasResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListSchemasResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListSchemasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSchemasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSchemasResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTablesRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentMetaEntityId: String?

    public var sortBy: String?

    public var tableTypes: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.tableTypes != nil {
            map["TableTypes"] = self.tableTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TableTypes"] as? [String] {
            self.tableTypes = value
        }
    }
}

public class ListTablesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentMetaEntityId: String?

    public var sortBy: String?

    public var tableTypesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentMetaEntityId != nil {
            map["ParentMetaEntityId"] = self.parentMetaEntityId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.tableTypesShrink != nil {
            map["TableTypes"] = self.tableTypesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ParentMetaEntityId"] as? String {
            self.parentMetaEntityId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TableTypes"] as? String {
            self.tableTypesShrink = value
        }
    }
}

public class ListTablesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tables: [Table]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tables != nil {
                var tmp : [Any] = []
                for k in self.tables! {
                    tmp.append(k.toMap())
                }
                map["Tables"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Tables"] as? [Any?] {
                var tmp : [Table] = []
                for v in value {
                    if v != nil {
                        var model = Table()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tables = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListTablesResponseBody.PagingInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListTablesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTablesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTaskInstanceOperationLogsRequest : Tea.TeaModel {
    public var date: Int64?

    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["Date"] = self.date!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Date"] as? Int64 {
            self.date = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListTaskInstanceOperationLogsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class OperationLogs : Tea.TeaModel {
            public var createTime: Int64?

            public var operationContent: String?

            public var operationSeq: Int64?

            public var taskInstanceId: Int64?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.operationContent != nil {
                    map["OperationContent"] = self.operationContent!
                }
                if self.operationSeq != nil {
                    map["OperationSeq"] = self.operationSeq!
                }
                if self.taskInstanceId != nil {
                    map["TaskInstanceId"] = self.taskInstanceId!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["OperationContent"] as? String {
                    self.operationContent = value
                }
                if let value = dict["OperationSeq"] as? Int64 {
                    self.operationSeq = value
                }
                if let value = dict["TaskInstanceId"] as? Int64 {
                    self.taskInstanceId = value
                }
                if let value = dict["User"] as? String {
                    self.user = value
                }
            }
        }
        public var operationLogs: [ListTaskInstanceOperationLogsResponseBody.PagingInfo.OperationLogs]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationLogs != nil {
                var tmp : [Any] = []
                for k in self.operationLogs! {
                    tmp.append(k.toMap())
                }
                map["OperationLogs"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperationLogs"] as? [Any?] {
                var tmp : [ListTaskInstanceOperationLogsResponseBody.PagingInfo.OperationLogs] = []
                for v in value {
                    if v != nil {
                        var model = ListTaskInstanceOperationLogsResponseBody.PagingInfo.OperationLogs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operationLogs = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListTaskInstanceOperationLogsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListTaskInstanceOperationLogsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListTaskInstanceOperationLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskInstanceOperationLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTaskInstanceOperationLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTaskInstancesRequest : Tea.TeaModel {
    public var bizdate: Int64?

    public var id: Int64?

    public var ids: [Int64]?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public var projectId: Int64?

    public var runtimeResource: String?

    public var sortBy: String?

    public var taskId: Int64?

    public var taskIds: [Int64]?

    public var taskName: String?

    public var taskType: String?

    public var triggerRecurrence: String?

    public var triggerType: String?

    public var workflowId: Int64?

    public var workflowInstanceId: Int64?

    public var workflowInstanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.triggerRecurrence != nil {
            map["TriggerRecurrence"] = self.triggerRecurrence!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        if self.workflowInstanceType != nil {
            map["WorkflowInstanceType"] = self.workflowInstanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bizdate"] as? Int64 {
            self.bizdate = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeResource"] as? String {
            self.runtimeResource = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskIds"] as? [Int64] {
            self.taskIds = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
        if let value = dict["TriggerRecurrence"] as? String {
            self.triggerRecurrence = value
        }
        if let value = dict["TriggerType"] as? String {
            self.triggerType = value
        }
        if let value = dict["WorkflowId"] as? Int64 {
            self.workflowId = value
        }
        if let value = dict["WorkflowInstanceId"] as? Int64 {
            self.workflowInstanceId = value
        }
        if let value = dict["WorkflowInstanceType"] as? String {
            self.workflowInstanceType = value
        }
    }
}

public class ListTaskInstancesShrinkRequest : Tea.TeaModel {
    public var bizdate: Int64?

    public var id: Int64?

    public var idsShrink: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public var projectId: Int64?

    public var runtimeResource: String?

    public var sortBy: String?

    public var taskId: Int64?

    public var taskIdsShrink: String?

    public var taskName: String?

    public var taskType: String?

    public var triggerRecurrence: String?

    public var triggerType: String?

    public var workflowId: Int64?

    public var workflowInstanceId: Int64?

    public var workflowInstanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskIdsShrink != nil {
            map["TaskIds"] = self.taskIdsShrink!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.triggerRecurrence != nil {
            map["TriggerRecurrence"] = self.triggerRecurrence!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        if self.workflowInstanceType != nil {
            map["WorkflowInstanceType"] = self.workflowInstanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Bizdate"] as? Int64 {
            self.bizdate = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeResource"] as? String {
            self.runtimeResource = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskIds"] as? String {
            self.taskIdsShrink = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
        if let value = dict["TriggerRecurrence"] as? String {
            self.triggerRecurrence = value
        }
        if let value = dict["TriggerType"] as? String {
            self.triggerType = value
        }
        if let value = dict["WorkflowId"] as? Int64 {
            self.workflowId = value
        }
        if let value = dict["WorkflowInstanceId"] as? Int64 {
            self.workflowInstanceId = value
        }
        if let value = dict["WorkflowInstanceType"] as? String {
            self.workflowInstanceType = value
        }
    }
}

public class ListTaskInstancesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class TaskInstances : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class Runtime : Tea.TeaModel {
                public var gateway: String?

                public var processId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gateway != nil {
                        map["Gateway"] = self.gateway!
                    }
                    if self.processId != nil {
                        map["ProcessId"] = self.processId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Gateway"] as? String {
                        self.gateway = value
                    }
                    if let value = dict["ProcessId"] as? String {
                        self.processId = value
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cu"] as? String {
                        self.cu = value
                    }
                    if let value = dict["Image"] as? String {
                        self.image = value
                    }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public var baselineId: Int64?

            public var bizdate: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource?

            public var description_: String?

            public var finishedTime: Int64?

            public var id: Int64?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var owner: String?

            public var periodNumber: Int32?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunMode: String?

            public var runNumber: Int32?

            public var runtime: ListTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime?

            public var runtimeResource: ListTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource?

            public var startedTime: Int64?

            public var status: String?

            public var taskId: Int64?

            public var taskName: String?

            public var taskType: String?

            public var timeout: Int32?

            public var triggerRecurrence: String?

            public var triggerTime: Int64?

            public var triggerType: String?

            public var workflowId: Int64?

            public var workflowInstanceId: Int64?

            public var workflowInstanceType: String?

            public var workflowName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtime?.validate()
                try self.runtimeResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.periodNumber != nil {
                    map["PeriodNumber"] = self.periodNumber!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.runNumber != nil {
                    map["RunNumber"] = self.runNumber!
                }
                if self.runtime != nil {
                    map["Runtime"] = self.runtime?.toMap()
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.startedTime != nil {
                    map["StartedTime"] = self.startedTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.triggerRecurrence != nil {
                    map["TriggerRecurrence"] = self.triggerRecurrence!
                }
                if self.triggerTime != nil {
                    map["TriggerTime"] = self.triggerTime!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                if self.workflowInstanceId != nil {
                    map["WorkflowInstanceId"] = self.workflowInstanceId!
                }
                if self.workflowInstanceType != nil {
                    map["WorkflowInstanceType"] = self.workflowInstanceType!
                }
                if self.workflowName != nil {
                    map["WorkflowName"] = self.workflowName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["Bizdate"] as? Int64 {
                    self.bizdate = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["FinishedTime"] as? Int64 {
                    self.finishedTime = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["PeriodNumber"] as? Int32 {
                    self.periodNumber = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectEnv"] as? String {
                    self.projectEnv = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RerunMode"] as? String {
                    self.rerunMode = value
                }
                if let value = dict["RunNumber"] as? Int32 {
                    self.runNumber = value
                }
                if let value = dict["Runtime"] as? [String: Any?] {
                    var model = ListTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime()
                    model.fromMap(value)
                    self.runtime = model
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = ListTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["StartedTime"] as? Int64 {
                    self.startedTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TaskId"] as? Int64 {
                    self.taskId = value
                }
                if let value = dict["TaskName"] as? String {
                    self.taskName = value
                }
                if let value = dict["TaskType"] as? String {
                    self.taskType = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["TriggerRecurrence"] as? String {
                    self.triggerRecurrence = value
                }
                if let value = dict["TriggerTime"] as? Int64 {
                    self.triggerTime = value
                }
                if let value = dict["TriggerType"] as? String {
                    self.triggerType = value
                }
                if let value = dict["WorkflowId"] as? Int64 {
                    self.workflowId = value
                }
                if let value = dict["WorkflowInstanceId"] as? Int64 {
                    self.workflowInstanceId = value
                }
                if let value = dict["WorkflowInstanceType"] as? String {
                    self.workflowInstanceType = value
                }
                if let value = dict["WorkflowName"] as? String {
                    self.workflowName = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var taskInstances: [ListTaskInstancesResponseBody.PagingInfo.TaskInstances]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.taskInstances != nil {
                var tmp : [Any] = []
                for k in self.taskInstances! {
                    tmp.append(k.toMap())
                }
                map["TaskInstances"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TaskInstances"] as? [Any?] {
                var tmp : [ListTaskInstancesResponseBody.PagingInfo.TaskInstances] = []
                for v in value {
                    if v != nil {
                        var model = ListTaskInstancesResponseBody.PagingInfo.TaskInstances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.taskInstances = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListTaskInstancesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListTaskInstancesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTaskOperationLogsRequest : Tea.TeaModel {
    public var date: Int64?

    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["Date"] = self.date!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Date"] as? Int64 {
            self.date = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class ListTaskOperationLogsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class OperationLogs : Tea.TeaModel {
            public var createTime: Int64?

            public var operationContent: String?

            public var operationSeq: Int64?

            public var taskId: Int64?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.operationContent != nil {
                    map["OperationContent"] = self.operationContent!
                }
                if self.operationSeq != nil {
                    map["OperationSeq"] = self.operationSeq!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["OperationContent"] as? String {
                    self.operationContent = value
                }
                if let value = dict["OperationSeq"] as? Int64 {
                    self.operationSeq = value
                }
                if let value = dict["TaskId"] as? Int64 {
                    self.taskId = value
                }
                if let value = dict["User"] as? String {
                    self.user = value
                }
            }
        }
        public var operationLogs: [ListTaskOperationLogsResponseBody.PagingInfo.OperationLogs]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationLogs != nil {
                var tmp : [Any] = []
                for k in self.operationLogs! {
                    tmp.append(k.toMap())
                }
                map["OperationLogs"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperationLogs"] as? [Any?] {
                var tmp : [ListTaskOperationLogsResponseBody.PagingInfo.OperationLogs] = []
                for v in value {
                    if v != nil {
                        var model = ListTaskOperationLogsResponseBody.PagingInfo.OperationLogs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operationLogs = tmp
            }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListTaskOperationLogsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListTaskOperationLogsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListTaskOperationLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskOperationLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTaskOperationLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTasksRequest : Tea.TeaModel {
    public var ids: [Int64]?

    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public var projectId: Int64?

    public var runtimeResource: String?

    public var sortBy: String?

    public var taskType: String?

    public var triggerRecurrence: String?

    public var triggerType: String?

    public var workflowId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.triggerRecurrence != nil {
            map["TriggerRecurrence"] = self.triggerRecurrence!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeResource"] as? String {
            self.runtimeResource = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
        if let value = dict["TriggerRecurrence"] as? String {
            self.triggerRecurrence = value
        }
        if let value = dict["TriggerType"] as? String {
            self.triggerType = value
        }
        if let value = dict["WorkflowId"] as? Int64 {
            self.workflowId = value
        }
    }
}

public class ListTasksShrinkRequest : Tea.TeaModel {
    public var idsShrink: String?

    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public var projectId: Int64?

    public var runtimeResource: String?

    public var sortBy: String?

    public var taskType: String?

    public var triggerRecurrence: String?

    public var triggerType: String?

    public var workflowId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.triggerRecurrence != nil {
            map["TriggerRecurrence"] = self.triggerRecurrence!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeResource"] as? String {
            self.runtimeResource = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TaskType"] as? String {
            self.taskType = value
        }
        if let value = dict["TriggerRecurrence"] as? String {
            self.triggerRecurrence = value
        }
        if let value = dict["TriggerType"] as? String {
            self.triggerType = value
        }
        if let value = dict["WorkflowId"] as? Int64 {
            self.workflowId = value
        }
    }
}

public class ListTasksResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Tasks : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cu"] as? String {
                        self.cu = value
                    }
                    if let value = dict["Image"] as? String {
                        self.image = value
                    }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var recurrence: String?

                public var startTime: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.recurrence != nil {
                        map["Recurrence"] = self.recurrence!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cron"] as? String {
                        self.cron = value
                    }
                    if let value = dict["EndTime"] as? String {
                        self.endTime = value
                    }
                    if let value = dict["Recurrence"] as? String {
                        self.recurrence = value
                    }
                    if let value = dict["StartTime"] as? String {
                        self.startTime = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var baselineId: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListTasksResponseBody.PagingInfo.Tasks.DataSource?

            public var description_: String?

            public var id: Int64?

            public var instanceMode: String?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var name: String?

            public var owner: String?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunInterval: Int32?

            public var rerunMode: String?

            public var rerunTimes: Int32?

            public var runtimeResource: ListTasksResponseBody.PagingInfo.Tasks.RuntimeResource?

            public var scriptParameters: String?

            public var timeout: Int32?

            public var trigger: ListTasksResponseBody.PagingInfo.Tasks.Trigger?

            public var type: String?

            public var workflowId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtimeResource?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceMode != nil {
                    map["InstanceMode"] = self.instanceMode!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunInterval != nil {
                    map["RerunInterval"] = self.rerunInterval!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.rerunTimes != nil {
                    map["RerunTimes"] = self.rerunTimes!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.scriptParameters != nil {
                    map["ScriptParameters"] = self.scriptParameters!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListTasksResponseBody.PagingInfo.Tasks.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["InstanceMode"] as? String {
                    self.instanceMode = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectEnv"] as? String {
                    self.projectEnv = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RerunInterval"] as? Int32 {
                    self.rerunInterval = value
                }
                if let value = dict["RerunMode"] as? String {
                    self.rerunMode = value
                }
                if let value = dict["RerunTimes"] as? Int32 {
                    self.rerunTimes = value
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = ListTasksResponseBody.PagingInfo.Tasks.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["ScriptParameters"] as? String {
                    self.scriptParameters = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["Trigger"] as? [String: Any?] {
                    var model = ListTasksResponseBody.PagingInfo.Tasks.Trigger()
                    model.fromMap(value)
                    self.trigger = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["WorkflowId"] as? Int64 {
                    self.workflowId = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tasks: [ListTasksResponseBody.PagingInfo.Tasks]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tasks != nil {
                var tmp : [Any] = []
                for k in self.tasks! {
                    tmp.append(k.toMap())
                }
                map["Tasks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Tasks"] as? [Any?] {
                var tmp : [ListTasksResponseBody.PagingInfo.Tasks] = []
                for v in value {
                    if v != nil {
                        var model = ListTasksResponseBody.PagingInfo.Tasks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tasks = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var pagingInfo: ListTasksResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListTasksResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUpstreamTaskInstancesRequest : Tea.TeaModel {
    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListUpstreamTaskInstancesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class TaskInstances : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class Runtime : Tea.TeaModel {
                public var gateway: String?

                public var processId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gateway != nil {
                        map["Gateway"] = self.gateway!
                    }
                    if self.processId != nil {
                        map["ProcessId"] = self.processId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Gateway"] as? String {
                        self.gateway = value
                    }
                    if let value = dict["ProcessId"] as? String {
                        self.processId = value
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cu"] as? String {
                        self.cu = value
                    }
                    if let value = dict["Image"] as? String {
                        self.image = value
                    }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public var baselineId: Int64?

            public var bizdate: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource?

            public var description_: String?

            public var envType: String?

            public var finishedTime: Int64?

            public var id: Int64?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var owner: String?

            public var periodNumber: Int32?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunMode: String?

            public var runNumber: Int32?

            public var runtime: ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime?

            public var runtimeResource: ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource?

            public var startedTime: Int64?

            public var status: String?

            public var stepType: String?

            public var taskId: Int64?

            public var taskName: String?

            public var taskType: String?

            public var timeout: Int32?

            public var triggerRecurrence: String?

            public var triggerTime: Int64?

            public var triggerType: String?

            public var workflowId: Int64?

            public var workflowInstanceId: Int64?

            public var workflowInstanceType: String?

            public var workflowName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtime?.validate()
                try self.runtimeResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.periodNumber != nil {
                    map["PeriodNumber"] = self.periodNumber!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.runNumber != nil {
                    map["RunNumber"] = self.runNumber!
                }
                if self.runtime != nil {
                    map["Runtime"] = self.runtime?.toMap()
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.startedTime != nil {
                    map["StartedTime"] = self.startedTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.triggerRecurrence != nil {
                    map["TriggerRecurrence"] = self.triggerRecurrence!
                }
                if self.triggerTime != nil {
                    map["TriggerTime"] = self.triggerTime!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                if self.workflowInstanceId != nil {
                    map["WorkflowInstanceId"] = self.workflowInstanceId!
                }
                if self.workflowInstanceType != nil {
                    map["WorkflowInstanceType"] = self.workflowInstanceType!
                }
                if self.workflowName != nil {
                    map["WorkflowName"] = self.workflowName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["Bizdate"] as? Int64 {
                    self.bizdate = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["FinishedTime"] as? Int64 {
                    self.finishedTime = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["PeriodNumber"] as? Int32 {
                    self.periodNumber = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectEnv"] as? String {
                    self.projectEnv = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RerunMode"] as? String {
                    self.rerunMode = value
                }
                if let value = dict["RunNumber"] as? Int32 {
                    self.runNumber = value
                }
                if let value = dict["Runtime"] as? [String: Any?] {
                    var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime()
                    model.fromMap(value)
                    self.runtime = model
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["StartedTime"] as? Int64 {
                    self.startedTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StepType"] as? String {
                    self.stepType = value
                }
                if let value = dict["TaskId"] as? Int64 {
                    self.taskId = value
                }
                if let value = dict["TaskName"] as? String {
                    self.taskName = value
                }
                if let value = dict["TaskType"] as? String {
                    self.taskType = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["TriggerRecurrence"] as? String {
                    self.triggerRecurrence = value
                }
                if let value = dict["TriggerTime"] as? Int64 {
                    self.triggerTime = value
                }
                if let value = dict["TriggerType"] as? String {
                    self.triggerType = value
                }
                if let value = dict["WorkflowId"] as? Int64 {
                    self.workflowId = value
                }
                if let value = dict["WorkflowInstanceId"] as? Int64 {
                    self.workflowInstanceId = value
                }
                if let value = dict["WorkflowInstanceType"] as? String {
                    self.workflowInstanceType = value
                }
                if let value = dict["WorkflowName"] as? String {
                    self.workflowName = value
                }
            }
        }
        public class UpstreamTaskInstances : Tea.TeaModel {
            public class TaskInstance : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                    }
                }
                public class Runtime : Tea.TeaModel {
                    public var gateway: String?

                    public var processId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gateway != nil {
                            map["Gateway"] = self.gateway!
                        }
                        if self.processId != nil {
                            map["ProcessId"] = self.processId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Gateway"] as? String {
                            self.gateway = value
                        }
                        if let value = dict["ProcessId"] as? String {
                            self.processId = value
                        }
                    }
                }
                public class RuntimeResource : Tea.TeaModel {
                    public var cu: String?

                    public var image: String?

                    public var resourceGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cu != nil {
                            map["Cu"] = self.cu!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.resourceGroupId != nil {
                            map["ResourceGroupId"] = self.resourceGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Cu"] as? String {
                            self.cu = value
                        }
                        if let value = dict["Image"] as? String {
                            self.image = value
                        }
                        if let value = dict["ResourceGroupId"] as? String {
                            self.resourceGroupId = value
                        }
                    }
                }
                public var baselineId: Int64?

                public var bizdate: Int64?

                public var createTime: Int64?

                public var createUser: String?

                public var dataSource: ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances.TaskInstance.DataSource?

                public var description_: String?

                public var envType: String?

                public var finishedTime: Int64?

                public var id: Int64?

                public var modifyTime: Int64?

                public var modifyUser: String?

                public var owner: String?

                public var periodNumber: Int32?

                public var priority: Int32?

                public var projectId: Int64?

                public var rerunMode: String?

                public var runNumber: Int32?

                public var runtime: ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances.TaskInstance.Runtime?

                public var runtimeResource: ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances.TaskInstance.RuntimeResource?

                public var startedTime: Int64?

                public var status: String?

                public var taskId: Int64?

                public var taskName: String?

                public var taskType: String?

                public var timeout: Int32?

                public var triggerRecurrence: String?

                public var triggerTime: Int64?

                public var triggerType: String?

                public var workflowId: Int64?

                public var workflowInstanceId: Int64?

                public var workflowInstanceType: String?

                public var workflowName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.dataSource?.validate()
                    try self.runtime?.validate()
                    try self.runtimeResource?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.baselineId != nil {
                        map["BaselineId"] = self.baselineId!
                    }
                    if self.bizdate != nil {
                        map["Bizdate"] = self.bizdate!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.createUser != nil {
                        map["CreateUser"] = self.createUser!
                    }
                    if self.dataSource != nil {
                        map["DataSource"] = self.dataSource?.toMap()
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.finishedTime != nil {
                        map["FinishedTime"] = self.finishedTime!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.modifyUser != nil {
                        map["ModifyUser"] = self.modifyUser!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.periodNumber != nil {
                        map["PeriodNumber"] = self.periodNumber!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.runNumber != nil {
                        map["RunNumber"] = self.runNumber!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    if self.runtimeResource != nil {
                        map["RuntimeResource"] = self.runtimeResource?.toMap()
                    }
                    if self.startedTime != nil {
                        map["StartedTime"] = self.startedTime!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.taskName != nil {
                        map["TaskName"] = self.taskName!
                    }
                    if self.taskType != nil {
                        map["TaskType"] = self.taskType!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.triggerRecurrence != nil {
                        map["TriggerRecurrence"] = self.triggerRecurrence!
                    }
                    if self.triggerTime != nil {
                        map["TriggerTime"] = self.triggerTime!
                    }
                    if self.triggerType != nil {
                        map["TriggerType"] = self.triggerType!
                    }
                    if self.workflowId != nil {
                        map["WorkflowId"] = self.workflowId!
                    }
                    if self.workflowInstanceId != nil {
                        map["WorkflowInstanceId"] = self.workflowInstanceId!
                    }
                    if self.workflowInstanceType != nil {
                        map["WorkflowInstanceType"] = self.workflowInstanceType!
                    }
                    if self.workflowName != nil {
                        map["WorkflowName"] = self.workflowName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BaselineId"] as? Int64 {
                        self.baselineId = value
                    }
                    if let value = dict["Bizdate"] as? Int64 {
                        self.bizdate = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["CreateUser"] as? String {
                        self.createUser = value
                    }
                    if let value = dict["DataSource"] as? [String: Any?] {
                        var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances.TaskInstance.DataSource()
                        model.fromMap(value)
                        self.dataSource = model
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["EnvType"] as? String {
                        self.envType = value
                    }
                    if let value = dict["FinishedTime"] as? Int64 {
                        self.finishedTime = value
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["ModifyTime"] as? Int64 {
                        self.modifyTime = value
                    }
                    if let value = dict["ModifyUser"] as? String {
                        self.modifyUser = value
                    }
                    if let value = dict["Owner"] as? String {
                        self.owner = value
                    }
                    if let value = dict["PeriodNumber"] as? Int32 {
                        self.periodNumber = value
                    }
                    if let value = dict["Priority"] as? Int32 {
                        self.priority = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["RerunMode"] as? String {
                        self.rerunMode = value
                    }
                    if let value = dict["RunNumber"] as? Int32 {
                        self.runNumber = value
                    }
                    if let value = dict["Runtime"] as? [String: Any?] {
                        var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances.TaskInstance.Runtime()
                        model.fromMap(value)
                        self.runtime = model
                    }
                    if let value = dict["RuntimeResource"] as? [String: Any?] {
                        var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances.TaskInstance.RuntimeResource()
                        model.fromMap(value)
                        self.runtimeResource = model
                    }
                    if let value = dict["StartedTime"] as? Int64 {
                        self.startedTime = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["TaskId"] as? Int64 {
                        self.taskId = value
                    }
                    if let value = dict["TaskName"] as? String {
                        self.taskName = value
                    }
                    if let value = dict["TaskType"] as? String {
                        self.taskType = value
                    }
                    if let value = dict["Timeout"] as? Int32 {
                        self.timeout = value
                    }
                    if let value = dict["TriggerRecurrence"] as? String {
                        self.triggerRecurrence = value
                    }
                    if let value = dict["TriggerTime"] as? Int64 {
                        self.triggerTime = value
                    }
                    if let value = dict["TriggerType"] as? String {
                        self.triggerType = value
                    }
                    if let value = dict["WorkflowId"] as? Int64 {
                        self.workflowId = value
                    }
                    if let value = dict["WorkflowInstanceId"] as? Int64 {
                        self.workflowInstanceId = value
                    }
                    if let value = dict["WorkflowInstanceType"] as? String {
                        self.workflowInstanceType = value
                    }
                    if let value = dict["WorkflowName"] as? String {
                        self.workflowName = value
                    }
                }
            }
            public var dependencyType: String?

            public var taskInstance: ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances.TaskInstance?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.taskInstance?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dependencyType != nil {
                    map["DependencyType"] = self.dependencyType!
                }
                if self.taskInstance != nil {
                    map["TaskInstance"] = self.taskInstance?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DependencyType"] as? String {
                    self.dependencyType = value
                }
                if let value = dict["TaskInstance"] as? [String: Any?] {
                    var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances.TaskInstance()
                    model.fromMap(value)
                    self.taskInstance = model
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var taskInstances: [ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances]?

        public var totalCount: Int32?

        public var upstreamTaskInstances: [ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.taskInstances != nil {
                var tmp : [Any] = []
                for k in self.taskInstances! {
                    tmp.append(k.toMap())
                }
                map["TaskInstances"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.upstreamTaskInstances != nil {
                var tmp : [Any] = []
                for k in self.upstreamTaskInstances! {
                    tmp.append(k.toMap())
                }
                map["UpstreamTaskInstances"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TaskInstances"] as? [Any?] {
                var tmp : [ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances] = []
                for v in value {
                    if v != nil {
                        var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.taskInstances = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
            if let value = dict["UpstreamTaskInstances"] as? [Any?] {
                var tmp : [ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances] = []
                for v in value {
                    if v != nil {
                        var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.UpstreamTaskInstances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.upstreamTaskInstances = tmp
            }
        }
    }
    public var pagingInfo: ListUpstreamTaskInstancesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListUpstreamTaskInstancesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListUpstreamTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUpstreamTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUpstreamTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUpstreamTasksRequest : Tea.TeaModel {
    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectEnv"] as? String {
            self.projectEnv = value
        }
    }
}

public class ListUpstreamTasksResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Tasks : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cu"] as? String {
                        self.cu = value
                    }
                    if let value = dict["Image"] as? String {
                        self.image = value
                    }
                    if let value = dict["ResourceGroupId"] as? String {
                        self.resourceGroupId = value
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var recurrence: String?

                public var startTime: String?

                public var timezone: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.recurrence != nil {
                        map["Recurrence"] = self.recurrence!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cron"] as? String {
                        self.cron = value
                    }
                    if let value = dict["EndTime"] as? String {
                        self.endTime = value
                    }
                    if let value = dict["Recurrence"] as? String {
                        self.recurrence = value
                    }
                    if let value = dict["StartTime"] as? String {
                        self.startTime = value
                    }
                    if let value = dict["Timezone"] as? String {
                        self.timezone = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var baselineId: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListUpstreamTasksResponseBody.PagingInfo.Tasks.DataSource?

            public var description_: String?

            public var envType: String?

            public var id: Int64?

            public var instanceMode: String?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var name: String?

            public var owner: String?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunInterval: Int32?

            public var rerunMode: String?

            public var rerunTimes: Int32?

            public var runtimeResource: ListUpstreamTasksResponseBody.PagingInfo.Tasks.RuntimeResource?

            public var stepType: String?

            public var timeout: Int32?

            public var trigger: ListUpstreamTasksResponseBody.PagingInfo.Tasks.Trigger?

            public var type: String?

            public var workflowId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtimeResource?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceMode != nil {
                    map["InstanceMode"] = self.instanceMode!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunInterval != nil {
                    map["RerunInterval"] = self.rerunInterval!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.rerunTimes != nil {
                    map["RerunTimes"] = self.rerunTimes!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BaselineId"] as? Int64 {
                    self.baselineId = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["DataSource"] as? [String: Any?] {
                    var model = ListUpstreamTasksResponseBody.PagingInfo.Tasks.DataSource()
                    model.fromMap(value)
                    self.dataSource = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["InstanceMode"] as? String {
                    self.instanceMode = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Priority"] as? Int32 {
                    self.priority = value
                }
                if let value = dict["ProjectEnv"] as? String {
                    self.projectEnv = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["RerunInterval"] as? Int32 {
                    self.rerunInterval = value
                }
                if let value = dict["RerunMode"] as? String {
                    self.rerunMode = value
                }
                if let value = dict["RerunTimes"] as? Int32 {
                    self.rerunTimes = value
                }
                if let value = dict["RuntimeResource"] as? [String: Any?] {
                    var model = ListUpstreamTasksResponseBody.PagingInfo.Tasks.RuntimeResource()
                    model.fromMap(value)
                    self.runtimeResource = model
                }
                if let value = dict["StepType"] as? String {
                    self.stepType = value
                }
                if let value = dict["Timeout"] as? Int32 {
                    self.timeout = value
                }
                if let value = dict["Trigger"] as? [String: Any?] {
                    var model = ListUpstreamTasksResponseBody.PagingInfo.Tasks.Trigger()
                    model.fromMap(value)
                    self.trigger = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["WorkflowId"] as? Int64 {
                    self.workflowId = value
                }
            }
        }
        public class UpstreamTasks : Tea.TeaModel {
            public class Task : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                    }
                }
                public class RuntimeResource : Tea.TeaModel {
                    public var cu: String?

                    public var image: String?

                    public var resourceGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cu != nil {
                            map["Cu"] = self.cu!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.resourceGroupId != nil {
                            map["ResourceGroupId"] = self.resourceGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Cu"] as? String {
                            self.cu = value
                        }
                        if let value = dict["Image"] as? String {
                            self.image = value
                        }
                        if let value = dict["ResourceGroupId"] as? String {
                            self.resourceGroupId = value
                        }
                    }
                }
                public class Trigger : Tea.TeaModel {
                    public var cron: String?

                    public var endTime: String?

                    public var recurrence: String?

                    public var startTime: String?

                    public var timezone: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cron != nil {
                            map["Cron"] = self.cron!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.recurrence != nil {
                            map["Recurrence"] = self.recurrence!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.timezone != nil {
                            map["Timezone"] = self.timezone!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Cron"] as? String {
                            self.cron = value
                        }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["Recurrence"] as? String {
                            self.recurrence = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                        if let value = dict["Timezone"] as? String {
                            self.timezone = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var baselineId: Int64?

                public var createTime: Int64?

                public var createUser: String?

                public var dataSource: ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks.Task.DataSource?

                public var description_: String?

                public var envType: String?

                public var id: Int64?

                public var instanceMode: String?

                public var modifyTime: Int64?

                public var modifyUser: String?

                public var name: String?

                public var owner: String?

                public var priority: Int32?

                public var projectId: Int64?

                public var rerunInterval: Int32?

                public var rerunMode: String?

                public var rerunTimes: Int32?

                public var runtimeResource: ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks.Task.RuntimeResource?

                public var timeout: Int32?

                public var trigger: ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks.Task.Trigger?

                public var type: String?

                public var workflowId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.dataSource?.validate()
                    try self.runtimeResource?.validate()
                    try self.trigger?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.baselineId != nil {
                        map["BaselineId"] = self.baselineId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.createUser != nil {
                        map["CreateUser"] = self.createUser!
                    }
                    if self.dataSource != nil {
                        map["DataSource"] = self.dataSource?.toMap()
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.envType != nil {
                        map["EnvType"] = self.envType!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.instanceMode != nil {
                        map["InstanceMode"] = self.instanceMode!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.modifyUser != nil {
                        map["ModifyUser"] = self.modifyUser!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.rerunInterval != nil {
                        map["RerunInterval"] = self.rerunInterval!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.rerunTimes != nil {
                        map["RerunTimes"] = self.rerunTimes!
                    }
                    if self.runtimeResource != nil {
                        map["RuntimeResource"] = self.runtimeResource?.toMap()
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.trigger != nil {
                        map["Trigger"] = self.trigger?.toMap()
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.workflowId != nil {
                        map["WorkflowId"] = self.workflowId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BaselineId"] as? Int64 {
                        self.baselineId = value
                    }
                    if let value = dict["CreateTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["CreateUser"] as? String {
                        self.createUser = value
                    }
                    if let value = dict["DataSource"] as? [String: Any?] {
                        var model = ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks.Task.DataSource()
                        model.fromMap(value)
                        self.dataSource = model
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["EnvType"] as? String {
                        self.envType = value
                    }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["InstanceMode"] as? String {
                        self.instanceMode = value
                    }
                    if let value = dict["ModifyTime"] as? Int64 {
                        self.modifyTime = value
                    }
                    if let value = dict["ModifyUser"] as? String {
                        self.modifyUser = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Owner"] as? String {
                        self.owner = value
                    }
                    if let value = dict["Priority"] as? Int32 {
                        self.priority = value
                    }
                    if let value = dict["ProjectId"] as? Int64 {
                        self.projectId = value
                    }
                    if let value = dict["RerunInterval"] as? Int32 {
                        self.rerunInterval = value
                    }
                    if let value = dict["RerunMode"] as? String {
                        self.rerunMode = value
                    }
                    if let value = dict["RerunTimes"] as? Int32 {
                        self.rerunTimes = value
                    }
                    if let value = dict["RuntimeResource"] as? [String: Any?] {
                        var model = ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks.Task.RuntimeResource()
                        model.fromMap(value)
                        self.runtimeResource = model
                    }
                    if let value = dict["Timeout"] as? Int32 {
                        self.timeout = value
                    }
                    if let value = dict["Trigger"] as? [String: Any?] {
                        var model = ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks.Task.Trigger()
                        model.fromMap(value)
                        self.trigger = model
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["WorkflowId"] as? Int64 {
                        self.workflowId = value
                    }
                }
            }
            public var dependencyType: String?

            public var task: ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks.Task?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.task?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dependencyType != nil {
                    map["DependencyType"] = self.dependencyType!
                }
                if self.task != nil {
                    map["Task"] = self.task?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DependencyType"] as? String {
                    self.dependencyType = value
                }
                if let value = dict["Task"] as? [String: Any?] {
                    var model = ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks.Task()
                    model.fromMap(value)
                    self.task = model
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tasks: [ListUpstreamTasksResponseBody.PagingInfo.Tasks]?

        public var totalCount: Int32?

        public var upstreamTasks: [ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tasks != nil {
                var tmp : [Any] = []
                for k in self.tasks! {
                    tmp.append(k.toMap())
                }
                map["Tasks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.upstreamTasks != nil {
                var tmp : [Any] = []
                for k in self.upstreamTasks! {
                    tmp.append(k.toMap())
                }
                map["UpstreamTasks"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Tasks"] as? [Any?] {
                var tmp : [ListUpstreamTasksResponseBody.PagingInfo.Tasks] = []
                for v in value {
                    if v != nil {
                        var model = ListUpstreamTasksResponseBody.PagingInfo.Tasks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tasks = tmp
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
            if let value = dict["UpstreamTasks"] as? [Any?] {
                var tmp : [ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks] = []
                for v in value {
                    if v != nil {
                        var model = ListUpstreamTasksResponseBody.PagingInfo.UpstreamTasks()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.upstreamTasks = tmp
            }
        }
    }
    public var pagingInfo: ListUpstreamTasksResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListUpstreamTasksResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListUpstreamTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUpstreamTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUpstreamTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWorkflowDefinitionsRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ListWorkflowDefinitionsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class WorkflowDefinitions : Tea.TeaModel {
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Command"] as? String {
                            self.command = value
                        }
                    }
                }
                public var id: Int64?

                public var path: String?

                public var runtime: ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Runtime"] as? [String: Any?] {
                        var model = ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions.Script.Runtime()
                        model.fromMap(value)
                        self.runtime = model
                    }
                }
            }
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var modifyTime: Int64?

            public var name: String?

            public var owner: String?

            public var projectId: Int64?

            public var script: ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions.Script?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.script?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Script"] as? [String: Any?] {
                    var model = ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions.Script()
                    model.fromMap(value)
                    self.script = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public var workflowDefinitions: [ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.workflowDefinitions != nil {
                var tmp : [Any] = []
                for k in self.workflowDefinitions! {
                    tmp.append(k.toMap())
                }
                map["WorkflowDefinitions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
            if let value = dict["WorkflowDefinitions"] as? [Any?] {
                var tmp : [ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions] = []
                for v in value {
                    if v != nil {
                        var model = ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.workflowDefinitions = tmp
            }
        }
    }
    public var pagingInfo: ListWorkflowDefinitionsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListWorkflowDefinitionsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListWorkflowDefinitionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkflowDefinitionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWorkflowDefinitionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWorkflowInstancesRequest : Tea.TeaModel {
    public var bizDate: Int64?

    public var ids: [Int64]?

    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sortBy: String?

    public var type: String?

    public var workflowId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizDate"] as? Int64 {
            self.bizDate = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["WorkflowId"] as? Int64 {
            self.workflowId = value
        }
    }
}

public class ListWorkflowInstancesShrinkRequest : Tea.TeaModel {
    public var bizDate: Int64?

    public var idsShrink: String?

    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sortBy: String?

    public var type: String?

    public var workflowId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizDate != nil {
            map["BizDate"] = self.bizDate!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BizDate"] as? Int64 {
            self.bizDate = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["WorkflowId"] as? Int64 {
            self.workflowId = value
        }
    }
}

public class ListWorkflowInstancesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class WorkflowInstances : Tea.TeaModel {
            public var bizDate: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var envType: String?

            public var finishedTime: Int64?

            public var id: Int64?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var name: String?

            public var projectId: Int64?

            public var startedTime: Int64?

            public var status: String?

            public var type: String?

            public var workflowId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizDate != nil {
                    map["BizDate"] = self.bizDate!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.startedTime != nil {
                    map["StartedTime"] = self.startedTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BizDate"] as? Int64 {
                    self.bizDate = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["FinishedTime"] as? Int64 {
                    self.finishedTime = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["StartedTime"] as? Int64 {
                    self.startedTime = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["WorkflowId"] as? Int64 {
                    self.workflowId = value
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public var workflowInstances: [ListWorkflowInstancesResponseBody.PagingInfo.WorkflowInstances]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.workflowInstances != nil {
                var tmp : [Any] = []
                for k in self.workflowInstances! {
                    tmp.append(k.toMap())
                }
                map["WorkflowInstances"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
            if let value = dict["WorkflowInstances"] as? [Any?] {
                var tmp : [ListWorkflowInstancesResponseBody.PagingInfo.WorkflowInstances] = []
                for v in value {
                    if v != nil {
                        var model = ListWorkflowInstancesResponseBody.PagingInfo.WorkflowInstances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.workflowInstances = tmp
            }
        }
    }
    public var pagingInfo: ListWorkflowInstancesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListWorkflowInstancesResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListWorkflowInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkflowInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWorkflowInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWorkflowsRequest : Tea.TeaModel {
    public var envType: String?

    public var ids: [Int64]?

    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sortBy: String?

    public var triggerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TriggerType"] as? String {
            self.triggerType = value
        }
    }
}

public class ListWorkflowsShrinkRequest : Tea.TeaModel {
    public var envType: String?

    public var idsShrink: String?

    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sortBy: String?

    public var triggerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["TriggerType"] as? String {
            self.triggerType = value
        }
    }
}

public class ListWorkflowsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Workflows : Tea.TeaModel {
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var recurrence: String?

                public var startTime: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.recurrence != nil {
                        map["Recurrence"] = self.recurrence!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Cron"] as? String {
                        self.cron = value
                    }
                    if let value = dict["EndTime"] as? String {
                        self.endTime = value
                    }
                    if let value = dict["Recurrence"] as? String {
                        self.recurrence = value
                    }
                    if let value = dict["StartTime"] as? String {
                        self.startTime = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var clientUniqueCode: String?

            public var createTime: Int64?

            public var createUser: String?

            public var description_: String?

            public var envType: String?

            public var id: Int64?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var name: String?

            public var owner: String?

            public var parameters: String?

            public var projectId: Int64?

            public var trigger: ListWorkflowsResponseBody.PagingInfo.Workflows.Trigger?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clientUniqueCode != nil {
                    map["ClientUniqueCode"] = self.clientUniqueCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envType != nil {
                    map["EnvType"] = self.envType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClientUniqueCode"] as? String {
                    self.clientUniqueCode = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreateUser"] as? String {
                    self.createUser = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["EnvType"] as? String {
                    self.envType = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["ModifyTime"] as? Int64 {
                    self.modifyTime = value
                }
                if let value = dict["ModifyUser"] as? String {
                    self.modifyUser = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Owner"] as? String {
                    self.owner = value
                }
                if let value = dict["Parameters"] as? String {
                    self.parameters = value
                }
                if let value = dict["ProjectId"] as? Int64 {
                    self.projectId = value
                }
                if let value = dict["Trigger"] as? [String: Any?] {
                    var model = ListWorkflowsResponseBody.PagingInfo.Workflows.Trigger()
                    model.fromMap(value)
                    self.trigger = model
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public var workflows: [ListWorkflowsResponseBody.PagingInfo.Workflows]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.workflows != nil {
                var tmp : [Any] = []
                for k in self.workflows! {
                    tmp.append(k.toMap())
                }
                map["Workflows"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int32 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
            if let value = dict["Workflows"] as? [Any?] {
                var tmp : [ListWorkflowsResponseBody.PagingInfo.Workflows] = []
                for v in value {
                    if v != nil {
                        var model = ListWorkflowsResponseBody.PagingInfo.Workflows()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.workflows = tmp
            }
        }
    }
    public var pagingInfo: ListWorkflowsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PagingInfo"] as? [String: Any?] {
            var model = ListWorkflowsResponseBody.PagingInfo()
            model.fromMap(value)
            self.pagingInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListWorkflowsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkflowsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWorkflowsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MoveFunctionRequest : Tea.TeaModel {
    public var id: Int64?

    public var path: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Path"] as? String {
            self.path = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class MoveFunctionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class MoveFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MoveFunctionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MoveNodeRequest : Tea.TeaModel {
    public var id: Int64?

    public var path: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Path"] as? String {
            self.path = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class MoveNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class MoveNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MoveNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MoveResourceRequest : Tea.TeaModel {
    public var id: Int64?

    public var path: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Path"] as? String {
            self.path = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class MoveResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class MoveResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MoveResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MoveWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: Int64?

    public var path: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Path"] as? String {
            self.path = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class MoveWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class MoveWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MoveWorkflowDefinitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveEntityFromMetaCollectionRequest : Tea.TeaModel {
    public var id: String?

    public var metaCollectionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.metaCollectionId != nil {
            map["MetaCollectionId"] = self.metaCollectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["MetaCollectionId"] as? String {
            self.metaCollectionId = value
        }
    }
}

public class RemoveEntityFromMetaCollectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveEntityFromMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveEntityFromMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveEntityFromMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveTaskInstanceDependenciesRequest : Tea.TeaModel {
    public var comment: String?

    public var id: Int64?

    public var upstreamTaskInstanceIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.upstreamTaskInstanceIds != nil {
            map["UpstreamTaskInstanceIds"] = self.upstreamTaskInstanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["UpstreamTaskInstanceIds"] as? [Int64] {
            self.upstreamTaskInstanceIds = value
        }
    }
}

public class RemoveTaskInstanceDependenciesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var id: Int64?

    public var upstreamTaskInstanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.upstreamTaskInstanceIdsShrink != nil {
            map["UpstreamTaskInstanceIds"] = self.upstreamTaskInstanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["UpstreamTaskInstanceIds"] as? String {
            self.upstreamTaskInstanceIdsShrink = value
        }
    }
}

public class RemoveTaskInstanceDependenciesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RemoveTaskInstanceDependenciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTaskInstanceDependenciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveTaskInstanceDependenciesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenameFunctionRequest : Tea.TeaModel {
    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class RenameFunctionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class RenameFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenameFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenameFunctionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenameNodeRequest : Tea.TeaModel {
    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class RenameNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RenameNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenameNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenameNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenameResourceRequest : Tea.TeaModel {
    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class RenameResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RenameResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenameResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenameResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenameWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class RenameWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RenameWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenameWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenameWorkflowDefinitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RerunTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
    }
}

public class RerunTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class RerunTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessInfo"] as? [String: Any?] {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class RerunTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RerunTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RerunTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResumeTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
    }
}

public class ResumeTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class ResumeTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessInfo"] as? [String: Any?] {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class ResumeTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResumeTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeMemberProjectRolesRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodes: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodes != nil {
            map["RoleCodes"] = self.roleCodes!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCodes"] as? [String] {
            self.roleCodes = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class RevokeMemberProjectRolesShrinkRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodesShrink: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodesShrink != nil {
            map["RoleCodes"] = self.roleCodesShrink!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RoleCodes"] as? String {
            self.roleCodesShrink = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class RevokeMemberProjectRolesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeMemberProjectRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeMemberProjectRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeMemberProjectRolesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetSuccessTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
    }
}

public class SetSuccessTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class SetSuccessTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessInfo"] as? [String: Any?] {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class SetSuccessTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetSuccessTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetSuccessTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartDIJobRequest : Tea.TeaModel {
    public class RealtimeStartSettings : Tea.TeaModel {
        public class FailoverSettings : Tea.TeaModel {
            public var interval: Int64?

            public var upperLimit: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.upperLimit != nil {
                    map["UpperLimit"] = self.upperLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Interval"] as? Int64 {
                    self.interval = value
                }
                if let value = dict["UpperLimit"] as? Int64 {
                    self.upperLimit = value
                }
            }
        }
        public var failoverSettings: StartDIJobRequest.RealtimeStartSettings.FailoverSettings?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.failoverSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failoverSettings != nil {
                map["FailoverSettings"] = self.failoverSettings?.toMap()
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FailoverSettings"] as? [String: Any?] {
                var model = StartDIJobRequest.RealtimeStartSettings.FailoverSettings()
                model.fromMap(value)
                self.failoverSettings = model
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
        }
    }
    public var DIJobId: Int64?

    public var forceToRerun: Bool?

    public var id: Int64?

    public var realtimeStartSettings: StartDIJobRequest.RealtimeStartSettings?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realtimeStartSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.forceToRerun != nil {
            map["ForceToRerun"] = self.forceToRerun!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.realtimeStartSettings != nil {
            map["RealtimeStartSettings"] = self.realtimeStartSettings?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["ForceToRerun"] as? Bool {
            self.forceToRerun = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RealtimeStartSettings"] as? [String: Any?] {
            var model = StartDIJobRequest.RealtimeStartSettings()
            model.fromMap(value)
            self.realtimeStartSettings = model
        }
    }
}

public class StartDIJobShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var forceToRerun: Bool?

    public var id: Int64?

    public var realtimeStartSettingsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.forceToRerun != nil {
            map["ForceToRerun"] = self.forceToRerun!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.realtimeStartSettingsShrink != nil {
            map["RealtimeStartSettings"] = self.realtimeStartSettingsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["ForceToRerun"] as? Bool {
            self.forceToRerun = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["RealtimeStartSettings"] as? String {
            self.realtimeStartSettingsShrink = value
        }
    }
}

public class StartDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class StartDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartWorkflowInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
    }
}

public class StartWorkflowInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class StartWorkflowInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessInfo"] as? [String: Any?] {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class StartWorkflowInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartWorkflowInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartWorkflowInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var id: Int64?

    public var instanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["InstanceId"] as? Int64 {
            self.instanceId = value
        }
    }
}

public class StopDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class StopDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
    }
}

public class StopTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class StopTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessInfo"] as? [String: Any?] {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class StopTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopWorkflowInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
    }
}

public class StopWorkflowInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class StopWorkflowInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessInfo"] as? [String: Any?] {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class StopWorkflowInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopWorkflowInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopWorkflowInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SuspendTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? [Int64] {
            self.ids = value
        }
    }
}

public class SuspendTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Ids"] as? String {
            self.idsShrink = value
        }
    }
}

public class SuspendTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessInfo"] as? [String: Any?] {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class SuspendTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SuspendTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagDataAssetsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var autoTraceEnabled: Bool?

    public var dataAssetIds: [String]?

    public var dataAssetType: String?

    public var envType: String?

    public var projectId: Int64?

    public var tags: [TagDataAssetsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoTraceEnabled != nil {
            map["AutoTraceEnabled"] = self.autoTraceEnabled!
        }
        if self.dataAssetIds != nil {
            map["DataAssetIds"] = self.dataAssetIds!
        }
        if self.dataAssetType != nil {
            map["DataAssetType"] = self.dataAssetType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoTraceEnabled"] as? Bool {
            self.autoTraceEnabled = value
        }
        if let value = dict["DataAssetIds"] as? [String] {
            self.dataAssetIds = value
        }
        if let value = dict["DataAssetType"] as? String {
            self.dataAssetType = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [TagDataAssetsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = TagDataAssetsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class TagDataAssetsShrinkRequest : Tea.TeaModel {
    public var autoTraceEnabled: Bool?

    public var dataAssetIdsShrink: String?

    public var dataAssetType: String?

    public var envType: String?

    public var projectId: Int64?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoTraceEnabled != nil {
            map["AutoTraceEnabled"] = self.autoTraceEnabled!
        }
        if self.dataAssetIdsShrink != nil {
            map["DataAssetIds"] = self.dataAssetIdsShrink!
        }
        if self.dataAssetType != nil {
            map["DataAssetType"] = self.dataAssetType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoTraceEnabled"] as? Bool {
            self.autoTraceEnabled = value
        }
        if let value = dict["DataAssetIds"] as? String {
            self.dataAssetIdsShrink = value
        }
        if let value = dict["DataAssetType"] as? String {
            self.dataAssetType = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
    }
}

public class TagDataAssetsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class TagDataAssetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagDataAssetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagDataAssetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TestDataSourceConnectivityRequest : Tea.TeaModel {
    public var dataSourceId: Int64?

    public var projectId: Int64?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class TestDataSourceConnectivityResponseBody : Tea.TeaModel {
    public class Connectivity : Tea.TeaModel {
        public class DetailLogs : Tea.TeaModel {
            public var code: String?

            public var endTime: Int64?

            public var message: String?

            public var startTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["EndTime"] as? Int64 {
                    self.endTime = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["StartTime"] as? Int64 {
                    self.startTime = value
                }
            }
        }
        public var connectMessage: String?

        public var connectState: String?

        public var detailLogs: [TestDataSourceConnectivityResponseBody.Connectivity.DetailLogs]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectMessage != nil {
                map["ConnectMessage"] = self.connectMessage!
            }
            if self.connectState != nil {
                map["ConnectState"] = self.connectState!
            }
            if self.detailLogs != nil {
                var tmp : [Any] = []
                for k in self.detailLogs! {
                    tmp.append(k.toMap())
                }
                map["DetailLogs"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnectMessage"] as? String {
                self.connectMessage = value
            }
            if let value = dict["ConnectState"] as? String {
                self.connectState = value
            }
            if let value = dict["DetailLogs"] as? [Any?] {
                var tmp : [TestDataSourceConnectivityResponseBody.Connectivity.DetailLogs] = []
                for v in value {
                    if v != nil {
                        var model = TestDataSourceConnectivityResponseBody.Connectivity.DetailLogs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.detailLogs = tmp
            }
        }
    }
    public var connectivity: TestDataSourceConnectivityResponseBody.Connectivity?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.connectivity?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectivity != nil {
            map["Connectivity"] = self.connectivity?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Connectivity"] as? [String: Any?] {
            var model = TestDataSourceConnectivityResponseBody.Connectivity()
            model.fromMap(value)
            self.connectivity = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TestDataSourceConnectivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TestDataSourceConnectivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TestDataSourceConnectivityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TriggerSchedulerTaskInstanceRequest : Tea.TeaModel {
    public var envType: String?

    public var taskId: Int64?

    public var triggerTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.triggerTime != nil {
            map["TriggerTime"] = self.triggerTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TriggerTime"] as? Int64 {
            self.triggerTime = value
        }
    }
}

public class TriggerSchedulerTaskInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class TriggerSchedulerTaskInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TriggerSchedulerTaskInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TriggerSchedulerTaskInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnTagDataAssetsRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var dataAssetIds: [String]?

    public var dataAssetType: String?

    public var envType: String?

    public var projectId: Int64?

    public var tags: [UnTagDataAssetsRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataAssetIds != nil {
            map["DataAssetIds"] = self.dataAssetIds!
        }
        if self.dataAssetType != nil {
            map["DataAssetType"] = self.dataAssetType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataAssetIds"] as? [String] {
            self.dataAssetIds = value
        }
        if let value = dict["DataAssetType"] as? String {
            self.dataAssetType = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [UnTagDataAssetsRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = UnTagDataAssetsRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class UnTagDataAssetsShrinkRequest : Tea.TeaModel {
    public var dataAssetIdsShrink: String?

    public var dataAssetType: String?

    public var envType: String?

    public var projectId: Int64?

    public var tagsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataAssetIdsShrink != nil {
            map["DataAssetIds"] = self.dataAssetIdsShrink!
        }
        if self.dataAssetType != nil {
            map["DataAssetType"] = self.dataAssetType!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataAssetIds"] as? String {
            self.dataAssetIdsShrink = value
        }
        if let value = dict["DataAssetType"] as? String {
            self.dataAssetType = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
    }
}

public class UnTagDataAssetsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class UnTagDataAssetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnTagDataAssetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnTagDataAssetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAlertRuleRequest : Tea.TeaModel {
    public class Notification : Tea.TeaModel {
        public class Receivers : Tea.TeaModel {
            public var extension_: String?

            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Extension"] as? String {
                    self.extension_ = value
                }
                if let value = dict["ReceiverType"] as? String {
                    self.receiverType = value
                }
                if let value = dict["ReceiverValues"] as? [String] {
                    self.receiverValues = value
                }
            }
        }
        public var channels: [String]?

        public var intervalInMinutes: Int32?

        public var maximum: Int32?

        public var receivers: [UpdateAlertRuleRequest.Notification.Receivers]?

        public var silenceEndTime: String?

        public var silenceStartTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channels != nil {
                map["Channels"] = self.channels!
            }
            if self.intervalInMinutes != nil {
                map["IntervalInMinutes"] = self.intervalInMinutes!
            }
            if self.maximum != nil {
                map["Maximum"] = self.maximum!
            }
            if self.receivers != nil {
                var tmp : [Any] = []
                for k in self.receivers! {
                    tmp.append(k.toMap())
                }
                map["Receivers"] = tmp
            }
            if self.silenceEndTime != nil {
                map["SilenceEndTime"] = self.silenceEndTime!
            }
            if self.silenceStartTime != nil {
                map["SilenceStartTime"] = self.silenceStartTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Channels"] as? [String] {
                self.channels = value
            }
            if let value = dict["IntervalInMinutes"] as? Int32 {
                self.intervalInMinutes = value
            }
            if let value = dict["Maximum"] as? Int32 {
                self.maximum = value
            }
            if let value = dict["Receivers"] as? [Any?] {
                var tmp : [UpdateAlertRuleRequest.Notification.Receivers] = []
                for v in value {
                    if v != nil {
                        var model = UpdateAlertRuleRequest.Notification.Receivers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.receivers = tmp
            }
            if let value = dict["SilenceEndTime"] as? String {
                self.silenceEndTime = value
            }
            if let value = dict["SilenceStartTime"] as? String {
                self.silenceStartTime = value
            }
        }
    }
    public class TriggerCondition : Tea.TeaModel {
        public class Extension_ : Tea.TeaModel {
            public class CycleUnfinished : Tea.TeaModel {
                public class CycleAndTime : Tea.TeaModel {
                    public var cycleId: Int32?

                    public var time: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleId != nil {
                            map["CycleId"] = self.cycleId!
                        }
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CycleId"] as? Int32 {
                            self.cycleId = value
                        }
                        if let value = dict["Time"] as? String {
                            self.time = value
                        }
                    }
                }
                public var cycleAndTime: [UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleAndTime != nil {
                        var tmp : [Any] = []
                        for k in self.cycleAndTime! {
                            tmp.append(k.toMap())
                        }
                        map["CycleAndTime"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CycleAndTime"] as? [Any?] {
                        var tmp : [UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime] = []
                        for v in value {
                            if v != nil {
                                var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.cycleAndTime = tmp
                    }
                }
            }
            public class Error : Tea.TeaModel {
                public var autoRerunAlertEnabled: Bool?

                public var streamTaskIds: [Int64]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoRerunAlertEnabled != nil {
                        map["AutoRerunAlertEnabled"] = self.autoRerunAlertEnabled!
                    }
                    if self.streamTaskIds != nil {
                        map["StreamTaskIds"] = self.streamTaskIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AutoRerunAlertEnabled"] as? Bool {
                        self.autoRerunAlertEnabled = value
                    }
                    if let value = dict["StreamTaskIds"] as? [Int64] {
                        self.streamTaskIds = value
                    }
                }
            }
            public class InstanceErrorCount : Tea.TeaModel {
                public var count: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Count"] as? Int32 {
                        self.count = value
                    }
                }
            }
            public class InstanceErrorPercentage : Tea.TeaModel {
                public var percentage: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Percentage"] as? Int32 {
                        self.percentage = value
                    }
                }
            }
            public class InstanceTransferFluctuate : Tea.TeaModel {
                public var percentage: Int32?

                public var trend: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    if self.trend != nil {
                        map["Trend"] = self.trend!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Percentage"] as? Int32 {
                        self.percentage = value
                    }
                    if let value = dict["Trend"] as? String {
                        self.trend = value
                    }
                }
            }
            public class Timeout : Tea.TeaModel {
                public var timeoutInMinutes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.timeoutInMinutes != nil {
                        map["TimeoutInMinutes"] = self.timeoutInMinutes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["TimeoutInMinutes"] as? Int32 {
                        self.timeoutInMinutes = value
                    }
                }
            }
            public class UnFinished : Tea.TeaModel {
                public var unFinishedTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.unFinishedTime != nil {
                        map["UnFinishedTime"] = self.unFinishedTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["UnFinishedTime"] as? String {
                        self.unFinishedTime = value
                    }
                }
            }
            public var cycleUnfinished: UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished?

            public var error: UpdateAlertRuleRequest.TriggerCondition.Extension_.Error?

            public var instanceErrorCount: UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorCount?

            public var instanceErrorPercentage: UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorPercentage?

            public var instanceTransferFluctuate: UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceTransferFluctuate?

            public var timeout: UpdateAlertRuleRequest.TriggerCondition.Extension_.Timeout?

            public var unFinished: UpdateAlertRuleRequest.TriggerCondition.Extension_.UnFinished?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cycleUnfinished?.validate()
                try self.error?.validate()
                try self.instanceErrorCount?.validate()
                try self.instanceErrorPercentage?.validate()
                try self.instanceTransferFluctuate?.validate()
                try self.timeout?.validate()
                try self.unFinished?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleUnfinished != nil {
                    map["CycleUnfinished"] = self.cycleUnfinished?.toMap()
                }
                if self.error != nil {
                    map["Error"] = self.error?.toMap()
                }
                if self.instanceErrorCount != nil {
                    map["InstanceErrorCount"] = self.instanceErrorCount?.toMap()
                }
                if self.instanceErrorPercentage != nil {
                    map["InstanceErrorPercentage"] = self.instanceErrorPercentage?.toMap()
                }
                if self.instanceTransferFluctuate != nil {
                    map["InstanceTransferFluctuate"] = self.instanceTransferFluctuate?.toMap()
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout?.toMap()
                }
                if self.unFinished != nil {
                    map["UnFinished"] = self.unFinished?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CycleUnfinished"] as? [String: Any?] {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished()
                    model.fromMap(value)
                    self.cycleUnfinished = model
                }
                if let value = dict["Error"] as? [String: Any?] {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.Error()
                    model.fromMap(value)
                    self.error = model
                }
                if let value = dict["InstanceErrorCount"] as? [String: Any?] {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorCount()
                    model.fromMap(value)
                    self.instanceErrorCount = model
                }
                if let value = dict["InstanceErrorPercentage"] as? [String: Any?] {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorPercentage()
                    model.fromMap(value)
                    self.instanceErrorPercentage = model
                }
                if let value = dict["InstanceTransferFluctuate"] as? [String: Any?] {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceTransferFluctuate()
                    model.fromMap(value)
                    self.instanceTransferFluctuate = model
                }
                if let value = dict["Timeout"] as? [String: Any?] {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.Timeout()
                    model.fromMap(value)
                    self.timeout = model
                }
                if let value = dict["UnFinished"] as? [String: Any?] {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.UnFinished()
                    model.fromMap(value)
                    self.unFinished = model
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var allowTasks: [Int64]?

            public var ids: [Int64]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowTasks != nil {
                    map["AllowTasks"] = self.allowTasks!
                }
                if self.ids != nil {
                    map["Ids"] = self.ids!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllowTasks"] as? [Int64] {
                    self.allowTasks = value
                }
                if let value = dict["Ids"] as? [Int64] {
                    self.ids = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var extension_: UpdateAlertRuleRequest.TriggerCondition.Extension_?

        public var target: UpdateAlertRuleRequest.TriggerCondition.Target?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extension_?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_?.toMap()
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extension"] as? [String: Any?] {
                var model = UpdateAlertRuleRequest.TriggerCondition.Extension_()
                model.fromMap(value)
                self.extension_ = model
            }
            if let value = dict["Target"] as? [String: Any?] {
                var model = UpdateAlertRuleRequest.TriggerCondition.Target()
                model.fromMap(value)
                self.target = model
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var enabled: Bool?

    public var id: Int64?

    public var name: String?

    public var notification: UpdateAlertRuleRequest.Notification?

    public var owner: String?

    public var triggerCondition: UpdateAlertRuleRequest.TriggerCondition?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notification?.validate()
        try self.triggerCondition?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notification != nil {
            map["Notification"] = self.notification?.toMap()
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.triggerCondition != nil {
            map["TriggerCondition"] = self.triggerCondition?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Notification"] as? [String: Any?] {
            var model = UpdateAlertRuleRequest.Notification()
            model.fromMap(value)
            self.notification = model
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["TriggerCondition"] as? [String: Any?] {
            var model = UpdateAlertRuleRequest.TriggerCondition()
            model.fromMap(value)
            self.triggerCondition = model
        }
    }
}

public class UpdateAlertRuleShrinkRequest : Tea.TeaModel {
    public var enabled: Bool?

    public var id: Int64?

    public var name: String?

    public var notificationShrink: String?

    public var owner: String?

    public var triggerConditionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationShrink != nil {
            map["Notification"] = self.notificationShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.triggerConditionShrink != nil {
            map["TriggerCondition"] = self.triggerConditionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Notification"] as? String {
            self.notificationShrink = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["TriggerCondition"] as? String {
            self.triggerConditionShrink = value
        }
    }
}

public class UpdateAlertRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAlertRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateColumnBusinessMetadataRequest : Tea.TeaModel {
    public var description_: String?

    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
    }
}

public class UpdateColumnBusinessMetadataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateColumnBusinessMetadataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateColumnBusinessMetadataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateColumnBusinessMetadataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDIAlarmRuleRequest : Tea.TeaModel {
    public class NotificationSettings : Tea.TeaModel {
        public class NotificationChannels : Tea.TeaModel {
            public var channels: [String]?

            public var severity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Channels"] as? [String] {
                    self.channels = value
                }
                if let value = dict["Severity"] as? String {
                    self.severity = value
                }
            }
        }
        public class NotificationReceivers : Tea.TeaModel {
            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReceiverType"] as? String {
                    self.receiverType = value
                }
                if let value = dict["ReceiverValues"] as? [String] {
                    self.receiverValues = value
                }
            }
        }
        public var inhibitionInterval: Int64?

        public var muteInterval: Int64?

        public var notificationChannels: [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels]?

        public var notificationReceivers: [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inhibitionInterval != nil {
                map["InhibitionInterval"] = self.inhibitionInterval!
            }
            if self.muteInterval != nil {
                map["MuteInterval"] = self.muteInterval!
            }
            if self.notificationChannels != nil {
                var tmp : [Any] = []
                for k in self.notificationChannels! {
                    tmp.append(k.toMap())
                }
                map["NotificationChannels"] = tmp
            }
            if self.notificationReceivers != nil {
                var tmp : [Any] = []
                for k in self.notificationReceivers! {
                    tmp.append(k.toMap())
                }
                map["NotificationReceivers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InhibitionInterval"] as? Int64 {
                self.inhibitionInterval = value
            }
            if let value = dict["MuteInterval"] as? Int64 {
                self.muteInterval = value
            }
            if let value = dict["NotificationChannels"] as? [Any?] {
                var tmp : [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notificationChannels = tmp
            }
            if let value = dict["NotificationReceivers"] as? [Any?] {
                var tmp : [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notificationReceivers = tmp
            }
        }
    }
    public class TriggerConditions : Tea.TeaModel {
        public var ddlReportTags: [String]?

        public var ddlTypes: [String]?

        public var duration: Int64?

        public var severity: String?

        public var threshold: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ddlReportTags != nil {
                map["DdlReportTags"] = self.ddlReportTags!
            }
            if self.ddlTypes != nil {
                map["DdlTypes"] = self.ddlTypes!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DdlReportTags"] as? [String] {
                self.ddlReportTags = value
            }
            if let value = dict["DdlTypes"] as? [String] {
                self.ddlTypes = value
            }
            if let value = dict["Duration"] as? Int64 {
                self.duration = value
            }
            if let value = dict["Severity"] as? String {
                self.severity = value
            }
            if let value = dict["Threshold"] as? Int64 {
                self.threshold = value
            }
        }
    }
    public var DIAlarmRuleId: Int64?

    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var id: Int64?

    public var metricType: String?

    public var name: String?

    public var notificationSettings: UpdateDIAlarmRuleRequest.NotificationSettings?

    public var triggerConditions: [UpdateDIAlarmRuleRequest.TriggerConditions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationSettings != nil {
            map["NotificationSettings"] = self.notificationSettings?.toMap()
        }
        if self.triggerConditions != nil {
            var tmp : [Any] = []
            for k in self.triggerConditions! {
                tmp.append(k.toMap())
            }
            map["TriggerConditions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? Int64 {
            self.DIAlarmRuleId = value
        }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NotificationSettings"] as? [String: Any?] {
            var model = UpdateDIAlarmRuleRequest.NotificationSettings()
            model.fromMap(value)
            self.notificationSettings = model
        }
        if let value = dict["TriggerConditions"] as? [Any?] {
            var tmp : [UpdateDIAlarmRuleRequest.TriggerConditions] = []
            for v in value {
                if v != nil {
                    var model = UpdateDIAlarmRuleRequest.TriggerConditions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.triggerConditions = tmp
        }
    }
}

public class UpdateDIAlarmRuleShrinkRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var id: Int64?

    public var metricType: String?

    public var name: String?

    public var notificationSettingsShrink: String?

    public var triggerConditionsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationSettingsShrink != nil {
            map["NotificationSettings"] = self.notificationSettingsShrink!
        }
        if self.triggerConditionsShrink != nil {
            map["TriggerConditions"] = self.triggerConditionsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIAlarmRuleId"] as? Int64 {
            self.DIAlarmRuleId = value
        }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NotificationSettings"] as? String {
            self.notificationSettingsShrink = value
        }
        if let value = dict["TriggerConditions"] as? String {
            self.triggerConditionsShrink = value
        }
    }
}

public class UpdateDIAlarmRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDIAlarmRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDIJobRequest : Tea.TeaModel {
    public class JobSettings : Tea.TeaModel {
        public class ColumnDataTypeSettings : Tea.TeaModel {
            public var destinationDataType: String?

            public var sourceDataType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDataType != nil {
                    map["DestinationDataType"] = self.destinationDataType!
                }
                if self.sourceDataType != nil {
                    map["SourceDataType"] = self.sourceDataType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DestinationDataType"] as? String {
                    self.destinationDataType = value
                }
                if let value = dict["SourceDataType"] as? String {
                    self.sourceDataType = value
                }
            }
        }
        public class CycleScheduleSettings : Tea.TeaModel {
            public var scheduleParameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scheduleParameters != nil {
                    map["ScheduleParameters"] = self.scheduleParameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ScheduleParameters"] as? String {
                    self.scheduleParameters = value
                }
            }
        }
        public class DdlHandlingSettings : Tea.TeaModel {
            public var action: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class RuntimeSettings : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var channelSettings: String?

        public var columnDataTypeSettings: [UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings]?

        public var cycleScheduleSettings: UpdateDIJobRequest.JobSettings.CycleScheduleSettings?

        public var ddlHandlingSettings: [UpdateDIJobRequest.JobSettings.DdlHandlingSettings]?

        public var runtimeSettings: [UpdateDIJobRequest.JobSettings.RuntimeSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cycleScheduleSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelSettings != nil {
                map["ChannelSettings"] = self.channelSettings!
            }
            if self.columnDataTypeSettings != nil {
                var tmp : [Any] = []
                for k in self.columnDataTypeSettings! {
                    tmp.append(k.toMap())
                }
                map["ColumnDataTypeSettings"] = tmp
            }
            if self.cycleScheduleSettings != nil {
                map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
            }
            if self.ddlHandlingSettings != nil {
                var tmp : [Any] = []
                for k in self.ddlHandlingSettings! {
                    tmp.append(k.toMap())
                }
                map["DdlHandlingSettings"] = tmp
            }
            if self.runtimeSettings != nil {
                var tmp : [Any] = []
                for k in self.runtimeSettings! {
                    tmp.append(k.toMap())
                }
                map["RuntimeSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChannelSettings"] as? String {
                self.channelSettings = value
            }
            if let value = dict["ColumnDataTypeSettings"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.columnDataTypeSettings = tmp
            }
            if let value = dict["CycleScheduleSettings"] as? [String: Any?] {
                var model = UpdateDIJobRequest.JobSettings.CycleScheduleSettings()
                model.fromMap(value)
                self.cycleScheduleSettings = model
            }
            if let value = dict["DdlHandlingSettings"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.JobSettings.DdlHandlingSettings] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.JobSettings.DdlHandlingSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ddlHandlingSettings = tmp
            }
            if let value = dict["RuntimeSettings"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.JobSettings.RuntimeSettings] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.JobSettings.RuntimeSettings()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.runtimeSettings = tmp
            }
        }
    }
    public class ResourceSettings : Tea.TeaModel {
        public class OfflineResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RequestedCu"] as? Double {
                    self.requestedCu = value
                }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public class RealtimeResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RequestedCu"] as? Double {
                    self.requestedCu = value
                }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public class ScheduleResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RequestedCu"] as? Double {
                    self.requestedCu = value
                }
                if let value = dict["ResourceGroupIdentifier"] as? String {
                    self.resourceGroupIdentifier = value
                }
            }
        }
        public var offlineResourceSettings: UpdateDIJobRequest.ResourceSettings.OfflineResourceSettings?

        public var realtimeResourceSettings: UpdateDIJobRequest.ResourceSettings.RealtimeResourceSettings?

        public var scheduleResourceSettings: UpdateDIJobRequest.ResourceSettings.ScheduleResourceSettings?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.offlineResourceSettings?.validate()
            try self.realtimeResourceSettings?.validate()
            try self.scheduleResourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.offlineResourceSettings != nil {
                map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
            }
            if self.realtimeResourceSettings != nil {
                map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
            }
            if self.scheduleResourceSettings != nil {
                map["ScheduleResourceSettings"] = self.scheduleResourceSettings?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OfflineResourceSettings"] as? [String: Any?] {
                var model = UpdateDIJobRequest.ResourceSettings.OfflineResourceSettings()
                model.fromMap(value)
                self.offlineResourceSettings = model
            }
            if let value = dict["RealtimeResourceSettings"] as? [String: Any?] {
                var model = UpdateDIJobRequest.ResourceSettings.RealtimeResourceSettings()
                model.fromMap(value)
                self.realtimeResourceSettings = model
            }
            if let value = dict["ScheduleResourceSettings"] as? [String: Any?] {
                var model = UpdateDIJobRequest.ResourceSettings.ScheduleResourceSettings()
                model.fromMap(value)
                self.scheduleResourceSettings = model
            }
        }
    }
    public class TableMappings : Tea.TeaModel {
        public class SourceObjectSelectionRules : Tea.TeaModel {
            public var action: String?

            public var expression: String?

            public var expressionType: String?

            public var objectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.expressionType != nil {
                    map["ExpressionType"] = self.expressionType!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["Expression"] as? String {
                    self.expression = value
                }
                if let value = dict["ExpressionType"] as? String {
                    self.expressionType = value
                }
                if let value = dict["ObjectType"] as? String {
                    self.objectType = value
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RuleActionType"] as? String {
                    self.ruleActionType = value
                }
                if let value = dict["RuleName"] as? String {
                    self.ruleName = value
                }
                if let value = dict["RuleTargetType"] as? String {
                    self.ruleTargetType = value
                }
            }
        }
        public var sourceObjectSelectionRules: [UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules]?

        public var transformationRules: [UpdateDIJobRequest.TableMappings.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceObjectSelectionRules != nil {
                var tmp : [Any] = []
                for k in self.sourceObjectSelectionRules! {
                    tmp.append(k.toMap())
                }
                map["SourceObjectSelectionRules"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SourceObjectSelectionRules"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sourceObjectSelectionRules = tmp
            }
            if let value = dict["TransformationRules"] as? [Any?] {
                var tmp : [UpdateDIJobRequest.TableMappings.TransformationRules] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDIJobRequest.TableMappings.TransformationRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.transformationRules = tmp
            }
        }
    }
    public class TransformationRules : Tea.TeaModel {
        public var ruleActionType: String?

        public var ruleExpression: String?

        public var ruleName: String?

        public var ruleTargetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleActionType != nil {
                map["RuleActionType"] = self.ruleActionType!
            }
            if self.ruleExpression != nil {
                map["RuleExpression"] = self.ruleExpression!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleTargetType != nil {
                map["RuleTargetType"] = self.ruleTargetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RuleActionType"] as? String {
                self.ruleActionType = value
            }
            if let value = dict["RuleExpression"] as? String {
                self.ruleExpression = value
            }
            if let value = dict["RuleName"] as? String {
                self.ruleName = value
            }
            if let value = dict["RuleTargetType"] as? String {
                self.ruleTargetType = value
            }
        }
    }
    public var DIJobId: Int64?

    public var description_: String?

    public var id: Int64?

    public var jobSettings: UpdateDIJobRequest.JobSettings?

    public var projectId: Int64?

    public var resourceSettings: UpdateDIJobRequest.ResourceSettings?

    public var tableMappings: [UpdateDIJobRequest.TableMappings]?

    public var transformationRules: [UpdateDIJobRequest.TransformationRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobSettings?.validate()
        try self.resourceSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.jobSettings != nil {
            map["JobSettings"] = self.jobSettings?.toMap()
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettings != nil {
            map["ResourceSettings"] = self.resourceSettings?.toMap()
        }
        if self.tableMappings != nil {
            var tmp : [Any] = []
            for k in self.tableMappings! {
                tmp.append(k.toMap())
            }
            map["TableMappings"] = tmp
        }
        if self.transformationRules != nil {
            var tmp : [Any] = []
            for k in self.transformationRules! {
                tmp.append(k.toMap())
            }
            map["TransformationRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["JobSettings"] as? [String: Any?] {
            var model = UpdateDIJobRequest.JobSettings()
            model.fromMap(value)
            self.jobSettings = model
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceSettings"] as? [String: Any?] {
            var model = UpdateDIJobRequest.ResourceSettings()
            model.fromMap(value)
            self.resourceSettings = model
        }
        if let value = dict["TableMappings"] as? [Any?] {
            var tmp : [UpdateDIJobRequest.TableMappings] = []
            for v in value {
                if v != nil {
                    var model = UpdateDIJobRequest.TableMappings()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tableMappings = tmp
        }
        if let value = dict["TransformationRules"] as? [Any?] {
            var tmp : [UpdateDIJobRequest.TransformationRules] = []
            for v in value {
                if v != nil {
                    var model = UpdateDIJobRequest.TransformationRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.transformationRules = tmp
        }
    }
}

public class UpdateDIJobShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var description_: String?

    public var id: Int64?

    public var jobSettingsShrink: String?

    public var projectId: Int64?

    public var resourceSettingsShrink: String?

    public var tableMappingsShrink: String?

    public var transformationRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.jobSettingsShrink != nil {
            map["JobSettings"] = self.jobSettingsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettingsShrink != nil {
            map["ResourceSettings"] = self.resourceSettingsShrink!
        }
        if self.tableMappingsShrink != nil {
            map["TableMappings"] = self.tableMappingsShrink!
        }
        if self.transformationRulesShrink != nil {
            map["TransformationRules"] = self.transformationRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DIJobId"] as? Int64 {
            self.DIJobId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["JobSettings"] as? String {
            self.jobSettingsShrink = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceSettings"] as? String {
            self.resourceSettingsShrink = value
        }
        if let value = dict["TableMappings"] as? String {
            self.tableMappingsShrink = value
        }
        if let value = dict["TransformationRules"] as? String {
            self.transformationRulesShrink = value
        }
    }
}

public class UpdateDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDIJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDataAssetTagRequest : Tea.TeaModel {
    public var description_: String?

    public var key: String?

    public var managers: [String]?

    public var values: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.managers != nil {
            map["Managers"] = self.managers!
        }
        if self.values != nil {
            map["Values"] = self.values!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["Managers"] as? [String] {
            self.managers = value
        }
        if let value = dict["Values"] as? [String] {
            self.values = value
        }
    }
}

public class UpdateDataAssetTagShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var key: String?

    public var managersShrink: String?

    public var valuesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.managersShrink != nil {
            map["Managers"] = self.managersShrink!
        }
        if self.valuesShrink != nil {
            map["Values"] = self.valuesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["Managers"] as? String {
            self.managersShrink = value
        }
        if let value = dict["Values"] as? String {
            self.valuesShrink = value
        }
    }
}

public class UpdateDataAssetTagResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDataAssetTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataAssetTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDataAssetTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDataQualityEvaluationTaskRequest : Tea.TeaModel {
    public class DataQualityRules : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public class Thresholds : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Expression"] as? String {
                            self.expression = value
                        }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public class Expected : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Expression"] as? String {
                            self.expression = value
                        }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public class Warned : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Expression"] as? String {
                            self.expression = value
                        }
                        if let value = dict["Operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var critical: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Critical?

                public var expected: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Expected?

                public var warned: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Warned?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.expected?.validate()
                    try self.warned?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.expected != nil {
                        map["Expected"] = self.expected?.toMap()
                    }
                    if self.warned != nil {
                        map["Warned"] = self.warned?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Critical"] as? [String: Any?] {
                        var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Critical()
                        model.fromMap(value)
                        self.critical = model
                    }
                    if let value = dict["Expected"] as? [String: Any?] {
                        var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Expected()
                        model.fromMap(value)
                        self.expected = model
                    }
                    if let value = dict["Warned"] as? [String: Any?] {
                        var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Warned()
                        model.fromMap(value)
                        self.warned = model
                    }
                }
            }
            public var referencedSamplesFilter: String?

            public var thresholds: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.thresholds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.thresholds != nil {
                    map["Thresholds"] = self.thresholds?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ReferencedSamplesFilter"] as? String {
                    self.referencedSamplesFilter = value
                }
                if let value = dict["Thresholds"] as? [String: Any?] {
                    var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds()
                    model.fromMap(value)
                    self.thresholds = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class ErrorHandlers : Tea.TeaModel {
            public var errorDataFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorDataFilter != nil {
                    map["ErrorDataFilter"] = self.errorDataFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorDataFilter"] as? String {
                    self.errorDataFilter = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var samplingFilter: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.samplingFilter != nil {
                    map["SamplingFilter"] = self.samplingFilter!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Metric"] as? String {
                    self.metric = value
                }
                if let value = dict["MetricParameters"] as? String {
                    self.metricParameters = value
                }
                if let value = dict["SamplingFilter"] as? String {
                    self.samplingFilter = value
                }
                if let value = dict["SettingConfig"] as? String {
                    self.settingConfig = value
                }
            }
        }
        public var checkingConfig: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig?

        public var description_: String?

        public var enabled: Bool?

        public var errorHandlers: [UpdateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers]?

        public var id: Int64?

        public var name: String?

        public var samplingConfig: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.SamplingConfig?

        public var severity: String?

        public var templateCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.errorHandlers != nil {
                var tmp : [Any] = []
                for k in self.errorHandlers! {
                    tmp.append(k.toMap())
                }
                map["ErrorHandlers"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.templateCode != nil {
                map["TemplateCode"] = self.templateCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CheckingConfig"] as? [String: Any?] {
                var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig()
                model.fromMap(value)
                self.checkingConfig = model
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["ErrorHandlers"] as? [Any?] {
                var tmp : [UpdateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.errorHandlers = tmp
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["SamplingConfig"] as? [String: Any?] {
                var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.SamplingConfig()
                model.fromMap(value)
                self.samplingConfig = model
            }
            if let value = dict["Severity"] as? String {
                self.severity = value
            }
            if let value = dict["TemplateCode"] as? String {
                self.templateCode = value
            }
        }
    }
    public class Hooks : Tea.TeaModel {
        public var condition: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Condition"] as? String {
                self.condition = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class Notifications : Tea.TeaModel {
        public class Notifications : Tea.TeaModel {
            public class NotificationChannels : Tea.TeaModel {
                public var channels: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Channels"] as? [String] {
                        self.channels = value
                    }
                }
            }
            public class NotificationReceivers : Tea.TeaModel {
                public var extension_: String?

                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Extension"] as? String {
                        self.extension_ = value
                    }
                    if let value = dict["ReceiverType"] as? String {
                        self.receiverType = value
                    }
                    if let value = dict["ReceiverValues"] as? [String] {
                        self.receiverValues = value
                    }
                }
            }
            public var notificationChannels: [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels]?

            public var notificationReceivers: [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notificationChannels != nil {
                    var tmp : [Any] = []
                    for k in self.notificationChannels! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationChannels"] = tmp
                }
                if self.notificationReceivers != nil {
                    var tmp : [Any] = []
                    for k in self.notificationReceivers! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationReceivers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["NotificationChannels"] as? [Any?] {
                    var tmp : [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notificationChannels = tmp
                }
                if let value = dict["NotificationReceivers"] as? [Any?] {
                    var tmp : [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.notificationReceivers = tmp
                }
            }
        }
        public var condition: String?

        public var notifications: [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.notifications != nil {
                var tmp : [Any] = []
                for k in self.notifications! {
                    tmp.append(k.toMap())
                }
                map["Notifications"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Condition"] as? String {
                self.condition = value
            }
            if let value = dict["Notifications"] as? [Any?] {
                var tmp : [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications] = []
                for v in value {
                    if v != nil {
                        var model = UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.notifications = tmp
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DatabaseType"] as? String {
                self.databaseType = value
            }
            if let value = dict["PartitionSpec"] as? String {
                self.partitionSpec = value
            }
            if let value = dict["TableGuid"] as? String {
                self.tableGuid = value
            }
        }
    }
    public class Trigger : Tea.TeaModel {
        public var taskIds: [Int64]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TaskIds"] as? [Int64] {
                self.taskIds = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var dataQualityRules: [UpdateDataQualityEvaluationTaskRequest.DataQualityRules]?

    public var dataSourceId: Int64?

    public var description_: String?

    public var hooks: [UpdateDataQualityEvaluationTaskRequest.Hooks]?

    public var id: Int64?

    public var name: String?

    public var notifications: UpdateDataQualityEvaluationTaskRequest.Notifications?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var target: UpdateDataQualityEvaluationTaskRequest.Target?

    public var trigger: UpdateDataQualityEvaluationTaskRequest.Trigger?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifications?.validate()
        try self.target?.validate()
        try self.trigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRules != nil {
            var tmp : [Any] = []
            for k in self.dataQualityRules! {
                tmp.append(k.toMap())
            }
            map["DataQualityRules"] = tmp
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooks != nil {
            var tmp : [Any] = []
            for k in self.hooks! {
                tmp.append(k.toMap())
            }
            map["Hooks"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifications != nil {
            map["Notifications"] = self.notifications?.toMap()
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.trigger != nil {
            map["Trigger"] = self.trigger?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityRules"] as? [Any?] {
            var tmp : [UpdateDataQualityEvaluationTaskRequest.DataQualityRules] = []
            for v in value {
                if v != nil {
                    var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataQualityRules = tmp
        }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Hooks"] as? [Any?] {
            var tmp : [UpdateDataQualityEvaluationTaskRequest.Hooks] = []
            for v in value {
                if v != nil {
                    var model = UpdateDataQualityEvaluationTaskRequest.Hooks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hooks = tmp
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Notifications"] as? [String: Any?] {
            var model = UpdateDataQualityEvaluationTaskRequest.Notifications()
            model.fromMap(value)
            self.notifications = model
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeConf"] as? String {
            self.runtimeConf = value
        }
        if let value = dict["Target"] as? [String: Any?] {
            var model = UpdateDataQualityEvaluationTaskRequest.Target()
            model.fromMap(value)
            self.target = model
        }
        if let value = dict["Trigger"] as? [String: Any?] {
            var model = UpdateDataQualityEvaluationTaskRequest.Trigger()
            model.fromMap(value)
            self.trigger = model
        }
    }
}

public class UpdateDataQualityEvaluationTaskShrinkRequest : Tea.TeaModel {
    public var dataQualityRulesShrink: String?

    public var dataSourceId: Int64?

    public var description_: String?

    public var hooksShrink: String?

    public var id: Int64?

    public var name: String?

    public var notificationsShrink: String?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var targetShrink: String?

    public var triggerShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRulesShrink != nil {
            map["DataQualityRules"] = self.dataQualityRulesShrink!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooksShrink != nil {
            map["Hooks"] = self.hooksShrink!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationsShrink != nil {
            map["Notifications"] = self.notificationsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.targetShrink != nil {
            map["Target"] = self.targetShrink!
        }
        if self.triggerShrink != nil {
            map["Trigger"] = self.triggerShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataQualityRules"] as? String {
            self.dataQualityRulesShrink = value
        }
        if let value = dict["DataSourceId"] as? Int64 {
            self.dataSourceId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Hooks"] as? String {
            self.hooksShrink = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Notifications"] as? String {
            self.notificationsShrink = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["RuntimeConf"] as? String {
            self.runtimeConf = value
        }
        if let value = dict["Target"] as? String {
            self.targetShrink = value
        }
        if let value = dict["Trigger"] as? String {
            self.triggerShrink = value
        }
    }
}

public class UpdateDataQualityEvaluationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDataQualityEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataQualityEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDataQualityEvaluationTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDataQualityRuleRequest : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public class Thresholds : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["Operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Expected : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["Operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Warned : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Expression"] as? String {
                        self.expression = value
                    }
                    if let value = dict["Operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var critical: UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Critical?

            public var expected: UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Expected?

            public var warned: UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Warned?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.expected?.validate()
                try self.warned?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.expected != nil {
                    map["Expected"] = self.expected?.toMap()
                }
                if self.warned != nil {
                    map["Warned"] = self.warned?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Critical"] as? [String: Any?] {
                    var model = UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Critical()
                    model.fromMap(value)
                    self.critical = model
                }
                if let value = dict["Expected"] as? [String: Any?] {
                    var model = UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Expected()
                    model.fromMap(value)
                    self.expected = model
                }
                if let value = dict["Warned"] as? [String: Any?] {
                    var model = UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Warned()
                    model.fromMap(value)
                    self.warned = model
                }
            }
        }
        public var referencedSamplesFilter: String?

        public var thresholds: UpdateDataQualityRuleRequest.CheckingConfig.Thresholds?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.thresholds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.thresholds != nil {
                map["Thresholds"] = self.thresholds?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReferencedSamplesFilter"] as? String {
                self.referencedSamplesFilter = value
            }
            if let value = dict["Thresholds"] as? [String: Any?] {
                var model = UpdateDataQualityRuleRequest.CheckingConfig.Thresholds()
                model.fromMap(value)
                self.thresholds = model
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class ErrorHandlers : Tea.TeaModel {
        public var errorDataFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorDataFilter != nil {
                map["ErrorDataFilter"] = self.errorDataFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ErrorDataFilter"] as? String {
                self.errorDataFilter = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var samplingFilter: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.samplingFilter != nil {
                map["SamplingFilter"] = self.samplingFilter!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Metric"] as? String {
                self.metric = value
            }
            if let value = dict["MetricParameters"] as? String {
                self.metricParameters = value
            }
            if let value = dict["SamplingFilter"] as? String {
                self.samplingFilter = value
            }
            if let value = dict["SettingConfig"] as? String {
                self.settingConfig = value
            }
        }
    }
    public var checkingConfig: UpdateDataQualityRuleRequest.CheckingConfig?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlers: [UpdateDataQualityRuleRequest.ErrorHandlers]?

    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: UpdateDataQualityRuleRequest.SamplingConfig?

    public var severity: String?

    public var templateCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlers != nil {
            var tmp : [Any] = []
            for k in self.errorHandlers! {
                tmp.append(k.toMap())
            }
            map["ErrorHandlers"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? [String: Any?] {
            var model = UpdateDataQualityRuleRequest.CheckingConfig()
            model.fromMap(value)
            self.checkingConfig = model
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["ErrorHandlers"] as? [Any?] {
            var tmp : [UpdateDataQualityRuleRequest.ErrorHandlers] = []
            for v in value {
                if v != nil {
                    var model = UpdateDataQualityRuleRequest.ErrorHandlers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.errorHandlers = tmp
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? [String: Any?] {
            var model = UpdateDataQualityRuleRequest.SamplingConfig()
            model.fromMap(value)
            self.samplingConfig = model
        }
        if let value = dict["Severity"] as? String {
            self.severity = value
        }
        if let value = dict["TemplateCode"] as? String {
            self.templateCode = value
        }
    }
}

public class UpdateDataQualityRuleShrinkRequest : Tea.TeaModel {
    public var checkingConfigShrink: String?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlersShrink: String?

    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfigShrink: String?

    public var severity: String?

    public var templateCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfigShrink != nil {
            map["CheckingConfig"] = self.checkingConfigShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlersShrink != nil {
            map["ErrorHandlers"] = self.errorHandlersShrink!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfigShrink != nil {
            map["SamplingConfig"] = self.samplingConfigShrink!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? String {
            self.checkingConfigShrink = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["ErrorHandlers"] as? String {
            self.errorHandlersShrink = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? String {
            self.samplingConfigShrink = value
        }
        if let value = dict["Severity"] as? String {
            self.severity = value
        }
        if let value = dict["TemplateCode"] as? String {
            self.templateCode = value
        }
    }
}

public class UpdateDataQualityRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDataQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDataQualityRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDataQualityRuleTemplateRequest : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public var referencedSamplesFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ReferencedSamplesFilter"] as? String {
                self.referencedSamplesFilter = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Metric"] as? String {
                self.metric = value
            }
            if let value = dict["MetricParameters"] as? String {
                self.metricParameters = value
            }
            if let value = dict["SettingConfig"] as? String {
                self.settingConfig = value
            }
        }
    }
    public var checkingConfig: UpdateDataQualityRuleTemplateRequest.CheckingConfig?

    public var code: String?

    public var directoryPath: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: UpdateDataQualityRuleTemplateRequest.SamplingConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? [String: Any?] {
            var model = UpdateDataQualityRuleTemplateRequest.CheckingConfig()
            model.fromMap(value)
            self.checkingConfig = model
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["DirectoryPath"] as? String {
            self.directoryPath = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? [String: Any?] {
            var model = UpdateDataQualityRuleTemplateRequest.SamplingConfig()
            model.fromMap(value)
            self.samplingConfig = model
        }
    }
}

public class UpdateDataQualityRuleTemplateShrinkRequest : Tea.TeaModel {
    public var checkingConfigShrink: String?

    public var code: String?

    public var directoryPath: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfigShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfigShrink != nil {
            map["CheckingConfig"] = self.checkingConfigShrink!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfigShrink != nil {
            map["SamplingConfig"] = self.samplingConfigShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckingConfig"] as? String {
            self.checkingConfigShrink = value
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["DirectoryPath"] as? String {
            self.directoryPath = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["SamplingConfig"] as? String {
            self.samplingConfigShrink = value
        }
    }
}

public class UpdateDataQualityRuleTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDataQualityRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataQualityRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDataQualityRuleTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDataSourceRequest : Tea.TeaModel {
    public var connectionProperties: String?

    public var connectionPropertiesMode: String?

    public var description_: String?

    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionProperties != nil {
            map["ConnectionProperties"] = self.connectionProperties!
        }
        if self.connectionPropertiesMode != nil {
            map["ConnectionPropertiesMode"] = self.connectionPropertiesMode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionProperties"] as? String {
            self.connectionProperties = value
        }
        if let value = dict["ConnectionPropertiesMode"] as? String {
            self.connectionPropertiesMode = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
    }
}

public class UpdateDataSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDataSourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateFunctionRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class UpdateFunctionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateFunctionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMetaCollectionRequest : Tea.TeaModel {
    public var administrators: [String]?

    public var description_: String?

    public var id: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.administrators != nil {
            map["Administrators"] = self.administrators!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Administrators"] as? [String] {
            self.administrators = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class UpdateMetaCollectionShrinkRequest : Tea.TeaModel {
    public var administratorsShrink: String?

    public var description_: String?

    public var id: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.administratorsShrink != nil {
            map["Administrators"] = self.administratorsShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Administrators"] as? String {
            self.administratorsShrink = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class UpdateMetaCollectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateMetaCollectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMetaCollectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMetaCollectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateNodeRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class UpdateNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateProjectRequest : Tea.TeaModel {
    public var description_: String?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var displayName: String?

    public var id: Int64?

    public var paiTaskEnabled: Bool?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DevEnvironmentEnabled"] as? Bool {
            self.devEnvironmentEnabled = value
        }
        if let value = dict["DevRoleDisabled"] as? Bool {
            self.devRoleDisabled = value
        }
        if let value = dict["DisplayName"] as? String {
            self.displayName = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["PaiTaskEnabled"] as? Bool {
            self.paiTaskEnabled = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class UpdateProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateResourceRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public var resourceFile: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceFile != nil {
            map["ResourceFile"] = self.resourceFile!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceFile"] as? String {
            self.resourceFile = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class UpdateResourceAdvanceRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public var resourceFileObject: InputStream?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceFileObject != nil {
            map["ResourceFile"] = self.resourceFileObject!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["ResourceFile"] as? InputStream {
            self.resourceFileObject = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class UpdateResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateResourceGroupRequest : Tea.TeaModel {
    public var aliyunResourceGroupId: String?

    public var id: String?

    public var name: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunResourceGroupId"] as? String {
            self.aliyunResourceGroupId = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Remark"] as? String {
            self.remark = value
        }
    }
}

public class UpdateResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRouteRequest : Tea.TeaModel {
    public var destinationCidr: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidr != nil {
            map["DestinationCidr"] = self.destinationCidr!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DestinationCidr"] as? String {
            self.destinationCidr = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class UpdateRouteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRouteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTableBusinessMetadataRequest : Tea.TeaModel {
    public var id: String?

    public var readme: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.readme != nil {
            map["Readme"] = self.readme!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Readme"] as? String {
            self.readme = value
        }
    }
}

public class UpdateTableBusinessMetadataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateTableBusinessMetadataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTableBusinessMetadataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTableBusinessMetadataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTaskRequest : Tea.TeaModel {
    public class DataSource : Tea.TeaModel {
        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Name"] as? String {
                self.name = value
            }
        }
    }
    public class Dependencies : Tea.TeaModel {
        public var type: String?

        public var upstreamOutput: String?

        public var upstreamTaskId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.upstreamOutput != nil {
                map["UpstreamOutput"] = self.upstreamOutput!
            }
            if self.upstreamTaskId != nil {
                map["UpstreamTaskId"] = self.upstreamTaskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["UpstreamOutput"] as? String {
                self.upstreamOutput = value
            }
            if let value = dict["UpstreamTaskId"] as? Int64 {
                self.upstreamTaskId = value
            }
        }
    }
    public class Inputs : Tea.TeaModel {
        public class Variables : Tea.TeaModel {
            public var name: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var variables: [UpdateTaskRequest.Inputs.Variables]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.variables != nil {
                var tmp : [Any] = []
                for k in self.variables! {
                    tmp.append(k.toMap())
                }
                map["Variables"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Variables"] as? [Any?] {
                var tmp : [UpdateTaskRequest.Inputs.Variables] = []
                for v in value {
                    if v != nil {
                        var model = UpdateTaskRequest.Inputs.Variables()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.variables = tmp
            }
        }
    }
    public class Outputs : Tea.TeaModel {
        public class TaskOutputs : Tea.TeaModel {
            public var output: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Output"] as? String {
                    self.output = value
                }
            }
        }
        public class Variables : Tea.TeaModel {
            public var name: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var taskOutputs: [UpdateTaskRequest.Outputs.TaskOutputs]?

        public var variables: [UpdateTaskRequest.Outputs.Variables]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskOutputs != nil {
                var tmp : [Any] = []
                for k in self.taskOutputs! {
                    tmp.append(k.toMap())
                }
                map["TaskOutputs"] = tmp
            }
            if self.variables != nil {
                var tmp : [Any] = []
                for k in self.variables! {
                    tmp.append(k.toMap())
                }
                map["Variables"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TaskOutputs"] as? [Any?] {
                var tmp : [UpdateTaskRequest.Outputs.TaskOutputs] = []
                for v in value {
                    if v != nil {
                        var model = UpdateTaskRequest.Outputs.TaskOutputs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.taskOutputs = tmp
            }
            if let value = dict["Variables"] as? [Any?] {
                var tmp : [UpdateTaskRequest.Outputs.Variables] = []
                for v in value {
                    if v != nil {
                        var model = UpdateTaskRequest.Outputs.Variables()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.variables = tmp
            }
        }
    }
    public class RuntimeResource : Tea.TeaModel {
        public var cu: String?

        public var image: String?

        public var resourceGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cu != nil {
                map["Cu"] = self.cu!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cu"] as? String {
                self.cu = value
            }
            if let value = dict["Image"] as? String {
                self.image = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
        }
    }
    public class Script : Tea.TeaModel {
        public var content: String?

        public var parameters: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.parameters != nil {
                map["Parameters"] = self.parameters!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Content"] as? String {
                self.content = value
            }
            if let value = dict["Parameters"] as? String {
                self.parameters = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Trigger : Tea.TeaModel {
        public var cron: String?

        public var endTime: String?

        public var recurrence: String?

        public var startTime: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cron != nil {
                map["Cron"] = self.cron!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.recurrence != nil {
                map["Recurrence"] = self.recurrence!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cron"] as? String {
                self.cron = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["Recurrence"] as? String {
                self.recurrence = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var clientUniqueCode: String?

    public var dataSource: UpdateTaskRequest.DataSource?

    public var dependencies: [UpdateTaskRequest.Dependencies]?

    public var description_: String?

    public var envType: String?

    public var id: Int64?

    public var inputs: UpdateTaskRequest.Inputs?

    public var instanceMode: String?

    public var name: String?

    public var outputs: UpdateTaskRequest.Outputs?

    public var owner: String?

    public var rerunInterval: Int32?

    public var rerunMode: String?

    public var rerunTimes: Int32?

    public var runtimeResource: UpdateTaskRequest.RuntimeResource?

    public var script: UpdateTaskRequest.Script?

    public var tags: [UpdateTaskRequest.Tags]?

    public var timeout: Int32?

    public var trigger: UpdateTaskRequest.Trigger?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataSource?.validate()
        try self.inputs?.validate()
        try self.outputs?.validate()
        try self.runtimeResource?.validate()
        try self.script?.validate()
        try self.trigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientUniqueCode != nil {
            map["ClientUniqueCode"] = self.clientUniqueCode!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource?.toMap()
        }
        if self.dependencies != nil {
            var tmp : [Any] = []
            for k in self.dependencies! {
                tmp.append(k.toMap())
            }
            map["Dependencies"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.inputs != nil {
            map["Inputs"] = self.inputs?.toMap()
        }
        if self.instanceMode != nil {
            map["InstanceMode"] = self.instanceMode!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputs != nil {
            map["Outputs"] = self.outputs?.toMap()
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.rerunInterval != nil {
            map["RerunInterval"] = self.rerunInterval!
        }
        if self.rerunMode != nil {
            map["RerunMode"] = self.rerunMode!
        }
        if self.rerunTimes != nil {
            map["RerunTimes"] = self.rerunTimes!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource?.toMap()
        }
        if self.script != nil {
            map["Script"] = self.script?.toMap()
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.trigger != nil {
            map["Trigger"] = self.trigger?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientUniqueCode"] as? String {
            self.clientUniqueCode = value
        }
        if let value = dict["DataSource"] as? [String: Any?] {
            var model = UpdateTaskRequest.DataSource()
            model.fromMap(value)
            self.dataSource = model
        }
        if let value = dict["Dependencies"] as? [Any?] {
            var tmp : [UpdateTaskRequest.Dependencies] = []
            for v in value {
                if v != nil {
                    var model = UpdateTaskRequest.Dependencies()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dependencies = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Inputs"] as? [String: Any?] {
            var model = UpdateTaskRequest.Inputs()
            model.fromMap(value)
            self.inputs = model
        }
        if let value = dict["InstanceMode"] as? String {
            self.instanceMode = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Outputs"] as? [String: Any?] {
            var model = UpdateTaskRequest.Outputs()
            model.fromMap(value)
            self.outputs = model
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["RerunInterval"] as? Int32 {
            self.rerunInterval = value
        }
        if let value = dict["RerunMode"] as? String {
            self.rerunMode = value
        }
        if let value = dict["RerunTimes"] as? Int32 {
            self.rerunTimes = value
        }
        if let value = dict["RuntimeResource"] as? [String: Any?] {
            var model = UpdateTaskRequest.RuntimeResource()
            model.fromMap(value)
            self.runtimeResource = model
        }
        if let value = dict["Script"] as? [String: Any?] {
            var model = UpdateTaskRequest.Script()
            model.fromMap(value)
            self.script = model
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [UpdateTaskRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = UpdateTaskRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["Trigger"] as? [String: Any?] {
            var model = UpdateTaskRequest.Trigger()
            model.fromMap(value)
            self.trigger = model
        }
    }
}

public class UpdateTaskShrinkRequest : Tea.TeaModel {
    public var clientUniqueCode: String?

    public var dataSourceShrink: String?

    public var dependenciesShrink: String?

    public var description_: String?

    public var envType: String?

    public var id: Int64?

    public var inputsShrink: String?

    public var instanceMode: String?

    public var name: String?

    public var outputsShrink: String?

    public var owner: String?

    public var rerunInterval: Int32?

    public var rerunMode: String?

    public var rerunTimes: Int32?

    public var runtimeResourceShrink: String?

    public var scriptShrink: String?

    public var tagsShrink: String?

    public var timeout: Int32?

    public var triggerShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientUniqueCode != nil {
            map["ClientUniqueCode"] = self.clientUniqueCode!
        }
        if self.dataSourceShrink != nil {
            map["DataSource"] = self.dataSourceShrink!
        }
        if self.dependenciesShrink != nil {
            map["Dependencies"] = self.dependenciesShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.inputsShrink != nil {
            map["Inputs"] = self.inputsShrink!
        }
        if self.instanceMode != nil {
            map["InstanceMode"] = self.instanceMode!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputsShrink != nil {
            map["Outputs"] = self.outputsShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.rerunInterval != nil {
            map["RerunInterval"] = self.rerunInterval!
        }
        if self.rerunMode != nil {
            map["RerunMode"] = self.rerunMode!
        }
        if self.rerunTimes != nil {
            map["RerunTimes"] = self.rerunTimes!
        }
        if self.runtimeResourceShrink != nil {
            map["RuntimeResource"] = self.runtimeResourceShrink!
        }
        if self.scriptShrink != nil {
            map["Script"] = self.scriptShrink!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.triggerShrink != nil {
            map["Trigger"] = self.triggerShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientUniqueCode"] as? String {
            self.clientUniqueCode = value
        }
        if let value = dict["DataSource"] as? String {
            self.dataSourceShrink = value
        }
        if let value = dict["Dependencies"] as? String {
            self.dependenciesShrink = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["Inputs"] as? String {
            self.inputsShrink = value
        }
        if let value = dict["InstanceMode"] as? String {
            self.instanceMode = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Outputs"] as? String {
            self.outputsShrink = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["RerunInterval"] as? Int32 {
            self.rerunInterval = value
        }
        if let value = dict["RerunMode"] as? String {
            self.rerunMode = value
        }
        if let value = dict["RerunTimes"] as? Int32 {
            self.rerunTimes = value
        }
        if let value = dict["RuntimeResource"] as? String {
            self.runtimeResourceShrink = value
        }
        if let value = dict["Script"] as? String {
            self.scriptShrink = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
        if let value = dict["Timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["Trigger"] as? String {
            self.triggerShrink = value
        }
    }
}

public class UpdateTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTaskInstancesRequest : Tea.TeaModel {
    public class TaskInstances : Tea.TeaModel {
        public class DataSource : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public var dataSource: UpdateTaskInstancesRequest.TaskInstances.DataSource?

        public var id: Int64?

        public var priority: Int32?

        public var runtimeResource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSource?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSource"] as? [String: Any?] {
                var model = UpdateTaskInstancesRequest.TaskInstances.DataSource()
                model.fromMap(value)
                self.dataSource = model
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["RuntimeResource"] as? String {
                self.runtimeResource = value
            }
        }
    }
    public var comment: String?

    public var taskInstances: [UpdateTaskInstancesRequest.TaskInstances]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.taskInstances != nil {
            var tmp : [Any] = []
            for k in self.taskInstances! {
                tmp.append(k.toMap())
            }
            map["TaskInstances"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["TaskInstances"] as? [Any?] {
            var tmp : [UpdateTaskInstancesRequest.TaskInstances] = []
            for v in value {
                if v != nil {
                    var model = UpdateTaskInstancesRequest.TaskInstances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.taskInstances = tmp
        }
    }
}

public class UpdateTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var taskInstancesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.taskInstancesShrink != nil {
            map["TaskInstances"] = self.taskInstancesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["TaskInstances"] as? String {
            self.taskInstancesShrink = value
        }
    }
}

public class UpdateTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessInfo"] as? [String: Any?] {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class UpdateTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTaskInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWorkflowRequest : Tea.TeaModel {
    public class Dependencies : Tea.TeaModel {
        public var type: String?

        public var upstreamOutput: String?

        public var upstreamTaskId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.upstreamOutput != nil {
                map["UpstreamOutput"] = self.upstreamOutput!
            }
            if self.upstreamTaskId != nil {
                map["UpstreamTaskId"] = self.upstreamTaskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["UpstreamOutput"] as? String {
                self.upstreamOutput = value
            }
            if let value = dict["UpstreamTaskId"] as? Int64 {
                self.upstreamTaskId = value
            }
        }
    }
    public class Outputs : Tea.TeaModel {
        public class TaskOutputs : Tea.TeaModel {
            public var output: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.output != nil {
                    map["Output"] = self.output!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Output"] as? String {
                    self.output = value
                }
            }
        }
        public var taskOutputs: [UpdateWorkflowRequest.Outputs.TaskOutputs]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskOutputs != nil {
                var tmp : [Any] = []
                for k in self.taskOutputs! {
                    tmp.append(k.toMap())
                }
                map["TaskOutputs"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TaskOutputs"] as? [Any?] {
                var tmp : [UpdateWorkflowRequest.Outputs.TaskOutputs] = []
                for v in value {
                    if v != nil {
                        var model = UpdateWorkflowRequest.Outputs.TaskOutputs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.taskOutputs = tmp
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public class Tasks : Tea.TeaModel {
        public class DataSource : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class Dependencies : Tea.TeaModel {
            public var type: String?

            public var upstreamOutput: String?

            public var upstreamTaskId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.upstreamOutput != nil {
                    map["UpstreamOutput"] = self.upstreamOutput!
                }
                if self.upstreamTaskId != nil {
                    map["UpstreamTaskId"] = self.upstreamTaskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["UpstreamOutput"] as? String {
                    self.upstreamOutput = value
                }
                if let value = dict["UpstreamTaskId"] as? Int64 {
                    self.upstreamTaskId = value
                }
            }
        }
        public class Inputs : Tea.TeaModel {
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var variables: [UpdateWorkflowRequest.Tasks.Inputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Variables"] as? [Any?] {
                    var tmp : [UpdateWorkflowRequest.Tasks.Inputs.Variables] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateWorkflowRequest.Tasks.Inputs.Variables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.variables = tmp
                }
            }
        }
        public class Outputs : Tea.TeaModel {
            public class TaskOutputs : Tea.TeaModel {
                public var output: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Output"] as? String {
                        self.output = value
                    }
                }
            }
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var taskOutputs: [UpdateWorkflowRequest.Tasks.Outputs.TaskOutputs]?

            public var variables: [UpdateWorkflowRequest.Tasks.Outputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskOutputs != nil {
                    var tmp : [Any] = []
                    for k in self.taskOutputs! {
                        tmp.append(k.toMap())
                    }
                    map["TaskOutputs"] = tmp
                }
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TaskOutputs"] as? [Any?] {
                    var tmp : [UpdateWorkflowRequest.Tasks.Outputs.TaskOutputs] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateWorkflowRequest.Tasks.Outputs.TaskOutputs()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.taskOutputs = tmp
                }
                if let value = dict["Variables"] as? [Any?] {
                    var tmp : [UpdateWorkflowRequest.Tasks.Outputs.Variables] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateWorkflowRequest.Tasks.Outputs.Variables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.variables = tmp
                }
            }
        }
        public class RuntimeResource : Tea.TeaModel {
            public var cu: String?

            public var image: String?

            public var resourceGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cu != nil {
                    map["Cu"] = self.cu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cu"] as? String {
                    self.cu = value
                }
                if let value = dict["Image"] as? String {
                    self.image = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
            }
        }
        public class Script : Tea.TeaModel {
            public var content: String?

            public var parameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Content"] as? String {
                    self.content = value
                }
                if let value = dict["Parameters"] as? String {
                    self.parameters = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public var recurrence: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.recurrence != nil {
                    map["Recurrence"] = self.recurrence!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Recurrence"] as? String {
                    self.recurrence = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var baseLineId: Int64?

        public var clientUniqueCode: String?

        public var dataSource: UpdateWorkflowRequest.Tasks.DataSource?

        public var dependencies: [UpdateWorkflowRequest.Tasks.Dependencies]?

        public var description_: String?

        public var envType: String?

        public var id: Int64?

        public var inputs: UpdateWorkflowRequest.Tasks.Inputs?

        public var name: String?

        public var outputs: UpdateWorkflowRequest.Tasks.Outputs?

        public var owner: String?

        public var rerunInterval: Int32?

        public var rerunMode: String?

        public var rerunTimes: Int32?

        public var runtimeResource: UpdateWorkflowRequest.Tasks.RuntimeResource?

        public var script: UpdateWorkflowRequest.Tasks.Script?

        public var tags: [UpdateWorkflowRequest.Tasks.Tags]?

        public var timeout: Int32?

        public var trigger: UpdateWorkflowRequest.Tasks.Trigger?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSource?.validate()
            try self.inputs?.validate()
            try self.outputs?.validate()
            try self.runtimeResource?.validate()
            try self.script?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baseLineId != nil {
                map["BaseLineId"] = self.baseLineId!
            }
            if self.clientUniqueCode != nil {
                map["ClientUniqueCode"] = self.clientUniqueCode!
            }
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource?.toMap()
            }
            if self.dependencies != nil {
                var tmp : [Any] = []
                for k in self.dependencies! {
                    tmp.append(k.toMap())
                }
                map["Dependencies"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.inputs != nil {
                map["Inputs"] = self.inputs?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputs != nil {
                map["Outputs"] = self.outputs?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.rerunInterval != nil {
                map["RerunInterval"] = self.rerunInterval!
            }
            if self.rerunMode != nil {
                map["RerunMode"] = self.rerunMode!
            }
            if self.rerunTimes != nil {
                map["RerunTimes"] = self.rerunTimes!
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource?.toMap()
            }
            if self.script != nil {
                map["Script"] = self.script?.toMap()
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BaseLineId"] as? Int64 {
                self.baseLineId = value
            }
            if let value = dict["ClientUniqueCode"] as? String {
                self.clientUniqueCode = value
            }
            if let value = dict["DataSource"] as? [String: Any?] {
                var model = UpdateWorkflowRequest.Tasks.DataSource()
                model.fromMap(value)
                self.dataSource = model
            }
            if let value = dict["Dependencies"] as? [Any?] {
                var tmp : [UpdateWorkflowRequest.Tasks.Dependencies] = []
                for v in value {
                    if v != nil {
                        var model = UpdateWorkflowRequest.Tasks.Dependencies()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dependencies = tmp
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EnvType"] as? String {
                self.envType = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Inputs"] as? [String: Any?] {
                var model = UpdateWorkflowRequest.Tasks.Inputs()
                model.fromMap(value)
                self.inputs = model
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Outputs"] as? [String: Any?] {
                var model = UpdateWorkflowRequest.Tasks.Outputs()
                model.fromMap(value)
                self.outputs = model
            }
            if let value = dict["Owner"] as? String {
                self.owner = value
            }
            if let value = dict["RerunInterval"] as? Int32 {
                self.rerunInterval = value
            }
            if let value = dict["RerunMode"] as? String {
                self.rerunMode = value
            }
            if let value = dict["RerunTimes"] as? Int32 {
                self.rerunTimes = value
            }
            if let value = dict["RuntimeResource"] as? [String: Any?] {
                var model = UpdateWorkflowRequest.Tasks.RuntimeResource()
                model.fromMap(value)
                self.runtimeResource = model
            }
            if let value = dict["Script"] as? [String: Any?] {
                var model = UpdateWorkflowRequest.Tasks.Script()
                model.fromMap(value)
                self.script = model
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [UpdateWorkflowRequest.Tasks.Tags] = []
                for v in value {
                    if v != nil {
                        var model = UpdateWorkflowRequest.Tasks.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["Timeout"] as? Int32 {
                self.timeout = value
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = UpdateWorkflowRequest.Tasks.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class Trigger : Tea.TeaModel {
        public var cron: String?

        public var endTime: String?

        public var startTime: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cron != nil {
                map["Cron"] = self.cron!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cron"] as? String {
                self.cron = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var clientUniqueCode: String?

    public var dependencies: [UpdateWorkflowRequest.Dependencies]?

    public var description_: String?

    public var envType: String?

    public var id: Int64?

    public var instanceMode: String?

    public var name: String?

    public var outputs: UpdateWorkflowRequest.Outputs?

    public var owner: String?

    public var parameters: String?

    public var tags: [UpdateWorkflowRequest.Tags]?

    public var tasks: [UpdateWorkflowRequest.Tasks]?

    public var trigger: UpdateWorkflowRequest.Trigger?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.outputs?.validate()
        try self.trigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientUniqueCode != nil {
            map["ClientUniqueCode"] = self.clientUniqueCode!
        }
        if self.dependencies != nil {
            var tmp : [Any] = []
            for k in self.dependencies! {
                tmp.append(k.toMap())
            }
            map["Dependencies"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceMode != nil {
            map["InstanceMode"] = self.instanceMode!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputs != nil {
            map["Outputs"] = self.outputs?.toMap()
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.tasks != nil {
            var tmp : [Any] = []
            for k in self.tasks! {
                tmp.append(k.toMap())
            }
            map["Tasks"] = tmp
        }
        if self.trigger != nil {
            map["Trigger"] = self.trigger?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientUniqueCode"] as? String {
            self.clientUniqueCode = value
        }
        if let value = dict["Dependencies"] as? [Any?] {
            var tmp : [UpdateWorkflowRequest.Dependencies] = []
            for v in value {
                if v != nil {
                    var model = UpdateWorkflowRequest.Dependencies()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dependencies = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["InstanceMode"] as? String {
            self.instanceMode = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Outputs"] as? [String: Any?] {
            var model = UpdateWorkflowRequest.Outputs()
            model.fromMap(value)
            self.outputs = model
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["Parameters"] as? String {
            self.parameters = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [UpdateWorkflowRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = UpdateWorkflowRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["Tasks"] as? [Any?] {
            var tmp : [UpdateWorkflowRequest.Tasks] = []
            for v in value {
                if v != nil {
                    var model = UpdateWorkflowRequest.Tasks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tasks = tmp
        }
        if let value = dict["Trigger"] as? [String: Any?] {
            var model = UpdateWorkflowRequest.Trigger()
            model.fromMap(value)
            self.trigger = model
        }
    }
}

public class UpdateWorkflowShrinkRequest : Tea.TeaModel {
    public var clientUniqueCode: String?

    public var dependenciesShrink: String?

    public var description_: String?

    public var envType: String?

    public var id: Int64?

    public var instanceMode: String?

    public var name: String?

    public var outputsShrink: String?

    public var owner: String?

    public var parameters: String?

    public var tagsShrink: String?

    public var tasksShrink: String?

    public var triggerShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientUniqueCode != nil {
            map["ClientUniqueCode"] = self.clientUniqueCode!
        }
        if self.dependenciesShrink != nil {
            map["Dependencies"] = self.dependenciesShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceMode != nil {
            map["InstanceMode"] = self.instanceMode!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.outputsShrink != nil {
            map["Outputs"] = self.outputsShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.tagsShrink != nil {
            map["Tags"] = self.tagsShrink!
        }
        if self.tasksShrink != nil {
            map["Tasks"] = self.tasksShrink!
        }
        if self.triggerShrink != nil {
            map["Trigger"] = self.triggerShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientUniqueCode"] as? String {
            self.clientUniqueCode = value
        }
        if let value = dict["Dependencies"] as? String {
            self.dependenciesShrink = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["InstanceMode"] as? String {
            self.instanceMode = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Outputs"] as? String {
            self.outputsShrink = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["Parameters"] as? String {
            self.parameters = value
        }
        if let value = dict["Tags"] as? String {
            self.tagsShrink = value
        }
        if let value = dict["Tasks"] as? String {
            self.tasksShrink = value
        }
        if let value = dict["Trigger"] as? String {
            self.triggerShrink = value
        }
    }
}

public class UpdateWorkflowResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWorkflowResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ProjectId"] as? Int64 {
            self.projectId = value
        }
        if let value = dict["Spec"] as? String {
            self.spec = value
        }
    }
}

public class UpdateWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWorkflowDefinitionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
