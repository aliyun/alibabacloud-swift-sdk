import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class DataQualityEvaluationTask : Tea.TeaModel {
    public class Hooks : Tea.TeaModel {
        public var condition: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Notifications : Tea.TeaModel {
        public class Notifications : Tea.TeaModel {
            public class NotificationChannels : Tea.TeaModel {
                public var channels: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! [String]
                    }
                }
            }
            public class NotificationReceivers : Tea.TeaModel {
                public var extension_: String?

                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Extension") {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("ReceiverType") {
                        self.receiverType = dict["ReceiverType"] as! String
                    }
                    if dict.keys.contains("ReceiverValues") {
                        self.receiverValues = dict["ReceiverValues"] as! [String]
                    }
                }
            }
            public var notificationChannels: [DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels]?

            public var notificationReceivers: [DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notificationChannels != nil {
                    var tmp : [Any] = []
                    for k in self.notificationChannels! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationChannels"] = tmp
                }
                if self.notificationReceivers != nil {
                    var tmp : [Any] = []
                    for k in self.notificationReceivers! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationReceivers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NotificationChannels") {
                    var tmp : [DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels] = []
                    for v in dict["NotificationChannels"] as! [Any] {
                        var model = DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notificationChannels = tmp
                }
                if dict.keys.contains("NotificationReceivers") {
                    var tmp : [DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers] = []
                    for v in dict["NotificationReceivers"] as! [Any] {
                        var model = DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notificationReceivers = tmp
                }
            }
        }
        public var condition: String?

        public var notifications: [DataQualityEvaluationTask.Notifications.Notifications]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.notifications != nil {
                var tmp : [Any] = []
                for k in self.notifications! {
                    tmp.append(k.toMap())
                }
                map["Notifications"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Notifications") {
                var tmp : [DataQualityEvaluationTask.Notifications.Notifications] = []
                for v in dict["Notifications"] as! [Any] {
                    var model = DataQualityEvaluationTask.Notifications.Notifications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifications = tmp
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseType") {
                self.databaseType = dict["DatabaseType"] as! String
            }
            if dict.keys.contains("PartitionSpec") {
                self.partitionSpec = dict["PartitionSpec"] as! String
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Trigger : Tea.TeaModel {
        public var taskIds: [Int64]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskIds") {
                self.taskIds = dict["TaskIds"] as! [Int64]
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var dataSourceId: Int64?

    public var description_: String?

    public var hooks: [DataQualityEvaluationTask.Hooks]?

    public var id: Int64?

    public var name: String?

    public var notifications: [DataQualityEvaluationTask.Notifications]?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var target: DataQualityEvaluationTask.Target?

    public var tenantId: Int64?

    public var trigger: DataQualityEvaluationTask.Trigger?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.target?.validate()
        try self.trigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooks != nil {
            var tmp : [Any] = []
            for k in self.hooks! {
                tmp.append(k.toMap())
            }
            map["Hooks"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifications != nil {
            var tmp : [Any] = []
            for k in self.notifications! {
                tmp.append(k.toMap())
            }
            map["Notifications"] = tmp
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        if self.trigger != nil {
            map["Trigger"] = self.trigger?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Hooks") {
            var tmp : [DataQualityEvaluationTask.Hooks] = []
            for v in dict["Hooks"] as! [Any] {
                var model = DataQualityEvaluationTask.Hooks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hooks = tmp
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notifications") {
            var tmp : [DataQualityEvaluationTask.Notifications] = []
            for v in dict["Notifications"] as! [Any] {
                var model = DataQualityEvaluationTask.Notifications()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.notifications = tmp
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeConf") {
            self.runtimeConf = dict["RuntimeConf"] as! String
        }
        if dict.keys.contains("Target") {
            var model = DataQualityEvaluationTask.Target()
            model.fromMap(dict["Target"] as! [String: Any])
            self.target = model
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
        if dict.keys.contains("Trigger") {
            var model = DataQualityEvaluationTask.Trigger()
            model.fromMap(dict["Trigger"] as! [String: Any])
            self.trigger = model
        }
    }
}

public class DataQualityEvaluationTaskInstance : Tea.TeaModel {
    public class Task : Tea.TeaModel {
        public class Hooks : Tea.TeaModel {
            public var condition: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Condition") {
                    self.condition = dict["Condition"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Notifications : Tea.TeaModel {
            public class Notifications : Tea.TeaModel {
                public class NotificationChannels : Tea.TeaModel {
                    public var channels: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! [String]
                        }
                    }
                }
                public class NotificationReceivers : Tea.TeaModel {
                    public var extension_: String?

                    public var receiverType: String?

                    public var receiverValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extension_ != nil {
                            map["Extension"] = self.extension_!
                        }
                        if self.receiverType != nil {
                            map["ReceiverType"] = self.receiverType!
                        }
                        if self.receiverValues != nil {
                            map["ReceiverValues"] = self.receiverValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Extension") {
                            self.extension_ = dict["Extension"] as! String
                        }
                        if dict.keys.contains("ReceiverType") {
                            self.receiverType = dict["ReceiverType"] as! String
                        }
                        if dict.keys.contains("ReceiverValues") {
                            self.receiverValues = dict["ReceiverValues"] as! [String]
                        }
                    }
                }
                public var notificationChannels: [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels]?

                public var notificationReceivers: [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.notificationChannels != nil {
                        var tmp : [Any] = []
                        for k in self.notificationChannels! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationChannels"] = tmp
                    }
                    if self.notificationReceivers != nil {
                        var tmp : [Any] = []
                        for k in self.notificationReceivers! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationReceivers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NotificationChannels") {
                        var tmp : [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels] = []
                        for v in dict["NotificationChannels"] as! [Any] {
                            var model = DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notificationChannels = tmp
                    }
                    if dict.keys.contains("NotificationReceivers") {
                        var tmp : [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers] = []
                        for v in dict["NotificationReceivers"] as! [Any] {
                            var model = DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notificationReceivers = tmp
                    }
                }
            }
            public var condition: String?

            public var notifications: [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.notifications != nil {
                    var tmp : [Any] = []
                    for k in self.notifications! {
                        tmp.append(k.toMap())
                    }
                    map["Notifications"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Condition") {
                    self.condition = dict["Condition"] as! String
                }
                if dict.keys.contains("Notifications") {
                    var tmp : [DataQualityEvaluationTaskInstance.Task.Notifications.Notifications] = []
                    for v in dict["Notifications"] as! [Any] {
                        var model = DataQualityEvaluationTaskInstance.Task.Notifications.Notifications()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notifications = tmp
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var databaseType: String?

            public var partitionSpec: String?

            public var tableGuid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseType != nil {
                    map["DatabaseType"] = self.databaseType!
                }
                if self.partitionSpec != nil {
                    map["PartitionSpec"] = self.partitionSpec!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseType") {
                    self.databaseType = dict["DatabaseType"] as! String
                }
                if dict.keys.contains("PartitionSpec") {
                    self.partitionSpec = dict["PartitionSpec"] as! String
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public var taskIds: [Int64]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskIds != nil {
                    map["TaskIds"] = self.taskIds!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TaskIds") {
                    self.taskIds = dict["TaskIds"] as! [Int64]
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var dataSourceId: Int64?

        public var hooks: [DataQualityEvaluationTaskInstance.Task.Hooks]?

        public var id: Int64?

        public var name: String?

        public var notifications: [DataQualityEvaluationTaskInstance.Task.Notifications]?

        public var projectId: Int64?

        public var runtimeConf: String?

        public var target: DataQualityEvaluationTaskInstance.Task.Target?

        public var tenantId: Int64?

        public var trigger: DataQualityEvaluationTaskInstance.Task.Trigger?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.target?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceId != nil {
                map["DataSourceId"] = self.dataSourceId!
            }
            if self.hooks != nil {
                var tmp : [Any] = []
                for k in self.hooks! {
                    tmp.append(k.toMap())
                }
                map["Hooks"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifications != nil {
                var tmp : [Any] = []
                for k in self.notifications! {
                    tmp.append(k.toMap())
                }
                map["Notifications"] = tmp
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.runtimeConf != nil {
                map["RuntimeConf"] = self.runtimeConf!
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSourceId") {
                self.dataSourceId = dict["DataSourceId"] as! Int64
            }
            if dict.keys.contains("Hooks") {
                var tmp : [DataQualityEvaluationTaskInstance.Task.Hooks] = []
                for v in dict["Hooks"] as! [Any] {
                    var model = DataQualityEvaluationTaskInstance.Task.Hooks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hooks = tmp
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Notifications") {
                var tmp : [DataQualityEvaluationTaskInstance.Task.Notifications] = []
                for v in dict["Notifications"] as! [Any] {
                    var model = DataQualityEvaluationTaskInstance.Task.Notifications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifications = tmp
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("RuntimeConf") {
                self.runtimeConf = dict["RuntimeConf"] as! String
            }
            if dict.keys.contains("Target") {
                var model = DataQualityEvaluationTaskInstance.Task.Target()
                model.fromMap(dict["Target"] as! [String: Any])
                self.target = model
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("Trigger") {
                var model = DataQualityEvaluationTaskInstance.Task.Trigger()
                model.fromMap(dict["Trigger"] as! [String: Any])
                self.trigger = model
            }
        }
    }
    public var createTime: Int64?

    public var finishTime: Int64?

    public var id: Int64?

    public var status: String?

    public var task: DataQualityEvaluationTaskInstance.Task?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.task?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.finishTime != nil {
            map["FinishTime"] = self.finishTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.task != nil {
            map["Task"] = self.task?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("FinishTime") {
            self.finishTime = dict["FinishTime"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Task") {
            var model = DataQualityEvaluationTaskInstance.Task()
            model.fromMap(dict["Task"] as! [String: Any])
            self.task = model
        }
    }
}

public class DataQualityResult : Tea.TeaModel {
    public class Details : Tea.TeaModel {
        public var checkedValue: String?

        public var referencedValue: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkedValue != nil {
                map["CheckedValue"] = self.checkedValue!
            }
            if self.referencedValue != nil {
                map["ReferencedValue"] = self.referencedValue!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckedValue") {
                self.checkedValue = dict["CheckedValue"] as! String
            }
            if dict.keys.contains("ReferencedValue") {
                self.referencedValue = dict["ReferencedValue"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class Rule : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public class Thresholds : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Expected : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Warned : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var critical: DataQualityResult.Rule.CheckingConfig.Thresholds.Critical?

                public var expected: DataQualityResult.Rule.CheckingConfig.Thresholds.Expected?

                public var warned: DataQualityResult.Rule.CheckingConfig.Thresholds.Warned?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.expected?.validate()
                    try self.warned?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.expected != nil {
                        map["Expected"] = self.expected?.toMap()
                    }
                    if self.warned != nil {
                        map["Warned"] = self.warned?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Critical") {
                        var model = DataQualityResult.Rule.CheckingConfig.Thresholds.Critical()
                        model.fromMap(dict["Critical"] as! [String: Any])
                        self.critical = model
                    }
                    if dict.keys.contains("Expected") {
                        var model = DataQualityResult.Rule.CheckingConfig.Thresholds.Expected()
                        model.fromMap(dict["Expected"] as! [String: Any])
                        self.expected = model
                    }
                    if dict.keys.contains("Warned") {
                        var model = DataQualityResult.Rule.CheckingConfig.Thresholds.Warned()
                        model.fromMap(dict["Warned"] as! [String: Any])
                        self.warned = model
                    }
                }
            }
            public var referencedSamplesFilter: String?

            public var thresholds: DataQualityResult.Rule.CheckingConfig.Thresholds?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.thresholds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.thresholds != nil {
                    map["Thresholds"] = self.thresholds?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReferencedSamplesFilter") {
                    self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
                }
                if dict.keys.contains("Thresholds") {
                    var model = DataQualityResult.Rule.CheckingConfig.Thresholds()
                    model.fromMap(dict["Thresholds"] as! [String: Any])
                    self.thresholds = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ErrorHandlers : Tea.TeaModel {
            public var errorDataFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorDataFilter != nil {
                    map["ErrorDataFilter"] = self.errorDataFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorDataFilter") {
                    self.errorDataFilter = dict["ErrorDataFilter"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var samplingFilter: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.samplingFilter != nil {
                    map["SamplingFilter"] = self.samplingFilter!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Metric") {
                    self.metric = dict["Metric"] as! String
                }
                if dict.keys.contains("MetricParameters") {
                    self.metricParameters = dict["MetricParameters"] as! String
                }
                if dict.keys.contains("SamplingFilter") {
                    self.samplingFilter = dict["SamplingFilter"] as! String
                }
                if dict.keys.contains("SettingConfig") {
                    self.settingConfig = dict["SettingConfig"] as! String
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var databaseType: String?

            public var partitionSpec: String?

            public var tableGuid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseType != nil {
                    map["DatabaseType"] = self.databaseType!
                }
                if self.partitionSpec != nil {
                    map["PartitionSpec"] = self.partitionSpec!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseType") {
                    self.databaseType = dict["DatabaseType"] as! String
                }
                if dict.keys.contains("PartitionSpec") {
                    self.partitionSpec = dict["PartitionSpec"] as! String
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var checkingConfig: DataQualityResult.Rule.CheckingConfig?

        public var description_: String?

        public var enabled: Bool?

        public var errorHandlers: [DataQualityResult.Rule.ErrorHandlers]?

        public var id: Int64?

        public var name: String?

        public var projectId: Int64?

        public var samplingConfig: DataQualityResult.Rule.SamplingConfig?

        public var severity: String?

        public var target: DataQualityResult.Rule.Target?

        public var templateCode: String?

        public var tenantId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.errorHandlers != nil {
                var tmp : [Any] = []
                for k in self.errorHandlers! {
                    tmp.append(k.toMap())
                }
                map["ErrorHandlers"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.templateCode != nil {
                map["TemplateCode"] = self.templateCode!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckingConfig") {
                var model = DataQualityResult.Rule.CheckingConfig()
                model.fromMap(dict["CheckingConfig"] as! [String: Any])
                self.checkingConfig = model
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("ErrorHandlers") {
                var tmp : [DataQualityResult.Rule.ErrorHandlers] = []
                for v in dict["ErrorHandlers"] as! [Any] {
                    var model = DataQualityResult.Rule.ErrorHandlers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorHandlers = tmp
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("SamplingConfig") {
                var model = DataQualityResult.Rule.SamplingConfig()
                model.fromMap(dict["SamplingConfig"] as! [String: Any])
                self.samplingConfig = model
            }
            if dict.keys.contains("Severity") {
                self.severity = dict["Severity"] as! String
            }
            if dict.keys.contains("Target") {
                var model = DataQualityResult.Rule.Target()
                model.fromMap(dict["Target"] as! [String: Any])
                self.target = model
            }
            if dict.keys.contains("TemplateCode") {
                self.templateCode = dict["TemplateCode"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
        }
    }
    public var details: [DataQualityResult.Details]?

    public var id: Int64?

    public var rule: DataQualityResult.Rule?

    public var sample: String?

    public var status: String?

    public var taskInstanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.rule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.details != nil {
            var tmp : [Any] = []
            for k in self.details! {
                tmp.append(k.toMap())
            }
            map["Details"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.rule != nil {
            map["Rule"] = self.rule?.toMap()
        }
        if self.sample != nil {
            map["Sample"] = self.sample!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskInstanceId != nil {
            map["TaskInstanceId"] = self.taskInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Details") {
            var tmp : [DataQualityResult.Details] = []
            for v in dict["Details"] as! [Any] {
                var model = DataQualityResult.Details()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.details = tmp
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Rule") {
            var model = DataQualityResult.Rule()
            model.fromMap(dict["Rule"] as! [String: Any])
            self.rule = model
        }
        if dict.keys.contains("Sample") {
            self.sample = dict["Sample"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskInstanceId") {
            self.taskInstanceId = dict["TaskInstanceId"] as! Int64
        }
    }
}

public class DataQualityRule : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public class Thresholds : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Expected : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Warned : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var critical: DataQualityRule.CheckingConfig.Thresholds.Critical?

            public var expected: DataQualityRule.CheckingConfig.Thresholds.Expected?

            public var warned: DataQualityRule.CheckingConfig.Thresholds.Warned?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.expected?.validate()
                try self.warned?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.expected != nil {
                    map["Expected"] = self.expected?.toMap()
                }
                if self.warned != nil {
                    map["Warned"] = self.warned?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Critical") {
                    var model = DataQualityRule.CheckingConfig.Thresholds.Critical()
                    model.fromMap(dict["Critical"] as! [String: Any])
                    self.critical = model
                }
                if dict.keys.contains("Expected") {
                    var model = DataQualityRule.CheckingConfig.Thresholds.Expected()
                    model.fromMap(dict["Expected"] as! [String: Any])
                    self.expected = model
                }
                if dict.keys.contains("Warned") {
                    var model = DataQualityRule.CheckingConfig.Thresholds.Warned()
                    model.fromMap(dict["Warned"] as! [String: Any])
                    self.warned = model
                }
            }
        }
        public var referencedSamplesFilter: String?

        public var thresholds: DataQualityRule.CheckingConfig.Thresholds?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.thresholds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.thresholds != nil {
                map["Thresholds"] = self.thresholds?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReferencedSamplesFilter") {
                self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
            }
            if dict.keys.contains("Thresholds") {
                var model = DataQualityRule.CheckingConfig.Thresholds()
                model.fromMap(dict["Thresholds"] as! [String: Any])
                self.thresholds = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ErrorHandlers : Tea.TeaModel {
        public var errorDataFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorDataFilter != nil {
                map["ErrorDataFilter"] = self.errorDataFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorDataFilter") {
                self.errorDataFilter = dict["ErrorDataFilter"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var samplingFilter: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.samplingFilter != nil {
                map["SamplingFilter"] = self.samplingFilter!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metric") {
                self.metric = dict["Metric"] as! String
            }
            if dict.keys.contains("MetricParameters") {
                self.metricParameters = dict["MetricParameters"] as! String
            }
            if dict.keys.contains("SamplingFilter") {
                self.samplingFilter = dict["SamplingFilter"] as! String
            }
            if dict.keys.contains("SettingConfig") {
                self.settingConfig = dict["SettingConfig"] as! String
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseType") {
                self.databaseType = dict["DatabaseType"] as! String
            }
            if dict.keys.contains("PartitionSpec") {
                self.partitionSpec = dict["PartitionSpec"] as! String
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var checkingConfig: DataQualityRule.CheckingConfig?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlers: [DataQualityRule.ErrorHandlers]?

    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: DataQualityRule.SamplingConfig?

    public var severity: String?

    public var target: DataQualityRule.Target?

    public var templateCode: String?

    public var tenantId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
        try self.target?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlers != nil {
            var tmp : [Any] = []
            for k in self.errorHandlers! {
                tmp.append(k.toMap())
            }
            map["ErrorHandlers"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        if self.tenantId != nil {
            map["TenantId"] = self.tenantId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckingConfig") {
            var model = DataQualityRule.CheckingConfig()
            model.fromMap(dict["CheckingConfig"] as! [String: Any])
            self.checkingConfig = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("ErrorHandlers") {
            var tmp : [DataQualityRule.ErrorHandlers] = []
            for v in dict["ErrorHandlers"] as! [Any] {
                var model = DataQualityRule.ErrorHandlers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.errorHandlers = tmp
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SamplingConfig") {
            var model = DataQualityRule.SamplingConfig()
            model.fromMap(dict["SamplingConfig"] as! [String: Any])
            self.samplingConfig = model
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("Target") {
            var model = DataQualityRule.Target()
            model.fromMap(dict["Target"] as! [String: Any])
            self.target = model
        }
        if dict.keys.contains("TemplateCode") {
            self.templateCode = dict["TemplateCode"] as! String
        }
        if dict.keys.contains("TenantId") {
            self.tenantId = dict["TenantId"] as! Int64
        }
    }
}

public class SuccessInfoValue : Tea.TeaModel {
    public var success: Bool?

    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
    }
}

public class AbolishDeploymentRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class AbolishDeploymentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AbolishDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbolishDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AbolishDeploymentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateProjectToResourceGroupRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class AssociateProjectToResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AssociateProjectToResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateProjectToResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateProjectToResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachDataQualityRulesToEvaluationTaskRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityRuleIds: [Int64]?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityRuleIds != nil {
            map["DataQualityRuleIds"] = self.dataQualityRuleIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityEvaluationTaskId") {
            self.dataQualityEvaluationTaskId = dict["DataQualityEvaluationTaskId"] as! Int64
        }
        if dict.keys.contains("DataQualityRuleIds") {
            self.dataQualityRuleIds = dict["DataQualityRuleIds"] as! [Int64]
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class AttachDataQualityRulesToEvaluationTaskShrinkRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityRuleIdsShrink: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityRuleIdsShrink != nil {
            map["DataQualityRuleIds"] = self.dataQualityRuleIdsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityEvaluationTaskId") {
            self.dataQualityEvaluationTaskId = dict["DataQualityEvaluationTaskId"] as! Int64
        }
        if dict.keys.contains("DataQualityRuleIds") {
            self.dataQualityRuleIdsShrink = dict["DataQualityRuleIds"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class AttachDataQualityRulesToEvaluationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AttachDataQualityRulesToEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDataQualityRulesToEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachDataQualityRulesToEvaluationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloneDataSourceRequest : Tea.TeaModel {
    public var cloneDataSourceName: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloneDataSourceName != nil {
            map["CloneDataSourceName"] = self.cloneDataSourceName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloneDataSourceName") {
            self.cloneDataSourceName = dict["CloneDataSourceName"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class CloneDataSourceResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CloneDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloneDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAlertRuleRequest : Tea.TeaModel {
    public class Notification : Tea.TeaModel {
        public class Receivers : Tea.TeaModel {
            public var extension_: String?

            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("ReceiverType") {
                    self.receiverType = dict["ReceiverType"] as! String
                }
                if dict.keys.contains("ReceiverValues") {
                    self.receiverValues = dict["ReceiverValues"] as! [String]
                }
            }
        }
        public var channels: [String]?

        public var intervalInMinutes: Int32?

        public var maximum: Int32?

        public var receivers: [CreateAlertRuleRequest.Notification.Receivers]?

        public var silenceEndTime: String?

        public var silenceStartTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channels != nil {
                map["Channels"] = self.channels!
            }
            if self.intervalInMinutes != nil {
                map["IntervalInMinutes"] = self.intervalInMinutes!
            }
            if self.maximum != nil {
                map["Maximum"] = self.maximum!
            }
            if self.receivers != nil {
                var tmp : [Any] = []
                for k in self.receivers! {
                    tmp.append(k.toMap())
                }
                map["Receivers"] = tmp
            }
            if self.silenceEndTime != nil {
                map["SilenceEndTime"] = self.silenceEndTime!
            }
            if self.silenceStartTime != nil {
                map["SilenceStartTime"] = self.silenceStartTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Channels") {
                self.channels = dict["Channels"] as! [String]
            }
            if dict.keys.contains("IntervalInMinutes") {
                self.intervalInMinutes = dict["IntervalInMinutes"] as! Int32
            }
            if dict.keys.contains("Maximum") {
                self.maximum = dict["Maximum"] as! Int32
            }
            if dict.keys.contains("Receivers") {
                var tmp : [CreateAlertRuleRequest.Notification.Receivers] = []
                for v in dict["Receivers"] as! [Any] {
                    var model = CreateAlertRuleRequest.Notification.Receivers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.receivers = tmp
            }
            if dict.keys.contains("SilenceEndTime") {
                self.silenceEndTime = dict["SilenceEndTime"] as! String
            }
            if dict.keys.contains("SilenceStartTime") {
                self.silenceStartTime = dict["SilenceStartTime"] as! String
            }
        }
    }
    public class TriggerCondition : Tea.TeaModel {
        public class Extension_ : Tea.TeaModel {
            public class CycleUnfinished : Tea.TeaModel {
                public class CycleAndTime : Tea.TeaModel {
                    public var cycleId: Int32?

                    public var time: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleId != nil {
                            map["CycleId"] = self.cycleId!
                        }
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CycleId") {
                            self.cycleId = dict["CycleId"] as! Int32
                        }
                        if dict.keys.contains("Time") {
                            self.time = dict["Time"] as! String
                        }
                    }
                }
                public var cycleAndTime: [CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleAndTime != nil {
                        var tmp : [Any] = []
                        for k in self.cycleAndTime! {
                            tmp.append(k.toMap())
                        }
                        map["CycleAndTime"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CycleAndTime") {
                        var tmp : [CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime] = []
                        for v in dict["CycleAndTime"] as! [Any] {
                            var model = CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.cycleAndTime = tmp
                    }
                }
            }
            public class Error : Tea.TeaModel {
                public var autoRerunAlert: Bool?

                public var streamTaskIds: [Int64]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoRerunAlert != nil {
                        map["AutoRerunAlert"] = self.autoRerunAlert!
                    }
                    if self.streamTaskIds != nil {
                        map["StreamTaskIds"] = self.streamTaskIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutoRerunAlert") {
                        self.autoRerunAlert = dict["AutoRerunAlert"] as! Bool
                    }
                    if dict.keys.contains("StreamTaskIds") {
                        self.streamTaskIds = dict["StreamTaskIds"] as! [Int64]
                    }
                }
            }
            public class InstanceErrorCount : Tea.TeaModel {
                public var count: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                }
            }
            public class InstanceErrorPercentage : Tea.TeaModel {
                public var percentage: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Percentage") {
                        self.percentage = dict["Percentage"] as! Int32
                    }
                }
            }
            public class InstanceTransferFluctuate : Tea.TeaModel {
                public var percentage: Int32?

                public var trend: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    if self.trend != nil {
                        map["Trend"] = self.trend!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Percentage") {
                        self.percentage = dict["Percentage"] as! Int32
                    }
                    if dict.keys.contains("Trend") {
                        self.trend = dict["Trend"] as! String
                    }
                }
            }
            public class Timeout : Tea.TeaModel {
                public var timeoutInMinutes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.timeoutInMinutes != nil {
                        map["TimeoutInMinutes"] = self.timeoutInMinutes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TimeoutInMinutes") {
                        self.timeoutInMinutes = dict["TimeoutInMinutes"] as! Int32
                    }
                }
            }
            public class UnFinished : Tea.TeaModel {
                public var unFinishedTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.unFinishedTime != nil {
                        map["UnFinishedTime"] = self.unFinishedTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("UnFinishedTime") {
                        self.unFinishedTime = dict["UnFinishedTime"] as! String
                    }
                }
            }
            public var cycleUnfinished: CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished?

            public var error: CreateAlertRuleRequest.TriggerCondition.Extension_.Error?

            public var instanceErrorCount: CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorCount?

            public var instanceErrorPercentage: CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorPercentage?

            public var instanceTransferFluctuate: CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceTransferFluctuate?

            public var timeout: CreateAlertRuleRequest.TriggerCondition.Extension_.Timeout?

            public var unFinished: CreateAlertRuleRequest.TriggerCondition.Extension_.UnFinished?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cycleUnfinished?.validate()
                try self.error?.validate()
                try self.instanceErrorCount?.validate()
                try self.instanceErrorPercentage?.validate()
                try self.instanceTransferFluctuate?.validate()
                try self.timeout?.validate()
                try self.unFinished?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleUnfinished != nil {
                    map["CycleUnfinished"] = self.cycleUnfinished?.toMap()
                }
                if self.error != nil {
                    map["Error"] = self.error?.toMap()
                }
                if self.instanceErrorCount != nil {
                    map["InstanceErrorCount"] = self.instanceErrorCount?.toMap()
                }
                if self.instanceErrorPercentage != nil {
                    map["InstanceErrorPercentage"] = self.instanceErrorPercentage?.toMap()
                }
                if self.instanceTransferFluctuate != nil {
                    map["InstanceTransferFluctuate"] = self.instanceTransferFluctuate?.toMap()
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout?.toMap()
                }
                if self.unFinished != nil {
                    map["UnFinished"] = self.unFinished?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleUnfinished") {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished()
                    model.fromMap(dict["CycleUnfinished"] as! [String: Any])
                    self.cycleUnfinished = model
                }
                if dict.keys.contains("Error") {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.Error()
                    model.fromMap(dict["Error"] as! [String: Any])
                    self.error = model
                }
                if dict.keys.contains("InstanceErrorCount") {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorCount()
                    model.fromMap(dict["InstanceErrorCount"] as! [String: Any])
                    self.instanceErrorCount = model
                }
                if dict.keys.contains("InstanceErrorPercentage") {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorPercentage()
                    model.fromMap(dict["InstanceErrorPercentage"] as! [String: Any])
                    self.instanceErrorPercentage = model
                }
                if dict.keys.contains("InstanceTransferFluctuate") {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.InstanceTransferFluctuate()
                    model.fromMap(dict["InstanceTransferFluctuate"] as! [String: Any])
                    self.instanceTransferFluctuate = model
                }
                if dict.keys.contains("Timeout") {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.Timeout()
                    model.fromMap(dict["Timeout"] as! [String: Any])
                    self.timeout = model
                }
                if dict.keys.contains("UnFinished") {
                    var model = CreateAlertRuleRequest.TriggerCondition.Extension_.UnFinished()
                    model.fromMap(dict["UnFinished"] as! [String: Any])
                    self.unFinished = model
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var allowTasks: [Int64]?

            public var ids: [Int64]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowTasks != nil {
                    map["AllowTasks"] = self.allowTasks!
                }
                if self.ids != nil {
                    map["Ids"] = self.ids!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowTasks") {
                    self.allowTasks = dict["AllowTasks"] as! [Int64]
                }
                if dict.keys.contains("Ids") {
                    self.ids = dict["Ids"] as! [Int64]
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var extension_: CreateAlertRuleRequest.TriggerCondition.Extension_?

        public var target: CreateAlertRuleRequest.TriggerCondition.Target?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extension_?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_?.toMap()
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extension") {
                var model = CreateAlertRuleRequest.TriggerCondition.Extension_()
                model.fromMap(dict["Extension"] as! [String: Any])
                self.extension_ = model
            }
            if dict.keys.contains("Target") {
                var model = CreateAlertRuleRequest.TriggerCondition.Target()
                model.fromMap(dict["Target"] as! [String: Any])
                self.target = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var enabled: Bool?

    public var name: String?

    public var notification: CreateAlertRuleRequest.Notification?

    public var owner: String?

    public var triggerCondition: CreateAlertRuleRequest.TriggerCondition?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notification?.validate()
        try self.triggerCondition?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notification != nil {
            map["Notification"] = self.notification?.toMap()
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.triggerCondition != nil {
            map["TriggerCondition"] = self.triggerCondition?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notification") {
            var model = CreateAlertRuleRequest.Notification()
            model.fromMap(dict["Notification"] as! [String: Any])
            self.notification = model
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("TriggerCondition") {
            var model = CreateAlertRuleRequest.TriggerCondition()
            model.fromMap(dict["TriggerCondition"] as! [String: Any])
            self.triggerCondition = model
        }
    }
}

public class CreateAlertRuleShrinkRequest : Tea.TeaModel {
    public var enabled: Bool?

    public var name: String?

    public var notificationShrink: String?

    public var owner: String?

    public var triggerConditionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationShrink != nil {
            map["Notification"] = self.notificationShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.triggerConditionShrink != nil {
            map["TriggerCondition"] = self.triggerConditionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notification") {
            self.notificationShrink = dict["Notification"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("TriggerCondition") {
            self.triggerConditionShrink = dict["TriggerCondition"] as! String
        }
    }
}

public class CreateAlertRuleResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDIAlarmRuleRequest : Tea.TeaModel {
    public class NotificationSettings : Tea.TeaModel {
        public class NotificationChannels : Tea.TeaModel {
            public var channels: [String]?

            public var severity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! [String]
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
            }
        }
        public class NotificationReceivers : Tea.TeaModel {
            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReceiverType") {
                    self.receiverType = dict["ReceiverType"] as! String
                }
                if dict.keys.contains("ReceiverValues") {
                    self.receiverValues = dict["ReceiverValues"] as! [String]
                }
            }
        }
        public var inhibitionInterval: Int32?

        public var notificationChannels: [CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels]?

        public var notificationReceivers: [CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inhibitionInterval != nil {
                map["InhibitionInterval"] = self.inhibitionInterval!
            }
            if self.notificationChannels != nil {
                var tmp : [Any] = []
                for k in self.notificationChannels! {
                    tmp.append(k.toMap())
                }
                map["NotificationChannels"] = tmp
            }
            if self.notificationReceivers != nil {
                var tmp : [Any] = []
                for k in self.notificationReceivers! {
                    tmp.append(k.toMap())
                }
                map["NotificationReceivers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InhibitionInterval") {
                self.inhibitionInterval = dict["InhibitionInterval"] as! Int32
            }
            if dict.keys.contains("NotificationChannels") {
                var tmp : [CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels] = []
                for v in dict["NotificationChannels"] as! [Any] {
                    var model = CreateDIAlarmRuleRequest.NotificationSettings.NotificationChannels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationChannels = tmp
            }
            if dict.keys.contains("NotificationReceivers") {
                var tmp : [CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers] = []
                for v in dict["NotificationReceivers"] as! [Any] {
                    var model = CreateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationReceivers = tmp
            }
        }
    }
    public class TriggerConditions : Tea.TeaModel {
        public var ddlReportTags: [String]?

        public var duration: Int64?

        public var severity: String?

        public var threshold: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ddlReportTags != nil {
                map["DdlReportTags"] = self.ddlReportTags!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DdlReportTags") {
                self.ddlReportTags = dict["DdlReportTags"] as! [String]
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Severity") {
                self.severity = dict["Severity"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Int64
            }
        }
    }
    public var clientToken: String?

    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var name: String?

    public var notificationSettings: CreateDIAlarmRuleRequest.NotificationSettings?

    public var triggerConditions: [CreateDIAlarmRuleRequest.TriggerConditions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationSettings != nil {
            map["NotificationSettings"] = self.notificationSettings?.toMap()
        }
        if self.triggerConditions != nil {
            var tmp : [Any] = []
            for k in self.triggerConditions! {
                tmp.append(k.toMap())
            }
            map["TriggerConditions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotificationSettings") {
            var model = CreateDIAlarmRuleRequest.NotificationSettings()
            model.fromMap(dict["NotificationSettings"] as! [String: Any])
            self.notificationSettings = model
        }
        if dict.keys.contains("TriggerConditions") {
            var tmp : [CreateDIAlarmRuleRequest.TriggerConditions] = []
            for v in dict["TriggerConditions"] as! [Any] {
                var model = CreateDIAlarmRuleRequest.TriggerConditions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.triggerConditions = tmp
        }
    }
}

public class CreateDIAlarmRuleShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var name: String?

    public var notificationSettingsShrink: String?

    public var triggerConditionsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationSettingsShrink != nil {
            map["NotificationSettings"] = self.notificationSettingsShrink!
        }
        if self.triggerConditionsShrink != nil {
            map["TriggerConditions"] = self.triggerConditionsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotificationSettings") {
            self.notificationSettingsShrink = dict["NotificationSettings"] as! String
        }
        if dict.keys.contains("TriggerConditions") {
            self.triggerConditionsShrink = dict["TriggerConditions"] as! String
        }
    }
}

public class CreateDIAlarmRuleResponseBody : Tea.TeaModel {
    public var DIAlarmRuleId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDIAlarmRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDIJobRequest : Tea.TeaModel {
    public class DestinationDataSourceSettings : Tea.TeaModel {
        public var dataSourceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceName != nil {
                map["DataSourceName"] = self.dataSourceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSourceName") {
                self.dataSourceName = dict["DataSourceName"] as! String
            }
        }
    }
    public class JobSettings : Tea.TeaModel {
        public class ColumnDataTypeSettings : Tea.TeaModel {
            public var destinationDataType: String?

            public var sourceDataType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDataType != nil {
                    map["DestinationDataType"] = self.destinationDataType!
                }
                if self.sourceDataType != nil {
                    map["SourceDataType"] = self.sourceDataType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestinationDataType") {
                    self.destinationDataType = dict["DestinationDataType"] as! String
                }
                if dict.keys.contains("SourceDataType") {
                    self.sourceDataType = dict["SourceDataType"] as! String
                }
            }
        }
        public class CycleScheduleSettings : Tea.TeaModel {
            public var cycleMigrationType: String?

            public var scheduleParameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleMigrationType != nil {
                    map["CycleMigrationType"] = self.cycleMigrationType!
                }
                if self.scheduleParameters != nil {
                    map["ScheduleParameters"] = self.scheduleParameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleMigrationType") {
                    self.cycleMigrationType = dict["CycleMigrationType"] as! String
                }
                if dict.keys.contains("ScheduleParameters") {
                    self.scheduleParameters = dict["ScheduleParameters"] as! String
                }
            }
        }
        public class DdlHandlingSettings : Tea.TeaModel {
            public var action: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class RuntimeSettings : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var channelSettings: String?

        public var columnDataTypeSettings: [CreateDIJobRequest.JobSettings.ColumnDataTypeSettings]?

        public var cycleScheduleSettings: CreateDIJobRequest.JobSettings.CycleScheduleSettings?

        public var ddlHandlingSettings: [CreateDIJobRequest.JobSettings.DdlHandlingSettings]?

        public var runtimeSettings: [CreateDIJobRequest.JobSettings.RuntimeSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cycleScheduleSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelSettings != nil {
                map["ChannelSettings"] = self.channelSettings!
            }
            if self.columnDataTypeSettings != nil {
                var tmp : [Any] = []
                for k in self.columnDataTypeSettings! {
                    tmp.append(k.toMap())
                }
                map["ColumnDataTypeSettings"] = tmp
            }
            if self.cycleScheduleSettings != nil {
                map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
            }
            if self.ddlHandlingSettings != nil {
                var tmp : [Any] = []
                for k in self.ddlHandlingSettings! {
                    tmp.append(k.toMap())
                }
                map["DdlHandlingSettings"] = tmp
            }
            if self.runtimeSettings != nil {
                var tmp : [Any] = []
                for k in self.runtimeSettings! {
                    tmp.append(k.toMap())
                }
                map["RuntimeSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelSettings") {
                self.channelSettings = dict["ChannelSettings"] as! String
            }
            if dict.keys.contains("ColumnDataTypeSettings") {
                var tmp : [CreateDIJobRequest.JobSettings.ColumnDataTypeSettings] = []
                for v in dict["ColumnDataTypeSettings"] as! [Any] {
                    var model = CreateDIJobRequest.JobSettings.ColumnDataTypeSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columnDataTypeSettings = tmp
            }
            if dict.keys.contains("CycleScheduleSettings") {
                var model = CreateDIJobRequest.JobSettings.CycleScheduleSettings()
                model.fromMap(dict["CycleScheduleSettings"] as! [String: Any])
                self.cycleScheduleSettings = model
            }
            if dict.keys.contains("DdlHandlingSettings") {
                var tmp : [CreateDIJobRequest.JobSettings.DdlHandlingSettings] = []
                for v in dict["DdlHandlingSettings"] as! [Any] {
                    var model = CreateDIJobRequest.JobSettings.DdlHandlingSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ddlHandlingSettings = tmp
            }
            if dict.keys.contains("RuntimeSettings") {
                var tmp : [CreateDIJobRequest.JobSettings.RuntimeSettings] = []
                for v in dict["RuntimeSettings"] as! [Any] {
                    var model = CreateDIJobRequest.JobSettings.RuntimeSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.runtimeSettings = tmp
            }
        }
    }
    public class ResourceSettings : Tea.TeaModel {
        public class OfflineResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestedCu") {
                    self.requestedCu = dict["RequestedCu"] as! Double
                }
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public class RealtimeResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestedCu") {
                    self.requestedCu = dict["RequestedCu"] as! Double
                }
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public class ScheduleResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestedCu") {
                    self.requestedCu = dict["RequestedCu"] as! Double
                }
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public var offlineResourceSettings: CreateDIJobRequest.ResourceSettings.OfflineResourceSettings?

        public var realtimeResourceSettings: CreateDIJobRequest.ResourceSettings.RealtimeResourceSettings?

        public var scheduleResourceSettings: CreateDIJobRequest.ResourceSettings.ScheduleResourceSettings?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.offlineResourceSettings?.validate()
            try self.realtimeResourceSettings?.validate()
            try self.scheduleResourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.offlineResourceSettings != nil {
                map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
            }
            if self.realtimeResourceSettings != nil {
                map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
            }
            if self.scheduleResourceSettings != nil {
                map["ScheduleResourceSettings"] = self.scheduleResourceSettings?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OfflineResourceSettings") {
                var model = CreateDIJobRequest.ResourceSettings.OfflineResourceSettings()
                model.fromMap(dict["OfflineResourceSettings"] as! [String: Any])
                self.offlineResourceSettings = model
            }
            if dict.keys.contains("RealtimeResourceSettings") {
                var model = CreateDIJobRequest.ResourceSettings.RealtimeResourceSettings()
                model.fromMap(dict["RealtimeResourceSettings"] as! [String: Any])
                self.realtimeResourceSettings = model
            }
            if dict.keys.contains("ScheduleResourceSettings") {
                var model = CreateDIJobRequest.ResourceSettings.ScheduleResourceSettings()
                model.fromMap(dict["ScheduleResourceSettings"] as! [String: Any])
                self.scheduleResourceSettings = model
            }
        }
    }
    public class SourceDataSourceSettings : Tea.TeaModel {
        public class DataSourceProperties : Tea.TeaModel {
            public var encoding: String?

            public var timezone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.encoding != nil {
                    map["Encoding"] = self.encoding!
                }
                if self.timezone != nil {
                    map["Timezone"] = self.timezone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Encoding") {
                    self.encoding = dict["Encoding"] as! String
                }
                if dict.keys.contains("Timezone") {
                    self.timezone = dict["Timezone"] as! String
                }
            }
        }
        public var dataSourceName: String?

        public var dataSourceProperties: CreateDIJobRequest.SourceDataSourceSettings.DataSourceProperties?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSourceProperties?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSourceName != nil {
                map["DataSourceName"] = self.dataSourceName!
            }
            if self.dataSourceProperties != nil {
                map["DataSourceProperties"] = self.dataSourceProperties?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSourceName") {
                self.dataSourceName = dict["DataSourceName"] as! String
            }
            if dict.keys.contains("DataSourceProperties") {
                var model = CreateDIJobRequest.SourceDataSourceSettings.DataSourceProperties()
                model.fromMap(dict["DataSourceProperties"] as! [String: Any])
                self.dataSourceProperties = model
            }
        }
    }
    public class TableMappings : Tea.TeaModel {
        public class SourceObjectSelectionRules : Tea.TeaModel {
            public var action: String?

            public var expression: String?

            public var expressionType: String?

            public var objectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.expressionType != nil {
                    map["ExpressionType"] = self.expressionType!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("Expression") {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("ExpressionType") {
                    self.expressionType = dict["ExpressionType"] as! String
                }
                if dict.keys.contains("ObjectType") {
                    self.objectType = dict["ObjectType"] as! String
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RuleActionType") {
                    self.ruleActionType = dict["RuleActionType"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("RuleTargetType") {
                    self.ruleTargetType = dict["RuleTargetType"] as! String
                }
            }
        }
        public var sourceObjectSelectionRules: [CreateDIJobRequest.TableMappings.SourceObjectSelectionRules]?

        public var transformationRules: [CreateDIJobRequest.TableMappings.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceObjectSelectionRules != nil {
                var tmp : [Any] = []
                for k in self.sourceObjectSelectionRules! {
                    tmp.append(k.toMap())
                }
                map["SourceObjectSelectionRules"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SourceObjectSelectionRules") {
                var tmp : [CreateDIJobRequest.TableMappings.SourceObjectSelectionRules] = []
                for v in dict["SourceObjectSelectionRules"] as! [Any] {
                    var model = CreateDIJobRequest.TableMappings.SourceObjectSelectionRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sourceObjectSelectionRules = tmp
            }
            if dict.keys.contains("TransformationRules") {
                var tmp : [CreateDIJobRequest.TableMappings.TransformationRules] = []
                for v in dict["TransformationRules"] as! [Any] {
                    var model = CreateDIJobRequest.TableMappings.TransformationRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transformationRules = tmp
            }
        }
    }
    public class TransformationRules : Tea.TeaModel {
        public var ruleActionType: String?

        public var ruleExpression: String?

        public var ruleName: String?

        public var ruleTargetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleActionType != nil {
                map["RuleActionType"] = self.ruleActionType!
            }
            if self.ruleExpression != nil {
                map["RuleExpression"] = self.ruleExpression!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleTargetType != nil {
                map["RuleTargetType"] = self.ruleTargetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleActionType") {
                self.ruleActionType = dict["RuleActionType"] as! String
            }
            if dict.keys.contains("RuleExpression") {
                self.ruleExpression = dict["RuleExpression"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleTargetType") {
                self.ruleTargetType = dict["RuleTargetType"] as! String
            }
        }
    }
    public var description_: String?

    public var destinationDataSourceSettings: [CreateDIJobRequest.DestinationDataSourceSettings]?

    public var destinationDataSourceType: String?

    public var jobName: String?

    public var jobSettings: CreateDIJobRequest.JobSettings?

    public var migrationType: String?

    public var projectId: Int64?

    public var resourceSettings: CreateDIJobRequest.ResourceSettings?

    public var sourceDataSourceSettings: [CreateDIJobRequest.SourceDataSourceSettings]?

    public var sourceDataSourceType: String?

    public var tableMappings: [CreateDIJobRequest.TableMappings]?

    public var transformationRules: [CreateDIJobRequest.TransformationRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobSettings?.validate()
        try self.resourceSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationDataSourceSettings != nil {
            var tmp : [Any] = []
            for k in self.destinationDataSourceSettings! {
                tmp.append(k.toMap())
            }
            map["DestinationDataSourceSettings"] = tmp
        }
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobSettings != nil {
            map["JobSettings"] = self.jobSettings?.toMap()
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettings != nil {
            map["ResourceSettings"] = self.resourceSettings?.toMap()
        }
        if self.sourceDataSourceSettings != nil {
            var tmp : [Any] = []
            for k in self.sourceDataSourceSettings! {
                tmp.append(k.toMap())
            }
            map["SourceDataSourceSettings"] = tmp
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        if self.tableMappings != nil {
            var tmp : [Any] = []
            for k in self.tableMappings! {
                tmp.append(k.toMap())
            }
            map["TableMappings"] = tmp
        }
        if self.transformationRules != nil {
            var tmp : [Any] = []
            for k in self.transformationRules! {
                tmp.append(k.toMap())
            }
            map["TransformationRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationDataSourceSettings") {
            var tmp : [CreateDIJobRequest.DestinationDataSourceSettings] = []
            for v in dict["DestinationDataSourceSettings"] as! [Any] {
                var model = CreateDIJobRequest.DestinationDataSourceSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.destinationDataSourceSettings = tmp
        }
        if dict.keys.contains("DestinationDataSourceType") {
            self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("JobSettings") {
            var model = CreateDIJobRequest.JobSettings()
            model.fromMap(dict["JobSettings"] as! [String: Any])
            self.jobSettings = model
        }
        if dict.keys.contains("MigrationType") {
            self.migrationType = dict["MigrationType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceSettings") {
            var model = CreateDIJobRequest.ResourceSettings()
            model.fromMap(dict["ResourceSettings"] as! [String: Any])
            self.resourceSettings = model
        }
        if dict.keys.contains("SourceDataSourceSettings") {
            var tmp : [CreateDIJobRequest.SourceDataSourceSettings] = []
            for v in dict["SourceDataSourceSettings"] as! [Any] {
                var model = CreateDIJobRequest.SourceDataSourceSettings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sourceDataSourceSettings = tmp
        }
        if dict.keys.contains("SourceDataSourceType") {
            self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
        }
        if dict.keys.contains("TableMappings") {
            var tmp : [CreateDIJobRequest.TableMappings] = []
            for v in dict["TableMappings"] as! [Any] {
                var model = CreateDIJobRequest.TableMappings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tableMappings = tmp
        }
        if dict.keys.contains("TransformationRules") {
            var tmp : [CreateDIJobRequest.TransformationRules] = []
            for v in dict["TransformationRules"] as! [Any] {
                var model = CreateDIJobRequest.TransformationRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transformationRules = tmp
        }
    }
}

public class CreateDIJobShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var destinationDataSourceSettingsShrink: String?

    public var destinationDataSourceType: String?

    public var jobName: String?

    public var jobSettingsShrink: String?

    public var migrationType: String?

    public var projectId: Int64?

    public var resourceSettingsShrink: String?

    public var sourceDataSourceSettingsShrink: String?

    public var sourceDataSourceType: String?

    public var tableMappingsShrink: String?

    public var transformationRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destinationDataSourceSettingsShrink != nil {
            map["DestinationDataSourceSettings"] = self.destinationDataSourceSettingsShrink!
        }
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobSettingsShrink != nil {
            map["JobSettings"] = self.jobSettingsShrink!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettingsShrink != nil {
            map["ResourceSettings"] = self.resourceSettingsShrink!
        }
        if self.sourceDataSourceSettingsShrink != nil {
            map["SourceDataSourceSettings"] = self.sourceDataSourceSettingsShrink!
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        if self.tableMappingsShrink != nil {
            map["TableMappings"] = self.tableMappingsShrink!
        }
        if self.transformationRulesShrink != nil {
            map["TransformationRules"] = self.transformationRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestinationDataSourceSettings") {
            self.destinationDataSourceSettingsShrink = dict["DestinationDataSourceSettings"] as! String
        }
        if dict.keys.contains("DestinationDataSourceType") {
            self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("JobSettings") {
            self.jobSettingsShrink = dict["JobSettings"] as! String
        }
        if dict.keys.contains("MigrationType") {
            self.migrationType = dict["MigrationType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceSettings") {
            self.resourceSettingsShrink = dict["ResourceSettings"] as! String
        }
        if dict.keys.contains("SourceDataSourceSettings") {
            self.sourceDataSourceSettingsShrink = dict["SourceDataSourceSettings"] as! String
        }
        if dict.keys.contains("SourceDataSourceType") {
            self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
        }
        if dict.keys.contains("TableMappings") {
            self.tableMappingsShrink = dict["TableMappings"] as! String
        }
        if dict.keys.contains("TransformationRules") {
            self.transformationRulesShrink = dict["TransformationRules"] as! String
        }
    }
}

public class CreateDIJobResponseBody : Tea.TeaModel {
    public var DIJobId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataQualityEvaluationTaskRequest : Tea.TeaModel {
    public class DataQualityRules : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public class Thresholds : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Expected : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Warned : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var critical: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Critical?

                public var expected: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Expected?

                public var warned: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Warned?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.expected?.validate()
                    try self.warned?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.expected != nil {
                        map["Expected"] = self.expected?.toMap()
                    }
                    if self.warned != nil {
                        map["Warned"] = self.warned?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Critical") {
                        var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Critical()
                        model.fromMap(dict["Critical"] as! [String: Any])
                        self.critical = model
                    }
                    if dict.keys.contains("Expected") {
                        var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Expected()
                        model.fromMap(dict["Expected"] as! [String: Any])
                        self.expected = model
                    }
                    if dict.keys.contains("Warned") {
                        var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Warned()
                        model.fromMap(dict["Warned"] as! [String: Any])
                        self.warned = model
                    }
                }
            }
            public var referencedSamplesFilter: String?

            public var thresholds: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.thresholds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.thresholds != nil {
                    map["Thresholds"] = self.thresholds?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReferencedSamplesFilter") {
                    self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
                }
                if dict.keys.contains("Thresholds") {
                    var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds()
                    model.fromMap(dict["Thresholds"] as! [String: Any])
                    self.thresholds = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ErrorHandlers : Tea.TeaModel {
            public var errorDataFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorDataFilter != nil {
                    map["ErrorDataFilter"] = self.errorDataFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorDataFilter") {
                    self.errorDataFilter = dict["ErrorDataFilter"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var samplingFilter: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.samplingFilter != nil {
                    map["SamplingFilter"] = self.samplingFilter!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Metric") {
                    self.metric = dict["Metric"] as! String
                }
                if dict.keys.contains("MetricParameters") {
                    self.metricParameters = dict["MetricParameters"] as! String
                }
                if dict.keys.contains("SamplingFilter") {
                    self.samplingFilter = dict["SamplingFilter"] as! String
                }
                if dict.keys.contains("SettingConfig") {
                    self.settingConfig = dict["SettingConfig"] as! String
                }
            }
        }
        public var checkingConfig: CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig?

        public var description_: String?

        public var enabled: Bool?

        public var errorHandlers: [CreateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers]?

        public var id: Int64?

        public var name: String?

        public var samplingConfig: CreateDataQualityEvaluationTaskRequest.DataQualityRules.SamplingConfig?

        public var severity: String?

        public var templateCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.errorHandlers != nil {
                var tmp : [Any] = []
                for k in self.errorHandlers! {
                    tmp.append(k.toMap())
                }
                map["ErrorHandlers"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.templateCode != nil {
                map["TemplateCode"] = self.templateCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckingConfig") {
                var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig()
                model.fromMap(dict["CheckingConfig"] as! [String: Any])
                self.checkingConfig = model
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("ErrorHandlers") {
                var tmp : [CreateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers] = []
                for v in dict["ErrorHandlers"] as! [Any] {
                    var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorHandlers = tmp
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SamplingConfig") {
                var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules.SamplingConfig()
                model.fromMap(dict["SamplingConfig"] as! [String: Any])
                self.samplingConfig = model
            }
            if dict.keys.contains("Severity") {
                self.severity = dict["Severity"] as! String
            }
            if dict.keys.contains("TemplateCode") {
                self.templateCode = dict["TemplateCode"] as! String
            }
        }
    }
    public class Hooks : Tea.TeaModel {
        public var condition: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Notifications : Tea.TeaModel {
        public class Notifications : Tea.TeaModel {
            public class NotificationChannels : Tea.TeaModel {
                public var channels: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! [String]
                    }
                }
            }
            public class NotificationReceivers : Tea.TeaModel {
                public var extension_: String?

                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Extension") {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("ReceiverType") {
                        self.receiverType = dict["ReceiverType"] as! String
                    }
                    if dict.keys.contains("ReceiverValues") {
                        self.receiverValues = dict["ReceiverValues"] as! [String]
                    }
                }
            }
            public var notificationChannels: [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels]?

            public var notificationReceivers: [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notificationChannels != nil {
                    var tmp : [Any] = []
                    for k in self.notificationChannels! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationChannels"] = tmp
                }
                if self.notificationReceivers != nil {
                    var tmp : [Any] = []
                    for k in self.notificationReceivers! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationReceivers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NotificationChannels") {
                    var tmp : [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels] = []
                    for v in dict["NotificationChannels"] as! [Any] {
                        var model = CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notificationChannels = tmp
                }
                if dict.keys.contains("NotificationReceivers") {
                    var tmp : [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers] = []
                    for v in dict["NotificationReceivers"] as! [Any] {
                        var model = CreateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notificationReceivers = tmp
                }
            }
        }
        public var condition: String?

        public var notifications: [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.notifications != nil {
                var tmp : [Any] = []
                for k in self.notifications! {
                    tmp.append(k.toMap())
                }
                map["Notifications"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Notifications") {
                var tmp : [CreateDataQualityEvaluationTaskRequest.Notifications.Notifications] = []
                for v in dict["Notifications"] as! [Any] {
                    var model = CreateDataQualityEvaluationTaskRequest.Notifications.Notifications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifications = tmp
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseType") {
                self.databaseType = dict["DatabaseType"] as! String
            }
            if dict.keys.contains("PartitionSpec") {
                self.partitionSpec = dict["PartitionSpec"] as! String
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
        }
    }
    public class Trigger : Tea.TeaModel {
        public var taskIds: [Int64]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskIds") {
                self.taskIds = dict["TaskIds"] as! [Int64]
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var dataQualityRules: [CreateDataQualityEvaluationTaskRequest.DataQualityRules]?

    public var dataSourceId: Int64?

    public var description_: String?

    public var hooks: [CreateDataQualityEvaluationTaskRequest.Hooks]?

    public var name: String?

    public var notifications: CreateDataQualityEvaluationTaskRequest.Notifications?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var target: CreateDataQualityEvaluationTaskRequest.Target?

    public var trigger: CreateDataQualityEvaluationTaskRequest.Trigger?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifications?.validate()
        try self.target?.validate()
        try self.trigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRules != nil {
            var tmp : [Any] = []
            for k in self.dataQualityRules! {
                tmp.append(k.toMap())
            }
            map["DataQualityRules"] = tmp
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooks != nil {
            var tmp : [Any] = []
            for k in self.hooks! {
                tmp.append(k.toMap())
            }
            map["Hooks"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifications != nil {
            map["Notifications"] = self.notifications?.toMap()
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.trigger != nil {
            map["Trigger"] = self.trigger?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityRules") {
            var tmp : [CreateDataQualityEvaluationTaskRequest.DataQualityRules] = []
            for v in dict["DataQualityRules"] as! [Any] {
                var model = CreateDataQualityEvaluationTaskRequest.DataQualityRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataQualityRules = tmp
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Hooks") {
            var tmp : [CreateDataQualityEvaluationTaskRequest.Hooks] = []
            for v in dict["Hooks"] as! [Any] {
                var model = CreateDataQualityEvaluationTaskRequest.Hooks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hooks = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notifications") {
            var model = CreateDataQualityEvaluationTaskRequest.Notifications()
            model.fromMap(dict["Notifications"] as! [String: Any])
            self.notifications = model
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeConf") {
            self.runtimeConf = dict["RuntimeConf"] as! String
        }
        if dict.keys.contains("Target") {
            var model = CreateDataQualityEvaluationTaskRequest.Target()
            model.fromMap(dict["Target"] as! [String: Any])
            self.target = model
        }
        if dict.keys.contains("Trigger") {
            var model = CreateDataQualityEvaluationTaskRequest.Trigger()
            model.fromMap(dict["Trigger"] as! [String: Any])
            self.trigger = model
        }
    }
}

public class CreateDataQualityEvaluationTaskShrinkRequest : Tea.TeaModel {
    public var dataQualityRulesShrink: String?

    public var dataSourceId: Int64?

    public var description_: String?

    public var hooksShrink: String?

    public var name: String?

    public var notificationsShrink: String?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var targetShrink: String?

    public var triggerShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRulesShrink != nil {
            map["DataQualityRules"] = self.dataQualityRulesShrink!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooksShrink != nil {
            map["Hooks"] = self.hooksShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationsShrink != nil {
            map["Notifications"] = self.notificationsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.targetShrink != nil {
            map["Target"] = self.targetShrink!
        }
        if self.triggerShrink != nil {
            map["Trigger"] = self.triggerShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityRules") {
            self.dataQualityRulesShrink = dict["DataQualityRules"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Hooks") {
            self.hooksShrink = dict["Hooks"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notifications") {
            self.notificationsShrink = dict["Notifications"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeConf") {
            self.runtimeConf = dict["RuntimeConf"] as! String
        }
        if dict.keys.contains("Target") {
            self.targetShrink = dict["Target"] as! String
        }
        if dict.keys.contains("Trigger") {
            self.triggerShrink = dict["Trigger"] as! String
        }
    }
}

public class CreateDataQualityEvaluationTaskResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDataQualityEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataQualityEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataQualityEvaluationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataQualityEvaluationTaskInstanceRequest : Tea.TeaModel {
    public class RuntimeResource : Tea.TeaModel {
        public var cu: Double?

        public var resourceGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cu != nil {
                map["Cu"] = self.cu!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cu") {
                self.cu = dict["Cu"] as! Double
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
        }
    }
    public var dataQualityEvaluationTaskId: Int64?

    public var parameters: String?

    public var projectId: Int64?

    public var runtimeResource: CreateDataQualityEvaluationTaskInstanceRequest.RuntimeResource?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.runtimeResource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityEvaluationTaskId") {
            self.dataQualityEvaluationTaskId = dict["DataQualityEvaluationTaskId"] as! Int64
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeResource") {
            var model = CreateDataQualityEvaluationTaskInstanceRequest.RuntimeResource()
            model.fromMap(dict["RuntimeResource"] as! [String: Any])
            self.runtimeResource = model
        }
    }
}

public class CreateDataQualityEvaluationTaskInstanceShrinkRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var parameters: String?

    public var projectId: Int64?

    public var runtimeResourceShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResourceShrink != nil {
            map["RuntimeResource"] = self.runtimeResourceShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityEvaluationTaskId") {
            self.dataQualityEvaluationTaskId = dict["DataQualityEvaluationTaskId"] as! Int64
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeResource") {
            self.runtimeResourceShrink = dict["RuntimeResource"] as! String
        }
    }
}

public class CreateDataQualityEvaluationTaskInstanceResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDataQualityEvaluationTaskInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataQualityEvaluationTaskInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataQualityEvaluationTaskInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataQualityRuleRequest : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public class Thresholds : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Expected : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Warned : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var critical: CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Critical?

            public var expected: CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Expected?

            public var warned: CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Warned?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.expected?.validate()
                try self.warned?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.expected != nil {
                    map["Expected"] = self.expected?.toMap()
                }
                if self.warned != nil {
                    map["Warned"] = self.warned?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Critical") {
                    var model = CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Critical()
                    model.fromMap(dict["Critical"] as! [String: Any])
                    self.critical = model
                }
                if dict.keys.contains("Expected") {
                    var model = CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Expected()
                    model.fromMap(dict["Expected"] as! [String: Any])
                    self.expected = model
                }
                if dict.keys.contains("Warned") {
                    var model = CreateDataQualityRuleRequest.CheckingConfig.Thresholds.Warned()
                    model.fromMap(dict["Warned"] as! [String: Any])
                    self.warned = model
                }
            }
        }
        public var referencedSamplesFilter: String?

        public var thresholds: CreateDataQualityRuleRequest.CheckingConfig.Thresholds?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.thresholds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.thresholds != nil {
                map["Thresholds"] = self.thresholds?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReferencedSamplesFilter") {
                self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
            }
            if dict.keys.contains("Thresholds") {
                var model = CreateDataQualityRuleRequest.CheckingConfig.Thresholds()
                model.fromMap(dict["Thresholds"] as! [String: Any])
                self.thresholds = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ErrorHandlers : Tea.TeaModel {
        public var errorDataFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorDataFilter != nil {
                map["ErrorDataFilter"] = self.errorDataFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorDataFilter") {
                self.errorDataFilter = dict["ErrorDataFilter"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var samplingFilter: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.samplingFilter != nil {
                map["SamplingFilter"] = self.samplingFilter!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metric") {
                self.metric = dict["Metric"] as! String
            }
            if dict.keys.contains("MetricParameters") {
                self.metricParameters = dict["MetricParameters"] as! String
            }
            if dict.keys.contains("SamplingFilter") {
                self.samplingFilter = dict["SamplingFilter"] as! String
            }
            if dict.keys.contains("SettingConfig") {
                self.settingConfig = dict["SettingConfig"] as! String
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseType") {
                self.databaseType = dict["DatabaseType"] as! String
            }
            if dict.keys.contains("PartitionSpec") {
                self.partitionSpec = dict["PartitionSpec"] as! String
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var checkingConfig: CreateDataQualityRuleRequest.CheckingConfig?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlers: [CreateDataQualityRuleRequest.ErrorHandlers]?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: CreateDataQualityRuleRequest.SamplingConfig?

    public var severity: String?

    public var target: CreateDataQualityRuleRequest.Target?

    public var templateCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
        try self.target?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlers != nil {
            var tmp : [Any] = []
            for k in self.errorHandlers! {
                tmp.append(k.toMap())
            }
            map["ErrorHandlers"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckingConfig") {
            var model = CreateDataQualityRuleRequest.CheckingConfig()
            model.fromMap(dict["CheckingConfig"] as! [String: Any])
            self.checkingConfig = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("ErrorHandlers") {
            var tmp : [CreateDataQualityRuleRequest.ErrorHandlers] = []
            for v in dict["ErrorHandlers"] as! [Any] {
                var model = CreateDataQualityRuleRequest.ErrorHandlers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.errorHandlers = tmp
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SamplingConfig") {
            var model = CreateDataQualityRuleRequest.SamplingConfig()
            model.fromMap(dict["SamplingConfig"] as! [String: Any])
            self.samplingConfig = model
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("Target") {
            var model = CreateDataQualityRuleRequest.Target()
            model.fromMap(dict["Target"] as! [String: Any])
            self.target = model
        }
        if dict.keys.contains("TemplateCode") {
            self.templateCode = dict["TemplateCode"] as! String
        }
    }
}

public class CreateDataQualityRuleShrinkRequest : Tea.TeaModel {
    public var checkingConfigShrink: String?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlersShrink: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfigShrink: String?

    public var severity: String?

    public var targetShrink: String?

    public var templateCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfigShrink != nil {
            map["CheckingConfig"] = self.checkingConfigShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlersShrink != nil {
            map["ErrorHandlers"] = self.errorHandlersShrink!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfigShrink != nil {
            map["SamplingConfig"] = self.samplingConfigShrink!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.targetShrink != nil {
            map["Target"] = self.targetShrink!
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckingConfig") {
            self.checkingConfigShrink = dict["CheckingConfig"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("ErrorHandlers") {
            self.errorHandlersShrink = dict["ErrorHandlers"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SamplingConfig") {
            self.samplingConfigShrink = dict["SamplingConfig"] as! String
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("Target") {
            self.targetShrink = dict["Target"] as! String
        }
        if dict.keys.contains("TemplateCode") {
            self.templateCode = dict["TemplateCode"] as! String
        }
    }
}

public class CreateDataQualityRuleResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDataQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataQualityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataQualityRuleTemplateRequest : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public var referencedSamplesFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReferencedSamplesFilter") {
                self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metric") {
                self.metric = dict["Metric"] as! String
            }
            if dict.keys.contains("MetricParameters") {
                self.metricParameters = dict["MetricParameters"] as! String
            }
            if dict.keys.contains("SettingConfig") {
                self.settingConfig = dict["SettingConfig"] as! String
            }
        }
    }
    public var checkingConfig: CreateDataQualityRuleTemplateRequest.CheckingConfig?

    public var directoryPath: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: CreateDataQualityRuleTemplateRequest.SamplingConfig?

    public var visibleScope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        if self.visibleScope != nil {
            map["VisibleScope"] = self.visibleScope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckingConfig") {
            var model = CreateDataQualityRuleTemplateRequest.CheckingConfig()
            model.fromMap(dict["CheckingConfig"] as! [String: Any])
            self.checkingConfig = model
        }
        if dict.keys.contains("DirectoryPath") {
            self.directoryPath = dict["DirectoryPath"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SamplingConfig") {
            var model = CreateDataQualityRuleTemplateRequest.SamplingConfig()
            model.fromMap(dict["SamplingConfig"] as! [String: Any])
            self.samplingConfig = model
        }
        if dict.keys.contains("VisibleScope") {
            self.visibleScope = dict["VisibleScope"] as! String
        }
    }
}

public class CreateDataQualityRuleTemplateShrinkRequest : Tea.TeaModel {
    public var checkingConfigShrink: String?

    public var directoryPath: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfigShrink: String?

    public var visibleScope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfigShrink != nil {
            map["CheckingConfig"] = self.checkingConfigShrink!
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfigShrink != nil {
            map["SamplingConfig"] = self.samplingConfigShrink!
        }
        if self.visibleScope != nil {
            map["VisibleScope"] = self.visibleScope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckingConfig") {
            self.checkingConfigShrink = dict["CheckingConfig"] as! String
        }
        if dict.keys.contains("DirectoryPath") {
            self.directoryPath = dict["DirectoryPath"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SamplingConfig") {
            self.samplingConfigShrink = dict["SamplingConfig"] as! String
        }
        if dict.keys.contains("VisibleScope") {
            self.visibleScope = dict["VisibleScope"] as! String
        }
    }
}

public class CreateDataQualityRuleTemplateResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDataQualityRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataQualityRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataQualityRuleTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataSourceRequest : Tea.TeaModel {
    public var connectionProperties: String?

    public var connectionPropertiesMode: String?

    public var description_: String?

    public var name: String?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionProperties != nil {
            map["ConnectionProperties"] = self.connectionProperties!
        }
        if self.connectionPropertiesMode != nil {
            map["ConnectionPropertiesMode"] = self.connectionPropertiesMode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionProperties") {
            self.connectionProperties = dict["ConnectionProperties"] as! String
        }
        if dict.keys.contains("ConnectionPropertiesMode") {
            self.connectionPropertiesMode = dict["ConnectionPropertiesMode"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateDataSourceResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataSourceSharedRuleRequest : Tea.TeaModel {
    public var dataSourceId: Int64?

    public var envType: String?

    public var sharedUser: String?

    public var targetProjectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.sharedUser != nil {
            map["SharedUser"] = self.sharedUser!
        }
        if self.targetProjectId != nil {
            map["TargetProjectId"] = self.targetProjectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! Int64
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("SharedUser") {
            self.sharedUser = dict["SharedUser"] as! String
        }
        if dict.keys.contains("TargetProjectId") {
            self.targetProjectId = dict["TargetProjectId"] as! Int64
        }
    }
}

public class CreateDataSourceSharedRuleResponseBody : Tea.TeaModel {
    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDataSourceSharedRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataSourceSharedRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataSourceSharedRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDeploymentRequest : Tea.TeaModel {
    public var description_: String?

    public var objectIds: [String]?

    public var projectId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.objectIds != nil {
            map["ObjectIds"] = self.objectIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ObjectIds") {
            self.objectIds = dict["ObjectIds"] as! [String]
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateDeploymentShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var objectIdsShrink: String?

    public var projectId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.objectIdsShrink != nil {
            map["ObjectIds"] = self.objectIdsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ObjectIds") {
            self.objectIdsShrink = dict["ObjectIds"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateDeploymentResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDeploymentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFunctionRequest : Tea.TeaModel {
    public var projectId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class CreateFunctionResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFunctionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var resourceGroupId: String?

    public var vpcId: String?

    public var vswitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vswitchId != nil {
            map["VswitchId"] = self.vswitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VswitchId") {
            self.vswitchId = dict["VswitchId"] as! String
        }
    }
}

public class CreateNetworkResponseBody : Tea.TeaModel {
    public var networkId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNodeRequest : Tea.TeaModel {
    public var containerId: String?

    public var projectId: String?

    public var scene: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContainerId") {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class CreateNodeResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProjectRequest : Tea.TeaModel {
    public class AliyunResourceTags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTags: [CreateProjectRequest.AliyunResourceTags]?

    public var description_: String?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var displayName: String?

    public var name: String?

    public var paiTaskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTags != nil {
            var tmp : [Any] = []
            for k in self.aliyunResourceTags! {
                tmp.append(k.toMap())
            }
            map["AliyunResourceTags"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunResourceGroupId") {
            self.aliyunResourceGroupId = dict["AliyunResourceGroupId"] as! String
        }
        if dict.keys.contains("AliyunResourceTags") {
            var tmp : [CreateProjectRequest.AliyunResourceTags] = []
            for v in dict["AliyunResourceTags"] as! [Any] {
                var model = CreateProjectRequest.AliyunResourceTags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aliyunResourceTags = tmp
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DevEnvironmentEnabled") {
            self.devEnvironmentEnabled = dict["DevEnvironmentEnabled"] as! Bool
        }
        if dict.keys.contains("DevRoleDisabled") {
            self.devRoleDisabled = dict["DevRoleDisabled"] as! Bool
        }
        if dict.keys.contains("DisplayName") {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PaiTaskEnabled") {
            self.paiTaskEnabled = dict["PaiTaskEnabled"] as! Bool
        }
    }
}

public class CreateProjectShrinkRequest : Tea.TeaModel {
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTagsShrink: String?

    public var description_: String?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var displayName: String?

    public var name: String?

    public var paiTaskEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTagsShrink != nil {
            map["AliyunResourceTags"] = self.aliyunResourceTagsShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunResourceGroupId") {
            self.aliyunResourceGroupId = dict["AliyunResourceGroupId"] as! String
        }
        if dict.keys.contains("AliyunResourceTags") {
            self.aliyunResourceTagsShrink = dict["AliyunResourceTags"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DevEnvironmentEnabled") {
            self.devEnvironmentEnabled = dict["DevEnvironmentEnabled"] as! Bool
        }
        if dict.keys.contains("DevRoleDisabled") {
            self.devRoleDisabled = dict["DevRoleDisabled"] as! Bool
        }
        if dict.keys.contains("DisplayName") {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PaiTaskEnabled") {
            self.paiTaskEnabled = dict["PaiTaskEnabled"] as! Bool
        }
    }
}

public class CreateProjectResponseBody : Tea.TeaModel {
    public var projectId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProjectMemberRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodes: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodes != nil {
            map["RoleCodes"] = self.roleCodes!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCodes") {
            self.roleCodes = dict["RoleCodes"] as! [String]
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CreateProjectMemberShrinkRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodesShrink: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodesShrink != nil {
            map["RoleCodes"] = self.roleCodesShrink!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCodes") {
            self.roleCodesShrink = dict["RoleCodes"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CreateProjectMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProjectMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateResourceRequest : Tea.TeaModel {
    public var projectId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class CreateResourceResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateResourceGroupRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var clientToken: String?

    public var name: String?

    public var paymentDuration: Int32?

    public var paymentDurationUnit: String?

    public var paymentType: String?

    public var remark: String?

    public var spec: Int32?

    public var vpcId: String?

    public var vswitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paymentDuration != nil {
            map["PaymentDuration"] = self.paymentDuration!
        }
        if self.paymentDurationUnit != nil {
            map["PaymentDurationUnit"] = self.paymentDurationUnit!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vswitchId != nil {
            map["VswitchId"] = self.vswitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PaymentDuration") {
            self.paymentDuration = dict["PaymentDuration"] as! Int32
        }
        if dict.keys.contains("PaymentDurationUnit") {
            self.paymentDurationUnit = dict["PaymentDurationUnit"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! Int32
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VswitchId") {
            self.vswitchId = dict["VswitchId"] as! String
        }
    }
}

public class CreateResourceGroupResponseBody : Tea.TeaModel {
    public class ResourceGroupOrder : Tea.TeaModel {
        public var id: String?

        public var orderId: Int64?

        public var orderInstanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            if self.orderInstanceId != nil {
                map["OrderInstanceId"] = self.orderInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! Int64
            }
            if dict.keys.contains("OrderInstanceId") {
                self.orderInstanceId = dict["OrderInstanceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var resourceGroupOrder: CreateResourceGroupResponseBody.ResourceGroupOrder?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceGroupOrder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupOrder != nil {
            map["ResourceGroupOrder"] = self.resourceGroupOrder?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupOrder") {
            var model = CreateResourceGroupResponseBody.ResourceGroupOrder()
            model.fromMap(dict["ResourceGroupOrder"] as! [String: Any])
            self.resourceGroupOrder = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRouteRequest : Tea.TeaModel {
    public var destinationCidr: String?

    public var networkId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidr != nil {
            map["DestinationCidr"] = self.destinationCidr!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationCidr") {
            self.destinationCidr = dict["DestinationCidr"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! Int64
        }
    }
}

public class CreateRouteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeId: Int64?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteId") {
            self.routeId = dict["RouteId"] as! Int64
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkflowDefinitionRequest : Tea.TeaModel {
    public var projectId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class CreateWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWorkflowDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAlertRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteAlertRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDIAlarmRuleRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var DIJobId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
        }
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
    }
}

public class DeleteDIAlarmRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDIAlarmRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class DeleteDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataQualityEvaluationTaskRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class DeleteDataQualityEvaluationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataQualityEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataQualityEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataQualityEvaluationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataQualityRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class DeleteDataQualityRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataQualityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataQualityRuleTemplateRequest : Tea.TeaModel {
    public var code: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class DeleteDataQualityRuleTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataQualityRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataQualityRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataQualityRuleTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataSourceRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteDataSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataSourceSharedRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteDataSourceSharedRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteDataSourceSharedRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataSourceSharedRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataSourceSharedRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFunctionRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteFunctionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFunctionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNodeRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProjectRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProjectMemberRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class DeleteProjectMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProjectMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteResourceRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteResourceGroupRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DeleteResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRouteRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DeleteRouteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTaskRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class DeleteTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWorkflowDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachDataQualityRulesFromEvaluationTaskRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityRuleIds: [Int64]?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityRuleIds != nil {
            map["DataQualityRuleIds"] = self.dataQualityRuleIds!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityEvaluationTaskId") {
            self.dataQualityEvaluationTaskId = dict["DataQualityEvaluationTaskId"] as! Int64
        }
        if dict.keys.contains("DataQualityRuleIds") {
            self.dataQualityRuleIds = dict["DataQualityRuleIds"] as! [Int64]
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class DetachDataQualityRulesFromEvaluationTaskShrinkRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityRuleIdsShrink: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityRuleIdsShrink != nil {
            map["DataQualityRuleIds"] = self.dataQualityRuleIdsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityEvaluationTaskId") {
            self.dataQualityEvaluationTaskId = dict["DataQualityEvaluationTaskId"] as! Int64
        }
        if dict.keys.contains("DataQualityRuleIds") {
            self.dataQualityRuleIdsShrink = dict["DataQualityRuleIds"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class DetachDataQualityRulesFromEvaluationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DetachDataQualityRulesFromEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDataQualityRulesFromEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachDataQualityRulesFromEvaluationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DissociateProjectFromResourceGroupRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class DissociateProjectFromResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DissociateProjectFromResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateProjectFromResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DissociateProjectFromResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecDeploymentStageRequest : Tea.TeaModel {
    public var code: String?

    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class ExecDeploymentStageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ExecDeploymentStageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecDeploymentStageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecDeploymentStageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAlertRuleRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class GetAlertRuleResponseBody : Tea.TeaModel {
    public class AlertRule : Tea.TeaModel {
        public class Notification : Tea.TeaModel {
            public class Receivers : Tea.TeaModel {
                public var extension_: String?

                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Extension") {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("ReceiverType") {
                        self.receiverType = dict["ReceiverType"] as! String
                    }
                    if dict.keys.contains("ReceiverValues") {
                        self.receiverValues = dict["ReceiverValues"] as! [String]
                    }
                }
            }
            public var channels: [String]?

            public var intervalInMinutes: Int32?

            public var maximum: Int32?

            public var receivers: [GetAlertRuleResponseBody.AlertRule.Notification.Receivers]?

            public var silenceEndTime: String?

            public var silenceStartTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.intervalInMinutes != nil {
                    map["IntervalInMinutes"] = self.intervalInMinutes!
                }
                if self.maximum != nil {
                    map["Maximum"] = self.maximum!
                }
                if self.receivers != nil {
                    var tmp : [Any] = []
                    for k in self.receivers! {
                        tmp.append(k.toMap())
                    }
                    map["Receivers"] = tmp
                }
                if self.silenceEndTime != nil {
                    map["SilenceEndTime"] = self.silenceEndTime!
                }
                if self.silenceStartTime != nil {
                    map["SilenceStartTime"] = self.silenceStartTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! [String]
                }
                if dict.keys.contains("IntervalInMinutes") {
                    self.intervalInMinutes = dict["IntervalInMinutes"] as! Int32
                }
                if dict.keys.contains("Maximum") {
                    self.maximum = dict["Maximum"] as! Int32
                }
                if dict.keys.contains("Receivers") {
                    var tmp : [GetAlertRuleResponseBody.AlertRule.Notification.Receivers] = []
                    for v in dict["Receivers"] as! [Any] {
                        var model = GetAlertRuleResponseBody.AlertRule.Notification.Receivers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.receivers = tmp
                }
                if dict.keys.contains("SilenceEndTime") {
                    self.silenceEndTime = dict["SilenceEndTime"] as! String
                }
                if dict.keys.contains("SilenceStartTime") {
                    self.silenceStartTime = dict["SilenceStartTime"] as! String
                }
            }
        }
        public class TriggerCondition : Tea.TeaModel {
            public class Extension_ : Tea.TeaModel {
                public class CycleUnfinished : Tea.TeaModel {
                    public class CycleAndTime : Tea.TeaModel {
                        public var cycleId: Int32?

                        public var time: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.cycleId != nil {
                                map["CycleId"] = self.cycleId!
                            }
                            if self.time != nil {
                                map["Time"] = self.time!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CycleId") {
                                self.cycleId = dict["CycleId"] as! Int32
                            }
                            if dict.keys.contains("Time") {
                                self.time = dict["Time"] as! String
                            }
                        }
                    }
                    public var cycleAndTime: [GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleAndTime != nil {
                            var tmp : [Any] = []
                            for k in self.cycleAndTime! {
                                tmp.append(k.toMap())
                            }
                            map["CycleAndTime"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CycleAndTime") {
                            var tmp : [GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime] = []
                            for v in dict["CycleAndTime"] as! [Any] {
                                var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.cycleAndTime = tmp
                        }
                    }
                }
                public class Error : Tea.TeaModel {
                    public var autoRerunAlert: Bool?

                    public var streamTaskIds: [Int64]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.autoRerunAlert != nil {
                            map["AutoRerunAlert"] = self.autoRerunAlert!
                        }
                        if self.streamTaskIds != nil {
                            map["StreamTaskIds"] = self.streamTaskIds!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AutoRerunAlert") {
                            self.autoRerunAlert = dict["AutoRerunAlert"] as! Bool
                        }
                        if dict.keys.contains("StreamTaskIds") {
                            self.streamTaskIds = dict["StreamTaskIds"] as! [Int64]
                        }
                    }
                }
                public class InstanceErrorCount : Tea.TeaModel {
                    public var count: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int32
                        }
                    }
                }
                public class InstanceErrorPercentage : Tea.TeaModel {
                    public var percentage: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.percentage != nil {
                            map["Percentage"] = self.percentage!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Percentage") {
                            self.percentage = dict["Percentage"] as! Int32
                        }
                    }
                }
                public class InstanceTransferFluctuate : Tea.TeaModel {
                    public var percentage: Int32?

                    public var trend: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.percentage != nil {
                            map["Percentage"] = self.percentage!
                        }
                        if self.trend != nil {
                            map["Trend"] = self.trend!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Percentage") {
                            self.percentage = dict["Percentage"] as! Int32
                        }
                        if dict.keys.contains("Trend") {
                            self.trend = dict["Trend"] as! String
                        }
                    }
                }
                public class Timeout : Tea.TeaModel {
                    public var timeoutInMinutes: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timeoutInMinutes != nil {
                            map["TimeoutInMinutes"] = self.timeoutInMinutes!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TimeoutInMinutes") {
                            self.timeoutInMinutes = dict["TimeoutInMinutes"] as! Int32
                        }
                    }
                }
                public class UnFinished : Tea.TeaModel {
                    public var unFinishedTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.unFinishedTime != nil {
                            map["UnFinishedTime"] = self.unFinishedTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("UnFinishedTime") {
                            self.unFinishedTime = dict["UnFinishedTime"] as! String
                        }
                    }
                }
                public var cycleUnfinished: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished?

                public var error: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.Error?

                public var instanceErrorCount: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceErrorCount?

                public var instanceErrorPercentage: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceErrorPercentage?

                public var instanceTransferFluctuate: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceTransferFluctuate?

                public var timeout: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.Timeout?

                public var unFinished: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.UnFinished?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.cycleUnfinished?.validate()
                    try self.error?.validate()
                    try self.instanceErrorCount?.validate()
                    try self.instanceErrorPercentage?.validate()
                    try self.instanceTransferFluctuate?.validate()
                    try self.timeout?.validate()
                    try self.unFinished?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleUnfinished != nil {
                        map["CycleUnfinished"] = self.cycleUnfinished?.toMap()
                    }
                    if self.error != nil {
                        map["Error"] = self.error?.toMap()
                    }
                    if self.instanceErrorCount != nil {
                        map["InstanceErrorCount"] = self.instanceErrorCount?.toMap()
                    }
                    if self.instanceErrorPercentage != nil {
                        map["InstanceErrorPercentage"] = self.instanceErrorPercentage?.toMap()
                    }
                    if self.instanceTransferFluctuate != nil {
                        map["InstanceTransferFluctuate"] = self.instanceTransferFluctuate?.toMap()
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout?.toMap()
                    }
                    if self.unFinished != nil {
                        map["UnFinished"] = self.unFinished?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CycleUnfinished") {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.CycleUnfinished()
                        model.fromMap(dict["CycleUnfinished"] as! [String: Any])
                        self.cycleUnfinished = model
                    }
                    if dict.keys.contains("Error") {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.Error()
                        model.fromMap(dict["Error"] as! [String: Any])
                        self.error = model
                    }
                    if dict.keys.contains("InstanceErrorCount") {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceErrorCount()
                        model.fromMap(dict["InstanceErrorCount"] as! [String: Any])
                        self.instanceErrorCount = model
                    }
                    if dict.keys.contains("InstanceErrorPercentage") {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceErrorPercentage()
                        model.fromMap(dict["InstanceErrorPercentage"] as! [String: Any])
                        self.instanceErrorPercentage = model
                    }
                    if dict.keys.contains("InstanceTransferFluctuate") {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.InstanceTransferFluctuate()
                        model.fromMap(dict["InstanceTransferFluctuate"] as! [String: Any])
                        self.instanceTransferFluctuate = model
                    }
                    if dict.keys.contains("Timeout") {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.Timeout()
                        model.fromMap(dict["Timeout"] as! [String: Any])
                        self.timeout = model
                    }
                    if dict.keys.contains("UnFinished") {
                        var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_.UnFinished()
                        model.fromMap(dict["UnFinished"] as! [String: Any])
                        self.unFinished = model
                    }
                }
            }
            public class Target : Tea.TeaModel {
                public var allowTasks: [Int64]?

                public var ids: [Int64]?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allowTasks != nil {
                        map["AllowTasks"] = self.allowTasks!
                    }
                    if self.ids != nil {
                        map["Ids"] = self.ids!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllowTasks") {
                        self.allowTasks = dict["AllowTasks"] as! [Int64]
                    }
                    if dict.keys.contains("Ids") {
                        self.ids = dict["Ids"] as! [Int64]
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var extension_: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_?

            public var target: GetAlertRuleResponseBody.AlertRule.TriggerCondition.Target?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.extension_?.validate()
                try self.target?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extension_ != nil {
                    map["Extension"] = self.extension_?.toMap()
                }
                if self.target != nil {
                    map["Target"] = self.target?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Extension") {
                    var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Extension_()
                    model.fromMap(dict["Extension"] as! [String: Any])
                    self.extension_ = model
                }
                if dict.keys.contains("Target") {
                    var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition.Target()
                    model.fromMap(dict["Target"] as! [String: Any])
                    self.target = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var enabled: Bool?

        public var id: Int64?

        public var name: String?

        public var notification: GetAlertRuleResponseBody.AlertRule.Notification?

        public var owner: String?

        public var triggerCondition: GetAlertRuleResponseBody.AlertRule.TriggerCondition?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notification?.validate()
            try self.triggerCondition?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notification != nil {
                map["Notification"] = self.notification?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.triggerCondition != nil {
                map["TriggerCondition"] = self.triggerCondition?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Notification") {
                var model = GetAlertRuleResponseBody.AlertRule.Notification()
                model.fromMap(dict["Notification"] as! [String: Any])
                self.notification = model
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("TriggerCondition") {
                var model = GetAlertRuleResponseBody.AlertRule.TriggerCondition()
                model.fromMap(dict["TriggerCondition"] as! [String: Any])
                self.triggerCondition = model
            }
        }
    }
    public var alertRule: GetAlertRuleResponseBody.AlertRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.alertRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertRule != nil {
            map["AlertRule"] = self.alertRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertRule") {
            var model = GetAlertRuleResponseBody.AlertRule()
            model.fromMap(dict["AlertRule"] as! [String: Any])
            self.alertRule = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var projectId: Int64?

    public var withDetails: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.withDetails != nil {
            map["WithDetails"] = self.withDetails!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("WithDetails") {
            self.withDetails = dict["WithDetails"] as! Bool
        }
    }
}

public class GetDIJobResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DestinationDataSourceSettings : Tea.TeaModel {
            public var dataSourceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataSourceName") {
                    self.dataSourceName = dict["DataSourceName"] as! String
                }
            }
        }
        public class JobSettings : Tea.TeaModel {
            public class ColumnDataTypeSettings : Tea.TeaModel {
                public var destinationDataType: String?

                public var sourceDataType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.destinationDataType != nil {
                        map["DestinationDataType"] = self.destinationDataType!
                    }
                    if self.sourceDataType != nil {
                        map["SourceDataType"] = self.sourceDataType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DestinationDataType") {
                        self.destinationDataType = dict["DestinationDataType"] as! String
                    }
                    if dict.keys.contains("SourceDataType") {
                        self.sourceDataType = dict["SourceDataType"] as! String
                    }
                }
            }
            public class CycleScheduleSettings : Tea.TeaModel {
                public var cycleMigrationType: String?

                public var scheduleParameters: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleMigrationType != nil {
                        map["CycleMigrationType"] = self.cycleMigrationType!
                    }
                    if self.scheduleParameters != nil {
                        map["ScheduleParameters"] = self.scheduleParameters!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CycleMigrationType") {
                        self.cycleMigrationType = dict["CycleMigrationType"] as! String
                    }
                    if dict.keys.contains("ScheduleParameters") {
                        self.scheduleParameters = dict["ScheduleParameters"] as! String
                    }
                }
            }
            public class DdlHandlingSettings : Tea.TeaModel {
                public var action: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["Action"] = self.action!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Action") {
                        self.action = dict["Action"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class RuntimeSettings : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var channelSettings: String?

            public var columnDataTypeSettings: [GetDIJobResponseBody.PagingInfo.JobSettings.ColumnDataTypeSettings]?

            public var cycleScheduleSettings: GetDIJobResponseBody.PagingInfo.JobSettings.CycleScheduleSettings?

            public var ddlHandlingSettings: [GetDIJobResponseBody.PagingInfo.JobSettings.DdlHandlingSettings]?

            public var runtimeSettings: [GetDIJobResponseBody.PagingInfo.JobSettings.RuntimeSettings]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cycleScheduleSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelSettings != nil {
                    map["ChannelSettings"] = self.channelSettings!
                }
                if self.columnDataTypeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.columnDataTypeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["ColumnDataTypeSettings"] = tmp
                }
                if self.cycleScheduleSettings != nil {
                    map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
                }
                if self.ddlHandlingSettings != nil {
                    var tmp : [Any] = []
                    for k in self.ddlHandlingSettings! {
                        tmp.append(k.toMap())
                    }
                    map["DdlHandlingSettings"] = tmp
                }
                if self.runtimeSettings != nil {
                    var tmp : [Any] = []
                    for k in self.runtimeSettings! {
                        tmp.append(k.toMap())
                    }
                    map["RuntimeSettings"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelSettings") {
                    self.channelSettings = dict["ChannelSettings"] as! String
                }
                if dict.keys.contains("ColumnDataTypeSettings") {
                    var tmp : [GetDIJobResponseBody.PagingInfo.JobSettings.ColumnDataTypeSettings] = []
                    for v in dict["ColumnDataTypeSettings"] as! [Any] {
                        var model = GetDIJobResponseBody.PagingInfo.JobSettings.ColumnDataTypeSettings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.columnDataTypeSettings = tmp
                }
                if dict.keys.contains("CycleScheduleSettings") {
                    var model = GetDIJobResponseBody.PagingInfo.JobSettings.CycleScheduleSettings()
                    model.fromMap(dict["CycleScheduleSettings"] as! [String: Any])
                    self.cycleScheduleSettings = model
                }
                if dict.keys.contains("DdlHandlingSettings") {
                    var tmp : [GetDIJobResponseBody.PagingInfo.JobSettings.DdlHandlingSettings] = []
                    for v in dict["DdlHandlingSettings"] as! [Any] {
                        var model = GetDIJobResponseBody.PagingInfo.JobSettings.DdlHandlingSettings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ddlHandlingSettings = tmp
                }
                if dict.keys.contains("RuntimeSettings") {
                    var tmp : [GetDIJobResponseBody.PagingInfo.JobSettings.RuntimeSettings] = []
                    for v in dict["RuntimeSettings"] as! [Any] {
                        var model = GetDIJobResponseBody.PagingInfo.JobSettings.RuntimeSettings()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.runtimeSettings = tmp
                }
            }
        }
        public class ResourceSettings : Tea.TeaModel {
            public class OfflineResourceSettings : Tea.TeaModel {
                public var requestedCu: Double?

                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestedCu != nil {
                        map["RequestedCu"] = self.requestedCu!
                    }
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RequestedCu") {
                        self.requestedCu = dict["RequestedCu"] as! Double
                    }
                    if dict.keys.contains("ResourceGroupIdentifier") {
                        self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                    }
                }
            }
            public class RealtimeResourceSettings : Tea.TeaModel {
                public var requestedCu: Double?

                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestedCu != nil {
                        map["RequestedCu"] = self.requestedCu!
                    }
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RequestedCu") {
                        self.requestedCu = dict["RequestedCu"] as! Double
                    }
                    if dict.keys.contains("ResourceGroupIdentifier") {
                        self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                    }
                }
            }
            public class ScheduleResourceSettings : Tea.TeaModel {
                public var requestedCu: Double?

                public var resourceGroupIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.requestedCu != nil {
                        map["RequestedCu"] = self.requestedCu!
                    }
                    if self.resourceGroupIdentifier != nil {
                        map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RequestedCu") {
                        self.requestedCu = dict["RequestedCu"] as! Double
                    }
                    if dict.keys.contains("ResourceGroupIdentifier") {
                        self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                    }
                }
            }
            public var offlineResourceSettings: GetDIJobResponseBody.PagingInfo.ResourceSettings.OfflineResourceSettings?

            public var realtimeResourceSettings: GetDIJobResponseBody.PagingInfo.ResourceSettings.RealtimeResourceSettings?

            public var scheduleResourceSettings: GetDIJobResponseBody.PagingInfo.ResourceSettings.ScheduleResourceSettings?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.offlineResourceSettings?.validate()
                try self.realtimeResourceSettings?.validate()
                try self.scheduleResourceSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.offlineResourceSettings != nil {
                    map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
                }
                if self.realtimeResourceSettings != nil {
                    map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
                }
                if self.scheduleResourceSettings != nil {
                    map["ScheduleResourceSettings"] = self.scheduleResourceSettings?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OfflineResourceSettings") {
                    var model = GetDIJobResponseBody.PagingInfo.ResourceSettings.OfflineResourceSettings()
                    model.fromMap(dict["OfflineResourceSettings"] as! [String: Any])
                    self.offlineResourceSettings = model
                }
                if dict.keys.contains("RealtimeResourceSettings") {
                    var model = GetDIJobResponseBody.PagingInfo.ResourceSettings.RealtimeResourceSettings()
                    model.fromMap(dict["RealtimeResourceSettings"] as! [String: Any])
                    self.realtimeResourceSettings = model
                }
                if dict.keys.contains("ScheduleResourceSettings") {
                    var model = GetDIJobResponseBody.PagingInfo.ResourceSettings.ScheduleResourceSettings()
                    model.fromMap(dict["ScheduleResourceSettings"] as! [String: Any])
                    self.scheduleResourceSettings = model
                }
            }
        }
        public class SourceDataSourceSettings : Tea.TeaModel {
            public class DataSourceProperties : Tea.TeaModel {
                public var encoding: String?

                public var timezone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Encoding") {
                        self.encoding = dict["Encoding"] as! String
                    }
                    if dict.keys.contains("Timezone") {
                        self.timezone = dict["Timezone"] as! String
                    }
                }
            }
            public var dataSourceName: String?

            public var dataSourceProperties: GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings.DataSourceProperties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSourceProperties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceName != nil {
                    map["DataSourceName"] = self.dataSourceName!
                }
                if self.dataSourceProperties != nil {
                    map["DataSourceProperties"] = self.dataSourceProperties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataSourceName") {
                    self.dataSourceName = dict["DataSourceName"] as! String
                }
                if dict.keys.contains("DataSourceProperties") {
                    var model = GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings.DataSourceProperties()
                    model.fromMap(dict["DataSourceProperties"] as! [String: Any])
                    self.dataSourceProperties = model
                }
            }
        }
        public class TableMappings : Tea.TeaModel {
            public class SourceObjectSelectionRules : Tea.TeaModel {
                public var action: String?

                public var expression: String?

                public var expressionType: String?

                public var objectType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["Action"] = self.action!
                    }
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.expressionType != nil {
                        map["ExpressionType"] = self.expressionType!
                    }
                    if self.objectType != nil {
                        map["ObjectType"] = self.objectType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Action") {
                        self.action = dict["Action"] as! String
                    }
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("ExpressionType") {
                        self.expressionType = dict["ExpressionType"] as! String
                    }
                    if dict.keys.contains("ObjectType") {
                        self.objectType = dict["ObjectType"] as! String
                    }
                }
            }
            public class TransformationRules : Tea.TeaModel {
                public var ruleActionType: String?

                public var ruleName: String?

                public var ruleTargetType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleActionType != nil {
                        map["RuleActionType"] = self.ruleActionType!
                    }
                    if self.ruleName != nil {
                        map["RuleName"] = self.ruleName!
                    }
                    if self.ruleTargetType != nil {
                        map["RuleTargetType"] = self.ruleTargetType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RuleActionType") {
                        self.ruleActionType = dict["RuleActionType"] as! String
                    }
                    if dict.keys.contains("RuleName") {
                        self.ruleName = dict["RuleName"] as! String
                    }
                    if dict.keys.contains("RuleTargetType") {
                        self.ruleTargetType = dict["RuleTargetType"] as! String
                    }
                }
            }
            public var sourceObjectSelectionRules: [GetDIJobResponseBody.PagingInfo.TableMappings.SourceObjectSelectionRules]?

            public var transformationRules: [GetDIJobResponseBody.PagingInfo.TableMappings.TransformationRules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceObjectSelectionRules != nil {
                    var tmp : [Any] = []
                    for k in self.sourceObjectSelectionRules! {
                        tmp.append(k.toMap())
                    }
                    map["SourceObjectSelectionRules"] = tmp
                }
                if self.transformationRules != nil {
                    var tmp : [Any] = []
                    for k in self.transformationRules! {
                        tmp.append(k.toMap())
                    }
                    map["TransformationRules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SourceObjectSelectionRules") {
                    var tmp : [GetDIJobResponseBody.PagingInfo.TableMappings.SourceObjectSelectionRules] = []
                    for v in dict["SourceObjectSelectionRules"] as! [Any] {
                        var model = GetDIJobResponseBody.PagingInfo.TableMappings.SourceObjectSelectionRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.sourceObjectSelectionRules = tmp
                }
                if dict.keys.contains("TransformationRules") {
                    var tmp : [GetDIJobResponseBody.PagingInfo.TableMappings.TransformationRules] = []
                    for v in dict["TransformationRules"] as! [Any] {
                        var model = GetDIJobResponseBody.PagingInfo.TableMappings.TransformationRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.transformationRules = tmp
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleExpression: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleExpression != nil {
                    map["RuleExpression"] = self.ruleExpression!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RuleActionType") {
                    self.ruleActionType = dict["RuleActionType"] as! String
                }
                if dict.keys.contains("RuleExpression") {
                    self.ruleExpression = dict["RuleExpression"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("RuleTargetType") {
                    self.ruleTargetType = dict["RuleTargetType"] as! String
                }
            }
        }
        public var DIJobId: String?

        public var description_: String?

        public var destinationDataSourceSettings: [GetDIJobResponseBody.PagingInfo.DestinationDataSourceSettings]?

        public var destinationDataSourceType: String?

        public var jobName: String?

        public var jobSettings: GetDIJobResponseBody.PagingInfo.JobSettings?

        public var jobStatus: String?

        public var migrationType: String?

        public var projectId: Int64?

        public var resourceSettings: GetDIJobResponseBody.PagingInfo.ResourceSettings?

        public var sourceDataSourceSettings: [GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings]?

        public var sourceDataSourceType: String?

        public var tableMappings: [GetDIJobResponseBody.PagingInfo.TableMappings]?

        public var transformationRules: [GetDIJobResponseBody.PagingInfo.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.jobSettings?.validate()
            try self.resourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobId != nil {
                map["DIJobId"] = self.DIJobId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationDataSourceSettings != nil {
                var tmp : [Any] = []
                for k in self.destinationDataSourceSettings! {
                    tmp.append(k.toMap())
                }
                map["DestinationDataSourceSettings"] = tmp
            }
            if self.destinationDataSourceType != nil {
                map["DestinationDataSourceType"] = self.destinationDataSourceType!
            }
            if self.jobName != nil {
                map["JobName"] = self.jobName!
            }
            if self.jobSettings != nil {
                map["JobSettings"] = self.jobSettings?.toMap()
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.migrationType != nil {
                map["MigrationType"] = self.migrationType!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.resourceSettings != nil {
                map["ResourceSettings"] = self.resourceSettings?.toMap()
            }
            if self.sourceDataSourceSettings != nil {
                var tmp : [Any] = []
                for k in self.sourceDataSourceSettings! {
                    tmp.append(k.toMap())
                }
                map["SourceDataSourceSettings"] = tmp
            }
            if self.sourceDataSourceType != nil {
                map["SourceDataSourceType"] = self.sourceDataSourceType!
            }
            if self.tableMappings != nil {
                var tmp : [Any] = []
                for k in self.tableMappings! {
                    tmp.append(k.toMap())
                }
                map["TableMappings"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DIJobId") {
                self.DIJobId = dict["DIJobId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationDataSourceSettings") {
                var tmp : [GetDIJobResponseBody.PagingInfo.DestinationDataSourceSettings] = []
                for v in dict["DestinationDataSourceSettings"] as! [Any] {
                    var model = GetDIJobResponseBody.PagingInfo.DestinationDataSourceSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.destinationDataSourceSettings = tmp
            }
            if dict.keys.contains("DestinationDataSourceType") {
                self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
            }
            if dict.keys.contains("JobName") {
                self.jobName = dict["JobName"] as! String
            }
            if dict.keys.contains("JobSettings") {
                var model = GetDIJobResponseBody.PagingInfo.JobSettings()
                model.fromMap(dict["JobSettings"] as! [String: Any])
                self.jobSettings = model
            }
            if dict.keys.contains("JobStatus") {
                self.jobStatus = dict["JobStatus"] as! String
            }
            if dict.keys.contains("MigrationType") {
                self.migrationType = dict["MigrationType"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("ResourceSettings") {
                var model = GetDIJobResponseBody.PagingInfo.ResourceSettings()
                model.fromMap(dict["ResourceSettings"] as! [String: Any])
                self.resourceSettings = model
            }
            if dict.keys.contains("SourceDataSourceSettings") {
                var tmp : [GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings] = []
                for v in dict["SourceDataSourceSettings"] as! [Any] {
                    var model = GetDIJobResponseBody.PagingInfo.SourceDataSourceSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sourceDataSourceSettings = tmp
            }
            if dict.keys.contains("SourceDataSourceType") {
                self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
            }
            if dict.keys.contains("TableMappings") {
                var tmp : [GetDIJobResponseBody.PagingInfo.TableMappings] = []
                for v in dict["TableMappings"] as! [Any] {
                    var model = GetDIJobResponseBody.PagingInfo.TableMappings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tableMappings = tmp
            }
            if dict.keys.contains("TransformationRules") {
                var tmp : [GetDIJobResponseBody.PagingInfo.TransformationRules] = []
                for v in dict["TransformationRules"] as! [Any] {
                    var model = GetDIJobResponseBody.PagingInfo.TransformationRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transformationRules = tmp
            }
        }
    }
    public var pagingInfo: GetDIJobResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = GetDIJobResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDIJobLogRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var failoverId: Int64?

    public var instanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.failoverId != nil {
            map["FailoverId"] = self.failoverId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("FailoverId") {
            self.failoverId = dict["FailoverId"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
    }
}

public class GetDIJobLogResponseBody : Tea.TeaModel {
    public var log: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.log != nil {
            map["Log"] = self.log!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Log") {
            self.log = dict["Log"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDIJobLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDIJobLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDIJobLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataQualityEvaluationTaskRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetDataQualityEvaluationTaskResponseBody : Tea.TeaModel {
    public class DataQualityEvaluationTask : Tea.TeaModel {
        public class Hooks : Tea.TeaModel {
            public var condition: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Condition") {
                    self.condition = dict["Condition"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Notifications : Tea.TeaModel {
            public class Notifications : Tea.TeaModel {
                public class NotificationChannels : Tea.TeaModel {
                    public var channels: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! [String]
                        }
                    }
                }
                public class NotificationReceivers : Tea.TeaModel {
                    public var extension_: String?

                    public var receiverType: String?

                    public var receiverValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extension_ != nil {
                            map["Extension"] = self.extension_!
                        }
                        if self.receiverType != nil {
                            map["ReceiverType"] = self.receiverType!
                        }
                        if self.receiverValues != nil {
                            map["ReceiverValues"] = self.receiverValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Extension") {
                            self.extension_ = dict["Extension"] as! String
                        }
                        if dict.keys.contains("ReceiverType") {
                            self.receiverType = dict["ReceiverType"] as! String
                        }
                        if dict.keys.contains("ReceiverValues") {
                            self.receiverValues = dict["ReceiverValues"] as! [String]
                        }
                    }
                }
                public var notificationChannels: [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels]?

                public var notificationReceivers: [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.notificationChannels != nil {
                        var tmp : [Any] = []
                        for k in self.notificationChannels! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationChannels"] = tmp
                    }
                    if self.notificationReceivers != nil {
                        var tmp : [Any] = []
                        for k in self.notificationReceivers! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationReceivers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NotificationChannels") {
                        var tmp : [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels] = []
                        for v in dict["NotificationChannels"] as! [Any] {
                            var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationChannels()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notificationChannels = tmp
                    }
                    if dict.keys.contains("NotificationReceivers") {
                        var tmp : [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers] = []
                        for v in dict["NotificationReceivers"] as! [Any] {
                            var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications.NotificationReceivers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notificationReceivers = tmp
                    }
                }
            }
            public var condition: String?

            public var notifications: [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.notifications != nil {
                    var tmp : [Any] = []
                    for k in self.notifications! {
                        tmp.append(k.toMap())
                    }
                    map["Notifications"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Condition") {
                    self.condition = dict["Condition"] as! String
                }
                if dict.keys.contains("Notifications") {
                    var tmp : [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications] = []
                    for v in dict["Notifications"] as! [Any] {
                        var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications.Notifications()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notifications = tmp
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var databaseType: String?

            public var partitionSpec: String?

            public var tableGuid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseType != nil {
                    map["DatabaseType"] = self.databaseType!
                }
                if self.partitionSpec != nil {
                    map["PartitionSpec"] = self.partitionSpec!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseType") {
                    self.databaseType = dict["DatabaseType"] as! String
                }
                if dict.keys.contains("PartitionSpec") {
                    self.partitionSpec = dict["PartitionSpec"] as! String
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public var taskIds: [Int64]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskIds != nil {
                    map["TaskIds"] = self.taskIds!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TaskIds") {
                    self.taskIds = dict["TaskIds"] as! [Int64]
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var description_: String?

        public var hooks: [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Hooks]?

        public var id: Int64?

        public var name: String?

        public var notifications: GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications?

        public var projectId: Int64?

        public var runtimeConf: String?

        public var target: GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Target?

        public var trigger: GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Trigger?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notifications?.validate()
            try self.target?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.hooks != nil {
                var tmp : [Any] = []
                for k in self.hooks! {
                    tmp.append(k.toMap())
                }
                map["Hooks"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifications != nil {
                map["Notifications"] = self.notifications?.toMap()
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.runtimeConf != nil {
                map["RuntimeConf"] = self.runtimeConf!
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Hooks") {
                var tmp : [GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Hooks] = []
                for v in dict["Hooks"] as! [Any] {
                    var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Hooks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hooks = tmp
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Notifications") {
                var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Notifications()
                model.fromMap(dict["Notifications"] as! [String: Any])
                self.notifications = model
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("RuntimeConf") {
                self.runtimeConf = dict["RuntimeConf"] as! String
            }
            if dict.keys.contains("Target") {
                var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Target()
                model.fromMap(dict["Target"] as! [String: Any])
                self.target = model
            }
            if dict.keys.contains("Trigger") {
                var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask.Trigger()
                model.fromMap(dict["Trigger"] as! [String: Any])
                self.trigger = model
            }
        }
    }
    public var dataQualityEvaluationTask: GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataQualityEvaluationTask?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTask != nil {
            map["DataQualityEvaluationTask"] = self.dataQualityEvaluationTask?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityEvaluationTask") {
            var model = GetDataQualityEvaluationTaskResponseBody.DataQualityEvaluationTask()
            model.fromMap(dict["DataQualityEvaluationTask"] as! [String: Any])
            self.dataQualityEvaluationTask = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataQualityEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataQualityEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataQualityEvaluationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataQualityEvaluationTaskInstanceRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetDataQualityEvaluationTaskInstanceResponseBody : Tea.TeaModel {
    public class DataQualityEvaluationTaskInstance : Tea.TeaModel {
        public class Task : Tea.TeaModel {
            public class Hooks : Tea.TeaModel {
                public var condition: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Condition") {
                        self.condition = dict["Condition"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Notifications : Tea.TeaModel {
                public class Notifications : Tea.TeaModel {
                    public class NotificationChannels : Tea.TeaModel {
                        public var channels: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! [String]
                            }
                        }
                    }
                    public class NotificationReceivers : Tea.TeaModel {
                        public var extension_: String?

                        public var receiverType: String?

                        public var receiverValues: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extension_ != nil {
                                map["Extension"] = self.extension_!
                            }
                            if self.receiverType != nil {
                                map["ReceiverType"] = self.receiverType!
                            }
                            if self.receiverValues != nil {
                                map["ReceiverValues"] = self.receiverValues!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Extension") {
                                self.extension_ = dict["Extension"] as! String
                            }
                            if dict.keys.contains("ReceiverType") {
                                self.receiverType = dict["ReceiverType"] as! String
                            }
                            if dict.keys.contains("ReceiverValues") {
                                self.receiverValues = dict["ReceiverValues"] as! [String]
                            }
                        }
                    }
                    public var notificationChannels: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels]?

                    public var notificationReceivers: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.notificationChannels != nil {
                            var tmp : [Any] = []
                            for k in self.notificationChannels! {
                                tmp.append(k.toMap())
                            }
                            map["NotificationChannels"] = tmp
                        }
                        if self.notificationReceivers != nil {
                            var tmp : [Any] = []
                            for k in self.notificationReceivers! {
                                tmp.append(k.toMap())
                            }
                            map["NotificationReceivers"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NotificationChannels") {
                            var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels] = []
                            for v in dict["NotificationChannels"] as! [Any] {
                                var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationChannels()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.notificationChannels = tmp
                        }
                        if dict.keys.contains("NotificationReceivers") {
                            var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers] = []
                            for v in dict["NotificationReceivers"] as! [Any] {
                                var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications.NotificationReceivers()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.notificationReceivers = tmp
                        }
                    }
                }
                public var condition: String?

                public var notifications: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.notifications != nil {
                        var tmp : [Any] = []
                        for k in self.notifications! {
                            tmp.append(k.toMap())
                        }
                        map["Notifications"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Condition") {
                        self.condition = dict["Condition"] as! String
                    }
                    if dict.keys.contains("Notifications") {
                        var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications] = []
                        for v in dict["Notifications"] as! [Any] {
                            var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications.Notifications()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notifications = tmp
                    }
                }
            }
            public class Target : Tea.TeaModel {
                public var databaseType: String?

                public var partitionSpec: String?

                public var tableGuid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseType != nil {
                        map["DatabaseType"] = self.databaseType!
                    }
                    if self.partitionSpec != nil {
                        map["PartitionSpec"] = self.partitionSpec!
                    }
                    if self.tableGuid != nil {
                        map["TableGuid"] = self.tableGuid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseType") {
                        self.databaseType = dict["DatabaseType"] as! String
                    }
                    if dict.keys.contains("PartitionSpec") {
                        self.partitionSpec = dict["PartitionSpec"] as! String
                    }
                    if dict.keys.contains("TableGuid") {
                        self.tableGuid = dict["TableGuid"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var taskIds: [Int64]?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.taskIds != nil {
                        map["TaskIds"] = self.taskIds!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TaskIds") {
                        self.taskIds = dict["TaskIds"] as! [Int64]
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var description_: String?

            public var hooks: [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Hooks]?

            public var id: Int64?

            public var name: String?

            public var notifications: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications?

            public var projectId: Int64?

            public var runtimeConf: String?

            public var target: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Target?

            public var trigger: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Trigger?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notifications?.validate()
                try self.target?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hooks != nil {
                    var tmp : [Any] = []
                    for k in self.hooks! {
                        tmp.append(k.toMap())
                    }
                    map["Hooks"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifications != nil {
                    map["Notifications"] = self.notifications?.toMap()
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.runtimeConf != nil {
                    map["RuntimeConf"] = self.runtimeConf!
                }
                if self.target != nil {
                    map["Target"] = self.target?.toMap()
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Hooks") {
                    var tmp : [GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Hooks] = []
                    for v in dict["Hooks"] as! [Any] {
                        var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Hooks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.hooks = tmp
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Notifications") {
                    var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Notifications()
                    model.fromMap(dict["Notifications"] as! [String: Any])
                    self.notifications = model
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RuntimeConf") {
                    self.runtimeConf = dict["RuntimeConf"] as! String
                }
                if dict.keys.contains("Target") {
                    var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Target()
                    model.fromMap(dict["Target"] as! [String: Any])
                    self.target = model
                }
                if dict.keys.contains("Trigger") {
                    var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task.Trigger()
                    model.fromMap(dict["Trigger"] as! [String: Any])
                    self.trigger = model
                }
            }
        }
        public var createTime: Int64?

        public var finishTime: Int64?

        public var id: Int64?

        public var parameters: String?

        public var projectId: Int64?

        public var status: String?

        public var task: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task?

        public var triggerContext: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.task?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.parameters != nil {
                map["Parameters"] = self.parameters!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.task != nil {
                map["Task"] = self.task?.toMap()
            }
            if self.triggerContext != nil {
                map["TriggerContext"] = self.triggerContext!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Parameters") {
                self.parameters = dict["Parameters"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Task") {
                var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance.Task()
                model.fromMap(dict["Task"] as! [String: Any])
                self.task = model
            }
            if dict.keys.contains("TriggerContext") {
                self.triggerContext = dict["TriggerContext"] as! String
            }
        }
    }
    public var dataQualityEvaluationTaskInstance: GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataQualityEvaluationTaskInstance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskInstance != nil {
            map["DataQualityEvaluationTaskInstance"] = self.dataQualityEvaluationTaskInstance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityEvaluationTaskInstance") {
            var model = GetDataQualityEvaluationTaskInstanceResponseBody.DataQualityEvaluationTaskInstance()
            model.fromMap(dict["DataQualityEvaluationTaskInstance"] as! [String: Any])
            self.dataQualityEvaluationTaskInstance = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataQualityEvaluationTaskInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataQualityEvaluationTaskInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataQualityEvaluationTaskInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataQualityRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetDataQualityRuleResponseBody : Tea.TeaModel {
    public class DataQualityRule : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public class Thresholds : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Expression") {
                            self.expression = dict["Expression"] as! String
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Expected : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Expression") {
                            self.expression = dict["Expression"] as! String
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Warned : Tea.TeaModel {
                    public var expression: String?

                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.expression != nil {
                            map["Expression"] = self.expression!
                        }
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Expression") {
                            self.expression = dict["Expression"] as! String
                        }
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var critical: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Critical?

                public var expected: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Expected?

                public var warned: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Warned?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.expected?.validate()
                    try self.warned?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.expected != nil {
                        map["Expected"] = self.expected?.toMap()
                    }
                    if self.warned != nil {
                        map["Warned"] = self.warned?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Critical") {
                        var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Critical()
                        model.fromMap(dict["Critical"] as! [String: Any])
                        self.critical = model
                    }
                    if dict.keys.contains("Expected") {
                        var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Expected()
                        model.fromMap(dict["Expected"] as! [String: Any])
                        self.expected = model
                    }
                    if dict.keys.contains("Warned") {
                        var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds.Warned()
                        model.fromMap(dict["Warned"] as! [String: Any])
                        self.warned = model
                    }
                }
            }
            public var referencedSamplesFilter: String?

            public var thresholds: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.thresholds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.thresholds != nil {
                    map["Thresholds"] = self.thresholds?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReferencedSamplesFilter") {
                    self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
                }
                if dict.keys.contains("Thresholds") {
                    var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig.Thresholds()
                    model.fromMap(dict["Thresholds"] as! [String: Any])
                    self.thresholds = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ErrorHandlers : Tea.TeaModel {
            public var errorDataFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorDataFilter != nil {
                    map["ErrorDataFilter"] = self.errorDataFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorDataFilter") {
                    self.errorDataFilter = dict["ErrorDataFilter"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var samplingFilter: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.samplingFilter != nil {
                    map["SamplingFilter"] = self.samplingFilter!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Metric") {
                    self.metric = dict["Metric"] as! String
                }
                if dict.keys.contains("MetricParameters") {
                    self.metricParameters = dict["MetricParameters"] as! String
                }
                if dict.keys.contains("SamplingFilter") {
                    self.samplingFilter = dict["SamplingFilter"] as! String
                }
                if dict.keys.contains("SettingConfig") {
                    self.settingConfig = dict["SettingConfig"] as! String
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var databaseType: String?

            public var partitionSpec: String?

            public var tableGuid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseType != nil {
                    map["DatabaseType"] = self.databaseType!
                }
                if self.partitionSpec != nil {
                    map["PartitionSpec"] = self.partitionSpec!
                }
                if self.tableGuid != nil {
                    map["TableGuid"] = self.tableGuid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DatabaseType") {
                    self.databaseType = dict["DatabaseType"] as! String
                }
                if dict.keys.contains("PartitionSpec") {
                    self.partitionSpec = dict["PartitionSpec"] as! String
                }
                if dict.keys.contains("TableGuid") {
                    self.tableGuid = dict["TableGuid"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var checkingConfig: GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig?

        public var description_: String?

        public var enabled: Bool?

        public var errorHandlers: [GetDataQualityRuleResponseBody.DataQualityRule.ErrorHandlers]?

        public var id: Int64?

        public var name: String?

        public var projectId: Int64?

        public var samplingConfig: GetDataQualityRuleResponseBody.DataQualityRule.SamplingConfig?

        public var severity: String?

        public var target: GetDataQualityRuleResponseBody.DataQualityRule.Target?

        public var templateCode: String?

        public var tenantId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.errorHandlers != nil {
                var tmp : [Any] = []
                for k in self.errorHandlers! {
                    tmp.append(k.toMap())
                }
                map["ErrorHandlers"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.templateCode != nil {
                map["TemplateCode"] = self.templateCode!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckingConfig") {
                var model = GetDataQualityRuleResponseBody.DataQualityRule.CheckingConfig()
                model.fromMap(dict["CheckingConfig"] as! [String: Any])
                self.checkingConfig = model
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("ErrorHandlers") {
                var tmp : [GetDataQualityRuleResponseBody.DataQualityRule.ErrorHandlers] = []
                for v in dict["ErrorHandlers"] as! [Any] {
                    var model = GetDataQualityRuleResponseBody.DataQualityRule.ErrorHandlers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorHandlers = tmp
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("SamplingConfig") {
                var model = GetDataQualityRuleResponseBody.DataQualityRule.SamplingConfig()
                model.fromMap(dict["SamplingConfig"] as! [String: Any])
                self.samplingConfig = model
            }
            if dict.keys.contains("Severity") {
                self.severity = dict["Severity"] as! String
            }
            if dict.keys.contains("Target") {
                var model = GetDataQualityRuleResponseBody.DataQualityRule.Target()
                model.fromMap(dict["Target"] as! [String: Any])
                self.target = model
            }
            if dict.keys.contains("TemplateCode") {
                self.templateCode = dict["TemplateCode"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
        }
    }
    public var dataQualityRule: GetDataQualityRuleResponseBody.DataQualityRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataQualityRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRule != nil {
            map["DataQualityRule"] = self.dataQualityRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityRule") {
            var model = GetDataQualityRuleResponseBody.DataQualityRule()
            model.fromMap(dict["DataQualityRule"] as! [String: Any])
            self.dataQualityRule = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataQualityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataQualityRuleTemplateRequest : Tea.TeaModel {
    public var code: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
    }
}

public class GetDataQualityRuleTemplateResponseBody : Tea.TeaModel {
    public class DataQualityRuleTemplate : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public var referencedSamplesFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReferencedSamplesFilter") {
                    self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Metric") {
                    self.metric = dict["Metric"] as! String
                }
                if dict.keys.contains("MetricParameters") {
                    self.metricParameters = dict["MetricParameters"] as! String
                }
                if dict.keys.contains("SettingConfig") {
                    self.settingConfig = dict["SettingConfig"] as! String
                }
            }
        }
        public var checkingConfig: GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate.CheckingConfig?

        public var code: String?

        public var directoryPath: String?

        public var name: String?

        public var projectId: Int64?

        public var samplingConfig: GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate.SamplingConfig?

        public var tenantId: Int64?

        public var visibleScope: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.directoryPath != nil {
                map["DirectoryPath"] = self.directoryPath!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.visibleScope != nil {
                map["VisibleScope"] = self.visibleScope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckingConfig") {
                var model = GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate.CheckingConfig()
                model.fromMap(dict["CheckingConfig"] as! [String: Any])
                self.checkingConfig = model
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("DirectoryPath") {
                self.directoryPath = dict["DirectoryPath"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("SamplingConfig") {
                var model = GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate.SamplingConfig()
                model.fromMap(dict["SamplingConfig"] as! [String: Any])
                self.samplingConfig = model
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("VisibleScope") {
                self.visibleScope = dict["VisibleScope"] as! String
            }
        }
    }
    public var dataQualityRuleTemplate: GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataQualityRuleTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRuleTemplate != nil {
            map["DataQualityRuleTemplate"] = self.dataQualityRuleTemplate?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityRuleTemplate") {
            var model = GetDataQualityRuleTemplateResponseBody.DataQualityRuleTemplate()
            model.fromMap(dict["DataQualityRuleTemplate"] as! [String: Any])
            self.dataQualityRuleTemplate = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataQualityRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataQualityRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataQualityRuleTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataSourceRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetDataSourceResponseBody : Tea.TeaModel {
    public class DataSource : Tea.TeaModel {
        public var connectionProperties: Any?

        public var connectionPropertiesMode: String?

        public var createTime: Int64?

        public var createUser: String?

        public var description_: String?

        public var id: Int64?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var name: String?

        public var projectId: Int64?

        public var qualifiedName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionProperties != nil {
                map["ConnectionProperties"] = self.connectionProperties!
            }
            if self.connectionPropertiesMode != nil {
                map["ConnectionPropertiesMode"] = self.connectionPropertiesMode!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.qualifiedName != nil {
                map["QualifiedName"] = self.qualifiedName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConnectionProperties") {
                self.connectionProperties = dict["ConnectionProperties"] as! Any
            }
            if dict.keys.contains("ConnectionPropertiesMode") {
                self.connectionPropertiesMode = dict["ConnectionPropertiesMode"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("ModifyUser") {
                self.modifyUser = dict["ModifyUser"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("QualifiedName") {
                self.qualifiedName = dict["QualifiedName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var dataSource: GetDataSourceResponseBody.DataSource?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dataSource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSource") {
            var model = GetDataSourceResponseBody.DataSource()
            model.fromMap(dict["DataSource"] as! [String: Any])
            self.dataSource = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeploymentRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetDeploymentResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public class Stages : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var detail: [String: Any]?

            public var message: String?

            public var name: String?

            public var status: String?

            public var step: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.detail != nil {
                    map["Detail"] = self.detail!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.step != nil {
                    map["Step"] = self.step!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Detail") {
                    self.detail = dict["Detail"] as! [String: Any]
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Step") {
                    self.step = dict["Step"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var createTime: Int64?

        public var creator: String?

        public var id: String?

        public var message: String?

        public var modifyTime: Int64?

        public var projectId: String?

        public var stages: [GetDeploymentResponseBody.Pipeline.Stages]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.stages != nil {
                var tmp : [Any] = []
                for k in self.stages! {
                    tmp.append(k.toMap())
                }
                map["Stages"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Stages") {
                var tmp : [GetDeploymentResponseBody.Pipeline.Stages] = []
                for v in dict["Stages"] as! [Any] {
                    var model = GetDeploymentResponseBody.Pipeline.Stages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.stages = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var pipeline: GetDeploymentResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = GetDeploymentResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeploymentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFunctionRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetFunctionResponseBody : Tea.TeaModel {
    public class Function : Tea.TeaModel {
        public var createTime: Int64?

        public var id: String?

        public var modifyTime: Int64?

        public var name: String?

        public var owner: String?

        public var projectId: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
        }
    }
    public var function: GetFunctionResponseBody.Function?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.function?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.function != nil {
            map["Function"] = self.function?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Function") {
            var model = GetFunctionResponseBody.Function()
            model.fromMap(dict["Function"] as! [String: Any])
            self.function = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFunctionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetJobStatusRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class GetJobStatusResponseBody : Tea.TeaModel {
    public class JobStatus : Tea.TeaModel {
        public var completed: String?

        public var createTime: String?

        public var error: String?

        public var jobId: String?

        public var jobType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completed != nil {
                map["Completed"] = self.completed!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.jobType != nil {
                map["JobType"] = self.jobType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Completed") {
                self.completed = dict["Completed"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Error") {
                self.error = dict["Error"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("JobType") {
                self.jobType = dict["JobType"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var jobStatus: GetJobStatusResponseBody.JobStatus?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobStatus != nil {
            map["JobStatus"] = self.jobStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobStatus") {
            var model = GetJobStatusResponseBody.JobStatus()
            model.fromMap(dict["JobStatus"] as! [String: Any])
            self.jobStatus = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetJobStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetJobStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetJobStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNetworkRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetNetworkResponseBody : Tea.TeaModel {
    public class Network : Tea.TeaModel {
        public var createTime: Int64?

        public var createUser: String?

        public var id: Int64?

        public var resourceGroupId: String?

        public var securityGroupId: String?

        public var status: String?

        public var vpcId: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("VswitchId") {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public var network: GetNetworkResponseBody.Network?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.network?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.network != nil {
            map["Network"] = self.network?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Network") {
            var model = GetNetworkResponseBody.Network()
            model.fromMap(dict["Network"] as! [String: Any])
            self.network = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNodeRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetNodeResponseBody : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public var createTime: Int64?

        public var id: String?

        public var modifyTime: Int64?

        public var name: String?

        public var owner: String?

        public var projectId: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
        }
    }
    public var node: GetNodeResponseBody.Node?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.node?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.node != nil {
            map["Node"] = self.node?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Node") {
            var model = GetNodeResponseBody.Node()
            model.fromMap(dict["Node"] as! [String: Any])
            self.node = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProjectRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public class AliyunResourceTags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var aliyunResourceGroupId: String?

        public var aliyunResourceTags: [GetProjectResponseBody.Project.AliyunResourceTags]?

        public var description_: String?

        public var devEnvironmentEnabled: Bool?

        public var devRoleDisabled: Bool?

        public var displayName: String?

        public var id: Int64?

        public var name: String?

        public var owner: String?

        public var paiTaskEnabled: Bool?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunResourceGroupId != nil {
                map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
            }
            if self.aliyunResourceTags != nil {
                var tmp : [Any] = []
                for k in self.aliyunResourceTags! {
                    tmp.append(k.toMap())
                }
                map["AliyunResourceTags"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.devEnvironmentEnabled != nil {
                map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
            }
            if self.devRoleDisabled != nil {
                map["DevRoleDisabled"] = self.devRoleDisabled!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.paiTaskEnabled != nil {
                map["PaiTaskEnabled"] = self.paiTaskEnabled!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliyunResourceGroupId") {
                self.aliyunResourceGroupId = dict["AliyunResourceGroupId"] as! String
            }
            if dict.keys.contains("AliyunResourceTags") {
                var tmp : [GetProjectResponseBody.Project.AliyunResourceTags] = []
                for v in dict["AliyunResourceTags"] as! [Any] {
                    var model = GetProjectResponseBody.Project.AliyunResourceTags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.aliyunResourceTags = tmp
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DevEnvironmentEnabled") {
                self.devEnvironmentEnabled = dict["DevEnvironmentEnabled"] as! Bool
            }
            if dict.keys.contains("DevRoleDisabled") {
                self.devRoleDisabled = dict["DevRoleDisabled"] as! Bool
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("PaiTaskEnabled") {
                self.paiTaskEnabled = dict["PaiTaskEnabled"] as! Bool
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var project: GetProjectResponseBody.Project?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") {
            var model = GetProjectResponseBody.Project()
            model.fromMap(dict["Project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProjectMemberRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetProjectMemberResponseBody : Tea.TeaModel {
    public class ProjectMember : Tea.TeaModel {
        public class Roles : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var projectId: Int64?

        public var roles: [GetProjectMemberResponseBody.ProjectMember.Roles]?

        public var status: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.roles != nil {
                var tmp : [Any] = []
                for k in self.roles! {
                    tmp.append(k.toMap())
                }
                map["Roles"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("Roles") {
                var tmp : [GetProjectMemberResponseBody.ProjectMember.Roles] = []
                for v in dict["Roles"] as! [Any] {
                    var model = GetProjectMemberResponseBody.ProjectMember.Roles()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roles = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var projectMember: GetProjectMemberResponseBody.ProjectMember?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projectMember?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectMember != nil {
            map["ProjectMember"] = self.projectMember?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectMember") {
            var model = GetProjectMemberResponseBody.ProjectMember()
            model.fromMap(dict["ProjectMember"] as! [String: Any])
            self.projectMember = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProjectMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProjectRoleRequest : Tea.TeaModel {
    public var code: String?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class GetProjectRoleResponseBody : Tea.TeaModel {
    public class ProjectRole : Tea.TeaModel {
        public var code: String?

        public var name: String?

        public var projectId: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var projectRole: GetProjectRoleResponseBody.ProjectRole?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projectRole?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectRole != nil {
            map["ProjectRole"] = self.projectRole?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectRole") {
            var model = GetProjectRoleResponseBody.ProjectRole()
            model.fromMap(dict["ProjectRole"] as! [String: Any])
            self.projectRole = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetProjectRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProjectRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetResourceRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetResourceResponseBody : Tea.TeaModel {
    public class Resource : Tea.TeaModel {
        public var createTime: Int64?

        public var id: String?

        public var modifyTime: Int64?

        public var name: String?

        public var owner: String?

        public var projectId: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
        }
    }
    public var requestId: String?

    public var resource: GetResourceResponseBody.Resource?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resource") {
            var model = GetResourceResponseBody.Resource()
            model.fromMap(dict["Resource"] as! [String: Any])
            self.resource = model
        }
    }
}

public class GetResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetResourceGroupRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class GetResourceGroupResponseBody : Tea.TeaModel {
    public class ResourceGroup : Tea.TeaModel {
        public class Spec : Tea.TeaModel {
            public var amount: Int32?

            public var standard: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.standard != nil {
                    map["Standard"] = self.standard!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Amount") {
                    self.amount = dict["Amount"] as! Int32
                }
                if dict.keys.contains("Standard") {
                    self.standard = dict["Standard"] as! String
                }
            }
        }
        public var createTime: Int64?

        public var createUser: String?

        public var defaultVpcId: String?

        public var defaultVswitchId: String?

        public var id: String?

        public var name: String?

        public var orderInstanceId: String?

        public var paymentType: String?

        public var remark: String?

        public var resourceGroupType: String?

        public var spec: GetResourceGroupResponseBody.ResourceGroup.Spec?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.spec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.defaultVpcId != nil {
                map["DefaultVpcId"] = self.defaultVpcId!
            }
            if self.defaultVswitchId != nil {
                map["DefaultVswitchId"] = self.defaultVswitchId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.orderInstanceId != nil {
                map["OrderInstanceId"] = self.orderInstanceId!
            }
            if self.paymentType != nil {
                map["PaymentType"] = self.paymentType!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.resourceGroupType != nil {
                map["ResourceGroupType"] = self.resourceGroupType!
            }
            if self.spec != nil {
                map["Spec"] = self.spec?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("DefaultVpcId") {
                self.defaultVpcId = dict["DefaultVpcId"] as! String
            }
            if dict.keys.contains("DefaultVswitchId") {
                self.defaultVswitchId = dict["DefaultVswitchId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrderInstanceId") {
                self.orderInstanceId = dict["OrderInstanceId"] as! String
            }
            if dict.keys.contains("PaymentType") {
                self.paymentType = dict["PaymentType"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ResourceGroupType") {
                self.resourceGroupType = dict["ResourceGroupType"] as! String
            }
            if dict.keys.contains("Spec") {
                var model = GetResourceGroupResponseBody.ResourceGroup.Spec()
                model.fromMap(dict["Spec"] as! [String: Any])
                self.spec = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var requestId: String?

    public var resourceGroup: GetResourceGroupResponseBody.ResourceGroup?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroup") {
            var model = GetResourceGroupResponseBody.ResourceGroup()
            model.fromMap(dict["ResourceGroup"] as! [String: Any])
            self.resourceGroup = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRouteRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetRouteResponseBody : Tea.TeaModel {
    public class Route : Tea.TeaModel {
        public var createTime: Int64?

        public var destinationCidr: String?

        public var id: Int64?

        public var networkId: Int64?

        public var resourceGroupId: String?

        public var resourceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.destinationCidr != nil {
                map["DestinationCidr"] = self.destinationCidr!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("DestinationCidr") {
                self.destinationCidr = dict["DestinationCidr"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! Int64
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var route: GetRouteResponseBody.Route?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.route?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.route != nil {
            map["Route"] = self.route?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Route") {
            var model = GetRouteResponseBody.Route()
            model.fromMap(dict["Route"] as! [String: Any])
            self.route = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskRequest : Tea.TeaModel {
    public var id: Int64?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class GetTaskResponseBody : Tea.TeaModel {
    public class Task : Tea.TeaModel {
        public class DataSource : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public class Dependencies : Tea.TeaModel {
            public var type: String?

            public var upstreamOutput: String?

            public var upstreamTaskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.upstreamOutput != nil {
                    map["UpstreamOutput"] = self.upstreamOutput!
                }
                if self.upstreamTaskId != nil {
                    map["UpstreamTaskId"] = self.upstreamTaskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpstreamOutput") {
                    self.upstreamOutput = dict["UpstreamOutput"] as! String
                }
                if dict.keys.contains("UpstreamTaskId") {
                    self.upstreamTaskId = dict["UpstreamTaskId"] as! String
                }
            }
        }
        public class Inputs : Tea.TeaModel {
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var variables: [GetTaskResponseBody.Task.Inputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Variables") {
                    var tmp : [GetTaskResponseBody.Task.Inputs.Variables] = []
                    for v in dict["Variables"] as! [Any] {
                        var model = GetTaskResponseBody.Task.Inputs.Variables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.variables = tmp
                }
            }
        }
        public class Outputs : Tea.TeaModel {
            public class TaskOutputs : Tea.TeaModel {
                public var output: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Output") {
                        self.output = dict["Output"] as! String
                    }
                }
            }
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var taskOutputs: [GetTaskResponseBody.Task.Outputs.TaskOutputs]?

            public var variables: [GetTaskResponseBody.Task.Outputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskOutputs != nil {
                    var tmp : [Any] = []
                    for k in self.taskOutputs! {
                        tmp.append(k.toMap())
                    }
                    map["TaskOutputs"] = tmp
                }
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TaskOutputs") {
                    var tmp : [GetTaskResponseBody.Task.Outputs.TaskOutputs] = []
                    for v in dict["TaskOutputs"] as! [Any] {
                        var model = GetTaskResponseBody.Task.Outputs.TaskOutputs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.taskOutputs = tmp
                }
                if dict.keys.contains("Variables") {
                    var tmp : [GetTaskResponseBody.Task.Outputs.Variables] = []
                    for v in dict["Variables"] as! [Any] {
                        var model = GetTaskResponseBody.Task.Outputs.Variables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.variables = tmp
                }
            }
        }
        public class RuntimeResource : Tea.TeaModel {
            public var cu: String?

            public var image: String?

            public var resourceGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cu != nil {
                    map["Cu"] = self.cu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cu") {
                    self.cu = dict["Cu"] as! String
                }
                if dict.keys.contains("Image") {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
            }
        }
        public class Script : Tea.TeaModel {
            public var content: String?

            public var parameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Parameters") {
                    self.parameters = dict["Parameters"] as! String
                }
            }
        }
        public class SubTasks : Tea.TeaModel {
            public class SubTasks : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public class RuntimeResource : Tea.TeaModel {
                    public var cu: String?

                    public var image: String?

                    public var resourceGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cu != nil {
                            map["Cu"] = self.cu!
                        }
                        if self.image != nil {
                            map["Image"] = self.image!
                        }
                        if self.resourceGroupId != nil {
                            map["ResourceGroupId"] = self.resourceGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Cu") {
                            self.cu = dict["Cu"] as! String
                        }
                        if dict.keys.contains("Image") {
                            self.image = dict["Image"] as! String
                        }
                        if dict.keys.contains("ResourceGroupId") {
                            self.resourceGroupId = dict["ResourceGroupId"] as! String
                        }
                    }
                }
                public class Trigger : Tea.TeaModel {
                    public var cron: String?

                    public var endTime: String?

                    public var recurrence: String?

                    public var startTime: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cron != nil {
                            map["Cron"] = self.cron!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.recurrence != nil {
                            map["Recurrence"] = self.recurrence!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Cron") {
                            self.cron = dict["Cron"] as! String
                        }
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("Recurrence") {
                            self.recurrence = dict["Recurrence"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var baselineId: Int64?

                public var createTime: Int64?

                public var createUser: String?

                public var dataSource: GetTaskResponseBody.Task.SubTasks.SubTasks.DataSource?

                public var description_: String?

                public var id: Int64?

                public var modifyTime: Int64?

                public var modifyUser: String?

                public var name: String?

                public var owner: String?

                public var priority: Int32?

                public var projectEnv: String?

                public var projectId: Int64?

                public var rerunInterval: Int32?

                public var rerunMode: String?

                public var rerunTimes: Int32?

                public var runtimeResource: GetTaskResponseBody.Task.SubTasks.SubTasks.RuntimeResource?

                public var tenantId: Int64?

                public var timeout: Int32?

                public var trigger: GetTaskResponseBody.Task.SubTasks.SubTasks.Trigger?

                public var type: String?

                public var workflowId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.dataSource?.validate()
                    try self.runtimeResource?.validate()
                    try self.trigger?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.baselineId != nil {
                        map["BaselineId"] = self.baselineId!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.createUser != nil {
                        map["CreateUser"] = self.createUser!
                    }
                    if self.dataSource != nil {
                        map["DataSource"] = self.dataSource?.toMap()
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.modifyUser != nil {
                        map["ModifyUser"] = self.modifyUser!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.owner != nil {
                        map["Owner"] = self.owner!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.projectEnv != nil {
                        map["ProjectEnv"] = self.projectEnv!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.rerunInterval != nil {
                        map["RerunInterval"] = self.rerunInterval!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.rerunTimes != nil {
                        map["RerunTimes"] = self.rerunTimes!
                    }
                    if self.runtimeResource != nil {
                        map["RuntimeResource"] = self.runtimeResource?.toMap()
                    }
                    if self.tenantId != nil {
                        map["TenantId"] = self.tenantId!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    if self.trigger != nil {
                        map["Trigger"] = self.trigger?.toMap()
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.workflowId != nil {
                        map["WorkflowId"] = self.workflowId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BaselineId") {
                        self.baselineId = dict["BaselineId"] as! Int64
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("CreateUser") {
                        self.createUser = dict["CreateUser"] as! String
                    }
                    if dict.keys.contains("DataSource") {
                        var model = GetTaskResponseBody.Task.SubTasks.SubTasks.DataSource()
                        model.fromMap(dict["DataSource"] as! [String: Any])
                        self.dataSource = model
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("ModifyTime") {
                        self.modifyTime = dict["ModifyTime"] as! Int64
                    }
                    if dict.keys.contains("ModifyUser") {
                        self.modifyUser = dict["ModifyUser"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Owner") {
                        self.owner = dict["Owner"] as! String
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! Int32
                    }
                    if dict.keys.contains("ProjectEnv") {
                        self.projectEnv = dict["ProjectEnv"] as! String
                    }
                    if dict.keys.contains("ProjectId") {
                        self.projectId = dict["ProjectId"] as! Int64
                    }
                    if dict.keys.contains("RerunInterval") {
                        self.rerunInterval = dict["RerunInterval"] as! Int32
                    }
                    if dict.keys.contains("RerunMode") {
                        self.rerunMode = dict["RerunMode"] as! String
                    }
                    if dict.keys.contains("RerunTimes") {
                        self.rerunTimes = dict["RerunTimes"] as! Int32
                    }
                    if dict.keys.contains("RuntimeResource") {
                        var model = GetTaskResponseBody.Task.SubTasks.SubTasks.RuntimeResource()
                        model.fromMap(dict["RuntimeResource"] as! [String: Any])
                        self.runtimeResource = model
                    }
                    if dict.keys.contains("TenantId") {
                        self.tenantId = dict["TenantId"] as! Int64
                    }
                    if dict.keys.contains("Timeout") {
                        self.timeout = dict["Timeout"] as! Int32
                    }
                    if dict.keys.contains("Trigger") {
                        var model = GetTaskResponseBody.Task.SubTasks.SubTasks.Trigger()
                        model.fromMap(dict["Trigger"] as! [String: Any])
                        self.trigger = model
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("WorkflowId") {
                        self.workflowId = dict["WorkflowId"] as! Int64
                    }
                }
            }
            public var subTasks: [GetTaskResponseBody.Task.SubTasks.SubTasks]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.subTasks != nil {
                    var tmp : [Any] = []
                    for k in self.subTasks! {
                        tmp.append(k.toMap())
                    }
                    map["SubTasks"] = tmp
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SubTasks") {
                    var tmp : [GetTaskResponseBody.Task.SubTasks.SubTasks] = []
                    for v in dict["SubTasks"] as! [Any] {
                        var model = GetTaskResponseBody.Task.SubTasks.SubTasks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subTasks = tmp
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Trigger : Tea.TeaModel {
            public var cron: String?

            public var endTime: String?

            public var recurrence: String?

            public var startTime: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cron != nil {
                    map["Cron"] = self.cron!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.recurrence != nil {
                    map["Recurrence"] = self.recurrence!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cron") {
                    self.cron = dict["Cron"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("Recurrence") {
                    self.recurrence = dict["Recurrence"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var baselineId: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var dataSource: GetTaskResponseBody.Task.DataSource?

        public var dependencies: [GetTaskResponseBody.Task.Dependencies]?

        public var description_: String?

        public var id: Int64?

        public var inputs: GetTaskResponseBody.Task.Inputs?

        public var instanceMode: String?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var name: String?

        public var outputs: GetTaskResponseBody.Task.Outputs?

        public var owner: String?

        public var priority: Int32?

        public var projectEnv: String?

        public var projectId: Int64?

        public var rerunInterval: Int32?

        public var rerunMode: String?

        public var rerunTimes: Int32?

        public var runtimeResource: GetTaskResponseBody.Task.RuntimeResource?

        public var script: GetTaskResponseBody.Task.Script?

        public var subTasks: GetTaskResponseBody.Task.SubTasks?

        public var tags: [GetTaskResponseBody.Task.Tags]?

        public var tenantId: Int64?

        public var timeout: Int32?

        public var trigger: GetTaskResponseBody.Task.Trigger?

        public var type: String?

        public var workflowId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSource?.validate()
            try self.inputs?.validate()
            try self.outputs?.validate()
            try self.runtimeResource?.validate()
            try self.script?.validate()
            try self.subTasks?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource?.toMap()
            }
            if self.dependencies != nil {
                var tmp : [Any] = []
                for k in self.dependencies! {
                    tmp.append(k.toMap())
                }
                map["Dependencies"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.inputs != nil {
                map["Inputs"] = self.inputs?.toMap()
            }
            if self.instanceMode != nil {
                map["InstanceMode"] = self.instanceMode!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.outputs != nil {
                map["Outputs"] = self.outputs?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectEnv != nil {
                map["ProjectEnv"] = self.projectEnv!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.rerunInterval != nil {
                map["RerunInterval"] = self.rerunInterval!
            }
            if self.rerunMode != nil {
                map["RerunMode"] = self.rerunMode!
            }
            if self.rerunTimes != nil {
                map["RerunTimes"] = self.rerunTimes!
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource?.toMap()
            }
            if self.script != nil {
                map["Script"] = self.script?.toMap()
            }
            if self.subTasks != nil {
                map["SubTasks"] = self.subTasks?.toMap()
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.workflowId != nil {
                map["WorkflowId"] = self.workflowId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineId") {
                self.baselineId = dict["BaselineId"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("DataSource") {
                var model = GetTaskResponseBody.Task.DataSource()
                model.fromMap(dict["DataSource"] as! [String: Any])
                self.dataSource = model
            }
            if dict.keys.contains("Dependencies") {
                var tmp : [GetTaskResponseBody.Task.Dependencies] = []
                for v in dict["Dependencies"] as! [Any] {
                    var model = GetTaskResponseBody.Task.Dependencies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dependencies = tmp
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Inputs") {
                var model = GetTaskResponseBody.Task.Inputs()
                model.fromMap(dict["Inputs"] as! [String: Any])
                self.inputs = model
            }
            if dict.keys.contains("InstanceMode") {
                self.instanceMode = dict["InstanceMode"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("ModifyUser") {
                self.modifyUser = dict["ModifyUser"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Outputs") {
                var model = GetTaskResponseBody.Task.Outputs()
                model.fromMap(dict["Outputs"] as! [String: Any])
                self.outputs = model
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("ProjectEnv") {
                self.projectEnv = dict["ProjectEnv"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("RerunInterval") {
                self.rerunInterval = dict["RerunInterval"] as! Int32
            }
            if dict.keys.contains("RerunMode") {
                self.rerunMode = dict["RerunMode"] as! String
            }
            if dict.keys.contains("RerunTimes") {
                self.rerunTimes = dict["RerunTimes"] as! Int32
            }
            if dict.keys.contains("RuntimeResource") {
                var model = GetTaskResponseBody.Task.RuntimeResource()
                model.fromMap(dict["RuntimeResource"] as! [String: Any])
                self.runtimeResource = model
            }
            if dict.keys.contains("Script") {
                var model = GetTaskResponseBody.Task.Script()
                model.fromMap(dict["Script"] as! [String: Any])
                self.script = model
            }
            if dict.keys.contains("SubTasks") {
                var model = GetTaskResponseBody.Task.SubTasks()
                model.fromMap(dict["SubTasks"] as! [String: Any])
                self.subTasks = model
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetTaskResponseBody.Task.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetTaskResponseBody.Task.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("Timeout") {
                self.timeout = dict["Timeout"] as! Int32
            }
            if dict.keys.contains("Trigger") {
                var model = GetTaskResponseBody.Task.Trigger()
                model.fromMap(dict["Trigger"] as! [String: Any])
                self.trigger = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WorkflowId") {
                self.workflowId = dict["WorkflowId"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var task: GetTaskResponseBody.Task?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.task?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.task != nil {
            map["Task"] = self.task?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Task") {
            var model = GetTaskResponseBody.Task()
            model.fromMap(dict["Task"] as! [String: Any])
            self.task = model
        }
    }
}

public class GetTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskInstanceRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetTaskInstanceResponseBody : Tea.TeaModel {
    public class TaskInstance : Tea.TeaModel {
        public class DataSource : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public class Inputs : Tea.TeaModel {
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var variables: [GetTaskInstanceResponseBody.TaskInstance.Inputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Variables") {
                    var tmp : [GetTaskInstanceResponseBody.TaskInstance.Inputs.Variables] = []
                    for v in dict["Variables"] as! [Any] {
                        var model = GetTaskInstanceResponseBody.TaskInstance.Inputs.Variables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.variables = tmp
                }
            }
        }
        public class Outputs : Tea.TeaModel {
            public class TaskOutputs : Tea.TeaModel {
                public var output: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Output") {
                        self.output = dict["Output"] as! String
                    }
                }
            }
            public class Variables : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var taskOutputs: [GetTaskInstanceResponseBody.TaskInstance.Outputs.TaskOutputs]?

            public var variables: [GetTaskInstanceResponseBody.TaskInstance.Outputs.Variables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.taskOutputs != nil {
                    var tmp : [Any] = []
                    for k in self.taskOutputs! {
                        tmp.append(k.toMap())
                    }
                    map["TaskOutputs"] = tmp
                }
                if self.variables != nil {
                    var tmp : [Any] = []
                    for k in self.variables! {
                        tmp.append(k.toMap())
                    }
                    map["Variables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TaskOutputs") {
                    var tmp : [GetTaskInstanceResponseBody.TaskInstance.Outputs.TaskOutputs] = []
                    for v in dict["TaskOutputs"] as! [Any] {
                        var model = GetTaskInstanceResponseBody.TaskInstance.Outputs.TaskOutputs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.taskOutputs = tmp
                }
                if dict.keys.contains("Variables") {
                    var tmp : [GetTaskInstanceResponseBody.TaskInstance.Outputs.Variables] = []
                    for v in dict["Variables"] as! [Any] {
                        var model = GetTaskInstanceResponseBody.TaskInstance.Outputs.Variables()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.variables = tmp
                }
            }
        }
        public class Runtime : Tea.TeaModel {
            public var gateway: String?

            public var processId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gateway != nil {
                    map["Gateway"] = self.gateway!
                }
                if self.processId != nil {
                    map["ProcessId"] = self.processId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Gateway") {
                    self.gateway = dict["Gateway"] as! String
                }
                if dict.keys.contains("ProcessId") {
                    self.processId = dict["ProcessId"] as! String
                }
            }
        }
        public class RuntimeResource : Tea.TeaModel {
            public var cu: String?

            public var image: String?

            public var resourceGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cu != nil {
                    map["Cu"] = self.cu!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cu") {
                    self.cu = dict["Cu"] as! String
                }
                if dict.keys.contains("Image") {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
            }
        }
        public class Script : Tea.TeaModel {
            public var content: String?

            public var parameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("Parameters") {
                    self.parameters = dict["Parameters"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var baselineId: Int64?

        public var bizdate: Int64?

        public var createTime: Int64?

        public var createUser: String?

        public var dataSource: GetTaskInstanceResponseBody.TaskInstance.DataSource?

        public var description_: String?

        public var finishedTime: Int64?

        public var id: Int64?

        public var inputs: GetTaskInstanceResponseBody.TaskInstance.Inputs?

        public var modifyTime: Int64?

        public var modifyUser: String?

        public var outputs: GetTaskInstanceResponseBody.TaskInstance.Outputs?

        public var owner: String?

        public var periodNumber: Int32?

        public var priority: Int32?

        public var projectEnv: String?

        public var projectId: Int64?

        public var rerunMode: String?

        public var runNumber: Int32?

        public var runtime: GetTaskInstanceResponseBody.TaskInstance.Runtime?

        public var runtimeResource: GetTaskInstanceResponseBody.TaskInstance.RuntimeResource?

        public var script: GetTaskInstanceResponseBody.TaskInstance.Script?

        public var startedTime: Int64?

        public var status: String?

        public var tags: [GetTaskInstanceResponseBody.TaskInstance.Tags]?

        public var taskId: Int64?

        public var taskName: String?

        public var taskType: String?

        public var tenantId: Int64?

        public var timeout: Int32?

        public var triggerRecurrence: String?

        public var triggerTime: Int64?

        public var triggerType: String?

        public var workflowId: Int64?

        public var workflowInstanceId: Int64?

        public var workflowInstanceType: String?

        public var workflowName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSource?.validate()
            try self.inputs?.validate()
            try self.outputs?.validate()
            try self.runtime?.validate()
            try self.runtimeResource?.validate()
            try self.script?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineId != nil {
                map["BaselineId"] = self.baselineId!
            }
            if self.bizdate != nil {
                map["Bizdate"] = self.bizdate!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.finishedTime != nil {
                map["FinishedTime"] = self.finishedTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.inputs != nil {
                map["Inputs"] = self.inputs?.toMap()
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.modifyUser != nil {
                map["ModifyUser"] = self.modifyUser!
            }
            if self.outputs != nil {
                map["Outputs"] = self.outputs?.toMap()
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.periodNumber != nil {
                map["PeriodNumber"] = self.periodNumber!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.projectEnv != nil {
                map["ProjectEnv"] = self.projectEnv!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.rerunMode != nil {
                map["RerunMode"] = self.rerunMode!
            }
            if self.runNumber != nil {
                map["RunNumber"] = self.runNumber!
            }
            if self.runtime != nil {
                map["Runtime"] = self.runtime?.toMap()
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource?.toMap()
            }
            if self.script != nil {
                map["Script"] = self.script?.toMap()
            }
            if self.startedTime != nil {
                map["StartedTime"] = self.startedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.triggerRecurrence != nil {
                map["TriggerRecurrence"] = self.triggerRecurrence!
            }
            if self.triggerTime != nil {
                map["TriggerTime"] = self.triggerTime!
            }
            if self.triggerType != nil {
                map["TriggerType"] = self.triggerType!
            }
            if self.workflowId != nil {
                map["WorkflowId"] = self.workflowId!
            }
            if self.workflowInstanceId != nil {
                map["WorkflowInstanceId"] = self.workflowInstanceId!
            }
            if self.workflowInstanceType != nil {
                map["WorkflowInstanceType"] = self.workflowInstanceType!
            }
            if self.workflowName != nil {
                map["WorkflowName"] = self.workflowName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineId") {
                self.baselineId = dict["BaselineId"] as! Int64
            }
            if dict.keys.contains("Bizdate") {
                self.bizdate = dict["Bizdate"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("DataSource") {
                var model = GetTaskInstanceResponseBody.TaskInstance.DataSource()
                model.fromMap(dict["DataSource"] as! [String: Any])
                self.dataSource = model
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("FinishedTime") {
                self.finishedTime = dict["FinishedTime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Inputs") {
                var model = GetTaskInstanceResponseBody.TaskInstance.Inputs()
                model.fromMap(dict["Inputs"] as! [String: Any])
                self.inputs = model
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("ModifyUser") {
                self.modifyUser = dict["ModifyUser"] as! String
            }
            if dict.keys.contains("Outputs") {
                var model = GetTaskInstanceResponseBody.TaskInstance.Outputs()
                model.fromMap(dict["Outputs"] as! [String: Any])
                self.outputs = model
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("PeriodNumber") {
                self.periodNumber = dict["PeriodNumber"] as! Int32
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("ProjectEnv") {
                self.projectEnv = dict["ProjectEnv"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! Int64
            }
            if dict.keys.contains("RerunMode") {
                self.rerunMode = dict["RerunMode"] as! String
            }
            if dict.keys.contains("RunNumber") {
                self.runNumber = dict["RunNumber"] as! Int32
            }
            if dict.keys.contains("Runtime") {
                var model = GetTaskInstanceResponseBody.TaskInstance.Runtime()
                model.fromMap(dict["Runtime"] as! [String: Any])
                self.runtime = model
            }
            if dict.keys.contains("RuntimeResource") {
                var model = GetTaskInstanceResponseBody.TaskInstance.RuntimeResource()
                model.fromMap(dict["RuntimeResource"] as! [String: Any])
                self.runtimeResource = model
            }
            if dict.keys.contains("Script") {
                var model = GetTaskInstanceResponseBody.TaskInstance.Script()
                model.fromMap(dict["Script"] as! [String: Any])
                self.script = model
            }
            if dict.keys.contains("StartedTime") {
                self.startedTime = dict["StartedTime"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [GetTaskInstanceResponseBody.TaskInstance.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = GetTaskInstanceResponseBody.TaskInstance.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! Int64
            }
            if dict.keys.contains("TaskName") {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! Int64
            }
            if dict.keys.contains("Timeout") {
                self.timeout = dict["Timeout"] as! Int32
            }
            if dict.keys.contains("TriggerRecurrence") {
                self.triggerRecurrence = dict["TriggerRecurrence"] as! String
            }
            if dict.keys.contains("TriggerTime") {
                self.triggerTime = dict["TriggerTime"] as! Int64
            }
            if dict.keys.contains("TriggerType") {
                self.triggerType = dict["TriggerType"] as! String
            }
            if dict.keys.contains("WorkflowId") {
                self.workflowId = dict["WorkflowId"] as! Int64
            }
            if dict.keys.contains("WorkflowInstanceId") {
                self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
            }
            if dict.keys.contains("WorkflowInstanceType") {
                self.workflowInstanceType = dict["WorkflowInstanceType"] as! String
            }
            if dict.keys.contains("WorkflowName") {
                self.workflowName = dict["WorkflowName"] as! String
            }
        }
    }
    public var requestId: String?

    public var taskInstance: GetTaskInstanceResponseBody.TaskInstance?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInstance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInstance != nil {
            map["TaskInstance"] = self.taskInstance?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskInstance") {
            var model = GetTaskInstanceResponseBody.TaskInstance()
            model.fromMap(dict["TaskInstance"] as! [String: Any])
            self.taskInstance = model
        }
    }
}

public class GetTaskInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTaskInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTaskInstanceLogRequest : Tea.TeaModel {
    public var id: Int64?

    public var runNumber: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.runNumber != nil {
            map["RunNumber"] = self.runNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RunNumber") {
            self.runNumber = dict["RunNumber"] as! Int32
        }
    }
}

public class GetTaskInstanceLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskInstanceLog: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInstanceLog != nil {
            map["TaskInstanceLog"] = self.taskInstanceLog!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskInstanceLog") {
            self.taskInstanceLog = dict["TaskInstanceLog"] as! String
        }
    }
}

public class GetTaskInstanceLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTaskInstanceLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTaskInstanceLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class GetWorkflowDefinitionResponseBody : Tea.TeaModel {
    public class WorkflowDefinition : Tea.TeaModel {
        public var createTime: Int64?

        public var id: String?

        public var modifyTime: Int64?

        public var name: String?

        public var owner: String?

        public var projectId: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.owner != nil {
                map["Owner"] = self.owner!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ModifyTime") {
                self.modifyTime = dict["ModifyTime"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Owner") {
                self.owner = dict["Owner"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("Spec") {
                self.spec = dict["Spec"] as! String
            }
        }
    }
    public var requestId: String?

    public var workflowDefinition: GetWorkflowDefinitionResponseBody.WorkflowDefinition?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflowDefinition?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflowDefinition != nil {
            map["WorkflowDefinition"] = self.workflowDefinition?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WorkflowDefinition") {
            var model = GetWorkflowDefinitionResponseBody.WorkflowDefinition()
            model.fromMap(dict["WorkflowDefinition"] as! [String: Any])
            self.workflowDefinition = model
        }
    }
}

public class GetWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkflowDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GrantMemberProjectRolesRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodes: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodes != nil {
            map["RoleCodes"] = self.roleCodes!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCodes") {
            self.roleCodes = dict["RoleCodes"] as! [String]
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GrantMemberProjectRolesShrinkRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodesShrink: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodesShrink != nil {
            map["RoleCodes"] = self.roleCodesShrink!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCodes") {
            self.roleCodesShrink = dict["RoleCodes"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GrantMemberProjectRolesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GrantMemberProjectRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantMemberProjectRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GrantMemberProjectRolesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportWorkflowDefinitionRequest : Tea.TeaModel {
    public var projectId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class ImportWorkflowDefinitionResponseBody : Tea.TeaModel {
    public class AsyncJob : Tea.TeaModel {
        public var completed: Bool?

        public var createTime: Int64?

        public var error: String?

        public var id: String?

        public var progress: Int32?

        public var response: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.completed != nil {
                map["Completed"] = self.completed!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.response != nil {
                map["Response"] = self.response!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Completed") {
                self.completed = dict["Completed"] as! Bool
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Error") {
                self.error = dict["Error"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("Response") {
                self.response = dict["Response"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var asyncJob: ImportWorkflowDefinitionResponseBody.AsyncJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.asyncJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asyncJob != nil {
            map["AsyncJob"] = self.asyncJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AsyncJob") {
            var model = ImportWorkflowDefinitionResponseBody.AsyncJob()
            model.fromMap(dict["AsyncJob"] as! [String: Any])
            self.asyncJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportWorkflowDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlertRulesRequest : Tea.TeaModel {
    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int64?

    public var receiver: String?

    public var taskIds: [Int64]?

    public var types: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.receiver != nil {
            map["Receiver"] = self.receiver!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Receiver") {
            self.receiver = dict["Receiver"] as! String
        }
        if dict.keys.contains("TaskIds") {
            self.taskIds = dict["TaskIds"] as! [Int64]
        }
        if dict.keys.contains("Types") {
            self.types = dict["Types"] as! [String]
        }
    }
}

public class ListAlertRulesShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int64?

    public var receiver: String?

    public var taskIdsShrink: String?

    public var typesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.receiver != nil {
            map["Receiver"] = self.receiver!
        }
        if self.taskIdsShrink != nil {
            map["TaskIds"] = self.taskIdsShrink!
        }
        if self.typesShrink != nil {
            map["Types"] = self.typesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Receiver") {
            self.receiver = dict["Receiver"] as! String
        }
        if dict.keys.contains("TaskIds") {
            self.taskIdsShrink = dict["TaskIds"] as! String
        }
        if dict.keys.contains("Types") {
            self.typesShrink = dict["Types"] as! String
        }
    }
}

public class ListAlertRulesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class AlertRules : Tea.TeaModel {
            public class TriggerCondition : Tea.TeaModel {
                public class Extension_ : Tea.TeaModel {
                    public class CycleUnfinished : Tea.TeaModel {
                        public class CycleAndTime : Tea.TeaModel {
                            public var cycleId: Int32?

                            public var time: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.cycleId != nil {
                                    map["CycleId"] = self.cycleId!
                                }
                                if self.time != nil {
                                    map["Time"] = self.time!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CycleId") {
                                    self.cycleId = dict["CycleId"] as! Int32
                                }
                                if dict.keys.contains("Time") {
                                    self.time = dict["Time"] as! String
                                }
                            }
                        }
                        public var cycleAndTime: [ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.cycleAndTime != nil {
                                var tmp : [Any] = []
                                for k in self.cycleAndTime! {
                                    tmp.append(k.toMap())
                                }
                                map["CycleAndTime"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CycleAndTime") {
                                var tmp : [ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime] = []
                                for v in dict["CycleAndTime"] as! [Any] {
                                    var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.cycleAndTime = tmp
                            }
                        }
                    }
                    public class Error : Tea.TeaModel {
                        public var autoRerunAlert: Bool?

                        public var streamTaskIds: [Int64]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.autoRerunAlert != nil {
                                map["AutoRerunAlert"] = self.autoRerunAlert!
                            }
                            if self.streamTaskIds != nil {
                                map["StreamTaskIds"] = self.streamTaskIds!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AutoRerunAlert") {
                                self.autoRerunAlert = dict["AutoRerunAlert"] as! Bool
                            }
                            if dict.keys.contains("StreamTaskIds") {
                                self.streamTaskIds = dict["StreamTaskIds"] as! [Int64]
                            }
                        }
                    }
                    public class InstanceErrorCount : Tea.TeaModel {
                        public var count: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! Int32
                            }
                        }
                    }
                    public class InstanceErrorPercentage : Tea.TeaModel {
                        public var percentage: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.percentage != nil {
                                map["Percentage"] = self.percentage!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Percentage") {
                                self.percentage = dict["Percentage"] as! Int32
                            }
                        }
                    }
                    public class InstanceTransferFluctuate : Tea.TeaModel {
                        public var percentage: Int32?

                        public var trend: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.percentage != nil {
                                map["Percentage"] = self.percentage!
                            }
                            if self.trend != nil {
                                map["Trend"] = self.trend!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Percentage") {
                                self.percentage = dict["Percentage"] as! Int32
                            }
                            if dict.keys.contains("Trend") {
                                self.trend = dict["Trend"] as! String
                            }
                        }
                    }
                    public class Timeout : Tea.TeaModel {
                        public var timeoutInMinutes: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.timeoutInMinutes != nil {
                                map["TimeoutInMinutes"] = self.timeoutInMinutes!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TimeoutInMinutes") {
                                self.timeoutInMinutes = dict["TimeoutInMinutes"] as! Int32
                            }
                        }
                    }
                    public class UnFinished : Tea.TeaModel {
                        public var unFinishedTime: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.unFinishedTime != nil {
                                map["UnFinishedTime"] = self.unFinishedTime!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("UnFinishedTime") {
                                self.unFinishedTime = dict["UnFinishedTime"] as! String
                            }
                        }
                    }
                    public var cycleUnfinished: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished?

                    public var error: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.Error?

                    public var instanceErrorCount: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceErrorCount?

                    public var instanceErrorPercentage: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceErrorPercentage?

                    public var instanceTransferFluctuate: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceTransferFluctuate?

                    public var timeout: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.Timeout?

                    public var unFinished: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.UnFinished?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.cycleUnfinished?.validate()
                        try self.error?.validate()
                        try self.instanceErrorCount?.validate()
                        try self.instanceErrorPercentage?.validate()
                        try self.instanceTransferFluctuate?.validate()
                        try self.timeout?.validate()
                        try self.unFinished?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleUnfinished != nil {
                            map["CycleUnfinished"] = self.cycleUnfinished?.toMap()
                        }
                        if self.error != nil {
                            map["Error"] = self.error?.toMap()
                        }
                        if self.instanceErrorCount != nil {
                            map["InstanceErrorCount"] = self.instanceErrorCount?.toMap()
                        }
                        if self.instanceErrorPercentage != nil {
                            map["InstanceErrorPercentage"] = self.instanceErrorPercentage?.toMap()
                        }
                        if self.instanceTransferFluctuate != nil {
                            map["InstanceTransferFluctuate"] = self.instanceTransferFluctuate?.toMap()
                        }
                        if self.timeout != nil {
                            map["Timeout"] = self.timeout?.toMap()
                        }
                        if self.unFinished != nil {
                            map["UnFinished"] = self.unFinished?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CycleUnfinished") {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.CycleUnfinished()
                            model.fromMap(dict["CycleUnfinished"] as! [String: Any])
                            self.cycleUnfinished = model
                        }
                        if dict.keys.contains("Error") {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.Error()
                            model.fromMap(dict["Error"] as! [String: Any])
                            self.error = model
                        }
                        if dict.keys.contains("InstanceErrorCount") {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceErrorCount()
                            model.fromMap(dict["InstanceErrorCount"] as! [String: Any])
                            self.instanceErrorCount = model
                        }
                        if dict.keys.contains("InstanceErrorPercentage") {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceErrorPercentage()
                            model.fromMap(dict["InstanceErrorPercentage"] as! [String: Any])
                            self.instanceErrorPercentage = model
                        }
                        if dict.keys.contains("InstanceTransferFluctuate") {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.InstanceTransferFluctuate()
                            model.fromMap(dict["InstanceTransferFluctuate"] as! [String: Any])
                            self.instanceTransferFluctuate = model
                        }
                        if dict.keys.contains("Timeout") {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.Timeout()
                            model.fromMap(dict["Timeout"] as! [String: Any])
                            self.timeout = model
                        }
                        if dict.keys.contains("UnFinished") {
                            var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_.UnFinished()
                            model.fromMap(dict["UnFinished"] as! [String: Any])
                            self.unFinished = model
                        }
                    }
                }
                public class Target : Tea.TeaModel {
                    public var allowTasks: [Int64]?

                    public var ids: [Int64]?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowTasks != nil {
                            map["AllowTasks"] = self.allowTasks!
                        }
                        if self.ids != nil {
                            map["Ids"] = self.ids!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllowTasks") {
                            self.allowTasks = dict["AllowTasks"] as! [Int64]
                        }
                        if dict.keys.contains("Ids") {
                            self.ids = dict["Ids"] as! [Int64]
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var extension_: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_?

                public var target: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Target?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.extension_?.validate()
                    try self.target?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_?.toMap()
                    }
                    if self.target != nil {
                        map["Target"] = self.target?.toMap()
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Extension") {
                        var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Extension_()
                        model.fromMap(dict["Extension"] as! [String: Any])
                        self.extension_ = model
                    }
                    if dict.keys.contains("Target") {
                        var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition.Target()
                        model.fromMap(dict["Target"] as! [String: Any])
                        self.target = model
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var enabled: Bool?

            public var id: Int64?

            public var name: String?

            public var owner: String?

            public var triggerCondition: ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.triggerCondition?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.triggerCondition != nil {
                    map["TriggerCondition"] = self.triggerCondition?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("TriggerCondition") {
                    var model = ListAlertRulesResponseBody.PagingInfo.AlertRules.TriggerCondition()
                    model.fromMap(dict["TriggerCondition"] as! [String: Any])
                    self.triggerCondition = model
                }
            }
        }
        public var alertRules: [ListAlertRulesResponseBody.PagingInfo.AlertRules]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertRules != nil {
                var tmp : [Any] = []
                for k in self.alertRules! {
                    tmp.append(k.toMap())
                }
                map["AlertRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertRules") {
                var tmp : [ListAlertRulesResponseBody.PagingInfo.AlertRules] = []
                for v in dict["AlertRules"] as! [Any] {
                    var model = ListAlertRulesResponseBody.PagingInfo.AlertRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.alertRules = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListAlertRulesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListAlertRulesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAlertRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlertRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAlertRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDIAlarmRulesRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var jobId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListDIAlarmRulesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DIJobAlarmRules : Tea.TeaModel {
            public class NotificationSettings : Tea.TeaModel {
                public class NotificationChannels : Tea.TeaModel {
                    public var channels: [String]?

                    public var severity: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! [String]
                        }
                        if dict.keys.contains("Severity") {
                            self.severity = dict["Severity"] as! String
                        }
                    }
                }
                public class NotificationReceivers : Tea.TeaModel {
                    public var receiverType: String?

                    public var receiverValues: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.receiverType != nil {
                            map["ReceiverType"] = self.receiverType!
                        }
                        if self.receiverValues != nil {
                            map["ReceiverValues"] = self.receiverValues!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ReceiverType") {
                            self.receiverType = dict["ReceiverType"] as! String
                        }
                        if dict.keys.contains("ReceiverValues") {
                            self.receiverValues = dict["ReceiverValues"] as! [String]
                        }
                    }
                }
                public var inhibitionInterval: Int64?

                public var notificationChannels: [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationChannels]?

                public var notificationReceivers: [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationReceivers]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inhibitionInterval != nil {
                        map["InhibitionInterval"] = self.inhibitionInterval!
                    }
                    if self.notificationChannels != nil {
                        var tmp : [Any] = []
                        for k in self.notificationChannels! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationChannels"] = tmp
                    }
                    if self.notificationReceivers != nil {
                        var tmp : [Any] = []
                        for k in self.notificationReceivers! {
                            tmp.append(k.toMap())
                        }
                        map["NotificationReceivers"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InhibitionInterval") {
                        self.inhibitionInterval = dict["InhibitionInterval"] as! Int64
                    }
                    if dict.keys.contains("NotificationChannels") {
                        var tmp : [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationChannels] = []
                        for v in dict["NotificationChannels"] as! [Any] {
                            var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationChannels()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notificationChannels = tmp
                    }
                    if dict.keys.contains("NotificationReceivers") {
                        var tmp : [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationReceivers] = []
                        for v in dict["NotificationReceivers"] as! [Any] {
                            var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings.NotificationReceivers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notificationReceivers = tmp
                    }
                }
            }
            public class TriggerConditions : Tea.TeaModel {
                public var ddlReportTags: [String]?

                public var duration: Int64?

                public var severity: String?

                public var threshold: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ddlReportTags != nil {
                        map["DdlReportTags"] = self.ddlReportTags!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DdlReportTags") {
                        self.ddlReportTags = dict["DdlReportTags"] as! [String]
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int64
                    }
                    if dict.keys.contains("Severity") {
                        self.severity = dict["Severity"] as! String
                    }
                    if dict.keys.contains("Threshold") {
                        self.threshold = dict["Threshold"] as! Int64
                    }
                }
            }
            public var DIAlarmRuleId: Int64?

            public var DIJobId: Int64?

            public var description_: String?

            public var enabled: Bool?

            public var metricType: String?

            public var name: String?

            public var notificationSettings: ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings?

            public var triggerConditions: [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.TriggerConditions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notificationSettings?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DIAlarmRuleId != nil {
                    map["DIAlarmRuleId"] = self.DIAlarmRuleId!
                }
                if self.DIJobId != nil {
                    map["DIJobId"] = self.DIJobId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.metricType != nil {
                    map["MetricType"] = self.metricType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notificationSettings != nil {
                    map["NotificationSettings"] = self.notificationSettings?.toMap()
                }
                if self.triggerConditions != nil {
                    var tmp : [Any] = []
                    for k in self.triggerConditions! {
                        tmp.append(k.toMap())
                    }
                    map["TriggerConditions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DIAlarmRuleId") {
                    self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
                }
                if dict.keys.contains("DIJobId") {
                    self.DIJobId = dict["DIJobId"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! Bool
                }
                if dict.keys.contains("MetricType") {
                    self.metricType = dict["MetricType"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NotificationSettings") {
                    var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.NotificationSettings()
                    model.fromMap(dict["NotificationSettings"] as! [String: Any])
                    self.notificationSettings = model
                }
                if dict.keys.contains("TriggerConditions") {
                    var tmp : [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.TriggerConditions] = []
                    for v in dict["TriggerConditions"] as! [Any] {
                        var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules.TriggerConditions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.triggerConditions = tmp
                }
            }
        }
        public var DIJobAlarmRules: [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobAlarmRules != nil {
                var tmp : [Any] = []
                for k in self.DIJobAlarmRules! {
                    tmp.append(k.toMap())
                }
                map["DIJobAlarmRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DIJobAlarmRules") {
                var tmp : [ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules] = []
                for v in dict["DIJobAlarmRules"] as! [Any] {
                    var model = ListDIAlarmRulesResponseBody.PagingInfo.DIJobAlarmRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DIJobAlarmRules = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var pagingInfo: ListDIAlarmRulesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDIAlarmRulesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDIAlarmRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIAlarmRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDIAlarmRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDIJobEventsRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var endTime: Int64?

    public var eventType: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListDIJobEventsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DIJobEvent : Tea.TeaModel {
            public var action: String?

            public var channels: String?

            public var createTime: String?

            public var detail: String?

            public var dstSql: String?

            public var dstTable: String?

            public var failoverMessage: String?

            public var id: String?

            public var severity: String?

            public var srcSql: String?

            public var srcTable: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.detail != nil {
                    map["Detail"] = self.detail!
                }
                if self.dstSql != nil {
                    map["DstSql"] = self.dstSql!
                }
                if self.dstTable != nil {
                    map["DstTable"] = self.dstTable!
                }
                if self.failoverMessage != nil {
                    map["FailoverMessage"] = self.failoverMessage!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.srcSql != nil {
                    map["SrcSql"] = self.srcSql!
                }
                if self.srcTable != nil {
                    map["SrcTable"] = self.srcTable!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Detail") {
                    self.detail = dict["Detail"] as! String
                }
                if dict.keys.contains("DstSql") {
                    self.dstSql = dict["DstSql"] as! String
                }
                if dict.keys.contains("DstTable") {
                    self.dstTable = dict["DstTable"] as! String
                }
                if dict.keys.contains("FailoverMessage") {
                    self.failoverMessage = dict["FailoverMessage"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("SrcSql") {
                    self.srcSql = dict["SrcSql"] as! String
                }
                if dict.keys.contains("SrcTable") {
                    self.srcTable = dict["SrcTable"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var DIJobEvent: [ListDIJobEventsResponseBody.PagingInfo.DIJobEvent]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobEvent != nil {
                var tmp : [Any] = []
                for k in self.DIJobEvent! {
                    tmp.append(k.toMap())
                }
                map["DIJobEvent"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DIJobEvent") {
                var tmp : [ListDIJobEventsResponseBody.PagingInfo.DIJobEvent] = []
                for v in dict["DIJobEvent"] as! [Any] {
                    var model = ListDIJobEventsResponseBody.PagingInfo.DIJobEvent()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DIJobEvent = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var pagingInfo: ListDIJobEventsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDIJobEventsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDIJobEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDIJobEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDIJobMetricsRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var endTime: Int64?

    public var metricName: [String]?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.metricName != nil {
            map["MetricName"] = self.metricName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("MetricName") {
            self.metricName = dict["MetricName"] as! [String]
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListDIJobMetricsShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var endTime: Int64?

    public var metricNameShrink: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.metricNameShrink != nil {
            map["MetricName"] = self.metricNameShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("MetricName") {
            self.metricNameShrink = dict["MetricName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListDIJobMetricsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class JobMetrics : Tea.TeaModel {
            public class SeriesList : Tea.TeaModel {
                public var time: Int64?

                public var value: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Time") {
                        self.time = dict["Time"] as! Int64
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! Double
                    }
                }
            }
            public var name: String?

            public var seriesList: [ListDIJobMetricsResponseBody.PagingInfo.JobMetrics.SeriesList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.seriesList != nil {
                    var tmp : [Any] = []
                    for k in self.seriesList! {
                        tmp.append(k.toMap())
                    }
                    map["SeriesList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SeriesList") {
                    var tmp : [ListDIJobMetricsResponseBody.PagingInfo.JobMetrics.SeriesList] = []
                    for v in dict["SeriesList"] as! [Any] {
                        var model = ListDIJobMetricsResponseBody.PagingInfo.JobMetrics.SeriesList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.seriesList = tmp
                }
            }
        }
        public var jobMetrics: [ListDIJobMetricsResponseBody.PagingInfo.JobMetrics]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobMetrics != nil {
                var tmp : [Any] = []
                for k in self.jobMetrics! {
                    tmp.append(k.toMap())
                }
                map["JobMetrics"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobMetrics") {
                var tmp : [ListDIJobMetricsResponseBody.PagingInfo.JobMetrics] = []
                for v in dict["JobMetrics"] as! [Any] {
                    var model = ListDIJobMetricsResponseBody.PagingInfo.JobMetrics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.jobMetrics = tmp
            }
        }
    }
    public var pagingInfo: ListDIJobMetricsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDIJobMetricsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDIJobMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDIJobMetricsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDIJobRunDetailsRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var instanceId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var sourceDataSourceName: String?

    public var sourceDatabaseName: String?

    public var sourceSchemaName: String?

    public var sourceTableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sourceDataSourceName != nil {
            map["SourceDataSourceName"] = self.sourceDataSourceName!
        }
        if self.sourceDatabaseName != nil {
            map["SourceDatabaseName"] = self.sourceDatabaseName!
        }
        if self.sourceSchemaName != nil {
            map["SourceSchemaName"] = self.sourceSchemaName!
        }
        if self.sourceTableName != nil {
            map["SourceTableName"] = self.sourceTableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SourceDataSourceName") {
            self.sourceDataSourceName = dict["SourceDataSourceName"] as! String
        }
        if dict.keys.contains("SourceDatabaseName") {
            self.sourceDatabaseName = dict["SourceDatabaseName"] as! String
        }
        if dict.keys.contains("SourceSchemaName") {
            self.sourceSchemaName = dict["SourceSchemaName"] as! String
        }
        if dict.keys.contains("SourceTableName") {
            self.sourceTableName = dict["SourceTableName"] as! String
        }
    }
}

public class ListDIJobRunDetailsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class JobRunInfos : Tea.TeaModel {
            public var destinationDatabaseName: String?

            public var destinationDatasourceName: String?

            public var destinationSchemaName: String?

            public var destinationTableName: String?

            public var fullMigrationErrorMessage: String?

            public var fullMigrationStatus: String?

            public var offlineErrorRecords: Int64?

            public var offlineTotalBytes: Int64?

            public var offlineTotalRecords: Int64?

            public var realtimeMigrationErrorMessage: String?

            public var realtimeMigrationStatus: String?

            public var sourceDatabaseName: String?

            public var sourceDatasourceName: String?

            public var sourceSchemaName: String?

            public var sourceTableName: String?

            public var structureMigrationErrorMessage: String?

            public var structureMigrationStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDatabaseName != nil {
                    map["DestinationDatabaseName"] = self.destinationDatabaseName!
                }
                if self.destinationDatasourceName != nil {
                    map["DestinationDatasourceName"] = self.destinationDatasourceName!
                }
                if self.destinationSchemaName != nil {
                    map["DestinationSchemaName"] = self.destinationSchemaName!
                }
                if self.destinationTableName != nil {
                    map["DestinationTableName"] = self.destinationTableName!
                }
                if self.fullMigrationErrorMessage != nil {
                    map["FullMigrationErrorMessage"] = self.fullMigrationErrorMessage!
                }
                if self.fullMigrationStatus != nil {
                    map["FullMigrationStatus"] = self.fullMigrationStatus!
                }
                if self.offlineErrorRecords != nil {
                    map["OfflineErrorRecords"] = self.offlineErrorRecords!
                }
                if self.offlineTotalBytes != nil {
                    map["OfflineTotalBytes"] = self.offlineTotalBytes!
                }
                if self.offlineTotalRecords != nil {
                    map["OfflineTotalRecords"] = self.offlineTotalRecords!
                }
                if self.realtimeMigrationErrorMessage != nil {
                    map["RealtimeMigrationErrorMessage"] = self.realtimeMigrationErrorMessage!
                }
                if self.realtimeMigrationStatus != nil {
                    map["RealtimeMigrationStatus"] = self.realtimeMigrationStatus!
                }
                if self.sourceDatabaseName != nil {
                    map["SourceDatabaseName"] = self.sourceDatabaseName!
                }
                if self.sourceDatasourceName != nil {
                    map["SourceDatasourceName"] = self.sourceDatasourceName!
                }
                if self.sourceSchemaName != nil {
                    map["SourceSchemaName"] = self.sourceSchemaName!
                }
                if self.sourceTableName != nil {
                    map["SourceTableName"] = self.sourceTableName!
                }
                if self.structureMigrationErrorMessage != nil {
                    map["StructureMigrationErrorMessage"] = self.structureMigrationErrorMessage!
                }
                if self.structureMigrationStatus != nil {
                    map["StructureMigrationStatus"] = self.structureMigrationStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestinationDatabaseName") {
                    self.destinationDatabaseName = dict["DestinationDatabaseName"] as! String
                }
                if dict.keys.contains("DestinationDatasourceName") {
                    self.destinationDatasourceName = dict["DestinationDatasourceName"] as! String
                }
                if dict.keys.contains("DestinationSchemaName") {
                    self.destinationSchemaName = dict["DestinationSchemaName"] as! String
                }
                if dict.keys.contains("DestinationTableName") {
                    self.destinationTableName = dict["DestinationTableName"] as! String
                }
                if dict.keys.contains("FullMigrationErrorMessage") {
                    self.fullMigrationErrorMessage = dict["FullMigrationErrorMessage"] as! String
                }
                if dict.keys.contains("FullMigrationStatus") {
                    self.fullMigrationStatus = dict["FullMigrationStatus"] as! String
                }
                if dict.keys.contains("OfflineErrorRecords") {
                    self.offlineErrorRecords = dict["OfflineErrorRecords"] as! Int64
                }
                if dict.keys.contains("OfflineTotalBytes") {
                    self.offlineTotalBytes = dict["OfflineTotalBytes"] as! Int64
                }
                if dict.keys.contains("OfflineTotalRecords") {
                    self.offlineTotalRecords = dict["OfflineTotalRecords"] as! Int64
                }
                if dict.keys.contains("RealtimeMigrationErrorMessage") {
                    self.realtimeMigrationErrorMessage = dict["RealtimeMigrationErrorMessage"] as! String
                }
                if dict.keys.contains("RealtimeMigrationStatus") {
                    self.realtimeMigrationStatus = dict["RealtimeMigrationStatus"] as! String
                }
                if dict.keys.contains("SourceDatabaseName") {
                    self.sourceDatabaseName = dict["SourceDatabaseName"] as! String
                }
                if dict.keys.contains("SourceDatasourceName") {
                    self.sourceDatasourceName = dict["SourceDatasourceName"] as! String
                }
                if dict.keys.contains("SourceSchemaName") {
                    self.sourceSchemaName = dict["SourceSchemaName"] as! String
                }
                if dict.keys.contains("SourceTableName") {
                    self.sourceTableName = dict["SourceTableName"] as! String
                }
                if dict.keys.contains("StructureMigrationErrorMessage") {
                    self.structureMigrationErrorMessage = dict["StructureMigrationErrorMessage"] as! String
                }
                if dict.keys.contains("StructureMigrationStatus") {
                    self.structureMigrationStatus = dict["StructureMigrationStatus"] as! String
                }
            }
        }
        public var jobRunInfos: [ListDIJobRunDetailsResponseBody.PagingInfo.JobRunInfos]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobRunInfos != nil {
                var tmp : [Any] = []
                for k in self.jobRunInfos! {
                    tmp.append(k.toMap())
                }
                map["JobRunInfos"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobRunInfos") {
                var tmp : [ListDIJobRunDetailsResponseBody.PagingInfo.JobRunInfos] = []
                for v in dict["JobRunInfos"] as! [Any] {
                    var model = ListDIJobRunDetailsResponseBody.PagingInfo.JobRunInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.jobRunInfos = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var pagingInfo: ListDIJobRunDetailsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDIJobRunDetailsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDIJobRunDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobRunDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDIJobRunDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDIJobsRequest : Tea.TeaModel {
    public var destinationDataSourceType: String?

    public var migrationType: String?

    public var name: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var projectId: Int64?

    public var sourceDataSourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationDataSourceType != nil {
            map["DestinationDataSourceType"] = self.destinationDataSourceType!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sourceDataSourceType != nil {
            map["SourceDataSourceType"] = self.sourceDataSourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationDataSourceType") {
            self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
        }
        if dict.keys.contains("MigrationType") {
            self.migrationType = dict["MigrationType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SourceDataSourceType") {
            self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
        }
    }
}

public class ListDIJobsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DIJobs : Tea.TeaModel {
            public var DIJobId: Int64?

            public var destinationDataSourceType: String?

            public var jobName: String?

            public var jobStatus: String?

            public var migrationType: String?

            public var projectId: Int64?

            public var sourceDataSourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DIJobId != nil {
                    map["DIJobId"] = self.DIJobId!
                }
                if self.destinationDataSourceType != nil {
                    map["DestinationDataSourceType"] = self.destinationDataSourceType!
                }
                if self.jobName != nil {
                    map["JobName"] = self.jobName!
                }
                if self.jobStatus != nil {
                    map["JobStatus"] = self.jobStatus!
                }
                if self.migrationType != nil {
                    map["MigrationType"] = self.migrationType!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.sourceDataSourceType != nil {
                    map["SourceDataSourceType"] = self.sourceDataSourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DIJobId") {
                    self.DIJobId = dict["DIJobId"] as! Int64
                }
                if dict.keys.contains("DestinationDataSourceType") {
                    self.destinationDataSourceType = dict["DestinationDataSourceType"] as! String
                }
                if dict.keys.contains("JobName") {
                    self.jobName = dict["JobName"] as! String
                }
                if dict.keys.contains("JobStatus") {
                    self.jobStatus = dict["JobStatus"] as! String
                }
                if dict.keys.contains("MigrationType") {
                    self.migrationType = dict["MigrationType"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("SourceDataSourceType") {
                    self.sourceDataSourceType = dict["SourceDataSourceType"] as! String
                }
            }
        }
        public var DIJobs: [ListDIJobsResponseBody.PagingInfo.DIJobs]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DIJobs != nil {
                var tmp : [Any] = []
                for k in self.DIJobs! {
                    tmp.append(k.toMap())
                }
                map["DIJobs"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DIJobs") {
                var tmp : [ListDIJobsResponseBody.PagingInfo.DIJobs] = []
                for v in dict["DIJobs"] as! [Any] {
                    var model = ListDIJobsResponseBody.PagingInfo.DIJobs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.DIJobs = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var pagingInfo: ListDIJobsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDIJobsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDIJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDIJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDIJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataQualityEvaluationTaskInstancesRequest : Tea.TeaModel {
    public var bizdateFrom: String?

    public var bizdateTo: String?

    public var createTimeFrom: Int64?

    public var createTimeTo: Int64?

    public var dataQualityEvaluationTaskId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tableGuid: String?

    public var triggerClient: String?

    public var triggerClientId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdateFrom != nil {
            map["BizdateFrom"] = self.bizdateFrom!
        }
        if self.bizdateTo != nil {
            map["BizdateTo"] = self.bizdateTo!
        }
        if self.createTimeFrom != nil {
            map["CreateTimeFrom"] = self.createTimeFrom!
        }
        if self.createTimeTo != nil {
            map["CreateTimeTo"] = self.createTimeTo!
        }
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        if self.triggerClient != nil {
            map["TriggerClient"] = self.triggerClient!
        }
        if self.triggerClientId != nil {
            map["TriggerClientId"] = self.triggerClientId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizdateFrom") {
            self.bizdateFrom = dict["BizdateFrom"] as! String
        }
        if dict.keys.contains("BizdateTo") {
            self.bizdateTo = dict["BizdateTo"] as! String
        }
        if dict.keys.contains("CreateTimeFrom") {
            self.createTimeFrom = dict["CreateTimeFrom"] as! Int64
        }
        if dict.keys.contains("CreateTimeTo") {
            self.createTimeTo = dict["CreateTimeTo"] as! Int64
        }
        if dict.keys.contains("DataQualityEvaluationTaskId") {
            self.dataQualityEvaluationTaskId = dict["DataQualityEvaluationTaskId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
        if dict.keys.contains("TriggerClient") {
            self.triggerClient = dict["TriggerClient"] as! String
        }
        if dict.keys.contains("TriggerClientId") {
            self.triggerClientId = dict["TriggerClientId"] as! String
        }
    }
}

public class ListDataQualityEvaluationTaskInstancesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityEvaluationTaskInstances : Tea.TeaModel {
            public class Task : Tea.TeaModel {
                public class Hooks : Tea.TeaModel {
                    public var condition: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.condition != nil {
                            map["Condition"] = self.condition!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Condition") {
                            self.condition = dict["Condition"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class Notifications : Tea.TeaModel {
                    public class Notifications : Tea.TeaModel {
                        public class NofiticationReceivers : Tea.TeaModel {
                            public var extension_: String?

                            public var receiverType: String?

                            public var receiverValues: [String]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.extension_ != nil {
                                    map["Extension"] = self.extension_!
                                }
                                if self.receiverType != nil {
                                    map["ReceiverType"] = self.receiverType!
                                }
                                if self.receiverValues != nil {
                                    map["ReceiverValues"] = self.receiverValues!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Extension") {
                                    self.extension_ = dict["Extension"] as! String
                                }
                                if dict.keys.contains("ReceiverType") {
                                    self.receiverType = dict["ReceiverType"] as! String
                                }
                                if dict.keys.contains("ReceiverValues") {
                                    self.receiverValues = dict["ReceiverValues"] as! [String]
                                }
                            }
                        }
                        public class NotificationChannels : Tea.TeaModel {
                            public var channels: [String]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! [String]
                                }
                            }
                        }
                        public var nofiticationReceivers: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NofiticationReceivers]?

                        public var notificationChannels: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NotificationChannels]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.nofiticationReceivers != nil {
                                var tmp : [Any] = []
                                for k in self.nofiticationReceivers! {
                                    tmp.append(k.toMap())
                                }
                                map["NofiticationReceivers"] = tmp
                            }
                            if self.notificationChannels != nil {
                                var tmp : [Any] = []
                                for k in self.notificationChannels! {
                                    tmp.append(k.toMap())
                                }
                                map["NotificationChannels"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("NofiticationReceivers") {
                                var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NofiticationReceivers] = []
                                for v in dict["NofiticationReceivers"] as! [Any] {
                                    var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NofiticationReceivers()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.nofiticationReceivers = tmp
                            }
                            if dict.keys.contains("NotificationChannels") {
                                var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NotificationChannels] = []
                                for v in dict["NotificationChannels"] as! [Any] {
                                    var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications.NotificationChannels()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.notificationChannels = tmp
                            }
                        }
                    }
                    public var condition: String?

                    public var notifications: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.condition != nil {
                            map["Condition"] = self.condition!
                        }
                        if self.notifications != nil {
                            var tmp : [Any] = []
                            for k in self.notifications! {
                                tmp.append(k.toMap())
                            }
                            map["Notifications"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Condition") {
                            self.condition = dict["Condition"] as! String
                        }
                        if dict.keys.contains("Notifications") {
                            var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications] = []
                            for v in dict["Notifications"] as! [Any] {
                                var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications.Notifications()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.notifications = tmp
                        }
                    }
                }
                public class Target : Tea.TeaModel {
                    public var databaseType: String?

                    public var partitionSpec: String?

                    public var tableGuid: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.databaseType != nil {
                            map["DatabaseType"] = self.databaseType!
                        }
                        if self.partitionSpec != nil {
                            map["PartitionSpec"] = self.partitionSpec!
                        }
                        if self.tableGuid != nil {
                            map["TableGuid"] = self.tableGuid!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DatabaseType") {
                            self.databaseType = dict["DatabaseType"] as! String
                        }
                        if dict.keys.contains("PartitionSpec") {
                            self.partitionSpec = dict["PartitionSpec"] as! String
                        }
                        if dict.keys.contains("TableGuid") {
                            self.tableGuid = dict["TableGuid"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class Trigger : Tea.TeaModel {
                    public var taskIds: [Int64]?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.taskIds != nil {
                            map["TaskIds"] = self.taskIds!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TaskIds") {
                            self.taskIds = dict["TaskIds"] as! [Int64]
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var description_: String?

                public var hooks: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Hooks]?

                public var id: Int64?

                public var name: String?

                public var notifications: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications?

                public var projectId: Int64?

                public var regionId: String?

                public var runtimeConf: String?

                public var target: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Target?

                public var tenantId: Int64?

                public var trigger: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Trigger?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.notifications?.validate()
                    try self.target?.validate()
                    try self.trigger?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.hooks != nil {
                        var tmp : [Any] = []
                        for k in self.hooks! {
                            tmp.append(k.toMap())
                        }
                        map["Hooks"] = tmp
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.notifications != nil {
                        map["Notifications"] = self.notifications?.toMap()
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.runtimeConf != nil {
                        map["RuntimeConf"] = self.runtimeConf!
                    }
                    if self.target != nil {
                        map["Target"] = self.target?.toMap()
                    }
                    if self.tenantId != nil {
                        map["TenantId"] = self.tenantId!
                    }
                    if self.trigger != nil {
                        map["Trigger"] = self.trigger?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Hooks") {
                        var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Hooks] = []
                        for v in dict["Hooks"] as! [Any] {
                            var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Hooks()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.hooks = tmp
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Notifications") {
                        var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Notifications()
                        model.fromMap(dict["Notifications"] as! [String: Any])
                        self.notifications = model
                    }
                    if dict.keys.contains("ProjectId") {
                        self.projectId = dict["ProjectId"] as! Int64
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("RuntimeConf") {
                        self.runtimeConf = dict["RuntimeConf"] as! String
                    }
                    if dict.keys.contains("Target") {
                        var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Target()
                        model.fromMap(dict["Target"] as! [String: Any])
                        self.target = model
                    }
                    if dict.keys.contains("TenantId") {
                        self.tenantId = dict["TenantId"] as! Int64
                    }
                    if dict.keys.contains("Trigger") {
                        var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task.Trigger()
                        model.fromMap(dict["Trigger"] as! [String: Any])
                        self.trigger = model
                    }
                }
            }
            public var createTime: Int64?

            public var finishTime: Int64?

            public var id: Int64?

            public var parameters: String?

            public var projectId: Int64?

            public var status: String?

            public var task: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task?

            public var triggerContext: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.task?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.task != nil {
                    map["Task"] = self.task?.toMap()
                }
                if self.triggerContext != nil {
                    map["TriggerContext"] = self.triggerContext!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Parameters") {
                    self.parameters = dict["Parameters"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Task") {
                    var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances.Task()
                    model.fromMap(dict["Task"] as! [String: Any])
                    self.task = model
                }
                if dict.keys.contains("TriggerContext") {
                    self.triggerContext = dict["TriggerContext"] as! String
                }
            }
        }
        public var dataQualityEvaluationTaskInstances: [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityEvaluationTaskInstances != nil {
                var tmp : [Any] = []
                for k in self.dataQualityEvaluationTaskInstances! {
                    tmp.append(k.toMap())
                }
                map["DataQualityEvaluationTaskInstances"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataQualityEvaluationTaskInstances") {
                var tmp : [ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances] = []
                for v in dict["DataQualityEvaluationTaskInstances"] as! [Any] {
                    var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo.DataQualityEvaluationTaskInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataQualityEvaluationTaskInstances = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDataQualityEvaluationTaskInstancesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataQualityEvaluationTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityEvaluationTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataQualityEvaluationTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataQualityEvaluationTasksRequest : Tea.TeaModel {
    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class ListDataQualityEvaluationTasksResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityEvaluationTasks : Tea.TeaModel {
            public class Hooks : Tea.TeaModel {
                public var condition: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Condition") {
                        self.condition = dict["Condition"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Notifications : Tea.TeaModel {
                public class Notifications : Tea.TeaModel {
                    public class NotificationChannels : Tea.TeaModel {
                        public var channels: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! [String]
                            }
                        }
                    }
                    public class NotificationReceivers : Tea.TeaModel {
                        public var extension_: String?

                        public var receiverType: String?

                        public var receiverValues: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extension_ != nil {
                                map["Extension"] = self.extension_!
                            }
                            if self.receiverType != nil {
                                map["ReceiverType"] = self.receiverType!
                            }
                            if self.receiverValues != nil {
                                map["ReceiverValues"] = self.receiverValues!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Extension") {
                                self.extension_ = dict["Extension"] as! String
                            }
                            if dict.keys.contains("ReceiverType") {
                                self.receiverType = dict["ReceiverType"] as! String
                            }
                            if dict.keys.contains("ReceiverValues") {
                                self.receiverValues = dict["ReceiverValues"] as! [String]
                            }
                        }
                    }
                    public var notificationChannels: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationChannels]?

                    public var notificationReceivers: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationReceivers]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.notificationChannels != nil {
                            var tmp : [Any] = []
                            for k in self.notificationChannels! {
                                tmp.append(k.toMap())
                            }
                            map["NotificationChannels"] = tmp
                        }
                        if self.notificationReceivers != nil {
                            var tmp : [Any] = []
                            for k in self.notificationReceivers! {
                                tmp.append(k.toMap())
                            }
                            map["NotificationReceivers"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NotificationChannels") {
                            var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationChannels] = []
                            for v in dict["NotificationChannels"] as! [Any] {
                                var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationChannels()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.notificationChannels = tmp
                        }
                        if dict.keys.contains("NotificationReceivers") {
                            var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationReceivers] = []
                            for v in dict["NotificationReceivers"] as! [Any] {
                                var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications.NotificationReceivers()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.notificationReceivers = tmp
                        }
                    }
                }
                public var condition: String?

                public var notifications: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.notifications != nil {
                        var tmp : [Any] = []
                        for k in self.notifications! {
                            tmp.append(k.toMap())
                        }
                        map["Notifications"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Condition") {
                        self.condition = dict["Condition"] as! String
                    }
                    if dict.keys.contains("Notifications") {
                        var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications] = []
                        for v in dict["Notifications"] as! [Any] {
                            var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications.Notifications()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.notifications = tmp
                    }
                }
            }
            public class Target : Tea.TeaModel {
                public var databaseType: String?

                public var partitionSpec: String?

                public var tableGuid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseType != nil {
                        map["DatabaseType"] = self.databaseType!
                    }
                    if self.partitionSpec != nil {
                        map["PartitionSpec"] = self.partitionSpec!
                    }
                    if self.tableGuid != nil {
                        map["TableGuid"] = self.tableGuid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseType") {
                        self.databaseType = dict["DatabaseType"] as! String
                    }
                    if dict.keys.contains("PartitionSpec") {
                        self.partitionSpec = dict["PartitionSpec"] as! String
                    }
                    if dict.keys.contains("TableGuid") {
                        self.tableGuid = dict["TableGuid"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var taskIds: [Int64]?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.taskIds != nil {
                        map["TaskIds"] = self.taskIds!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TaskIds") {
                        self.taskIds = dict["TaskIds"] as! [Int64]
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var description_: String?

            public var hooks: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Hooks]?

            public var id: Int64?

            public var name: String?

            public var notifications: ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications?

            public var projectId: Int64?

            public var runtimeConf: String?

            public var target: ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Target?

            public var tenantId: Int64?

            public var trigger: ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Trigger?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notifications?.validate()
                try self.target?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hooks != nil {
                    var tmp : [Any] = []
                    for k in self.hooks! {
                        tmp.append(k.toMap())
                    }
                    map["Hooks"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifications != nil {
                    map["Notifications"] = self.notifications?.toMap()
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.runtimeConf != nil {
                    map["RuntimeConf"] = self.runtimeConf!
                }
                if self.target != nil {
                    map["Target"] = self.target?.toMap()
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Hooks") {
                    var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Hooks] = []
                    for v in dict["Hooks"] as! [Any] {
                        var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Hooks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.hooks = tmp
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Notifications") {
                    var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Notifications()
                    model.fromMap(dict["Notifications"] as! [String: Any])
                    self.notifications = model
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RuntimeConf") {
                    self.runtimeConf = dict["RuntimeConf"] as! String
                }
                if dict.keys.contains("Target") {
                    var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Target()
                    model.fromMap(dict["Target"] as! [String: Any])
                    self.target = model
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("Trigger") {
                    var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks.Trigger()
                    model.fromMap(dict["Trigger"] as! [String: Any])
                    self.trigger = model
                }
            }
        }
        public var dataQualityEvaluationTasks: [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityEvaluationTasks != nil {
                var tmp : [Any] = []
                for k in self.dataQualityEvaluationTasks! {
                    tmp.append(k.toMap())
                }
                map["DataQualityEvaluationTasks"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataQualityEvaluationTasks") {
                var tmp : [ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks] = []
                for v in dict["DataQualityEvaluationTasks"] as! [Any] {
                    var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo.DataQualityEvaluationTasks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataQualityEvaluationTasks = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var pagingInfo: ListDataQualityEvaluationTasksResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDataQualityEvaluationTasksResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataQualityEvaluationTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityEvaluationTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataQualityEvaluationTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataQualityResultsRequest : Tea.TeaModel {
    public var bizdateFrom: String?

    public var bizdateTo: String?

    public var createTimeFrom: Int64?

    public var createTimeTo: Int64?

    public var dataQualityEvaluationTaskId: Int64?

    public var dataQualityEvaluationTaskInstanceId: Int64?

    public var dataQualityRuleId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdateFrom != nil {
            map["BizdateFrom"] = self.bizdateFrom!
        }
        if self.bizdateTo != nil {
            map["BizdateTo"] = self.bizdateTo!
        }
        if self.createTimeFrom != nil {
            map["CreateTimeFrom"] = self.createTimeFrom!
        }
        if self.createTimeTo != nil {
            map["CreateTimeTo"] = self.createTimeTo!
        }
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.dataQualityEvaluationTaskInstanceId != nil {
            map["DataQualityEvaluationTaskInstanceId"] = self.dataQualityEvaluationTaskInstanceId!
        }
        if self.dataQualityRuleId != nil {
            map["DataQualityRuleId"] = self.dataQualityRuleId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizdateFrom") {
            self.bizdateFrom = dict["BizdateFrom"] as! String
        }
        if dict.keys.contains("BizdateTo") {
            self.bizdateTo = dict["BizdateTo"] as! String
        }
        if dict.keys.contains("CreateTimeFrom") {
            self.createTimeFrom = dict["CreateTimeFrom"] as! Int64
        }
        if dict.keys.contains("CreateTimeTo") {
            self.createTimeTo = dict["CreateTimeTo"] as! Int64
        }
        if dict.keys.contains("DataQualityEvaluationTaskId") {
            self.dataQualityEvaluationTaskId = dict["DataQualityEvaluationTaskId"] as! Int64
        }
        if dict.keys.contains("DataQualityEvaluationTaskInstanceId") {
            self.dataQualityEvaluationTaskInstanceId = dict["DataQualityEvaluationTaskInstanceId"] as! Int64
        }
        if dict.keys.contains("DataQualityRuleId") {
            self.dataQualityRuleId = dict["DataQualityRuleId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListDataQualityResultsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityResults : Tea.TeaModel {
            public class Details : Tea.TeaModel {
                public var checkedValue: String?

                public var referencedValue: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkedValue != nil {
                        map["CheckedValue"] = self.checkedValue!
                    }
                    if self.referencedValue != nil {
                        map["ReferencedValue"] = self.referencedValue!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckedValue") {
                        self.checkedValue = dict["CheckedValue"] as! String
                    }
                    if dict.keys.contains("ReferencedValue") {
                        self.referencedValue = dict["ReferencedValue"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class Rule : Tea.TeaModel {
                public class CheckingConfig : Tea.TeaModel {
                    public class Thresholds : Tea.TeaModel {
                        public class Critical : Tea.TeaModel {
                            public var operator_: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.operator_ != nil {
                                    map["Operator"] = self.operator_!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Operator") {
                                    self.operator_ = dict["Operator"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public class Expected : Tea.TeaModel {
                            public var operator_: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.operator_ != nil {
                                    map["Operator"] = self.operator_!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Operator") {
                                    self.operator_ = dict["Operator"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public class Warned : Tea.TeaModel {
                            public var operator_: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.operator_ != nil {
                                    map["Operator"] = self.operator_!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Operator") {
                                    self.operator_ = dict["Operator"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var critical: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Critical?

                        public var expected: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Expected?

                        public var warned: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Warned?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.critical?.validate()
                            try self.expected?.validate()
                            try self.warned?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.critical != nil {
                                map["Critical"] = self.critical?.toMap()
                            }
                            if self.expected != nil {
                                map["Expected"] = self.expected?.toMap()
                            }
                            if self.warned != nil {
                                map["Warned"] = self.warned?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Critical") {
                                var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Critical()
                                model.fromMap(dict["Critical"] as! [String: Any])
                                self.critical = model
                            }
                            if dict.keys.contains("Expected") {
                                var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Expected()
                                model.fromMap(dict["Expected"] as! [String: Any])
                                self.expected = model
                            }
                            if dict.keys.contains("Warned") {
                                var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds.Warned()
                                model.fromMap(dict["Warned"] as! [String: Any])
                                self.warned = model
                            }
                        }
                    }
                    public var referencedSamplesFilter: String?

                    public var thresholds: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.thresholds?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.referencedSamplesFilter != nil {
                            map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                        }
                        if self.thresholds != nil {
                            map["Thresholds"] = self.thresholds?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ReferencedSamplesFilter") {
                            self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
                        }
                        if dict.keys.contains("Thresholds") {
                            var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig.Thresholds()
                            model.fromMap(dict["Thresholds"] as! [String: Any])
                            self.thresholds = model
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class ErrorHandlers : Tea.TeaModel {
                    public var errorDataFilter: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorDataFilter != nil {
                            map["ErrorDataFilter"] = self.errorDataFilter!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorDataFilter") {
                            self.errorDataFilter = dict["ErrorDataFilter"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class SamplingConfig : Tea.TeaModel {
                    public var metric: String?

                    public var metricParameters: String?

                    public var samplingFilter: String?

                    public var settingConfig: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.metric != nil {
                            map["Metric"] = self.metric!
                        }
                        if self.metricParameters != nil {
                            map["MetricParameters"] = self.metricParameters!
                        }
                        if self.samplingFilter != nil {
                            map["SamplingFilter"] = self.samplingFilter!
                        }
                        if self.settingConfig != nil {
                            map["SettingConfig"] = self.settingConfig!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Metric") {
                            self.metric = dict["Metric"] as! String
                        }
                        if dict.keys.contains("MetricParameters") {
                            self.metricParameters = dict["MetricParameters"] as! String
                        }
                        if dict.keys.contains("SamplingFilter") {
                            self.samplingFilter = dict["SamplingFilter"] as! String
                        }
                        if dict.keys.contains("SettingConfig") {
                            self.settingConfig = dict["SettingConfig"] as! String
                        }
                    }
                }
                public class Target : Tea.TeaModel {
                    public var databaseType: String?

                    public var partitionSpec: String?

                    public var tableGuid: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.databaseType != nil {
                            map["DatabaseType"] = self.databaseType!
                        }
                        if self.partitionSpec != nil {
                            map["PartitionSpec"] = self.partitionSpec!
                        }
                        if self.tableGuid != nil {
                            map["TableGuid"] = self.tableGuid!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DatabaseType") {
                            self.databaseType = dict["DatabaseType"] as! String
                        }
                        if dict.keys.contains("PartitionSpec") {
                            self.partitionSpec = dict["PartitionSpec"] as! String
                        }
                        if dict.keys.contains("TableGuid") {
                            self.tableGuid = dict["TableGuid"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var checkingConfig: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig?

                public var description_: String?

                public var enabled: Bool?

                public var errorHandlers: [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.ErrorHandlers]?

                public var id: Int64?

                public var name: String?

                public var projectId: Int64?

                public var samplingConfig: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.SamplingConfig?

                public var severity: String?

                public var target: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.Target?

                public var templateCode: String?

                public var tenantId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.checkingConfig?.validate()
                    try self.samplingConfig?.validate()
                    try self.target?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkingConfig != nil {
                        map["CheckingConfig"] = self.checkingConfig?.toMap()
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.enabled != nil {
                        map["Enabled"] = self.enabled!
                    }
                    if self.errorHandlers != nil {
                        var tmp : [Any] = []
                        for k in self.errorHandlers! {
                            tmp.append(k.toMap())
                        }
                        map["ErrorHandlers"] = tmp
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.projectId != nil {
                        map["ProjectId"] = self.projectId!
                    }
                    if self.samplingConfig != nil {
                        map["SamplingConfig"] = self.samplingConfig?.toMap()
                    }
                    if self.severity != nil {
                        map["Severity"] = self.severity!
                    }
                    if self.target != nil {
                        map["Target"] = self.target?.toMap()
                    }
                    if self.templateCode != nil {
                        map["TemplateCode"] = self.templateCode!
                    }
                    if self.tenantId != nil {
                        map["TenantId"] = self.tenantId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckingConfig") {
                        var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.CheckingConfig()
                        model.fromMap(dict["CheckingConfig"] as! [String: Any])
                        self.checkingConfig = model
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Enabled") {
                        self.enabled = dict["Enabled"] as! Bool
                    }
                    if dict.keys.contains("ErrorHandlers") {
                        var tmp : [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.ErrorHandlers] = []
                        for v in dict["ErrorHandlers"] as! [Any] {
                            var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.ErrorHandlers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.errorHandlers = tmp
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("ProjectId") {
                        self.projectId = dict["ProjectId"] as! Int64
                    }
                    if dict.keys.contains("SamplingConfig") {
                        var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.SamplingConfig()
                        model.fromMap(dict["SamplingConfig"] as! [String: Any])
                        self.samplingConfig = model
                    }
                    if dict.keys.contains("Severity") {
                        self.severity = dict["Severity"] as! String
                    }
                    if dict.keys.contains("Target") {
                        var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule.Target()
                        model.fromMap(dict["Target"] as! [String: Any])
                        self.target = model
                    }
                    if dict.keys.contains("TemplateCode") {
                        self.templateCode = dict["TemplateCode"] as! String
                    }
                    if dict.keys.contains("TenantId") {
                        self.tenantId = dict["TenantId"] as! Int64
                    }
                }
            }
            public var createTime: Int64?

            public var details: [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Details]?

            public var id: Int64?

            public var rule: ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule?

            public var sample: String?

            public var status: String?

            public var taskInstanceId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.rule?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.details != nil {
                    var tmp : [Any] = []
                    for k in self.details! {
                        tmp.append(k.toMap())
                    }
                    map["Details"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.rule != nil {
                    map["Rule"] = self.rule?.toMap()
                }
                if self.sample != nil {
                    map["Sample"] = self.sample!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskInstanceId != nil {
                    map["TaskInstanceId"] = self.taskInstanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Details") {
                    var tmp : [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Details] = []
                    for v in dict["Details"] as! [Any] {
                        var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Details()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.details = tmp
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Rule") {
                    var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults.Rule()
                    model.fromMap(dict["Rule"] as! [String: Any])
                    self.rule = model
                }
                if dict.keys.contains("Sample") {
                    self.sample = dict["Sample"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskInstanceId") {
                    self.taskInstanceId = dict["TaskInstanceId"] as! Int64
                }
            }
        }
        public var dataQualityResults: [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityResults != nil {
                var tmp : [Any] = []
                for k in self.dataQualityResults! {
                    tmp.append(k.toMap())
                }
                map["DataQualityResults"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataQualityResults") {
                var tmp : [ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults] = []
                for v in dict["DataQualityResults"] as! [Any] {
                    var model = ListDataQualityResultsResponseBody.PagingInfo.DataQualityResults()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataQualityResults = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListDataQualityResultsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDataQualityResultsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataQualityResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataQualityResultsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataQualityRuleTemplateRequest : Tea.TeaModel {
    public var creationSource: String?

    public var directoryPath: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationSource != nil {
            map["CreationSource"] = self.creationSource!
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationSource") {
            self.creationSource = dict["CreationSource"] as! String
        }
        if dict.keys.contains("DirectoryPath") {
            self.directoryPath = dict["DirectoryPath"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class ListDataQualityRuleTemplateResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityRuleTemplates : Tea.TeaModel {
            public class CheckingConfig : Tea.TeaModel {
                public var referencedSamplesFilter: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.referencedSamplesFilter != nil {
                        map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ReferencedSamplesFilter") {
                        self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class SamplingConfig : Tea.TeaModel {
                public var metric: String?

                public var metricParameters: String?

                public var settingConfig: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metric != nil {
                        map["Metric"] = self.metric!
                    }
                    if self.metricParameters != nil {
                        map["MetricParameters"] = self.metricParameters!
                    }
                    if self.settingConfig != nil {
                        map["SettingConfig"] = self.settingConfig!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Metric") {
                        self.metric = dict["Metric"] as! String
                    }
                    if dict.keys.contains("MetricParameters") {
                        self.metricParameters = dict["MetricParameters"] as! String
                    }
                    if dict.keys.contains("SettingConfig") {
                        self.settingConfig = dict["SettingConfig"] as! String
                    }
                }
            }
            public var checkingConfig: ListDataQualityRuleTemplateResponseBody.PagingInfo.DataQualityRuleTemplates.CheckingConfig?

            public var code: String?

            public var directoryPath: String?

            public var name: String?

            public var projectId: Int64?

            public var samplingConfig: ListDataQualityRuleTemplateResponseBody.PagingInfo.DataQualityRuleTemplates.SamplingConfig?

            public var tenantId: Int64?

            public var visibleScope: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkingConfig?.validate()
                try self.samplingConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkingConfig != nil {
                    map["CheckingConfig"] = self.checkingConfig?.toMap()
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.directoryPath != nil {
                    map["DirectoryPath"] = self.directoryPath!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.samplingConfig != nil {
                    map["SamplingConfig"] = self.samplingConfig?.toMap()
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.visibleScope != nil {
                    map["VisibleScope"] = self.visibleScope!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckingConfig") {
                    var model = ListDataQualityRuleTemplateResponseBody.PagingInfo.DataQualityRuleTemplates.CheckingConfig()
                    model.fromMap(dict["CheckingConfig"] as! [String: Any])
                    self.checkingConfig = model
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("DirectoryPath") {
                    self.directoryPath = dict["DirectoryPath"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("SamplingConfig") {
                    var model = ListDataQualityRuleTemplateResponseBody.PagingInfo.DataQualityRuleTemplates.SamplingConfig()
                    model.fromMap(dict["SamplingConfig"] as! [String: Any])
                    self.samplingConfig = model
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("VisibleScope") {
                    self.visibleScope = dict["VisibleScope"] as! String
                }
            }
        }
        public var dataQualityRuleTemplates: [ListDataQualityRuleTemplateResponseBody.PagingInfo.DataQualityRuleTemplates]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityRuleTemplates != nil {
                var tmp : [Any] = []
                for k in self.dataQualityRuleTemplates! {
                    tmp.append(k.toMap())
                }
                map["DataQualityRuleTemplates"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataQualityRuleTemplates") {
                var tmp : [ListDataQualityRuleTemplateResponseBody.PagingInfo.DataQualityRuleTemplates] = []
                for v in dict["DataQualityRuleTemplates"] as! [Any] {
                    var model = ListDataQualityRuleTemplateResponseBody.PagingInfo.DataQualityRuleTemplates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataQualityRuleTemplates = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListDataQualityRuleTemplateResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDataQualityRuleTemplateResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataQualityRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataQualityRuleTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataQualityRulesRequest : Tea.TeaModel {
    public var dataQualityEvaluationTaskId: Int64?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var tableGuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityEvaluationTaskId != nil {
            map["DataQualityEvaluationTaskId"] = self.dataQualityEvaluationTaskId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.tableGuid != nil {
            map["TableGuid"] = self.tableGuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityEvaluationTaskId") {
            self.dataQualityEvaluationTaskId = dict["DataQualityEvaluationTaskId"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("TableGuid") {
            self.tableGuid = dict["TableGuid"] as! String
        }
    }
}

public class ListDataQualityRulesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataQualityRules : Tea.TeaModel {
            public class CheckingConfig : Tea.TeaModel {
                public class Thresholds : Tea.TeaModel {
                    public class Critical : Tea.TeaModel {
                        public var expression: String?

                        public var operator_: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.expression != nil {
                                map["Expression"] = self.expression!
                            }
                            if self.operator_ != nil {
                                map["Operator"] = self.operator_!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Expression") {
                                self.expression = dict["Expression"] as! String
                            }
                            if dict.keys.contains("Operator") {
                                self.operator_ = dict["Operator"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Expected : Tea.TeaModel {
                        public var expression: String?

                        public var operator_: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.expression != nil {
                                map["Expression"] = self.expression!
                            }
                            if self.operator_ != nil {
                                map["Operator"] = self.operator_!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Expression") {
                                self.expression = dict["Expression"] as! String
                            }
                            if dict.keys.contains("Operator") {
                                self.operator_ = dict["Operator"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public class Warned : Tea.TeaModel {
                        public var expression: String?

                        public var operator_: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.expression != nil {
                                map["Expression"] = self.expression!
                            }
                            if self.operator_ != nil {
                                map["Operator"] = self.operator_!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Expression") {
                                self.expression = dict["Expression"] as! String
                            }
                            if dict.keys.contains("Operator") {
                                self.operator_ = dict["Operator"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var critical: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Critical?

                    public var expected: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Expected?

                    public var warned: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Warned?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.critical?.validate()
                        try self.expected?.validate()
                        try self.warned?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.critical != nil {
                            map["Critical"] = self.critical?.toMap()
                        }
                        if self.expected != nil {
                            map["Expected"] = self.expected?.toMap()
                        }
                        if self.warned != nil {
                            map["Warned"] = self.warned?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Critical") {
                            var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Critical()
                            model.fromMap(dict["Critical"] as! [String: Any])
                            self.critical = model
                        }
                        if dict.keys.contains("Expected") {
                            var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Expected()
                            model.fromMap(dict["Expected"] as! [String: Any])
                            self.expected = model
                        }
                        if dict.keys.contains("Warned") {
                            var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds.Warned()
                            model.fromMap(dict["Warned"] as! [String: Any])
                            self.warned = model
                        }
                    }
                }
                public var referencedSamplesFilter: String?

                public var thresholds: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.thresholds?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.referencedSamplesFilter != nil {
                        map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                    }
                    if self.thresholds != nil {
                        map["Thresholds"] = self.thresholds?.toMap()
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ReferencedSamplesFilter") {
                        self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
                    }
                    if dict.keys.contains("Thresholds") {
                        var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig.Thresholds()
                        model.fromMap(dict["Thresholds"] as! [String: Any])
                        self.thresholds = model
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class ErrorHandlers : Tea.TeaModel {
                public var errorDataFilter: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorDataFilter != nil {
                        map["ErrorDataFilter"] = self.errorDataFilter!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorDataFilter") {
                        self.errorDataFilter = dict["ErrorDataFilter"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class SamplingConfig : Tea.TeaModel {
                public var metric: String?

                public var metricParameters: String?

                public var samplingFilter: String?

                public var settingConfig: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metric != nil {
                        map["Metric"] = self.metric!
                    }
                    if self.metricParameters != nil {
                        map["MetricParameters"] = self.metricParameters!
                    }
                    if self.samplingFilter != nil {
                        map["SamplingFilter"] = self.samplingFilter!
                    }
                    if self.settingConfig != nil {
                        map["SettingConfig"] = self.settingConfig!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Metric") {
                        self.metric = dict["Metric"] as! String
                    }
                    if dict.keys.contains("MetricParameters") {
                        self.metricParameters = dict["MetricParameters"] as! String
                    }
                    if dict.keys.contains("SamplingFilter") {
                        self.samplingFilter = dict["SamplingFilter"] as! String
                    }
                    if dict.keys.contains("SettingConfig") {
                        self.settingConfig = dict["SettingConfig"] as! String
                    }
                }
            }
            public class Target : Tea.TeaModel {
                public var databaseType: String?

                public var partitionSpec: String?

                public var tableGuid: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.databaseType != nil {
                        map["DatabaseType"] = self.databaseType!
                    }
                    if self.partitionSpec != nil {
                        map["PartitionSpec"] = self.partitionSpec!
                    }
                    if self.tableGuid != nil {
                        map["TableGuid"] = self.tableGuid!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DatabaseType") {
                        self.databaseType = dict["DatabaseType"] as! String
                    }
                    if dict.keys.contains("PartitionSpec") {
                        self.partitionSpec = dict["PartitionSpec"] as! String
                    }
                    if dict.keys.contains("TableGuid") {
                        self.tableGuid = dict["TableGuid"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var checkingConfig: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig?

            public var description_: String?

            public var enabled: Bool?

            public var errorHandlers: [ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.ErrorHandlers]?

            public var id: Int64?

            public var name: String?

            public var projectId: Int64?

            public var samplingConfig: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.SamplingConfig?

            public var severity: String?

            public var target: ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.Target?

            public var templateCode: String?

            public var tenantId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkingConfig?.validate()
                try self.samplingConfig?.validate()
                try self.target?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkingConfig != nil {
                    map["CheckingConfig"] = self.checkingConfig?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.errorHandlers != nil {
                    var tmp : [Any] = []
                    for k in self.errorHandlers! {
                        tmp.append(k.toMap())
                    }
                    map["ErrorHandlers"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.samplingConfig != nil {
                    map["SamplingConfig"] = self.samplingConfig?.toMap()
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.target != nil {
                    map["Target"] = self.target?.toMap()
                }
                if self.templateCode != nil {
                    map["TemplateCode"] = self.templateCode!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckingConfig") {
                    var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.CheckingConfig()
                    model.fromMap(dict["CheckingConfig"] as! [String: Any])
                    self.checkingConfig = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! Bool
                }
                if dict.keys.contains("ErrorHandlers") {
                    var tmp : [ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.ErrorHandlers] = []
                    for v in dict["ErrorHandlers"] as! [Any] {
                        var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.ErrorHandlers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.errorHandlers = tmp
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("SamplingConfig") {
                    var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.SamplingConfig()
                    model.fromMap(dict["SamplingConfig"] as! [String: Any])
                    self.samplingConfig = model
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("Target") {
                    var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules.Target()
                    model.fromMap(dict["Target"] as! [String: Any])
                    self.target = model
                }
                if dict.keys.contains("TemplateCode") {
                    self.templateCode = dict["TemplateCode"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
            }
        }
        public var dataQualityRules: [ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataQualityRules != nil {
                var tmp : [Any] = []
                for k in self.dataQualityRules! {
                    tmp.append(k.toMap())
                }
                map["DataQualityRules"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataQualityRules") {
                var tmp : [ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules] = []
                for v in dict["DataQualityRules"] as! [Any] {
                    var model = ListDataQualityRulesResponseBody.PagingInfo.DataQualityRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataQualityRules = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListDataQualityRulesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDataQualityRulesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataQualityRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataQualityRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataQualityRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataSourceSharedRulesRequest : Tea.TeaModel {
    public var dataSourceId: Int64?

    public var targetProjectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.targetProjectId != nil {
            map["TargetProjectId"] = self.targetProjectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! Int64
        }
        if dict.keys.contains("TargetProjectId") {
            self.targetProjectId = dict["TargetProjectId"] as! Int64
        }
    }
}

public class ListDataSourceSharedRulesResponseBody : Tea.TeaModel {
    public class DataSourceSharedRules : Tea.TeaModel {
        public var createTime: Int64?

        public var createUser: String?

        public var dataSourceId: Int64?

        public var envType: String?

        public var id: Int64?

        public var sharedDataSourceName: String?

        public var sharedUser: String?

        public var sourceProjectId: Int64?

        public var targetProjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.dataSourceId != nil {
                map["DataSourceId"] = self.dataSourceId!
            }
            if self.envType != nil {
                map["EnvType"] = self.envType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.sharedDataSourceName != nil {
                map["SharedDataSourceName"] = self.sharedDataSourceName!
            }
            if self.sharedUser != nil {
                map["SharedUser"] = self.sharedUser!
            }
            if self.sourceProjectId != nil {
                map["SourceProjectId"] = self.sourceProjectId!
            }
            if self.targetProjectId != nil {
                map["TargetProjectId"] = self.targetProjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("DataSourceId") {
                self.dataSourceId = dict["DataSourceId"] as! Int64
            }
            if dict.keys.contains("EnvType") {
                self.envType = dict["EnvType"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("SharedDataSourceName") {
                self.sharedDataSourceName = dict["SharedDataSourceName"] as! String
            }
            if dict.keys.contains("SharedUser") {
                self.sharedUser = dict["SharedUser"] as! String
            }
            if dict.keys.contains("SourceProjectId") {
                self.sourceProjectId = dict["SourceProjectId"] as! Int64
            }
            if dict.keys.contains("TargetProjectId") {
                self.targetProjectId = dict["TargetProjectId"] as! Int64
            }
        }
    }
    public var dataSourceSharedRules: [ListDataSourceSharedRulesResponseBody.DataSourceSharedRules]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataSourceSharedRules != nil {
            var tmp : [Any] = []
            for k in self.dataSourceSharedRules! {
                tmp.append(k.toMap())
            }
            map["DataSourceSharedRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataSourceSharedRules") {
            var tmp : [ListDataSourceSharedRulesResponseBody.DataSourceSharedRules] = []
            for v in dict["DataSourceSharedRules"] as! [Any] {
                var model = ListDataSourceSharedRulesResponseBody.DataSourceSharedRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataSourceSharedRules = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataSourceSharedRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataSourceSharedRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataSourceSharedRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataSourcesRequest : Tea.TeaModel {
    public var envType: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sortBy: String?

    public var tags: String?

    public var types: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Types") {
            self.types = dict["Types"] as! [String]
        }
    }
}

public class ListDataSourcesShrinkRequest : Tea.TeaModel {
    public var envType: String?

    public var name: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var sortBy: String?

    public var tags: String?

    public var typesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.typesShrink != nil {
            map["Types"] = self.typesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Types") {
            self.typesShrink = dict["Types"] as! String
        }
    }
}

public class ListDataSourcesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class DataSources : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var connectionProperties: Any?

                public var connectionPropertiesMode: String?

                public var createTime: Int64?

                public var createUser: String?

                public var description_: String?

                public var id: Int64?

                public var modifyTime: Int64?

                public var modifyUser: String?

                public var qualifiedName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connectionProperties != nil {
                        map["ConnectionProperties"] = self.connectionProperties!
                    }
                    if self.connectionPropertiesMode != nil {
                        map["ConnectionPropertiesMode"] = self.connectionPropertiesMode!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.createUser != nil {
                        map["CreateUser"] = self.createUser!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.modifyTime != nil {
                        map["ModifyTime"] = self.modifyTime!
                    }
                    if self.modifyUser != nil {
                        map["ModifyUser"] = self.modifyUser!
                    }
                    if self.qualifiedName != nil {
                        map["QualifiedName"] = self.qualifiedName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConnectionProperties") {
                        self.connectionProperties = dict["ConnectionProperties"] as! Any
                    }
                    if dict.keys.contains("ConnectionPropertiesMode") {
                        self.connectionPropertiesMode = dict["ConnectionPropertiesMode"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("CreateUser") {
                        self.createUser = dict["CreateUser"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("ModifyTime") {
                        self.modifyTime = dict["ModifyTime"] as! Int64
                    }
                    if dict.keys.contains("ModifyUser") {
                        self.modifyUser = dict["ModifyUser"] as! String
                    }
                    if dict.keys.contains("QualifiedName") {
                        self.qualifiedName = dict["QualifiedName"] as! String
                    }
                }
            }
            public var dataSource: [ListDataSourcesResponseBody.PagingInfo.DataSources.DataSource]?

            public var name: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSource != nil {
                    var tmp : [Any] = []
                    for k in self.dataSource! {
                        tmp.append(k.toMap())
                    }
                    map["DataSource"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataSource") {
                    var tmp : [ListDataSourcesResponseBody.PagingInfo.DataSources.DataSource] = []
                    for v in dict["DataSource"] as! [Any] {
                        var model = ListDataSourcesResponseBody.PagingInfo.DataSources.DataSource()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dataSource = tmp
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var dataSources: [ListDataSourcesResponseBody.PagingInfo.DataSources]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSources != nil {
                var tmp : [Any] = []
                for k in self.dataSources! {
                    tmp.append(k.toMap())
                }
                map["DataSources"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSources") {
                var tmp : [ListDataSourcesResponseBody.PagingInfo.DataSources] = []
                for v in dict["DataSources"] as! [Any] {
                    var model = ListDataSourcesResponseBody.PagingInfo.DataSources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataSources = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var pagingInfo: ListDataSourcesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDataSourcesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDataSourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataSourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataSourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDeploymentsRequest : Tea.TeaModel {
    public var creator: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListDeploymentsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Deployments : Tea.TeaModel {
            public class Stages : Tea.TeaModel {
                public var code: String?

                public var description_: String?

                public var detail: [String: Any]?

                public var message: String?

                public var name: String?

                public var status: String?

                public var step: Int32?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.detail != nil {
                        map["Detail"] = self.detail!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Detail") {
                        self.detail = dict["Detail"] as! [String: Any]
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Step") {
                        self.step = dict["Step"] as! Int32
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var createTime: Int64?

            public var creator: String?

            public var id: String?

            public var message: String?

            public var modifyTime: Int64?

            public var projectId: String?

            public var stages: [ListDeploymentsResponseBody.PagingInfo.Deployments.Stages]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.stages != nil {
                    var tmp : [Any] = []
                    for k in self.stages! {
                        tmp.append(k.toMap())
                    }
                    map["Stages"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Stages") {
                    var tmp : [ListDeploymentsResponseBody.PagingInfo.Deployments.Stages] = []
                    for v in dict["Stages"] as! [Any] {
                        var model = ListDeploymentsResponseBody.PagingInfo.Deployments.Stages()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.stages = tmp
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var deployments: [ListDeploymentsResponseBody.PagingInfo.Deployments]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployments != nil {
                var tmp : [Any] = []
                for k in self.deployments! {
                    tmp.append(k.toMap())
                }
                map["Deployments"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Deployments") {
                var tmp : [ListDeploymentsResponseBody.PagingInfo.Deployments] = []
                for v in dict["Deployments"] as! [Any] {
                    var model = ListDeploymentsResponseBody.PagingInfo.Deployments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deployments = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var pagingInfo: ListDeploymentsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDeploymentsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDeploymentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDeploymentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDeploymentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDownstreamTaskInstancesRequest : Tea.TeaModel {
    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListDownstreamTaskInstancesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class TaskInstances : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class Runtime : Tea.TeaModel {
                public var gateway: String?

                public var processId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gateway != nil {
                        map["Gateway"] = self.gateway!
                    }
                    if self.processId != nil {
                        map["ProcessId"] = self.processId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Gateway") {
                        self.gateway = dict["Gateway"] as! String
                    }
                    if dict.keys.contains("ProcessId") {
                        self.processId = dict["ProcessId"] as! String
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cu") {
                        self.cu = dict["Cu"] as! String
                    }
                    if dict.keys.contains("Image") {
                        self.image = dict["Image"] as! String
                    }
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                }
            }
            public var baselineId: Int64?

            public var bizdate: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource?

            public var description_: String?

            public var finishedTime: Int64?

            public var id: Int64?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var owner: String?

            public var periodNumber: Int32?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunMode: String?

            public var runNumber: Int32?

            public var runtime: ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime?

            public var runtimeResource: ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource?

            public var startedTime: Int64?

            public var status: String?

            public var taskId: Int64?

            public var taskName: String?

            public var taskType: String?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var triggerRecurrence: String?

            public var triggerTime: Int64?

            public var triggerType: String?

            public var workflowId: Int64?

            public var workflowInstanceId: Int64?

            public var workflowInstanceType: String?

            public var workflowName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtime?.validate()
                try self.runtimeResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.periodNumber != nil {
                    map["PeriodNumber"] = self.periodNumber!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.runNumber != nil {
                    map["RunNumber"] = self.runNumber!
                }
                if self.runtime != nil {
                    map["Runtime"] = self.runtime?.toMap()
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.startedTime != nil {
                    map["StartedTime"] = self.startedTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.triggerRecurrence != nil {
                    map["TriggerRecurrence"] = self.triggerRecurrence!
                }
                if self.triggerTime != nil {
                    map["TriggerTime"] = self.triggerTime!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                if self.workflowInstanceId != nil {
                    map["WorkflowInstanceId"] = self.workflowInstanceId!
                }
                if self.workflowInstanceType != nil {
                    map["WorkflowInstanceType"] = self.workflowInstanceType!
                }
                if self.workflowName != nil {
                    map["WorkflowName"] = self.workflowName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("Bizdate") {
                    self.bizdate = dict["Bizdate"] as! Int64
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("DataSource") {
                    var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FinishedTime") {
                    self.finishedTime = dict["FinishedTime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("ModifyUser") {
                    self.modifyUser = dict["ModifyUser"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("PeriodNumber") {
                    self.periodNumber = dict["PeriodNumber"] as! Int32
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectEnv") {
                    self.projectEnv = dict["ProjectEnv"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RerunMode") {
                    self.rerunMode = dict["RerunMode"] as! String
                }
                if dict.keys.contains("RunNumber") {
                    self.runNumber = dict["RunNumber"] as! Int32
                }
                if dict.keys.contains("Runtime") {
                    var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime()
                    model.fromMap(dict["Runtime"] as! [String: Any])
                    self.runtime = model
                }
                if dict.keys.contains("RuntimeResource") {
                    var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource()
                    model.fromMap(dict["RuntimeResource"] as! [String: Any])
                    self.runtimeResource = model
                }
                if dict.keys.contains("StartedTime") {
                    self.startedTime = dict["StartedTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! Int64
                }
                if dict.keys.contains("TaskName") {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("TriggerRecurrence") {
                    self.triggerRecurrence = dict["TriggerRecurrence"] as! String
                }
                if dict.keys.contains("TriggerTime") {
                    self.triggerTime = dict["TriggerTime"] as! Int64
                }
                if dict.keys.contains("TriggerType") {
                    self.triggerType = dict["TriggerType"] as! String
                }
                if dict.keys.contains("WorkflowId") {
                    self.workflowId = dict["WorkflowId"] as! Int64
                }
                if dict.keys.contains("WorkflowInstanceId") {
                    self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
                }
                if dict.keys.contains("WorkflowInstanceType") {
                    self.workflowInstanceType = dict["WorkflowInstanceType"] as! String
                }
                if dict.keys.contains("WorkflowName") {
                    self.workflowName = dict["WorkflowName"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var taskInstances: [ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.taskInstances != nil {
                var tmp : [Any] = []
                for k in self.taskInstances! {
                    tmp.append(k.toMap())
                }
                map["TaskInstances"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TaskInstances") {
                var tmp : [ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances] = []
                for v in dict["TaskInstances"] as! [Any] {
                    var model = ListDownstreamTaskInstancesResponseBody.PagingInfo.TaskInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskInstances = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListDownstreamTaskInstancesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDownstreamTaskInstancesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDownstreamTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDownstreamTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDownstreamTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDownstreamTasksRequest : Tea.TeaModel {
    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class ListDownstreamTasksResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Tasks : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cu") {
                        self.cu = dict["Cu"] as! String
                    }
                    if dict.keys.contains("Image") {
                        self.image = dict["Image"] as! String
                    }
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var recurrence: String?

                public var startTime: String?

                public var timezone: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.recurrence != nil {
                        map["Recurrence"] = self.recurrence!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cron") {
                        self.cron = dict["Cron"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("Recurrence") {
                        self.recurrence = dict["Recurrence"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timezone") {
                        self.timezone = dict["Timezone"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var baselineId: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListDownstreamTasksResponseBody.PagingInfo.Tasks.DataSource?

            public var description_: String?

            public var id: Int64?

            public var instanceMode: String?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var name: String?

            public var owner: String?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunInterval: Int32?

            public var rerunMode: String?

            public var rerunTimes: Int32?

            public var runtimeResource: ListDownstreamTasksResponseBody.PagingInfo.Tasks.RuntimeResource?

            public var stepType: String?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var trigger: ListDownstreamTasksResponseBody.PagingInfo.Tasks.Trigger?

            public var type: String?

            public var workflowId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtimeResource?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceMode != nil {
                    map["InstanceMode"] = self.instanceMode!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunInterval != nil {
                    map["RerunInterval"] = self.rerunInterval!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.rerunTimes != nil {
                    map["RerunTimes"] = self.rerunTimes!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("DataSource") {
                    var model = ListDownstreamTasksResponseBody.PagingInfo.Tasks.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstanceMode") {
                    self.instanceMode = dict["InstanceMode"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("ModifyUser") {
                    self.modifyUser = dict["ModifyUser"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectEnv") {
                    self.projectEnv = dict["ProjectEnv"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RerunInterval") {
                    self.rerunInterval = dict["RerunInterval"] as! Int32
                }
                if dict.keys.contains("RerunMode") {
                    self.rerunMode = dict["RerunMode"] as! String
                }
                if dict.keys.contains("RerunTimes") {
                    self.rerunTimes = dict["RerunTimes"] as! Int32
                }
                if dict.keys.contains("RuntimeResource") {
                    var model = ListDownstreamTasksResponseBody.PagingInfo.Tasks.RuntimeResource()
                    model.fromMap(dict["RuntimeResource"] as! [String: Any])
                    self.runtimeResource = model
                }
                if dict.keys.contains("StepType") {
                    self.stepType = dict["StepType"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("Trigger") {
                    var model = ListDownstreamTasksResponseBody.PagingInfo.Tasks.Trigger()
                    model.fromMap(dict["Trigger"] as! [String: Any])
                    self.trigger = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkflowId") {
                    self.workflowId = dict["WorkflowId"] as! Int64
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tasks: [ListDownstreamTasksResponseBody.PagingInfo.Tasks]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tasks != nil {
                var tmp : [Any] = []
                for k in self.tasks! {
                    tmp.append(k.toMap())
                }
                map["Tasks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Tasks") {
                var tmp : [ListDownstreamTasksResponseBody.PagingInfo.Tasks] = []
                for v in dict["Tasks"] as! [Any] {
                    var model = ListDownstreamTasksResponseBody.PagingInfo.Tasks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tasks = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListDownstreamTasksResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListDownstreamTasksResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDownstreamTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDownstreamTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDownstreamTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFunctionsRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListFunctionsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Functions : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                }
            }
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Command") {
                            self.command = dict["Command"] as! String
                        }
                    }
                }
                public var id: String?

                public var path: String?

                public var runtime: ListFunctionsResponseBody.PagingInfo.Functions.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Runtime") {
                        var model = ListFunctionsResponseBody.PagingInfo.Functions.Script.Runtime()
                        model.fromMap(dict["Runtime"] as! [String: Any])
                        self.runtime = model
                    }
                }
            }
            public var armResource: String?

            public var className: String?

            public var commandDescription: String?

            public var createTime: Int64?

            public var dataSource: ListFunctionsResponseBody.PagingInfo.Functions.DataSource?

            public var databaseName: String?

            public var description_: String?

            public var embeddedCode: String?

            public var embeddedCodeType: String?

            public var embeddedResourceType: String?

            public var exampleDescription: String?

            public var fileResource: String?

            public var id: String?

            public var modifyTime: Int64?

            public var name: String?

            public var owner: String?

            public var parameterDescription: String?

            public var projectId: String?

            public var returnValueDescription: String?

            public var runtimeResource: ListFunctionsResponseBody.PagingInfo.Functions.RuntimeResource?

            public var script: ListFunctionsResponseBody.PagingInfo.Functions.Script?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtimeResource?.validate()
                try self.script?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.armResource != nil {
                    map["ArmResource"] = self.armResource!
                }
                if self.className != nil {
                    map["ClassName"] = self.className!
                }
                if self.commandDescription != nil {
                    map["CommandDescription"] = self.commandDescription!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.embeddedCode != nil {
                    map["EmbeddedCode"] = self.embeddedCode!
                }
                if self.embeddedCodeType != nil {
                    map["EmbeddedCodeType"] = self.embeddedCodeType!
                }
                if self.embeddedResourceType != nil {
                    map["EmbeddedResourceType"] = self.embeddedResourceType!
                }
                if self.exampleDescription != nil {
                    map["ExampleDescription"] = self.exampleDescription!
                }
                if self.fileResource != nil {
                    map["FileResource"] = self.fileResource!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parameterDescription != nil {
                    map["ParameterDescription"] = self.parameterDescription!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.returnValueDescription != nil {
                    map["ReturnValueDescription"] = self.returnValueDescription!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ArmResource") {
                    self.armResource = dict["ArmResource"] as! String
                }
                if dict.keys.contains("ClassName") {
                    self.className = dict["ClassName"] as! String
                }
                if dict.keys.contains("CommandDescription") {
                    self.commandDescription = dict["CommandDescription"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DataSource") {
                    var model = ListFunctionsResponseBody.PagingInfo.Functions.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EmbeddedCode") {
                    self.embeddedCode = dict["EmbeddedCode"] as! String
                }
                if dict.keys.contains("EmbeddedCodeType") {
                    self.embeddedCodeType = dict["EmbeddedCodeType"] as! String
                }
                if dict.keys.contains("EmbeddedResourceType") {
                    self.embeddedResourceType = dict["EmbeddedResourceType"] as! String
                }
                if dict.keys.contains("ExampleDescription") {
                    self.exampleDescription = dict["ExampleDescription"] as! String
                }
                if dict.keys.contains("FileResource") {
                    self.fileResource = dict["FileResource"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ParameterDescription") {
                    self.parameterDescription = dict["ParameterDescription"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("ReturnValueDescription") {
                    self.returnValueDescription = dict["ReturnValueDescription"] as! String
                }
                if dict.keys.contains("RuntimeResource") {
                    var model = ListFunctionsResponseBody.PagingInfo.Functions.RuntimeResource()
                    model.fromMap(dict["RuntimeResource"] as! [String: Any])
                    self.runtimeResource = model
                }
                if dict.keys.contains("Script") {
                    var model = ListFunctionsResponseBody.PagingInfo.Functions.Script()
                    model.fromMap(dict["Script"] as! [String: Any])
                    self.script = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var functions: [ListFunctionsResponseBody.PagingInfo.Functions]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.functions != nil {
                var tmp : [Any] = []
                for k in self.functions! {
                    tmp.append(k.toMap())
                }
                map["Functions"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Functions") {
                var tmp : [ListFunctionsResponseBody.PagingInfo.Functions] = []
                for v in dict["Functions"] as! [Any] {
                    var model = ListFunctionsResponseBody.PagingInfo.Functions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.functions = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListFunctionsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListFunctionsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFunctionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFunctionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFunctionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNetworksRequest : Tea.TeaModel {
    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ListNetworksResponseBody : Tea.TeaModel {
    public class NetworkList : Tea.TeaModel {
        public var createTime: Int64?

        public var createUser: String?

        public var id: Int64?

        public var resourceGroupId: String?

        public var securityGroupId: String?

        public var status: String?

        public var vpcId: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("VswitchId") {
                self.vswitchId = dict["VswitchId"] as! String
            }
        }
    }
    public var networkList: [ListNetworksResponseBody.NetworkList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkList != nil {
            var tmp : [Any] = []
            for k in self.networkList! {
                tmp.append(k.toMap())
            }
            map["NetworkList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkList") {
            var tmp : [ListNetworksResponseBody.NetworkList] = []
            for v in dict["NetworkList"] as! [Any] {
                var model = ListNetworksResponseBody.NetworkList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkList = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListNetworksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNetworksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNetworksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodeDependenciesRequest : Tea.TeaModel {
    public var id: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class ListNodeDependenciesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Inputs : Tea.TeaModel {
                public class NodeOutputs : Tea.TeaModel {
                    public var data: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Data") {
                            self.data = dict["Data"] as! String
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public var guid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.guid != nil {
                            map["Guid"] = self.guid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Guid") {
                            self.guid = dict["Guid"] as! String
                        }
                    }
                }
                public class Variables : Tea.TeaModel {
                    public class Node : Tea.TeaModel {
                        public var output: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.output != nil {
                                map["Output"] = self.output!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Output") {
                                self.output = dict["Output"] as! String
                            }
                        }
                    }
                    public var artifactType: String?

                    public var id: String?

                    public var name: String?

                    public var node: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables.Node?

                    public var scope: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.node?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.artifactType != nil {
                            map["ArtifactType"] = self.artifactType!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.node != nil {
                            map["Node"] = self.node?.toMap()
                        }
                        if self.scope != nil {
                            map["Scope"] = self.scope!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ArtifactType") {
                            self.artifactType = dict["ArtifactType"] as! String
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Node") {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables.Node()
                            model.fromMap(dict["Node"] as! [String: Any])
                            self.node = model
                        }
                        if dict.keys.contains("Scope") {
                            self.scope = dict["Scope"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var nodeOutputs: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs]?

                public var tables: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Tables]?

                public var variables: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeOutputs != nil {
                        var tmp : [Any] = []
                        for k in self.nodeOutputs! {
                            tmp.append(k.toMap())
                        }
                        map["NodeOutputs"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.variables != nil {
                        var tmp : [Any] = []
                        for k in self.variables! {
                            tmp.append(k.toMap())
                        }
                        map["Variables"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NodeOutputs") {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs] = []
                        for v in dict["NodeOutputs"] as! [Any] {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.nodeOutputs = tmp
                    }
                    if dict.keys.contains("Tables") {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Tables] = []
                        for v in dict["Tables"] as! [Any] {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Tables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tables = tmp
                    }
                    if dict.keys.contains("Variables") {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables] = []
                        for v in dict["Variables"] as! [Any] {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs.Variables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.variables = tmp
                    }
                }
            }
            public class Outputs : Tea.TeaModel {
                public class NodeOutputs : Tea.TeaModel {
                    public var data: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Data") {
                            self.data = dict["Data"] as! String
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public var guid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.guid != nil {
                            map["Guid"] = self.guid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Guid") {
                            self.guid = dict["Guid"] as! String
                        }
                    }
                }
                public class Variables : Tea.TeaModel {
                    public class Node : Tea.TeaModel {
                        public var output: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.output != nil {
                                map["Output"] = self.output!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Output") {
                                self.output = dict["Output"] as! String
                            }
                        }
                    }
                    public var artifactType: String?

                    public var id: String?

                    public var name: String?

                    public var node: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables.Node?

                    public var scope: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.node?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.artifactType != nil {
                            map["ArtifactType"] = self.artifactType!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.node != nil {
                            map["Node"] = self.node?.toMap()
                        }
                        if self.scope != nil {
                            map["Scope"] = self.scope!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ArtifactType") {
                            self.artifactType = dict["ArtifactType"] as! String
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Node") {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables.Node()
                            model.fromMap(dict["Node"] as! [String: Any])
                            self.node = model
                        }
                        if dict.keys.contains("Scope") {
                            self.scope = dict["Scope"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var nodeOutputs: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs]?

                public var tables: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Tables]?

                public var variables: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeOutputs != nil {
                        var tmp : [Any] = []
                        for k in self.nodeOutputs! {
                            tmp.append(k.toMap())
                        }
                        map["NodeOutputs"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.variables != nil {
                        var tmp : [Any] = []
                        for k in self.variables! {
                            tmp.append(k.toMap())
                        }
                        map["Variables"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NodeOutputs") {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs] = []
                        for v in dict["NodeOutputs"] as! [Any] {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.nodeOutputs = tmp
                    }
                    if dict.keys.contains("Tables") {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Tables] = []
                        for v in dict["Tables"] as! [Any] {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Tables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tables = tmp
                    }
                    if dict.keys.contains("Variables") {
                        var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables] = []
                        for v in dict["Variables"] as! [Any] {
                            var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs.Variables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.variables = tmp
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                }
            }
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Command") {
                            self.command = dict["Command"] as! String
                        }
                    }
                }
                public var id: String?

                public var path: String?

                public var runtime: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Runtime") {
                        var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Script.Runtime()
                        model.fromMap(dict["Runtime"] as! [String: Any])
                        self.runtime = model
                    }
                }
            }
            public class Strategy : Tea.TeaModel {
                public var instanceMode: String?

                public var rerunInterval: Int32?

                public var rerunMode: String?

                public var rerunTimes: Int32?

                public var timeout: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceMode != nil {
                        map["InstanceMode"] = self.instanceMode!
                    }
                    if self.rerunInterval != nil {
                        map["RerunInterval"] = self.rerunInterval!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.rerunTimes != nil {
                        map["RerunTimes"] = self.rerunTimes!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceMode") {
                        self.instanceMode = dict["InstanceMode"] as! String
                    }
                    if dict.keys.contains("RerunInterval") {
                        self.rerunInterval = dict["RerunInterval"] as! Int32
                    }
                    if dict.keys.contains("RerunMode") {
                        self.rerunMode = dict["RerunMode"] as! String
                    }
                    if dict.keys.contains("RerunTimes") {
                        self.rerunTimes = dict["RerunTimes"] as! Int32
                    }
                    if dict.keys.contains("Timeout") {
                        self.timeout = dict["Timeout"] as! Int32
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var id: String?

                public var startTime: String?

                public var timezone: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cron") {
                        self.cron = dict["Cron"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timezone") {
                        self.timezone = dict["Timezone"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var createTime: Int64?

            public var dataSource: ListNodeDependenciesResponseBody.PagingInfo.Nodes.DataSource?

            public var description_: String?

            public var id: String?

            public var inputs: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs?

            public var modifyTime: Int64?

            public var name: String?

            public var outputs: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs?

            public var owner: String?

            public var projectId: String?

            public var recurrence: String?

            public var runtimeResource: ListNodeDependenciesResponseBody.PagingInfo.Nodes.RuntimeResource?

            public var script: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Script?

            public var strategy: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Strategy?

            public var tags: [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Tags]?

            public var taskId: String?

            public var trigger: ListNodeDependenciesResponseBody.PagingInfo.Nodes.Trigger?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.inputs?.validate()
                try self.outputs?.validate()
                try self.runtimeResource?.validate()
                try self.script?.validate()
                try self.strategy?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.inputs != nil {
                    map["Inputs"] = self.inputs?.toMap()
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outputs != nil {
                    map["Outputs"] = self.outputs?.toMap()
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.recurrence != nil {
                    map["Recurrence"] = self.recurrence!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy?.toMap()
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DataSource") {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Inputs") {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Inputs()
                    model.fromMap(dict["Inputs"] as! [String: Any])
                    self.inputs = model
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Outputs") {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Outputs()
                    model.fromMap(dict["Outputs"] as! [String: Any])
                    self.outputs = model
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Recurrence") {
                    self.recurrence = dict["Recurrence"] as! String
                }
                if dict.keys.contains("RuntimeResource") {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.RuntimeResource()
                    model.fromMap(dict["RuntimeResource"] as! [String: Any])
                    self.runtimeResource = model
                }
                if dict.keys.contains("Script") {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Script()
                    model.fromMap(dict["Script"] as! [String: Any])
                    self.script = model
                }
                if dict.keys.contains("Strategy") {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Strategy()
                    model.fromMap(dict["Strategy"] as! [String: Any])
                    self.strategy = model
                }
                if dict.keys.contains("Tags") {
                    var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("Trigger") {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes.Trigger()
                    model.fromMap(dict["Trigger"] as! [String: Any])
                    self.trigger = model
                }
            }
        }
        public var nodes: [ListNodeDependenciesResponseBody.PagingInfo.Nodes]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Nodes") {
                var tmp : [ListNodeDependenciesResponseBody.PagingInfo.Nodes] = []
                for v in dict["Nodes"] as! [Any] {
                    var model = ListNodeDependenciesResponseBody.PagingInfo.Nodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodes = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var pagingInfo: ListNodeDependenciesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListNodeDependenciesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListNodeDependenciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodeDependenciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodeDependenciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public var containerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var recurrence: String?

    public var rerunMode: String?

    public var scene: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.recurrence != nil {
            map["Recurrence"] = self.recurrence!
        }
        if self.rerunMode != nil {
            map["RerunMode"] = self.rerunMode!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContainerId") {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Recurrence") {
            self.recurrence = dict["Recurrence"] as! String
        }
        if dict.keys.contains("RerunMode") {
            self.rerunMode = dict["RerunMode"] as! String
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Nodes : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Inputs : Tea.TeaModel {
                public class NodeOutputs : Tea.TeaModel {
                    public var data: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Data") {
                            self.data = dict["Data"] as! String
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public var guid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.guid != nil {
                            map["Guid"] = self.guid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Guid") {
                            self.guid = dict["Guid"] as! String
                        }
                    }
                }
                public class Variables : Tea.TeaModel {
                    public class Node : Tea.TeaModel {
                        public var output: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.output != nil {
                                map["Output"] = self.output!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Output") {
                                self.output = dict["Output"] as! String
                            }
                        }
                    }
                    public var artifactType: String?

                    public var id: String?

                    public var name: String?

                    public var node: ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables.Node?

                    public var scope: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.node?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.artifactType != nil {
                            map["ArtifactType"] = self.artifactType!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.node != nil {
                            map["Node"] = self.node?.toMap()
                        }
                        if self.scope != nil {
                            map["Scope"] = self.scope!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ArtifactType") {
                            self.artifactType = dict["ArtifactType"] as! String
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Node") {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables.Node()
                            model.fromMap(dict["Node"] as! [String: Any])
                            self.node = model
                        }
                        if dict.keys.contains("Scope") {
                            self.scope = dict["Scope"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var nodeOutputs: [ListNodesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs]?

                public var tables: [ListNodesResponseBody.PagingInfo.Nodes.Inputs.Tables]?

                public var variables: [ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeOutputs != nil {
                        var tmp : [Any] = []
                        for k in self.nodeOutputs! {
                            tmp.append(k.toMap())
                        }
                        map["NodeOutputs"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.variables != nil {
                        var tmp : [Any] = []
                        for k in self.variables! {
                            tmp.append(k.toMap())
                        }
                        map["Variables"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NodeOutputs") {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs] = []
                        for v in dict["NodeOutputs"] as! [Any] {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs.NodeOutputs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.nodeOutputs = tmp
                    }
                    if dict.keys.contains("Tables") {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Inputs.Tables] = []
                        for v in dict["Tables"] as! [Any] {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs.Tables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tables = tmp
                    }
                    if dict.keys.contains("Variables") {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables] = []
                        for v in dict["Variables"] as! [Any] {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs.Variables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.variables = tmp
                    }
                }
            }
            public class Outputs : Tea.TeaModel {
                public class NodeOutputs : Tea.TeaModel {
                    public var data: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.data != nil {
                            map["Data"] = self.data!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Data") {
                            self.data = dict["Data"] as! String
                        }
                    }
                }
                public class Tables : Tea.TeaModel {
                    public var guid: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.guid != nil {
                            map["Guid"] = self.guid!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Guid") {
                            self.guid = dict["Guid"] as! String
                        }
                    }
                }
                public class Variables : Tea.TeaModel {
                    public class Node : Tea.TeaModel {
                        public var output: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.output != nil {
                                map["Output"] = self.output!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Output") {
                                self.output = dict["Output"] as! String
                            }
                        }
                    }
                    public var artifactType: String?

                    public var id: String?

                    public var name: String?

                    public var node: ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables.Node?

                    public var scope: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.node?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.artifactType != nil {
                            map["ArtifactType"] = self.artifactType!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.node != nil {
                            map["Node"] = self.node?.toMap()
                        }
                        if self.scope != nil {
                            map["Scope"] = self.scope!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ArtifactType") {
                            self.artifactType = dict["ArtifactType"] as! String
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Node") {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables.Node()
                            model.fromMap(dict["Node"] as! [String: Any])
                            self.node = model
                        }
                        if dict.keys.contains("Scope") {
                            self.scope = dict["Scope"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var nodeOutputs: [ListNodesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs]?

                public var tables: [ListNodesResponseBody.PagingInfo.Nodes.Outputs.Tables]?

                public var variables: [ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nodeOutputs != nil {
                        var tmp : [Any] = []
                        for k in self.nodeOutputs! {
                            tmp.append(k.toMap())
                        }
                        map["NodeOutputs"] = tmp
                    }
                    if self.tables != nil {
                        var tmp : [Any] = []
                        for k in self.tables! {
                            tmp.append(k.toMap())
                        }
                        map["Tables"] = tmp
                    }
                    if self.variables != nil {
                        var tmp : [Any] = []
                        for k in self.variables! {
                            tmp.append(k.toMap())
                        }
                        map["Variables"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NodeOutputs") {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs] = []
                        for v in dict["NodeOutputs"] as! [Any] {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs.NodeOutputs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.nodeOutputs = tmp
                    }
                    if dict.keys.contains("Tables") {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Outputs.Tables] = []
                        for v in dict["Tables"] as! [Any] {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs.Tables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tables = tmp
                    }
                    if dict.keys.contains("Variables") {
                        var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables] = []
                        for v in dict["Variables"] as! [Any] {
                            var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs.Variables()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.variables = tmp
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                }
            }
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Command") {
                            self.command = dict["Command"] as! String
                        }
                    }
                }
                public var id: String?

                public var path: String?

                public var runtime: ListNodesResponseBody.PagingInfo.Nodes.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Runtime") {
                        var model = ListNodesResponseBody.PagingInfo.Nodes.Script.Runtime()
                        model.fromMap(dict["Runtime"] as! [String: Any])
                        self.runtime = model
                    }
                }
            }
            public class Strategy : Tea.TeaModel {
                public var instanceMode: String?

                public var rerunInterval: Int32?

                public var rerunMode: String?

                public var rerunTimes: Int32?

                public var timeout: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceMode != nil {
                        map["InstanceMode"] = self.instanceMode!
                    }
                    if self.rerunInterval != nil {
                        map["RerunInterval"] = self.rerunInterval!
                    }
                    if self.rerunMode != nil {
                        map["RerunMode"] = self.rerunMode!
                    }
                    if self.rerunTimes != nil {
                        map["RerunTimes"] = self.rerunTimes!
                    }
                    if self.timeout != nil {
                        map["Timeout"] = self.timeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceMode") {
                        self.instanceMode = dict["InstanceMode"] as! String
                    }
                    if dict.keys.contains("RerunInterval") {
                        self.rerunInterval = dict["RerunInterval"] as! Int32
                    }
                    if dict.keys.contains("RerunMode") {
                        self.rerunMode = dict["RerunMode"] as! String
                    }
                    if dict.keys.contains("RerunTimes") {
                        self.rerunTimes = dict["RerunTimes"] as! Int32
                    }
                    if dict.keys.contains("Timeout") {
                        self.timeout = dict["Timeout"] as! Int32
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var id: String?

                public var startTime: String?

                public var timezone: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cron") {
                        self.cron = dict["Cron"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timezone") {
                        self.timezone = dict["Timezone"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var createTime: Int64?

            public var dataSource: ListNodesResponseBody.PagingInfo.Nodes.DataSource?

            public var description_: String?

            public var id: String?

            public var inputs: ListNodesResponseBody.PagingInfo.Nodes.Inputs?

            public var modifyTime: Int64?

            public var name: String?

            public var outputs: ListNodesResponseBody.PagingInfo.Nodes.Outputs?

            public var owner: String?

            public var projectId: String?

            public var recurrence: String?

            public var runtimeResource: ListNodesResponseBody.PagingInfo.Nodes.RuntimeResource?

            public var script: ListNodesResponseBody.PagingInfo.Nodes.Script?

            public var strategy: ListNodesResponseBody.PagingInfo.Nodes.Strategy?

            public var tags: [ListNodesResponseBody.PagingInfo.Nodes.Tags]?

            public var taskId: String?

            public var trigger: ListNodesResponseBody.PagingInfo.Nodes.Trigger?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.inputs?.validate()
                try self.outputs?.validate()
                try self.runtimeResource?.validate()
                try self.script?.validate()
                try self.strategy?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.inputs != nil {
                    map["Inputs"] = self.inputs?.toMap()
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.outputs != nil {
                    map["Outputs"] = self.outputs?.toMap()
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.recurrence != nil {
                    map["Recurrence"] = self.recurrence!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy?.toMap()
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DataSource") {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Inputs") {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Inputs()
                    model.fromMap(dict["Inputs"] as! [String: Any])
                    self.inputs = model
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Outputs") {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Outputs()
                    model.fromMap(dict["Outputs"] as! [String: Any])
                    self.outputs = model
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Recurrence") {
                    self.recurrence = dict["Recurrence"] as! String
                }
                if dict.keys.contains("RuntimeResource") {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.RuntimeResource()
                    model.fromMap(dict["RuntimeResource"] as! [String: Any])
                    self.runtimeResource = model
                }
                if dict.keys.contains("Script") {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Script()
                    model.fromMap(dict["Script"] as! [String: Any])
                    self.script = model
                }
                if dict.keys.contains("Strategy") {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Strategy()
                    model.fromMap(dict["Strategy"] as! [String: Any])
                    self.strategy = model
                }
                if dict.keys.contains("Tags") {
                    var tmp : [ListNodesResponseBody.PagingInfo.Nodes.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListNodesResponseBody.PagingInfo.Nodes.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("Trigger") {
                    var model = ListNodesResponseBody.PagingInfo.Nodes.Trigger()
                    model.fromMap(dict["Trigger"] as! [String: Any])
                    self.trigger = model
                }
            }
        }
        public var nodes: [ListNodesResponseBody.PagingInfo.Nodes]?

        public var pageNumber: String?

        public var pageSize: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodes != nil {
                var tmp : [Any] = []
                for k in self.nodes! {
                    tmp.append(k.toMap())
                }
                map["Nodes"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Nodes") {
                var tmp : [ListNodesResponseBody.PagingInfo.Nodes] = []
                for v in dict["Nodes"] as! [Any] {
                    var model = ListNodesResponseBody.PagingInfo.Nodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodes = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var pagingInfo: ListNodesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListNodesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectMembersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var roleCodes: [String]?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodes != nil {
            map["RoleCodes"] = self.roleCodes!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCodes") {
            self.roleCodes = dict["RoleCodes"] as! [String]
        }
        if dict.keys.contains("UserIds") {
            self.userIds = dict["UserIds"] as! [String]
        }
    }
}

public class ListProjectMembersShrinkRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var roleCodesShrink: String?

    public var userIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodesShrink != nil {
            map["RoleCodes"] = self.roleCodesShrink!
        }
        if self.userIdsShrink != nil {
            map["UserIds"] = self.userIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCodes") {
            self.roleCodesShrink = dict["RoleCodes"] as! String
        }
        if dict.keys.contains("UserIds") {
            self.userIdsShrink = dict["UserIds"] as! String
        }
    }
}

public class ListProjectMembersResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class ProjectMembers : Tea.TeaModel {
            public class Roles : Tea.TeaModel {
                public var code: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var projectId: Int64?

            public var roles: [ListProjectMembersResponseBody.PagingInfo.ProjectMembers.Roles]?

            public var status: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.roles != nil {
                    var tmp : [Any] = []
                    for k in self.roles! {
                        tmp.append(k.toMap())
                    }
                    map["Roles"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Roles") {
                    var tmp : [ListProjectMembersResponseBody.PagingInfo.ProjectMembers.Roles] = []
                    for v in dict["Roles"] as! [Any] {
                        var model = ListProjectMembersResponseBody.PagingInfo.ProjectMembers.Roles()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.roles = tmp
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var projectMembers: [ListProjectMembersResponseBody.PagingInfo.ProjectMembers]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projectMembers != nil {
                var tmp : [Any] = []
                for k in self.projectMembers! {
                    tmp.append(k.toMap())
                }
                map["ProjectMembers"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("ProjectMembers") {
                var tmp : [ListProjectMembersResponseBody.PagingInfo.ProjectMembers] = []
                for v in dict["ProjectMembers"] as! [Any] {
                    var model = ListProjectMembersResponseBody.PagingInfo.ProjectMembers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.projectMembers = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListProjectMembersResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListProjectMembersResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListProjectMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectRolesRequest : Tea.TeaModel {
    public var codes: [String]?

    public var names: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.codes != nil {
            map["Codes"] = self.codes!
        }
        if self.names != nil {
            map["Names"] = self.names!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Codes") {
            self.codes = dict["Codes"] as! [String]
        }
        if dict.keys.contains("Names") {
            self.names = dict["Names"] as! [String]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListProjectRolesShrinkRequest : Tea.TeaModel {
    public var codesShrink: String?

    public var namesShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.codesShrink != nil {
            map["Codes"] = self.codesShrink!
        }
        if self.namesShrink != nil {
            map["Names"] = self.namesShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Codes") {
            self.codesShrink = dict["Codes"] as! String
        }
        if dict.keys.contains("Names") {
            self.namesShrink = dict["Names"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListProjectRolesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class ProjectRoles : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public var projectId: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pageNumber: String?

        public var pageSize: String?

        public var projectRoles: [ListProjectRolesResponseBody.PagingInfo.ProjectRoles]?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projectRoles != nil {
                var tmp : [Any] = []
                for k in self.projectRoles! {
                    tmp.append(k.toMap())
                }
                map["ProjectRoles"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("ProjectRoles") {
                var tmp : [ListProjectRolesResponseBody.PagingInfo.ProjectRoles] = []
                for v in dict["ProjectRoles"] as! [Any] {
                    var model = ListProjectRolesResponseBody.PagingInfo.ProjectRoles()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.projectRoles = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public var pagingInfo: ListProjectRolesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListProjectRolesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListProjectRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectRolesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectsRequest : Tea.TeaModel {
    public class AliyunResourceTags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTags: [ListProjectsRequest.AliyunResourceTags]?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var ids: [Int64]?

    public var names: [String]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var paiTaskEnabled: Bool?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTags != nil {
            var tmp : [Any] = []
            for k in self.aliyunResourceTags! {
                tmp.append(k.toMap())
            }
            map["AliyunResourceTags"] = tmp
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.names != nil {
            map["Names"] = self.names!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunResourceGroupId") {
            self.aliyunResourceGroupId = dict["AliyunResourceGroupId"] as! String
        }
        if dict.keys.contains("AliyunResourceTags") {
            var tmp : [ListProjectsRequest.AliyunResourceTags] = []
            for v in dict["AliyunResourceTags"] as! [Any] {
                var model = ListProjectsRequest.AliyunResourceTags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aliyunResourceTags = tmp
        }
        if dict.keys.contains("DevEnvironmentEnabled") {
            self.devEnvironmentEnabled = dict["DevEnvironmentEnabled"] as! Bool
        }
        if dict.keys.contains("DevRoleDisabled") {
            self.devRoleDisabled = dict["DevRoleDisabled"] as! Bool
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
        if dict.keys.contains("Names") {
            self.names = dict["Names"] as! [String]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PaiTaskEnabled") {
            self.paiTaskEnabled = dict["PaiTaskEnabled"] as! Bool
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListProjectsShrinkRequest : Tea.TeaModel {
    public var aliyunResourceGroupId: String?

    public var aliyunResourceTagsShrink: String?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var idsShrink: String?

    public var namesShrink: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var paiTaskEnabled: Bool?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunResourceGroupId != nil {
            map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
        }
        if self.aliyunResourceTagsShrink != nil {
            map["AliyunResourceTags"] = self.aliyunResourceTagsShrink!
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.namesShrink != nil {
            map["Names"] = self.namesShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliyunResourceGroupId") {
            self.aliyunResourceGroupId = dict["AliyunResourceGroupId"] as! String
        }
        if dict.keys.contains("AliyunResourceTags") {
            self.aliyunResourceTagsShrink = dict["AliyunResourceTags"] as! String
        }
        if dict.keys.contains("DevEnvironmentEnabled") {
            self.devEnvironmentEnabled = dict["DevEnvironmentEnabled"] as! Bool
        }
        if dict.keys.contains("DevRoleDisabled") {
            self.devRoleDisabled = dict["DevRoleDisabled"] as! Bool
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
        if dict.keys.contains("Names") {
            self.namesShrink = dict["Names"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PaiTaskEnabled") {
            self.paiTaskEnabled = dict["PaiTaskEnabled"] as! Bool
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListProjectsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Projects : Tea.TeaModel {
            public class AliyunResourceTags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var aliyunResourceGroupId: String?

            public var aliyunResourceTags: [ListProjectsResponseBody.PagingInfo.Projects.AliyunResourceTags]?

            public var description_: String?

            public var devEnvironmentEnabled: Bool?

            public var devRoleDisabled: Bool?

            public var displayName: String?

            public var id: Int64?

            public var name: String?

            public var owner: String?

            public var paiTaskEnabled: Bool?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunResourceGroupId != nil {
                    map["AliyunResourceGroupId"] = self.aliyunResourceGroupId!
                }
                if self.aliyunResourceTags != nil {
                    var tmp : [Any] = []
                    for k in self.aliyunResourceTags! {
                        tmp.append(k.toMap())
                    }
                    map["AliyunResourceTags"] = tmp
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.devEnvironmentEnabled != nil {
                    map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
                }
                if self.devRoleDisabled != nil {
                    map["DevRoleDisabled"] = self.devRoleDisabled!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.paiTaskEnabled != nil {
                    map["PaiTaskEnabled"] = self.paiTaskEnabled!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunResourceGroupId") {
                    self.aliyunResourceGroupId = dict["AliyunResourceGroupId"] as! String
                }
                if dict.keys.contains("AliyunResourceTags") {
                    var tmp : [ListProjectsResponseBody.PagingInfo.Projects.AliyunResourceTags] = []
                    for v in dict["AliyunResourceTags"] as! [Any] {
                        var model = ListProjectsResponseBody.PagingInfo.Projects.AliyunResourceTags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.aliyunResourceTags = tmp
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DevEnvironmentEnabled") {
                    self.devEnvironmentEnabled = dict["DevEnvironmentEnabled"] as! Bool
                }
                if dict.keys.contains("DevRoleDisabled") {
                    self.devRoleDisabled = dict["DevRoleDisabled"] as! Bool
                }
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("PaiTaskEnabled") {
                    self.paiTaskEnabled = dict["PaiTaskEnabled"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var projects: [ListProjectsResponseBody.PagingInfo.Projects]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.projects != nil {
                var tmp : [Any] = []
                for k in self.projects! {
                    tmp.append(k.toMap())
                }
                map["Projects"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Projects") {
                var tmp : [ListProjectsResponseBody.PagingInfo.Projects] = []
                for v in dict["Projects"] as! [Any] {
                    var model = ListProjectsResponseBody.PagingInfo.Projects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.projects = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListProjectsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListProjectsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListResourceGroupsRequest : Tea.TeaModel {
    public var name: String?

    public var paymentType: String?

    public var projectId: Int64?

    public var resourceGroupTypes: [String]?

    public var statuses: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupTypes != nil {
            map["ResourceGroupTypes"] = self.resourceGroupTypes!
        }
        if self.statuses != nil {
            map["Statuses"] = self.statuses!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceGroupTypes") {
            self.resourceGroupTypes = dict["ResourceGroupTypes"] as! [String]
        }
        if dict.keys.contains("Statuses") {
            self.statuses = dict["Statuses"] as! [String]
        }
    }
}

public class ListResourceGroupsShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var paymentType: String?

    public var projectId: Int64?

    public var resourceGroupTypesShrink: String?

    public var statusesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paymentType != nil {
            map["PaymentType"] = self.paymentType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceGroupTypesShrink != nil {
            map["ResourceGroupTypes"] = self.resourceGroupTypesShrink!
        }
        if self.statusesShrink != nil {
            map["Statuses"] = self.statusesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PaymentType") {
            self.paymentType = dict["PaymentType"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceGroupTypes") {
            self.resourceGroupTypesShrink = dict["ResourceGroupTypes"] as! String
        }
        if dict.keys.contains("Statuses") {
            self.statusesShrink = dict["Statuses"] as! String
        }
    }
}

public class ListResourceGroupsResponseBody : Tea.TeaModel {
    public class ResourceGroupList : Tea.TeaModel {
        public class Spec : Tea.TeaModel {
            public var amount: Int32?

            public var standard: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.standard != nil {
                    map["Standard"] = self.standard!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Amount") {
                    self.amount = dict["Amount"] as! Int32
                }
                if dict.keys.contains("Standard") {
                    self.standard = dict["Standard"] as! String
                }
            }
        }
        public var createTime: Int64?

        public var createUser: String?

        public var defaultVpcId: String?

        public var defaultVswicthId: String?

        public var id: String?

        public var name: String?

        public var orderInstanceId: String?

        public var paymentType: String?

        public var remark: String?

        public var resourceGroupType: String?

        public var spec: ListResourceGroupsResponseBody.ResourceGroupList.Spec?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.spec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.createUser != nil {
                map["CreateUser"] = self.createUser!
            }
            if self.defaultVpcId != nil {
                map["DefaultVpcId"] = self.defaultVpcId!
            }
            if self.defaultVswicthId != nil {
                map["DefaultVswicthId"] = self.defaultVswicthId!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.orderInstanceId != nil {
                map["OrderInstanceId"] = self.orderInstanceId!
            }
            if self.paymentType != nil {
                map["PaymentType"] = self.paymentType!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.resourceGroupType != nil {
                map["ResourceGroupType"] = self.resourceGroupType!
            }
            if self.spec != nil {
                map["Spec"] = self.spec?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreateUser") {
                self.createUser = dict["CreateUser"] as! String
            }
            if dict.keys.contains("DefaultVpcId") {
                self.defaultVpcId = dict["DefaultVpcId"] as! String
            }
            if dict.keys.contains("DefaultVswicthId") {
                self.defaultVswicthId = dict["DefaultVswicthId"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrderInstanceId") {
                self.orderInstanceId = dict["OrderInstanceId"] as! String
            }
            if dict.keys.contains("PaymentType") {
                self.paymentType = dict["PaymentType"] as! String
            }
            if dict.keys.contains("Remark") {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("ResourceGroupType") {
                self.resourceGroupType = dict["ResourceGroupType"] as! String
            }
            if dict.keys.contains("Spec") {
                var model = ListResourceGroupsResponseBody.ResourceGroupList.Spec()
                model.fromMap(dict["Spec"] as! [String: Any])
                self.spec = model
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var requestId: String?

    public var resourceGroupList: [ListResourceGroupsResponseBody.ResourceGroupList]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupList != nil {
            var tmp : [Any] = []
            for k in self.resourceGroupList! {
                tmp.append(k.toMap())
            }
            map["ResourceGroupList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupList") {
            var tmp : [ListResourceGroupsResponseBody.ResourceGroupList] = []
            for v in dict["ResourceGroupList"] as! [Any] {
                var model = ListResourceGroupsResponseBody.ResourceGroupList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceGroupList = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListResourceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListResourceGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListResourcesRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListResourcesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Resources : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Command") {
                            self.command = dict["Command"] as! String
                        }
                    }
                }
                public var id: String?

                public var path: String?

                public var runtime: ListResourcesResponseBody.PagingInfo.Resources.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Runtime") {
                        var model = ListResourcesResponseBody.PagingInfo.Resources.Script.Runtime()
                        model.fromMap(dict["Runtime"] as! [String: Any])
                        self.runtime = model
                    }
                }
            }
            public var createTime: Int64?

            public var dataSource: ListResourcesResponseBody.PagingInfo.Resources.DataSource?

            public var id: String?

            public var modifyTime: Int64?

            public var name: String?

            public var owner: String?

            public var projectId: String?

            public var script: ListResourcesResponseBody.PagingInfo.Resources.Script?

            public var sourcePath: String?

            public var sourceType: String?

            public var targetPath: String?

            public var targetType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.script?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.sourcePath != nil {
                    map["SourcePath"] = self.sourcePath!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.targetPath != nil {
                    map["TargetPath"] = self.targetPath!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DataSource") {
                    var model = ListResourcesResponseBody.PagingInfo.Resources.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Script") {
                    var model = ListResourcesResponseBody.PagingInfo.Resources.Script()
                    model.fromMap(dict["Script"] as! [String: Any])
                    self.script = model
                }
                if dict.keys.contains("SourcePath") {
                    self.sourcePath = dict["SourcePath"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("TargetPath") {
                    self.targetPath = dict["TargetPath"] as! String
                }
                if dict.keys.contains("TargetType") {
                    self.targetType = dict["TargetType"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var resources: [ListResourcesResponseBody.PagingInfo.Resources]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.resources != nil {
                var tmp : [Any] = []
                for k in self.resources! {
                    tmp.append(k.toMap())
                }
                map["Resources"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Resources") {
                var tmp : [ListResourcesResponseBody.PagingInfo.Resources] = []
                for v in dict["Resources"] as! [Any] {
                    var model = ListResourcesResponseBody.PagingInfo.Resources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resources = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListResourcesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListResourcesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRoutesRequest : Tea.TeaModel {
    public var networkId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! Int64
        }
    }
}

public class ListRoutesResponseBody : Tea.TeaModel {
    public class RouteList : Tea.TeaModel {
        public var createTime: Int64?

        public var destinationCidr: String?

        public var id: Int64?

        public var networkId: Int64?

        public var resourceGroupId: String?

        public var resourceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.destinationCidr != nil {
                map["DestinationCidr"] = self.destinationCidr!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("DestinationCidr") {
                self.destinationCidr = dict["DestinationCidr"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! Int64
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var routeList: [ListRoutesResponseBody.RouteList]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeList != nil {
            var tmp : [Any] = []
            for k in self.routeList! {
                tmp.append(k.toMap())
            }
            map["RouteList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteList") {
            var tmp : [ListRoutesResponseBody.RouteList] = []
            for v in dict["RouteList"] as! [Any] {
                var model = ListRoutesResponseBody.RouteList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routeList = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListRoutesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRoutesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRoutesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskInstanceOperationLogsRequest : Tea.TeaModel {
    public var date: Int64?

    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["Date"] = self.date!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Date") {
            self.date = dict["Date"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListTaskInstanceOperationLogsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class OperationLogs : Tea.TeaModel {
            public var createTime: Int64?

            public var operationContent: String?

            public var operationSeq: Int64?

            public var taskInstanceId: Int64?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.operationContent != nil {
                    map["OperationContent"] = self.operationContent!
                }
                if self.operationSeq != nil {
                    map["OperationSeq"] = self.operationSeq!
                }
                if self.taskInstanceId != nil {
                    map["TaskInstanceId"] = self.taskInstanceId!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("OperationContent") {
                    self.operationContent = dict["OperationContent"] as! String
                }
                if dict.keys.contains("OperationSeq") {
                    self.operationSeq = dict["OperationSeq"] as! Int64
                }
                if dict.keys.contains("TaskInstanceId") {
                    self.taskInstanceId = dict["TaskInstanceId"] as! Int64
                }
                if dict.keys.contains("User") {
                    self.user = dict["User"] as! String
                }
            }
        }
        public var operationLogs: [ListTaskInstanceOperationLogsResponseBody.PagingInfo.OperationLogs]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationLogs != nil {
                var tmp : [Any] = []
                for k in self.operationLogs! {
                    tmp.append(k.toMap())
                }
                map["OperationLogs"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OperationLogs") {
                var tmp : [ListTaskInstanceOperationLogsResponseBody.PagingInfo.OperationLogs] = []
                for v in dict["OperationLogs"] as! [Any] {
                    var model = ListTaskInstanceOperationLogsResponseBody.PagingInfo.OperationLogs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.operationLogs = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListTaskInstanceOperationLogsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListTaskInstanceOperationLogsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTaskInstanceOperationLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskInstanceOperationLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskInstanceOperationLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskInstancesRequest : Tea.TeaModel {
    public var bizdate: Int64?

    public var id: Int64?

    public var ids: [Int64]?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public var projectId: Int64?

    public var runtimeResource: String?

    public var sortBy: String?

    public var taskId: Int64?

    public var taskIds: [Int64]?

    public var taskName: String?

    public var taskType: String?

    public var triggerRecurrence: String?

    public var triggerType: String?

    public var workflowId: Int64?

    public var workflowInstanceId: Int64?

    public var workflowInstanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.triggerRecurrence != nil {
            map["TriggerRecurrence"] = self.triggerRecurrence!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        if self.workflowInstanceType != nil {
            map["WorkflowInstanceType"] = self.workflowInstanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizdate") {
            self.bizdate = dict["Bizdate"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeResource") {
            self.runtimeResource = dict["RuntimeResource"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TaskIds") {
            self.taskIds = dict["TaskIds"] as! [Int64]
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("TriggerRecurrence") {
            self.triggerRecurrence = dict["TriggerRecurrence"] as! String
        }
        if dict.keys.contains("TriggerType") {
            self.triggerType = dict["TriggerType"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! Int64
        }
        if dict.keys.contains("WorkflowInstanceId") {
            self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
        }
        if dict.keys.contains("WorkflowInstanceType") {
            self.workflowInstanceType = dict["WorkflowInstanceType"] as! String
        }
    }
}

public class ListTaskInstancesShrinkRequest : Tea.TeaModel {
    public var bizdate: Int64?

    public var id: Int64?

    public var idsShrink: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public var projectId: Int64?

    public var runtimeResource: String?

    public var sortBy: String?

    public var taskId: Int64?

    public var taskIdsShrink: String?

    public var taskName: String?

    public var taskType: String?

    public var triggerRecurrence: String?

    public var triggerType: String?

    public var workflowId: Int64?

    public var workflowInstanceId: Int64?

    public var workflowInstanceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizdate != nil {
            map["Bizdate"] = self.bizdate!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskIdsShrink != nil {
            map["TaskIds"] = self.taskIdsShrink!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.triggerRecurrence != nil {
            map["TriggerRecurrence"] = self.triggerRecurrence!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        if self.workflowInstanceId != nil {
            map["WorkflowInstanceId"] = self.workflowInstanceId!
        }
        if self.workflowInstanceType != nil {
            map["WorkflowInstanceType"] = self.workflowInstanceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizdate") {
            self.bizdate = dict["Bizdate"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeResource") {
            self.runtimeResource = dict["RuntimeResource"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TaskIds") {
            self.taskIdsShrink = dict["TaskIds"] as! String
        }
        if dict.keys.contains("TaskName") {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("TriggerRecurrence") {
            self.triggerRecurrence = dict["TriggerRecurrence"] as! String
        }
        if dict.keys.contains("TriggerType") {
            self.triggerType = dict["TriggerType"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! Int64
        }
        if dict.keys.contains("WorkflowInstanceId") {
            self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
        }
        if dict.keys.contains("WorkflowInstanceType") {
            self.workflowInstanceType = dict["WorkflowInstanceType"] as! String
        }
    }
}

public class ListTaskInstancesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class TaskInstances : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class Runtime : Tea.TeaModel {
                public var gateway: String?

                public var processId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gateway != nil {
                        map["Gateway"] = self.gateway!
                    }
                    if self.processId != nil {
                        map["ProcessId"] = self.processId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Gateway") {
                        self.gateway = dict["Gateway"] as! String
                    }
                    if dict.keys.contains("ProcessId") {
                        self.processId = dict["ProcessId"] as! String
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cu") {
                        self.cu = dict["Cu"] as! String
                    }
                    if dict.keys.contains("Image") {
                        self.image = dict["Image"] as! String
                    }
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                }
            }
            public var baselineId: Int64?

            public var bizdate: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource?

            public var description_: String?

            public var finishedTime: Int64?

            public var id: Int64?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var owner: String?

            public var periodNumber: Int32?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunMode: String?

            public var runNumber: Int32?

            public var runtime: ListTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime?

            public var runtimeResource: ListTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource?

            public var startedTime: Int64?

            public var status: String?

            public var taskId: Int64?

            public var taskName: String?

            public var taskType: String?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var triggerRecurrence: String?

            public var triggerTime: Int64?

            public var triggerType: String?

            public var workflowId: Int64?

            public var workflowInstanceId: Int64?

            public var workflowInstanceType: String?

            public var workflowName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtime?.validate()
                try self.runtimeResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.periodNumber != nil {
                    map["PeriodNumber"] = self.periodNumber!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.runNumber != nil {
                    map["RunNumber"] = self.runNumber!
                }
                if self.runtime != nil {
                    map["Runtime"] = self.runtime?.toMap()
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.startedTime != nil {
                    map["StartedTime"] = self.startedTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.triggerRecurrence != nil {
                    map["TriggerRecurrence"] = self.triggerRecurrence!
                }
                if self.triggerTime != nil {
                    map["TriggerTime"] = self.triggerTime!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                if self.workflowInstanceId != nil {
                    map["WorkflowInstanceId"] = self.workflowInstanceId!
                }
                if self.workflowInstanceType != nil {
                    map["WorkflowInstanceType"] = self.workflowInstanceType!
                }
                if self.workflowName != nil {
                    map["WorkflowName"] = self.workflowName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("Bizdate") {
                    self.bizdate = dict["Bizdate"] as! Int64
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("DataSource") {
                    var model = ListTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FinishedTime") {
                    self.finishedTime = dict["FinishedTime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("ModifyUser") {
                    self.modifyUser = dict["ModifyUser"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("PeriodNumber") {
                    self.periodNumber = dict["PeriodNumber"] as! Int32
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectEnv") {
                    self.projectEnv = dict["ProjectEnv"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RerunMode") {
                    self.rerunMode = dict["RerunMode"] as! String
                }
                if dict.keys.contains("RunNumber") {
                    self.runNumber = dict["RunNumber"] as! Int32
                }
                if dict.keys.contains("Runtime") {
                    var model = ListTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime()
                    model.fromMap(dict["Runtime"] as! [String: Any])
                    self.runtime = model
                }
                if dict.keys.contains("RuntimeResource") {
                    var model = ListTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource()
                    model.fromMap(dict["RuntimeResource"] as! [String: Any])
                    self.runtimeResource = model
                }
                if dict.keys.contains("StartedTime") {
                    self.startedTime = dict["StartedTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! Int64
                }
                if dict.keys.contains("TaskName") {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("TriggerRecurrence") {
                    self.triggerRecurrence = dict["TriggerRecurrence"] as! String
                }
                if dict.keys.contains("TriggerTime") {
                    self.triggerTime = dict["TriggerTime"] as! Int64
                }
                if dict.keys.contains("TriggerType") {
                    self.triggerType = dict["TriggerType"] as! String
                }
                if dict.keys.contains("WorkflowId") {
                    self.workflowId = dict["WorkflowId"] as! Int64
                }
                if dict.keys.contains("WorkflowInstanceId") {
                    self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
                }
                if dict.keys.contains("WorkflowInstanceType") {
                    self.workflowInstanceType = dict["WorkflowInstanceType"] as! String
                }
                if dict.keys.contains("WorkflowName") {
                    self.workflowName = dict["WorkflowName"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var taskInstances: [ListTaskInstancesResponseBody.PagingInfo.TaskInstances]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.taskInstances != nil {
                var tmp : [Any] = []
                for k in self.taskInstances! {
                    tmp.append(k.toMap())
                }
                map["TaskInstances"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TaskInstances") {
                var tmp : [ListTaskInstancesResponseBody.PagingInfo.TaskInstances] = []
                for v in dict["TaskInstances"] as! [Any] {
                    var model = ListTaskInstancesResponseBody.PagingInfo.TaskInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskInstances = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListTaskInstancesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListTaskInstancesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTaskOperationLogsRequest : Tea.TeaModel {
    public var date: Int64?

    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.date != nil {
            map["Date"] = self.date!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Date") {
            self.date = dict["Date"] as! Int64
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class ListTaskOperationLogsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class OperationLogs : Tea.TeaModel {
            public var createTime: Int64?

            public var operationContent: String?

            public var operationSeq: Int64?

            public var taskId: Int64?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.operationContent != nil {
                    map["OperationContent"] = self.operationContent!
                }
                if self.operationSeq != nil {
                    map["OperationSeq"] = self.operationSeq!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("OperationContent") {
                    self.operationContent = dict["OperationContent"] as! String
                }
                if dict.keys.contains("OperationSeq") {
                    self.operationSeq = dict["OperationSeq"] as! Int64
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! Int64
                }
                if dict.keys.contains("User") {
                    self.user = dict["User"] as! String
                }
            }
        }
        public var operationLogs: [ListTaskOperationLogsResponseBody.PagingInfo.OperationLogs]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationLogs != nil {
                var tmp : [Any] = []
                for k in self.operationLogs! {
                    tmp.append(k.toMap())
                }
                map["OperationLogs"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OperationLogs") {
                var tmp : [ListTaskOperationLogsResponseBody.PagingInfo.OperationLogs] = []
                for v in dict["OperationLogs"] as! [Any] {
                    var model = ListTaskOperationLogsResponseBody.PagingInfo.OperationLogs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.operationLogs = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListTaskOperationLogsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListTaskOperationLogsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTaskOperationLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTaskOperationLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTaskOperationLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTasksRequest : Tea.TeaModel {
    public var name: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public var projectId: Int64?

    public var runtimeResource: String?

    public var sortBy: String?

    public var taskType: String?

    public var triggerRecurrence: String?

    public var triggerType: String?

    public var workflowId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeResource != nil {
            map["RuntimeResource"] = self.runtimeResource!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.triggerRecurrence != nil {
            map["TriggerRecurrence"] = self.triggerRecurrence!
        }
        if self.triggerType != nil {
            map["TriggerType"] = self.triggerType!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeResource") {
            self.runtimeResource = dict["RuntimeResource"] as! String
        }
        if dict.keys.contains("SortBy") {
            self.sortBy = dict["SortBy"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("TriggerRecurrence") {
            self.triggerRecurrence = dict["TriggerRecurrence"] as! String
        }
        if dict.keys.contains("TriggerType") {
            self.triggerType = dict["TriggerType"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! Int64
        }
    }
}

public class ListTasksResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Tasks : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cu") {
                        self.cu = dict["Cu"] as! String
                    }
                    if dict.keys.contains("Image") {
                        self.image = dict["Image"] as! String
                    }
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var recurrence: String?

                public var startTime: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.recurrence != nil {
                        map["Recurrence"] = self.recurrence!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cron") {
                        self.cron = dict["Cron"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("Recurrence") {
                        self.recurrence = dict["Recurrence"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var baselineId: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListTasksResponseBody.PagingInfo.Tasks.DataSource?

            public var description_: String?

            public var id: Int64?

            public var instanceMode: String?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var name: String?

            public var owner: String?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunInterval: Int32?

            public var rerunMode: String?

            public var rerunTimes: Int32?

            public var runtimeResource: ListTasksResponseBody.PagingInfo.Tasks.RuntimeResource?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var trigger: ListTasksResponseBody.PagingInfo.Tasks.Trigger?

            public var type: String?

            public var workflowId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtimeResource?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceMode != nil {
                    map["InstanceMode"] = self.instanceMode!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunInterval != nil {
                    map["RerunInterval"] = self.rerunInterval!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.rerunTimes != nil {
                    map["RerunTimes"] = self.rerunTimes!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("DataSource") {
                    var model = ListTasksResponseBody.PagingInfo.Tasks.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstanceMode") {
                    self.instanceMode = dict["InstanceMode"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("ModifyUser") {
                    self.modifyUser = dict["ModifyUser"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectEnv") {
                    self.projectEnv = dict["ProjectEnv"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RerunInterval") {
                    self.rerunInterval = dict["RerunInterval"] as! Int32
                }
                if dict.keys.contains("RerunMode") {
                    self.rerunMode = dict["RerunMode"] as! String
                }
                if dict.keys.contains("RerunTimes") {
                    self.rerunTimes = dict["RerunTimes"] as! Int32
                }
                if dict.keys.contains("RuntimeResource") {
                    var model = ListTasksResponseBody.PagingInfo.Tasks.RuntimeResource()
                    model.fromMap(dict["RuntimeResource"] as! [String: Any])
                    self.runtimeResource = model
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("Trigger") {
                    var model = ListTasksResponseBody.PagingInfo.Tasks.Trigger()
                    model.fromMap(dict["Trigger"] as! [String: Any])
                    self.trigger = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkflowId") {
                    self.workflowId = dict["WorkflowId"] as! Int64
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tasks: [ListTasksResponseBody.PagingInfo.Tasks]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tasks != nil {
                var tmp : [Any] = []
                for k in self.tasks! {
                    tmp.append(k.toMap())
                }
                map["Tasks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Tasks") {
                var tmp : [ListTasksResponseBody.PagingInfo.Tasks] = []
                for v in dict["Tasks"] as! [Any] {
                    var model = ListTasksResponseBody.PagingInfo.Tasks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tasks = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListTasksResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListTasksResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUpstreamTaskInstancesRequest : Tea.TeaModel {
    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListUpstreamTaskInstancesResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class TaskInstances : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class Runtime : Tea.TeaModel {
                public var gateway: String?

                public var processId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gateway != nil {
                        map["Gateway"] = self.gateway!
                    }
                    if self.processId != nil {
                        map["ProcessId"] = self.processId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Gateway") {
                        self.gateway = dict["Gateway"] as! String
                    }
                    if dict.keys.contains("ProcessId") {
                        self.processId = dict["ProcessId"] as! String
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cu") {
                        self.cu = dict["Cu"] as! String
                    }
                    if dict.keys.contains("Image") {
                        self.image = dict["Image"] as! String
                    }
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                }
            }
            public var baselineId: Int64?

            public var bizdate: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource?

            public var description_: String?

            public var finishedTime: Int64?

            public var id: Int64?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var owner: String?

            public var periodNumber: Int32?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunMode: String?

            public var runNumber: Int32?

            public var runtime: ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime?

            public var runtimeResource: ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource?

            public var startedTime: Int64?

            public var status: String?

            public var taskId: Int64?

            public var taskName: String?

            public var taskType: String?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var triggerRecurrence: String?

            public var triggerTime: Int64?

            public var triggerType: String?

            public var workflowId: Int64?

            public var workflowInstanceId: Int64?

            public var workflowInstanceType: String?

            public var workflowName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtime?.validate()
                try self.runtimeResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.bizdate != nil {
                    map["Bizdate"] = self.bizdate!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.periodNumber != nil {
                    map["PeriodNumber"] = self.periodNumber!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.runNumber != nil {
                    map["RunNumber"] = self.runNumber!
                }
                if self.runtime != nil {
                    map["Runtime"] = self.runtime?.toMap()
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.startedTime != nil {
                    map["StartedTime"] = self.startedTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.triggerRecurrence != nil {
                    map["TriggerRecurrence"] = self.triggerRecurrence!
                }
                if self.triggerTime != nil {
                    map["TriggerTime"] = self.triggerTime!
                }
                if self.triggerType != nil {
                    map["TriggerType"] = self.triggerType!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                if self.workflowInstanceId != nil {
                    map["WorkflowInstanceId"] = self.workflowInstanceId!
                }
                if self.workflowInstanceType != nil {
                    map["WorkflowInstanceType"] = self.workflowInstanceType!
                }
                if self.workflowName != nil {
                    map["WorkflowName"] = self.workflowName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("Bizdate") {
                    self.bizdate = dict["Bizdate"] as! Int64
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("DataSource") {
                    var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FinishedTime") {
                    self.finishedTime = dict["FinishedTime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("ModifyUser") {
                    self.modifyUser = dict["ModifyUser"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("PeriodNumber") {
                    self.periodNumber = dict["PeriodNumber"] as! Int32
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectEnv") {
                    self.projectEnv = dict["ProjectEnv"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RerunMode") {
                    self.rerunMode = dict["RerunMode"] as! String
                }
                if dict.keys.contains("RunNumber") {
                    self.runNumber = dict["RunNumber"] as! Int32
                }
                if dict.keys.contains("Runtime") {
                    var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.Runtime()
                    model.fromMap(dict["Runtime"] as! [String: Any])
                    self.runtime = model
                }
                if dict.keys.contains("RuntimeResource") {
                    var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances.RuntimeResource()
                    model.fromMap(dict["RuntimeResource"] as! [String: Any])
                    self.runtimeResource = model
                }
                if dict.keys.contains("StartedTime") {
                    self.startedTime = dict["StartedTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! Int64
                }
                if dict.keys.contains("TaskName") {
                    self.taskName = dict["TaskName"] as! String
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("TriggerRecurrence") {
                    self.triggerRecurrence = dict["TriggerRecurrence"] as! String
                }
                if dict.keys.contains("TriggerTime") {
                    self.triggerTime = dict["TriggerTime"] as! Int64
                }
                if dict.keys.contains("TriggerType") {
                    self.triggerType = dict["TriggerType"] as! String
                }
                if dict.keys.contains("WorkflowId") {
                    self.workflowId = dict["WorkflowId"] as! Int64
                }
                if dict.keys.contains("WorkflowInstanceId") {
                    self.workflowInstanceId = dict["WorkflowInstanceId"] as! Int64
                }
                if dict.keys.contains("WorkflowInstanceType") {
                    self.workflowInstanceType = dict["WorkflowInstanceType"] as! String
                }
                if dict.keys.contains("WorkflowName") {
                    self.workflowName = dict["WorkflowName"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var taskInstances: [ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.taskInstances != nil {
                var tmp : [Any] = []
                for k in self.taskInstances! {
                    tmp.append(k.toMap())
                }
                map["TaskInstances"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TaskInstances") {
                var tmp : [ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances] = []
                for v in dict["TaskInstances"] as! [Any] {
                    var model = ListUpstreamTaskInstancesResponseBody.PagingInfo.TaskInstances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskInstances = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListUpstreamTaskInstancesResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListUpstreamTaskInstancesResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUpstreamTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUpstreamTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUpstreamTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUpstreamTasksRequest : Tea.TeaModel {
    public var id: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectEnv: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectEnv != nil {
            map["ProjectEnv"] = self.projectEnv!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectEnv") {
            self.projectEnv = dict["ProjectEnv"] as! String
        }
    }
}

public class ListUpstreamTasksResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class Tasks : Tea.TeaModel {
            public class DataSource : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class RuntimeResource : Tea.TeaModel {
                public var cu: String?

                public var image: String?

                public var resourceGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cu != nil {
                        map["Cu"] = self.cu!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cu") {
                        self.cu = dict["Cu"] as! String
                    }
                    if dict.keys.contains("Image") {
                        self.image = dict["Image"] as! String
                    }
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                }
            }
            public class Trigger : Tea.TeaModel {
                public var cron: String?

                public var endTime: String?

                public var recurrence: String?

                public var startTime: String?

                public var timezone: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cron != nil {
                        map["Cron"] = self.cron!
                    }
                    if self.endTime != nil {
                        map["EndTime"] = self.endTime!
                    }
                    if self.recurrence != nil {
                        map["Recurrence"] = self.recurrence!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.timezone != nil {
                        map["Timezone"] = self.timezone!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cron") {
                        self.cron = dict["Cron"] as! String
                    }
                    if dict.keys.contains("EndTime") {
                        self.endTime = dict["EndTime"] as! String
                    }
                    if dict.keys.contains("Recurrence") {
                        self.recurrence = dict["Recurrence"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("Timezone") {
                        self.timezone = dict["Timezone"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var baselineId: Int64?

            public var createTime: Int64?

            public var createUser: String?

            public var dataSource: ListUpstreamTasksResponseBody.PagingInfo.Tasks.DataSource?

            public var description_: String?

            public var id: Int64?

            public var instanceMode: String?

            public var modifyTime: Int64?

            public var modifyUser: String?

            public var name: String?

            public var owner: String?

            public var priority: Int32?

            public var projectEnv: String?

            public var projectId: Int64?

            public var rerunInterval: Int32?

            public var rerunMode: String?

            public var rerunTimes: Int32?

            public var runtimeResource: ListUpstreamTasksResponseBody.PagingInfo.Tasks.RuntimeResource?

            public var stepType: String?

            public var tenantId: Int64?

            public var timeout: Int32?

            public var trigger: ListUpstreamTasksResponseBody.PagingInfo.Tasks.Trigger?

            public var type: String?

            public var workflowId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dataSource?.validate()
                try self.runtimeResource?.validate()
                try self.trigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineId != nil {
                    map["BaselineId"] = self.baselineId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUser != nil {
                    map["CreateUser"] = self.createUser!
                }
                if self.dataSource != nil {
                    map["DataSource"] = self.dataSource?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceMode != nil {
                    map["InstanceMode"] = self.instanceMode!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.modifyUser != nil {
                    map["ModifyUser"] = self.modifyUser!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.projectEnv != nil {
                    map["ProjectEnv"] = self.projectEnv!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.rerunInterval != nil {
                    map["RerunInterval"] = self.rerunInterval!
                }
                if self.rerunMode != nil {
                    map["RerunMode"] = self.rerunMode!
                }
                if self.rerunTimes != nil {
                    map["RerunTimes"] = self.rerunTimes!
                }
                if self.runtimeResource != nil {
                    map["RuntimeResource"] = self.runtimeResource?.toMap()
                }
                if self.stepType != nil {
                    map["StepType"] = self.stepType!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.trigger != nil {
                    map["Trigger"] = self.trigger?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.workflowId != nil {
                    map["WorkflowId"] = self.workflowId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineId") {
                    self.baselineId = dict["BaselineId"] as! Int64
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreateUser") {
                    self.createUser = dict["CreateUser"] as! String
                }
                if dict.keys.contains("DataSource") {
                    var model = ListUpstreamTasksResponseBody.PagingInfo.Tasks.DataSource()
                    model.fromMap(dict["DataSource"] as! [String: Any])
                    self.dataSource = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstanceMode") {
                    self.instanceMode = dict["InstanceMode"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("ModifyUser") {
                    self.modifyUser = dict["ModifyUser"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("ProjectEnv") {
                    self.projectEnv = dict["ProjectEnv"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! Int64
                }
                if dict.keys.contains("RerunInterval") {
                    self.rerunInterval = dict["RerunInterval"] as! Int32
                }
                if dict.keys.contains("RerunMode") {
                    self.rerunMode = dict["RerunMode"] as! String
                }
                if dict.keys.contains("RerunTimes") {
                    self.rerunTimes = dict["RerunTimes"] as! Int32
                }
                if dict.keys.contains("RuntimeResource") {
                    var model = ListUpstreamTasksResponseBody.PagingInfo.Tasks.RuntimeResource()
                    model.fromMap(dict["RuntimeResource"] as! [String: Any])
                    self.runtimeResource = model
                }
                if dict.keys.contains("StepType") {
                    self.stepType = dict["StepType"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! Int64
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int32
                }
                if dict.keys.contains("Trigger") {
                    var model = ListUpstreamTasksResponseBody.PagingInfo.Tasks.Trigger()
                    model.fromMap(dict["Trigger"] as! [String: Any])
                    self.trigger = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("WorkflowId") {
                    self.workflowId = dict["WorkflowId"] as! Int64
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var tasks: [ListUpstreamTasksResponseBody.PagingInfo.Tasks]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tasks != nil {
                var tmp : [Any] = []
                for k in self.tasks! {
                    tmp.append(k.toMap())
                }
                map["Tasks"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Tasks") {
                var tmp : [ListUpstreamTasksResponseBody.PagingInfo.Tasks] = []
                for v in dict["Tasks"] as! [Any] {
                    var model = ListUpstreamTasksResponseBody.PagingInfo.Tasks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tasks = tmp
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pagingInfo: ListUpstreamTasksResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListUpstreamTasksResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUpstreamTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUpstreamTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUpstreamTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkflowDefinitionsRequest : Tea.TeaModel {
    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListWorkflowDefinitionsResponseBody : Tea.TeaModel {
    public class PagingInfo : Tea.TeaModel {
        public class WorkflowDefinitions : Tea.TeaModel {
            public class Script : Tea.TeaModel {
                public class Runtime : Tea.TeaModel {
                    public var command: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Command") {
                            self.command = dict["Command"] as! String
                        }
                    }
                }
                public var id: String?

                public var path: String?

                public var runtime: ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions.Script.Runtime?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.runtime?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.runtime != nil {
                        map["Runtime"] = self.runtime?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("Path") {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Runtime") {
                        var model = ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions.Script.Runtime()
                        model.fromMap(dict["Runtime"] as! [String: Any])
                        self.runtime = model
                    }
                }
            }
            public var createTime: Int64?

            public var description_: String?

            public var id: String?

            public var modifyTime: Int64?

            public var name: String?

            public var owner: String?

            public var projectId: String?

            public var script: ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions.Script?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.script?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.modifyTime != nil {
                    map["ModifyTime"] = self.modifyTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.script != nil {
                    map["Script"] = self.script?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ModifyTime") {
                    self.modifyTime = dict["ModifyTime"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Script") {
                    var model = ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions.Script()
                    model.fromMap(dict["Script"] as! [String: Any])
                    self.script = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public var workflowDefinitions: [ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.workflowDefinitions != nil {
                var tmp : [Any] = []
                for k in self.workflowDefinitions! {
                    tmp.append(k.toMap())
                }
                map["WorkflowDefinitions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("WorkflowDefinitions") {
                var tmp : [ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions] = []
                for v in dict["WorkflowDefinitions"] as! [Any] {
                    var model = ListWorkflowDefinitionsResponseBody.PagingInfo.WorkflowDefinitions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.workflowDefinitions = tmp
            }
        }
    }
    public var pagingInfo: ListWorkflowDefinitionsResponseBody.PagingInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagingInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pagingInfo != nil {
            map["PagingInfo"] = self.pagingInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PagingInfo") {
            var model = ListWorkflowDefinitionsResponseBody.PagingInfo()
            model.fromMap(dict["PagingInfo"] as! [String: Any])
            self.pagingInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListWorkflowDefinitionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkflowDefinitionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkflowDefinitionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveFunctionRequest : Tea.TeaModel {
    public var id: String?

    public var path: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class MoveFunctionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class MoveFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveFunctionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveNodeRequest : Tea.TeaModel {
    public var id: String?

    public var path: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class MoveNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class MoveNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveResourceRequest : Tea.TeaModel {
    public var id: String?

    public var path: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class MoveResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class MoveResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: String?

    public var path: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class MoveWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class MoveWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveWorkflowDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveTaskInstanceDependenciesRequest : Tea.TeaModel {
    public var comment: String?

    public var id: Int64?

    public var upstreamTaskInstanceIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.upstreamTaskInstanceIds != nil {
            map["UpstreamTaskInstanceIds"] = self.upstreamTaskInstanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("UpstreamTaskInstanceIds") {
            self.upstreamTaskInstanceIds = dict["UpstreamTaskInstanceIds"] as! [Int64]
        }
    }
}

public class RemoveTaskInstanceDependenciesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var id: Int64?

    public var upstreamTaskInstanceIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.upstreamTaskInstanceIdsShrink != nil {
            map["UpstreamTaskInstanceIds"] = self.upstreamTaskInstanceIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("UpstreamTaskInstanceIds") {
            self.upstreamTaskInstanceIdsShrink = dict["UpstreamTaskInstanceIds"] as! String
        }
    }
}

public class RemoveTaskInstanceDependenciesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveTaskInstanceDependenciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTaskInstanceDependenciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveTaskInstanceDependenciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenameFunctionRequest : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class RenameFunctionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class RenameFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenameFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenameFunctionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenameNodeRequest : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class RenameNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RenameNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenameNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenameNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenameResourceRequest : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class RenameResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RenameResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenameResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenameResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenameWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class RenameWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RenameWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenameWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenameWorkflowDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RerunTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
    }
}

public class RerunTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
    }
}

public class RerunTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessInfo") {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in dict["SuccessInfo"] as! [String: Any] {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class RerunTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RerunTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RerunTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
    }
}

public class ResumeTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
    }
}

public class ResumeTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessInfo") {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in dict["SuccessInfo"] as! [String: Any] {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class ResumeTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeMemberProjectRolesRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodes: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodes != nil {
            map["RoleCodes"] = self.roleCodes!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCodes") {
            self.roleCodes = dict["RoleCodes"] as! [String]
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RevokeMemberProjectRolesShrinkRequest : Tea.TeaModel {
    public var projectId: Int64?

    public var roleCodesShrink: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.roleCodesShrink != nil {
            map["RoleCodes"] = self.roleCodesShrink!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RoleCodes") {
            self.roleCodesShrink = dict["RoleCodes"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RevokeMemberProjectRolesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeMemberProjectRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeMemberProjectRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeMemberProjectRolesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetSuccessTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
    }
}

public class SetSuccessTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
    }
}

public class SetSuccessTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessInfo") {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in dict["SuccessInfo"] as! [String: Any] {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class SetSuccessTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetSuccessTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetSuccessTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartDIJobRequest : Tea.TeaModel {
    public class RealtimeStartSettings : Tea.TeaModel {
        public class FailoverSettings : Tea.TeaModel {
            public var interval: Int64?

            public var upperLimit: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.upperLimit != nil {
                    map["UpperLimit"] = self.upperLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int64
                }
                if dict.keys.contains("UpperLimit") {
                    self.upperLimit = dict["UpperLimit"] as! Int64
                }
            }
        }
        public var failoverSettings: StartDIJobRequest.RealtimeStartSettings.FailoverSettings?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.failoverSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failoverSettings != nil {
                map["FailoverSettings"] = self.failoverSettings?.toMap()
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailoverSettings") {
                var model = StartDIJobRequest.RealtimeStartSettings.FailoverSettings()
                model.fromMap(dict["FailoverSettings"] as! [String: Any])
                self.failoverSettings = model
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var DIJobId: Int64?

    public var forceToRerun: Bool?

    public var realtimeStartSettings: StartDIJobRequest.RealtimeStartSettings?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realtimeStartSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.forceToRerun != nil {
            map["ForceToRerun"] = self.forceToRerun!
        }
        if self.realtimeStartSettings != nil {
            map["RealtimeStartSettings"] = self.realtimeStartSettings?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("ForceToRerun") {
            self.forceToRerun = dict["ForceToRerun"] as! Bool
        }
        if dict.keys.contains("RealtimeStartSettings") {
            var model = StartDIJobRequest.RealtimeStartSettings()
            model.fromMap(dict["RealtimeStartSettings"] as! [String: Any])
            self.realtimeStartSettings = model
        }
    }
}

public class StartDIJobShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var forceToRerun: Bool?

    public var realtimeStartSettingsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.forceToRerun != nil {
            map["ForceToRerun"] = self.forceToRerun!
        }
        if self.realtimeStartSettingsShrink != nil {
            map["RealtimeStartSettings"] = self.realtimeStartSettingsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("ForceToRerun") {
            self.forceToRerun = dict["ForceToRerun"] as! Bool
        }
        if dict.keys.contains("RealtimeStartSettings") {
            self.realtimeStartSettingsShrink = dict["RealtimeStartSettings"] as! String
        }
    }
}

public class StartDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StartDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopDIJobRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var instanceId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! Int64
        }
    }
}

public class StopDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StopDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
    }
}

public class StopTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
    }
}

public class StopTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessInfo") {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in dict["SuccessInfo"] as! [String: Any] {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class StopTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendTaskInstancesRequest : Tea.TeaModel {
    public var comment: String?

    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.ids = dict["Ids"] as! [Int64]
        }
    }
}

public class SuspendTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var idsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.idsShrink != nil {
            map["Ids"] = self.idsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("Ids") {
            self.idsShrink = dict["Ids"] as! String
        }
    }
}

public class SuspendTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessInfo") {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in dict["SuccessInfo"] as! [String: Any] {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class SuspendTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TriggerSchedulerTaskInstanceRequest : Tea.TeaModel {
    public var taskId: Int64?

    public var triggerTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.triggerTime != nil {
            map["TriggerTime"] = self.triggerTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TriggerTime") {
            self.triggerTime = dict["TriggerTime"] as! Int64
        }
    }
}

public class TriggerSchedulerTaskInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TriggerSchedulerTaskInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TriggerSchedulerTaskInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TriggerSchedulerTaskInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAlertRuleRequest : Tea.TeaModel {
    public class Notification : Tea.TeaModel {
        public class Receivers : Tea.TeaModel {
            public var extension_: String?

            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("ReceiverType") {
                    self.receiverType = dict["ReceiverType"] as! String
                }
                if dict.keys.contains("ReceiverValues") {
                    self.receiverValues = dict["ReceiverValues"] as! [String]
                }
            }
        }
        public var channels: [String]?

        public var intervalInMinutes: Int32?

        public var maximum: Int32?

        public var receivers: [UpdateAlertRuleRequest.Notification.Receivers]?

        public var silenceEndTime: String?

        public var silenceStartTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channels != nil {
                map["Channels"] = self.channels!
            }
            if self.intervalInMinutes != nil {
                map["IntervalInMinutes"] = self.intervalInMinutes!
            }
            if self.maximum != nil {
                map["Maximum"] = self.maximum!
            }
            if self.receivers != nil {
                var tmp : [Any] = []
                for k in self.receivers! {
                    tmp.append(k.toMap())
                }
                map["Receivers"] = tmp
            }
            if self.silenceEndTime != nil {
                map["SilenceEndTime"] = self.silenceEndTime!
            }
            if self.silenceStartTime != nil {
                map["SilenceStartTime"] = self.silenceStartTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Channels") {
                self.channels = dict["Channels"] as! [String]
            }
            if dict.keys.contains("IntervalInMinutes") {
                self.intervalInMinutes = dict["IntervalInMinutes"] as! Int32
            }
            if dict.keys.contains("Maximum") {
                self.maximum = dict["Maximum"] as! Int32
            }
            if dict.keys.contains("Receivers") {
                var tmp : [UpdateAlertRuleRequest.Notification.Receivers] = []
                for v in dict["Receivers"] as! [Any] {
                    var model = UpdateAlertRuleRequest.Notification.Receivers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.receivers = tmp
            }
            if dict.keys.contains("SilenceEndTime") {
                self.silenceEndTime = dict["SilenceEndTime"] as! String
            }
            if dict.keys.contains("SilenceStartTime") {
                self.silenceStartTime = dict["SilenceStartTime"] as! String
            }
        }
    }
    public class TriggerCondition : Tea.TeaModel {
        public class Extension_ : Tea.TeaModel {
            public class CycleUnfinished : Tea.TeaModel {
                public class CycleAndTime : Tea.TeaModel {
                    public var cycleId: Int32?

                    public var time: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleId != nil {
                            map["CycleId"] = self.cycleId!
                        }
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CycleId") {
                            self.cycleId = dict["CycleId"] as! Int32
                        }
                        if dict.keys.contains("Time") {
                            self.time = dict["Time"] as! String
                        }
                    }
                }
                public var cycleAndTime: [UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleAndTime != nil {
                        var tmp : [Any] = []
                        for k in self.cycleAndTime! {
                            tmp.append(k.toMap())
                        }
                        map["CycleAndTime"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CycleAndTime") {
                        var tmp : [UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime] = []
                        for v in dict["CycleAndTime"] as! [Any] {
                            var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished.CycleAndTime()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.cycleAndTime = tmp
                    }
                }
            }
            public class Error : Tea.TeaModel {
                public var autoRerunAlert: Bool?

                public var streamTaskIds: [Int64]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoRerunAlert != nil {
                        map["AutoRerunAlert"] = self.autoRerunAlert!
                    }
                    if self.streamTaskIds != nil {
                        map["StreamTaskIds"] = self.streamTaskIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutoRerunAlert") {
                        self.autoRerunAlert = dict["AutoRerunAlert"] as! Bool
                    }
                    if dict.keys.contains("StreamTaskIds") {
                        self.streamTaskIds = dict["StreamTaskIds"] as! [Int64]
                    }
                }
            }
            public class InstanceErrorCount : Tea.TeaModel {
                public var count: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                }
            }
            public class InstanceErrorPercentage : Tea.TeaModel {
                public var percentage: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Percentage") {
                        self.percentage = dict["Percentage"] as! Int32
                    }
                }
            }
            public class InstanceTransferFluctuate : Tea.TeaModel {
                public var percentage: Int32?

                public var trend: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.percentage != nil {
                        map["Percentage"] = self.percentage!
                    }
                    if self.trend != nil {
                        map["Trend"] = self.trend!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Percentage") {
                        self.percentage = dict["Percentage"] as! Int32
                    }
                    if dict.keys.contains("Trend") {
                        self.trend = dict["Trend"] as! String
                    }
                }
            }
            public class Timeout : Tea.TeaModel {
                public var timeoutInMinutes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.timeoutInMinutes != nil {
                        map["TimeoutInMinutes"] = self.timeoutInMinutes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TimeoutInMinutes") {
                        self.timeoutInMinutes = dict["TimeoutInMinutes"] as! Int32
                    }
                }
            }
            public class UnFinished : Tea.TeaModel {
                public var unFinishedTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.unFinishedTime != nil {
                        map["UnFinishedTime"] = self.unFinishedTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("UnFinishedTime") {
                        self.unFinishedTime = dict["UnFinishedTime"] as! String
                    }
                }
            }
            public var cycleUnfinished: UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished?

            public var error: UpdateAlertRuleRequest.TriggerCondition.Extension_.Error?

            public var instanceErrorCount: UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorCount?

            public var instanceErrorPercentage: UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorPercentage?

            public var instanceTransferFluctuate: UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceTransferFluctuate?

            public var timeout: UpdateAlertRuleRequest.TriggerCondition.Extension_.Timeout?

            public var unFinished: UpdateAlertRuleRequest.TriggerCondition.Extension_.UnFinished?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cycleUnfinished?.validate()
                try self.error?.validate()
                try self.instanceErrorCount?.validate()
                try self.instanceErrorPercentage?.validate()
                try self.instanceTransferFluctuate?.validate()
                try self.timeout?.validate()
                try self.unFinished?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cycleUnfinished != nil {
                    map["CycleUnfinished"] = self.cycleUnfinished?.toMap()
                }
                if self.error != nil {
                    map["Error"] = self.error?.toMap()
                }
                if self.instanceErrorCount != nil {
                    map["InstanceErrorCount"] = self.instanceErrorCount?.toMap()
                }
                if self.instanceErrorPercentage != nil {
                    map["InstanceErrorPercentage"] = self.instanceErrorPercentage?.toMap()
                }
                if self.instanceTransferFluctuate != nil {
                    map["InstanceTransferFluctuate"] = self.instanceTransferFluctuate?.toMap()
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout?.toMap()
                }
                if self.unFinished != nil {
                    map["UnFinished"] = self.unFinished?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CycleUnfinished") {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.CycleUnfinished()
                    model.fromMap(dict["CycleUnfinished"] as! [String: Any])
                    self.cycleUnfinished = model
                }
                if dict.keys.contains("Error") {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.Error()
                    model.fromMap(dict["Error"] as! [String: Any])
                    self.error = model
                }
                if dict.keys.contains("InstanceErrorCount") {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorCount()
                    model.fromMap(dict["InstanceErrorCount"] as! [String: Any])
                    self.instanceErrorCount = model
                }
                if dict.keys.contains("InstanceErrorPercentage") {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceErrorPercentage()
                    model.fromMap(dict["InstanceErrorPercentage"] as! [String: Any])
                    self.instanceErrorPercentage = model
                }
                if dict.keys.contains("InstanceTransferFluctuate") {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.InstanceTransferFluctuate()
                    model.fromMap(dict["InstanceTransferFluctuate"] as! [String: Any])
                    self.instanceTransferFluctuate = model
                }
                if dict.keys.contains("Timeout") {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.Timeout()
                    model.fromMap(dict["Timeout"] as! [String: Any])
                    self.timeout = model
                }
                if dict.keys.contains("UnFinished") {
                    var model = UpdateAlertRuleRequest.TriggerCondition.Extension_.UnFinished()
                    model.fromMap(dict["UnFinished"] as! [String: Any])
                    self.unFinished = model
                }
            }
        }
        public class Target : Tea.TeaModel {
            public var allowTasks: [Int64]?

            public var ids: [Int64]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowTasks != nil {
                    map["AllowTasks"] = self.allowTasks!
                }
                if self.ids != nil {
                    map["Ids"] = self.ids!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowTasks") {
                    self.allowTasks = dict["AllowTasks"] as! [Int64]
                }
                if dict.keys.contains("Ids") {
                    self.ids = dict["Ids"] as! [Int64]
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var extension_: UpdateAlertRuleRequest.TriggerCondition.Extension_?

        public var target: UpdateAlertRuleRequest.TriggerCondition.Target?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extension_?.validate()
            try self.target?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_?.toMap()
            }
            if self.target != nil {
                map["Target"] = self.target?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extension") {
                var model = UpdateAlertRuleRequest.TriggerCondition.Extension_()
                model.fromMap(dict["Extension"] as! [String: Any])
                self.extension_ = model
            }
            if dict.keys.contains("Target") {
                var model = UpdateAlertRuleRequest.TriggerCondition.Target()
                model.fromMap(dict["Target"] as! [String: Any])
                self.target = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var enabled: Bool?

    public var id: Int64?

    public var name: String?

    public var notification: UpdateAlertRuleRequest.Notification?

    public var owner: String?

    public var triggerCondition: UpdateAlertRuleRequest.TriggerCondition?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notification?.validate()
        try self.triggerCondition?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notification != nil {
            map["Notification"] = self.notification?.toMap()
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.triggerCondition != nil {
            map["TriggerCondition"] = self.triggerCondition?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notification") {
            var model = UpdateAlertRuleRequest.Notification()
            model.fromMap(dict["Notification"] as! [String: Any])
            self.notification = model
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("TriggerCondition") {
            var model = UpdateAlertRuleRequest.TriggerCondition()
            model.fromMap(dict["TriggerCondition"] as! [String: Any])
            self.triggerCondition = model
        }
    }
}

public class UpdateAlertRuleShrinkRequest : Tea.TeaModel {
    public var enabled: Bool?

    public var id: Int64?

    public var name: String?

    public var notificationShrink: String?

    public var owner: String?

    public var triggerConditionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationShrink != nil {
            map["Notification"] = self.notificationShrink!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.triggerConditionShrink != nil {
            map["TriggerCondition"] = self.triggerConditionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notification") {
            self.notificationShrink = dict["Notification"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("TriggerCondition") {
            self.triggerConditionShrink = dict["TriggerCondition"] as! String
        }
    }
}

public class UpdateAlertRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAlertRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAlertRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAlertRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDIAlarmRuleRequest : Tea.TeaModel {
    public class NotificationSettings : Tea.TeaModel {
        public class NotificationChannels : Tea.TeaModel {
            public var channels: [String]?

            public var severity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! [String]
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
            }
        }
        public class NotificationReceivers : Tea.TeaModel {
            public var receiverType: String?

            public var receiverValues: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.receiverType != nil {
                    map["ReceiverType"] = self.receiverType!
                }
                if self.receiverValues != nil {
                    map["ReceiverValues"] = self.receiverValues!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReceiverType") {
                    self.receiverType = dict["ReceiverType"] as! String
                }
                if dict.keys.contains("ReceiverValues") {
                    self.receiverValues = dict["ReceiverValues"] as! [String]
                }
            }
        }
        public var inhibitionInterval: Int64?

        public var notificationChannels: [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels]?

        public var notificationReceivers: [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inhibitionInterval != nil {
                map["InhibitionInterval"] = self.inhibitionInterval!
            }
            if self.notificationChannels != nil {
                var tmp : [Any] = []
                for k in self.notificationChannels! {
                    tmp.append(k.toMap())
                }
                map["NotificationChannels"] = tmp
            }
            if self.notificationReceivers != nil {
                var tmp : [Any] = []
                for k in self.notificationReceivers! {
                    tmp.append(k.toMap())
                }
                map["NotificationReceivers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InhibitionInterval") {
                self.inhibitionInterval = dict["InhibitionInterval"] as! Int64
            }
            if dict.keys.contains("NotificationChannels") {
                var tmp : [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels] = []
                for v in dict["NotificationChannels"] as! [Any] {
                    var model = UpdateDIAlarmRuleRequest.NotificationSettings.NotificationChannels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationChannels = tmp
            }
            if dict.keys.contains("NotificationReceivers") {
                var tmp : [UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers] = []
                for v in dict["NotificationReceivers"] as! [Any] {
                    var model = UpdateDIAlarmRuleRequest.NotificationSettings.NotificationReceivers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notificationReceivers = tmp
            }
        }
    }
    public class TriggerConditions : Tea.TeaModel {
        public var ddlReportTags: [String]?

        public var duration: Int64?

        public var severity: String?

        public var threshold: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ddlReportTags != nil {
                map["DdlReportTags"] = self.ddlReportTags!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.threshold != nil {
                map["Threshold"] = self.threshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DdlReportTags") {
                self.ddlReportTags = dict["DdlReportTags"] as! [String]
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("Severity") {
                self.severity = dict["Severity"] as! String
            }
            if dict.keys.contains("Threshold") {
                self.threshold = dict["Threshold"] as! Int64
            }
        }
    }
    public var DIAlarmRuleId: Int64?

    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var name: String?

    public var notificationSettings: UpdateDIAlarmRuleRequest.NotificationSettings?

    public var triggerConditions: [UpdateDIAlarmRuleRequest.TriggerConditions]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notificationSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationSettings != nil {
            map["NotificationSettings"] = self.notificationSettings?.toMap()
        }
        if self.triggerConditions != nil {
            var tmp : [Any] = []
            for k in self.triggerConditions! {
                tmp.append(k.toMap())
            }
            map["TriggerConditions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
        }
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotificationSettings") {
            var model = UpdateDIAlarmRuleRequest.NotificationSettings()
            model.fromMap(dict["NotificationSettings"] as! [String: Any])
            self.notificationSettings = model
        }
        if dict.keys.contains("TriggerConditions") {
            var tmp : [UpdateDIAlarmRuleRequest.TriggerConditions] = []
            for v in dict["TriggerConditions"] as! [Any] {
                var model = UpdateDIAlarmRuleRequest.TriggerConditions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.triggerConditions = tmp
        }
    }
}

public class UpdateDIAlarmRuleShrinkRequest : Tea.TeaModel {
    public var DIAlarmRuleId: Int64?

    public var DIJobId: Int64?

    public var description_: String?

    public var enabled: Bool?

    public var metricType: String?

    public var name: String?

    public var notificationSettingsShrink: String?

    public var triggerConditionsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIAlarmRuleId != nil {
            map["DIAlarmRuleId"] = self.DIAlarmRuleId!
        }
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationSettingsShrink != nil {
            map["NotificationSettings"] = self.notificationSettingsShrink!
        }
        if self.triggerConditionsShrink != nil {
            map["TriggerConditions"] = self.triggerConditionsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIAlarmRuleId") {
            self.DIAlarmRuleId = dict["DIAlarmRuleId"] as! Int64
        }
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("MetricType") {
            self.metricType = dict["MetricType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotificationSettings") {
            self.notificationSettingsShrink = dict["NotificationSettings"] as! String
        }
        if dict.keys.contains("TriggerConditions") {
            self.triggerConditionsShrink = dict["TriggerConditions"] as! String
        }
    }
}

public class UpdateDIAlarmRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDIAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDIAlarmRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDIJobRequest : Tea.TeaModel {
    public class JobSettings : Tea.TeaModel {
        public class ColumnDataTypeSettings : Tea.TeaModel {
            public var destinationDataType: String?

            public var sourceDataType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinationDataType != nil {
                    map["DestinationDataType"] = self.destinationDataType!
                }
                if self.sourceDataType != nil {
                    map["SourceDataType"] = self.sourceDataType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DestinationDataType") {
                    self.destinationDataType = dict["DestinationDataType"] as! String
                }
                if dict.keys.contains("SourceDataType") {
                    self.sourceDataType = dict["SourceDataType"] as! String
                }
            }
        }
        public class CycleScheduleSettings : Tea.TeaModel {
            public var scheduleParameters: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.scheduleParameters != nil {
                    map["ScheduleParameters"] = self.scheduleParameters!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ScheduleParameters") {
                    self.scheduleParameters = dict["ScheduleParameters"] as! String
                }
            }
        }
        public class DdlHandlingSettings : Tea.TeaModel {
            public var action: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class RuntimeSettings : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var channelSettings: String?

        public var columnDataTypeSettings: [UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings]?

        public var cycleScheduleSettings: UpdateDIJobRequest.JobSettings.CycleScheduleSettings?

        public var ddlHandlingSettings: [UpdateDIJobRequest.JobSettings.DdlHandlingSettings]?

        public var runtimeSettings: [UpdateDIJobRequest.JobSettings.RuntimeSettings]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.cycleScheduleSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelSettings != nil {
                map["ChannelSettings"] = self.channelSettings!
            }
            if self.columnDataTypeSettings != nil {
                var tmp : [Any] = []
                for k in self.columnDataTypeSettings! {
                    tmp.append(k.toMap())
                }
                map["ColumnDataTypeSettings"] = tmp
            }
            if self.cycleScheduleSettings != nil {
                map["CycleScheduleSettings"] = self.cycleScheduleSettings?.toMap()
            }
            if self.ddlHandlingSettings != nil {
                var tmp : [Any] = []
                for k in self.ddlHandlingSettings! {
                    tmp.append(k.toMap())
                }
                map["DdlHandlingSettings"] = tmp
            }
            if self.runtimeSettings != nil {
                var tmp : [Any] = []
                for k in self.runtimeSettings! {
                    tmp.append(k.toMap())
                }
                map["RuntimeSettings"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelSettings") {
                self.channelSettings = dict["ChannelSettings"] as! String
            }
            if dict.keys.contains("ColumnDataTypeSettings") {
                var tmp : [UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings] = []
                for v in dict["ColumnDataTypeSettings"] as! [Any] {
                    var model = UpdateDIJobRequest.JobSettings.ColumnDataTypeSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.columnDataTypeSettings = tmp
            }
            if dict.keys.contains("CycleScheduleSettings") {
                var model = UpdateDIJobRequest.JobSettings.CycleScheduleSettings()
                model.fromMap(dict["CycleScheduleSettings"] as! [String: Any])
                self.cycleScheduleSettings = model
            }
            if dict.keys.contains("DdlHandlingSettings") {
                var tmp : [UpdateDIJobRequest.JobSettings.DdlHandlingSettings] = []
                for v in dict["DdlHandlingSettings"] as! [Any] {
                    var model = UpdateDIJobRequest.JobSettings.DdlHandlingSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ddlHandlingSettings = tmp
            }
            if dict.keys.contains("RuntimeSettings") {
                var tmp : [UpdateDIJobRequest.JobSettings.RuntimeSettings] = []
                for v in dict["RuntimeSettings"] as! [Any] {
                    var model = UpdateDIJobRequest.JobSettings.RuntimeSettings()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.runtimeSettings = tmp
            }
        }
    }
    public class ResourceSettings : Tea.TeaModel {
        public class OfflineResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestedCu") {
                    self.requestedCu = dict["RequestedCu"] as! Double
                }
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public class RealtimeResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestedCu") {
                    self.requestedCu = dict["RequestedCu"] as! Double
                }
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public class ScheduleResourceSettings : Tea.TeaModel {
            public var requestedCu: Double?

            public var resourceGroupIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestedCu != nil {
                    map["RequestedCu"] = self.requestedCu!
                }
                if self.resourceGroupIdentifier != nil {
                    map["ResourceGroupIdentifier"] = self.resourceGroupIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestedCu") {
                    self.requestedCu = dict["RequestedCu"] as! Double
                }
                if dict.keys.contains("ResourceGroupIdentifier") {
                    self.resourceGroupIdentifier = dict["ResourceGroupIdentifier"] as! String
                }
            }
        }
        public var offlineResourceSettings: UpdateDIJobRequest.ResourceSettings.OfflineResourceSettings?

        public var realtimeResourceSettings: UpdateDIJobRequest.ResourceSettings.RealtimeResourceSettings?

        public var scheduleResourceSettings: UpdateDIJobRequest.ResourceSettings.ScheduleResourceSettings?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.offlineResourceSettings?.validate()
            try self.realtimeResourceSettings?.validate()
            try self.scheduleResourceSettings?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.offlineResourceSettings != nil {
                map["OfflineResourceSettings"] = self.offlineResourceSettings?.toMap()
            }
            if self.realtimeResourceSettings != nil {
                map["RealtimeResourceSettings"] = self.realtimeResourceSettings?.toMap()
            }
            if self.scheduleResourceSettings != nil {
                map["ScheduleResourceSettings"] = self.scheduleResourceSettings?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OfflineResourceSettings") {
                var model = UpdateDIJobRequest.ResourceSettings.OfflineResourceSettings()
                model.fromMap(dict["OfflineResourceSettings"] as! [String: Any])
                self.offlineResourceSettings = model
            }
            if dict.keys.contains("RealtimeResourceSettings") {
                var model = UpdateDIJobRequest.ResourceSettings.RealtimeResourceSettings()
                model.fromMap(dict["RealtimeResourceSettings"] as! [String: Any])
                self.realtimeResourceSettings = model
            }
            if dict.keys.contains("ScheduleResourceSettings") {
                var model = UpdateDIJobRequest.ResourceSettings.ScheduleResourceSettings()
                model.fromMap(dict["ScheduleResourceSettings"] as! [String: Any])
                self.scheduleResourceSettings = model
            }
        }
    }
    public class TableMappings : Tea.TeaModel {
        public class SourceObjectSelectionRules : Tea.TeaModel {
            public var action: String?

            public var expression: String?

            public var expressionType: String?

            public var objectType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.expression != nil {
                    map["Expression"] = self.expression!
                }
                if self.expressionType != nil {
                    map["ExpressionType"] = self.expressionType!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("Expression") {
                    self.expression = dict["Expression"] as! String
                }
                if dict.keys.contains("ExpressionType") {
                    self.expressionType = dict["ExpressionType"] as! String
                }
                if dict.keys.contains("ObjectType") {
                    self.objectType = dict["ObjectType"] as! String
                }
            }
        }
        public class TransformationRules : Tea.TeaModel {
            public var ruleActionType: String?

            public var ruleName: String?

            public var ruleTargetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.ruleTargetType != nil {
                    map["RuleTargetType"] = self.ruleTargetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RuleActionType") {
                    self.ruleActionType = dict["RuleActionType"] as! String
                }
                if dict.keys.contains("RuleName") {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("RuleTargetType") {
                    self.ruleTargetType = dict["RuleTargetType"] as! String
                }
            }
        }
        public var sourceObjectSelectionRules: [UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules]?

        public var transformationRules: [UpdateDIJobRequest.TableMappings.TransformationRules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceObjectSelectionRules != nil {
                var tmp : [Any] = []
                for k in self.sourceObjectSelectionRules! {
                    tmp.append(k.toMap())
                }
                map["SourceObjectSelectionRules"] = tmp
            }
            if self.transformationRules != nil {
                var tmp : [Any] = []
                for k in self.transformationRules! {
                    tmp.append(k.toMap())
                }
                map["TransformationRules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SourceObjectSelectionRules") {
                var tmp : [UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules] = []
                for v in dict["SourceObjectSelectionRules"] as! [Any] {
                    var model = UpdateDIJobRequest.TableMappings.SourceObjectSelectionRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sourceObjectSelectionRules = tmp
            }
            if dict.keys.contains("TransformationRules") {
                var tmp : [UpdateDIJobRequest.TableMappings.TransformationRules] = []
                for v in dict["TransformationRules"] as! [Any] {
                    var model = UpdateDIJobRequest.TableMappings.TransformationRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transformationRules = tmp
            }
        }
    }
    public class TransformationRules : Tea.TeaModel {
        public var ruleActionType: String?

        public var ruleExpression: String?

        public var ruleName: String?

        public var ruleTargetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleActionType != nil {
                map["RuleActionType"] = self.ruleActionType!
            }
            if self.ruleExpression != nil {
                map["RuleExpression"] = self.ruleExpression!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleTargetType != nil {
                map["RuleTargetType"] = self.ruleTargetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleActionType") {
                self.ruleActionType = dict["RuleActionType"] as! String
            }
            if dict.keys.contains("RuleExpression") {
                self.ruleExpression = dict["RuleExpression"] as! String
            }
            if dict.keys.contains("RuleName") {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleTargetType") {
                self.ruleTargetType = dict["RuleTargetType"] as! String
            }
        }
    }
    public var DIJobId: Int64?

    public var description_: String?

    public var jobSettings: UpdateDIJobRequest.JobSettings?

    public var projectId: Int64?

    public var resourceSettings: UpdateDIJobRequest.ResourceSettings?

    public var tableMappings: [UpdateDIJobRequest.TableMappings]?

    public var transformationRules: [UpdateDIJobRequest.TransformationRules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobSettings?.validate()
        try self.resourceSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.jobSettings != nil {
            map["JobSettings"] = self.jobSettings?.toMap()
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettings != nil {
            map["ResourceSettings"] = self.resourceSettings?.toMap()
        }
        if self.tableMappings != nil {
            var tmp : [Any] = []
            for k in self.tableMappings! {
                tmp.append(k.toMap())
            }
            map["TableMappings"] = tmp
        }
        if self.transformationRules != nil {
            var tmp : [Any] = []
            for k in self.transformationRules! {
                tmp.append(k.toMap())
            }
            map["TransformationRules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("JobSettings") {
            var model = UpdateDIJobRequest.JobSettings()
            model.fromMap(dict["JobSettings"] as! [String: Any])
            self.jobSettings = model
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceSettings") {
            var model = UpdateDIJobRequest.ResourceSettings()
            model.fromMap(dict["ResourceSettings"] as! [String: Any])
            self.resourceSettings = model
        }
        if dict.keys.contains("TableMappings") {
            var tmp : [UpdateDIJobRequest.TableMappings] = []
            for v in dict["TableMappings"] as! [Any] {
                var model = UpdateDIJobRequest.TableMappings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tableMappings = tmp
        }
        if dict.keys.contains("TransformationRules") {
            var tmp : [UpdateDIJobRequest.TransformationRules] = []
            for v in dict["TransformationRules"] as! [Any] {
                var model = UpdateDIJobRequest.TransformationRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.transformationRules = tmp
        }
    }
}

public class UpdateDIJobShrinkRequest : Tea.TeaModel {
    public var DIJobId: Int64?

    public var description_: String?

    public var jobSettingsShrink: String?

    public var projectId: Int64?

    public var resourceSettingsShrink: String?

    public var tableMappingsShrink: String?

    public var transformationRulesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DIJobId != nil {
            map["DIJobId"] = self.DIJobId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.jobSettingsShrink != nil {
            map["JobSettings"] = self.jobSettingsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.resourceSettingsShrink != nil {
            map["ResourceSettings"] = self.resourceSettingsShrink!
        }
        if self.tableMappingsShrink != nil {
            map["TableMappings"] = self.tableMappingsShrink!
        }
        if self.transformationRulesShrink != nil {
            map["TransformationRules"] = self.transformationRulesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DIJobId") {
            self.DIJobId = dict["DIJobId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("JobSettings") {
            self.jobSettingsShrink = dict["JobSettings"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("ResourceSettings") {
            self.resourceSettingsShrink = dict["ResourceSettings"] as! String
        }
        if dict.keys.contains("TableMappings") {
            self.tableMappingsShrink = dict["TableMappings"] as! String
        }
        if dict.keys.contains("TransformationRules") {
            self.transformationRulesShrink = dict["TransformationRules"] as! String
        }
    }
}

public class UpdateDIJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDIJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDIJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDIJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataQualityEvaluationTaskRequest : Tea.TeaModel {
    public class DataQualityRules : Tea.TeaModel {
        public class CheckingConfig : Tea.TeaModel {
            public class Thresholds : Tea.TeaModel {
                public class Critical : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Expected : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public class Warned : Tea.TeaModel {
                    public var operator_: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.operator_ != nil {
                            map["Operator"] = self.operator_!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Operator") {
                            self.operator_ = dict["Operator"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var critical: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Critical?

                public var expected: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Expected?

                public var warned: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Warned?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.critical?.validate()
                    try self.expected?.validate()
                    try self.warned?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.critical != nil {
                        map["Critical"] = self.critical?.toMap()
                    }
                    if self.expected != nil {
                        map["Expected"] = self.expected?.toMap()
                    }
                    if self.warned != nil {
                        map["Warned"] = self.warned?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Critical") {
                        var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Critical()
                        model.fromMap(dict["Critical"] as! [String: Any])
                        self.critical = model
                    }
                    if dict.keys.contains("Expected") {
                        var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Expected()
                        model.fromMap(dict["Expected"] as! [String: Any])
                        self.expected = model
                    }
                    if dict.keys.contains("Warned") {
                        var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds.Warned()
                        model.fromMap(dict["Warned"] as! [String: Any])
                        self.warned = model
                    }
                }
            }
            public var referencedSamplesFilter: String?

            public var thresholds: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.thresholds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencedSamplesFilter != nil {
                    map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
                }
                if self.thresholds != nil {
                    map["Thresholds"] = self.thresholds?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReferencedSamplesFilter") {
                    self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
                }
                if dict.keys.contains("Thresholds") {
                    var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig.Thresholds()
                    model.fromMap(dict["Thresholds"] as! [String: Any])
                    self.thresholds = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class ErrorHandlers : Tea.TeaModel {
            public var errorDataFilter: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorDataFilter != nil {
                    map["ErrorDataFilter"] = self.errorDataFilter!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorDataFilter") {
                    self.errorDataFilter = dict["ErrorDataFilter"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class SamplingConfig : Tea.TeaModel {
            public var metric: String?

            public var metricParameters: String?

            public var samplingFilter: String?

            public var settingConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.metric != nil {
                    map["Metric"] = self.metric!
                }
                if self.metricParameters != nil {
                    map["MetricParameters"] = self.metricParameters!
                }
                if self.samplingFilter != nil {
                    map["SamplingFilter"] = self.samplingFilter!
                }
                if self.settingConfig != nil {
                    map["SettingConfig"] = self.settingConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Metric") {
                    self.metric = dict["Metric"] as! String
                }
                if dict.keys.contains("MetricParameters") {
                    self.metricParameters = dict["MetricParameters"] as! String
                }
                if dict.keys.contains("SamplingFilter") {
                    self.samplingFilter = dict["SamplingFilter"] as! String
                }
                if dict.keys.contains("SettingConfig") {
                    self.settingConfig = dict["SettingConfig"] as! String
                }
            }
        }
        public var checkingConfig: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig?

        public var description_: String?

        public var enabled: Bool?

        public var errorHandlers: [UpdateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers]?

        public var id: Int64?

        public var name: String?

        public var samplingConfig: UpdateDataQualityEvaluationTaskRequest.DataQualityRules.SamplingConfig?

        public var severity: String?

        public var templateCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkingConfig?.validate()
            try self.samplingConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkingConfig != nil {
                map["CheckingConfig"] = self.checkingConfig?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.errorHandlers != nil {
                var tmp : [Any] = []
                for k in self.errorHandlers! {
                    tmp.append(k.toMap())
                }
                map["ErrorHandlers"] = tmp
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.samplingConfig != nil {
                map["SamplingConfig"] = self.samplingConfig?.toMap()
            }
            if self.severity != nil {
                map["Severity"] = self.severity!
            }
            if self.templateCode != nil {
                map["TemplateCode"] = self.templateCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckingConfig") {
                var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.CheckingConfig()
                model.fromMap(dict["CheckingConfig"] as! [String: Any])
                self.checkingConfig = model
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("ErrorHandlers") {
                var tmp : [UpdateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers] = []
                for v in dict["ErrorHandlers"] as! [Any] {
                    var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.ErrorHandlers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorHandlers = tmp
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SamplingConfig") {
                var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules.SamplingConfig()
                model.fromMap(dict["SamplingConfig"] as! [String: Any])
                self.samplingConfig = model
            }
            if dict.keys.contains("Severity") {
                self.severity = dict["Severity"] as! String
            }
            if dict.keys.contains("TemplateCode") {
                self.templateCode = dict["TemplateCode"] as! String
            }
        }
    }
    public class Hooks : Tea.TeaModel {
        public var condition: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Notifications : Tea.TeaModel {
        public class Notifications : Tea.TeaModel {
            public class NotificationChannels : Tea.TeaModel {
                public var channels: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! [String]
                    }
                }
            }
            public class NotificationReceivers : Tea.TeaModel {
                public var extension_: String?

                public var receiverType: String?

                public var receiverValues: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.receiverType != nil {
                        map["ReceiverType"] = self.receiverType!
                    }
                    if self.receiverValues != nil {
                        map["ReceiverValues"] = self.receiverValues!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Extension") {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("ReceiverType") {
                        self.receiverType = dict["ReceiverType"] as! String
                    }
                    if dict.keys.contains("ReceiverValues") {
                        self.receiverValues = dict["ReceiverValues"] as! [String]
                    }
                }
            }
            public var notificationChannels: [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels]?

            public var notificationReceivers: [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.notificationChannels != nil {
                    var tmp : [Any] = []
                    for k in self.notificationChannels! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationChannels"] = tmp
                }
                if self.notificationReceivers != nil {
                    var tmp : [Any] = []
                    for k in self.notificationReceivers! {
                        tmp.append(k.toMap())
                    }
                    map["NotificationReceivers"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NotificationChannels") {
                    var tmp : [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels] = []
                    for v in dict["NotificationChannels"] as! [Any] {
                        var model = UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationChannels()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notificationChannels = tmp
                }
                if dict.keys.contains("NotificationReceivers") {
                    var tmp : [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers] = []
                    for v in dict["NotificationReceivers"] as! [Any] {
                        var model = UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications.NotificationReceivers()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.notificationReceivers = tmp
                }
            }
        }
        public var condition: String?

        public var notifications: [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.condition != nil {
                map["Condition"] = self.condition!
            }
            if self.notifications != nil {
                var tmp : [Any] = []
                for k in self.notifications! {
                    tmp.append(k.toMap())
                }
                map["Notifications"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Condition") {
                self.condition = dict["Condition"] as! String
            }
            if dict.keys.contains("Notifications") {
                var tmp : [UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications] = []
                for v in dict["Notifications"] as! [Any] {
                    var model = UpdateDataQualityEvaluationTaskRequest.Notifications.Notifications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notifications = tmp
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseType") {
                self.databaseType = dict["DatabaseType"] as! String
            }
            if dict.keys.contains("PartitionSpec") {
                self.partitionSpec = dict["PartitionSpec"] as! String
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
        }
    }
    public class Trigger : Tea.TeaModel {
        public var taskIds: [Int64]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskIds != nil {
                map["TaskIds"] = self.taskIds!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskIds") {
                self.taskIds = dict["TaskIds"] as! [Int64]
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var dataQualityRules: [UpdateDataQualityEvaluationTaskRequest.DataQualityRules]?

    public var dataSourceId: Int64?

    public var description_: String?

    public var hooks: [UpdateDataQualityEvaluationTaskRequest.Hooks]?

    public var id: Int64?

    public var name: String?

    public var notifications: UpdateDataQualityEvaluationTaskRequest.Notifications?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var target: UpdateDataQualityEvaluationTaskRequest.Target?

    public var trigger: UpdateDataQualityEvaluationTaskRequest.Trigger?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifications?.validate()
        try self.target?.validate()
        try self.trigger?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRules != nil {
            var tmp : [Any] = []
            for k in self.dataQualityRules! {
                tmp.append(k.toMap())
            }
            map["DataQualityRules"] = tmp
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooks != nil {
            var tmp : [Any] = []
            for k in self.hooks! {
                tmp.append(k.toMap())
            }
            map["Hooks"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifications != nil {
            map["Notifications"] = self.notifications?.toMap()
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.trigger != nil {
            map["Trigger"] = self.trigger?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityRules") {
            var tmp : [UpdateDataQualityEvaluationTaskRequest.DataQualityRules] = []
            for v in dict["DataQualityRules"] as! [Any] {
                var model = UpdateDataQualityEvaluationTaskRequest.DataQualityRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataQualityRules = tmp
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Hooks") {
            var tmp : [UpdateDataQualityEvaluationTaskRequest.Hooks] = []
            for v in dict["Hooks"] as! [Any] {
                var model = UpdateDataQualityEvaluationTaskRequest.Hooks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hooks = tmp
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notifications") {
            var model = UpdateDataQualityEvaluationTaskRequest.Notifications()
            model.fromMap(dict["Notifications"] as! [String: Any])
            self.notifications = model
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeConf") {
            self.runtimeConf = dict["RuntimeConf"] as! String
        }
        if dict.keys.contains("Target") {
            var model = UpdateDataQualityEvaluationTaskRequest.Target()
            model.fromMap(dict["Target"] as! [String: Any])
            self.target = model
        }
        if dict.keys.contains("Trigger") {
            var model = UpdateDataQualityEvaluationTaskRequest.Trigger()
            model.fromMap(dict["Trigger"] as! [String: Any])
            self.trigger = model
        }
    }
}

public class UpdateDataQualityEvaluationTaskShrinkRequest : Tea.TeaModel {
    public var dataQualityRulesShrink: String?

    public var dataSourceId: Int64?

    public var description_: String?

    public var hooksShrink: String?

    public var id: Int64?

    public var name: String?

    public var notificationsShrink: String?

    public var projectId: Int64?

    public var runtimeConf: String?

    public var targetShrink: String?

    public var triggerShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataQualityRulesShrink != nil {
            map["DataQualityRules"] = self.dataQualityRulesShrink!
        }
        if self.dataSourceId != nil {
            map["DataSourceId"] = self.dataSourceId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hooksShrink != nil {
            map["Hooks"] = self.hooksShrink!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notificationsShrink != nil {
            map["Notifications"] = self.notificationsShrink!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.runtimeConf != nil {
            map["RuntimeConf"] = self.runtimeConf!
        }
        if self.targetShrink != nil {
            map["Target"] = self.targetShrink!
        }
        if self.triggerShrink != nil {
            map["Trigger"] = self.triggerShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataQualityRules") {
            self.dataQualityRulesShrink = dict["DataQualityRules"] as! String
        }
        if dict.keys.contains("DataSourceId") {
            self.dataSourceId = dict["DataSourceId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Hooks") {
            self.hooksShrink = dict["Hooks"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Notifications") {
            self.notificationsShrink = dict["Notifications"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("RuntimeConf") {
            self.runtimeConf = dict["RuntimeConf"] as! String
        }
        if dict.keys.contains("Target") {
            self.targetShrink = dict["Target"] as! String
        }
        if dict.keys.contains("Trigger") {
            self.triggerShrink = dict["Trigger"] as! String
        }
    }
}

public class UpdateDataQualityEvaluationTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDataQualityEvaluationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataQualityEvaluationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataQualityEvaluationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataQualityRuleRequest : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public class Thresholds : Tea.TeaModel {
            public class Critical : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Expected : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class Warned : Tea.TeaModel {
                public var expression: String?

                public var operator_: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expression != nil {
                        map["Expression"] = self.expression!
                    }
                    if self.operator_ != nil {
                        map["Operator"] = self.operator_!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Expression") {
                        self.expression = dict["Expression"] as! String
                    }
                    if dict.keys.contains("Operator") {
                        self.operator_ = dict["Operator"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var critical: UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Critical?

            public var expected: UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Expected?

            public var warned: UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Warned?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.critical?.validate()
                try self.expected?.validate()
                try self.warned?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.critical != nil {
                    map["Critical"] = self.critical?.toMap()
                }
                if self.expected != nil {
                    map["Expected"] = self.expected?.toMap()
                }
                if self.warned != nil {
                    map["Warned"] = self.warned?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Critical") {
                    var model = UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Critical()
                    model.fromMap(dict["Critical"] as! [String: Any])
                    self.critical = model
                }
                if dict.keys.contains("Expected") {
                    var model = UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Expected()
                    model.fromMap(dict["Expected"] as! [String: Any])
                    self.expected = model
                }
                if dict.keys.contains("Warned") {
                    var model = UpdateDataQualityRuleRequest.CheckingConfig.Thresholds.Warned()
                    model.fromMap(dict["Warned"] as! [String: Any])
                    self.warned = model
                }
            }
        }
        public var referencedSamplesFilter: String?

        public var thresholds: UpdateDataQualityRuleRequest.CheckingConfig.Thresholds?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.thresholds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.thresholds != nil {
                map["Thresholds"] = self.thresholds?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReferencedSamplesFilter") {
                self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
            }
            if dict.keys.contains("Thresholds") {
                var model = UpdateDataQualityRuleRequest.CheckingConfig.Thresholds()
                model.fromMap(dict["Thresholds"] as! [String: Any])
                self.thresholds = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class ErrorHandlers : Tea.TeaModel {
        public var errorDataFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorDataFilter != nil {
                map["ErrorDataFilter"] = self.errorDataFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorDataFilter") {
                self.errorDataFilter = dict["ErrorDataFilter"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var samplingFilter: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.samplingFilter != nil {
                map["SamplingFilter"] = self.samplingFilter!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metric") {
                self.metric = dict["Metric"] as! String
            }
            if dict.keys.contains("MetricParameters") {
                self.metricParameters = dict["MetricParameters"] as! String
            }
            if dict.keys.contains("SamplingFilter") {
                self.samplingFilter = dict["SamplingFilter"] as! String
            }
            if dict.keys.contains("SettingConfig") {
                self.settingConfig = dict["SettingConfig"] as! String
            }
        }
    }
    public class Target : Tea.TeaModel {
        public var databaseType: String?

        public var partitionSpec: String?

        public var tableGuid: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.partitionSpec != nil {
                map["PartitionSpec"] = self.partitionSpec!
            }
            if self.tableGuid != nil {
                map["TableGuid"] = self.tableGuid!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DatabaseType") {
                self.databaseType = dict["DatabaseType"] as! String
            }
            if dict.keys.contains("PartitionSpec") {
                self.partitionSpec = dict["PartitionSpec"] as! String
            }
            if dict.keys.contains("TableGuid") {
                self.tableGuid = dict["TableGuid"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var checkingConfig: UpdateDataQualityRuleRequest.CheckingConfig?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlers: [UpdateDataQualityRuleRequest.ErrorHandlers]?

    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: UpdateDataQualityRuleRequest.SamplingConfig?

    public var severity: String?

    public var target: UpdateDataQualityRuleRequest.Target?

    public var templateCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
        try self.target?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlers != nil {
            var tmp : [Any] = []
            for k in self.errorHandlers! {
                tmp.append(k.toMap())
            }
            map["ErrorHandlers"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.target != nil {
            map["Target"] = self.target?.toMap()
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckingConfig") {
            var model = UpdateDataQualityRuleRequest.CheckingConfig()
            model.fromMap(dict["CheckingConfig"] as! [String: Any])
            self.checkingConfig = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("ErrorHandlers") {
            var tmp : [UpdateDataQualityRuleRequest.ErrorHandlers] = []
            for v in dict["ErrorHandlers"] as! [Any] {
                var model = UpdateDataQualityRuleRequest.ErrorHandlers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.errorHandlers = tmp
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SamplingConfig") {
            var model = UpdateDataQualityRuleRequest.SamplingConfig()
            model.fromMap(dict["SamplingConfig"] as! [String: Any])
            self.samplingConfig = model
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("Target") {
            var model = UpdateDataQualityRuleRequest.Target()
            model.fromMap(dict["Target"] as! [String: Any])
            self.target = model
        }
        if dict.keys.contains("TemplateCode") {
            self.templateCode = dict["TemplateCode"] as! String
        }
    }
}

public class UpdateDataQualityRuleShrinkRequest : Tea.TeaModel {
    public var checkingConfigShrink: String?

    public var description_: String?

    public var enabled: Bool?

    public var errorHandlersShrink: String?

    public var id: Int64?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfigShrink: String?

    public var severity: String?

    public var targetShrink: String?

    public var templateCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfigShrink != nil {
            map["CheckingConfig"] = self.checkingConfigShrink!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.errorHandlersShrink != nil {
            map["ErrorHandlers"] = self.errorHandlersShrink!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfigShrink != nil {
            map["SamplingConfig"] = self.samplingConfigShrink!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.targetShrink != nil {
            map["Target"] = self.targetShrink!
        }
        if self.templateCode != nil {
            map["TemplateCode"] = self.templateCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckingConfig") {
            self.checkingConfigShrink = dict["CheckingConfig"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("ErrorHandlers") {
            self.errorHandlersShrink = dict["ErrorHandlers"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SamplingConfig") {
            self.samplingConfigShrink = dict["SamplingConfig"] as! String
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("Target") {
            self.targetShrink = dict["Target"] as! String
        }
        if dict.keys.contains("TemplateCode") {
            self.templateCode = dict["TemplateCode"] as! String
        }
    }
}

public class UpdateDataQualityRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDataQualityRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataQualityRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataQualityRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataQualityRuleTemplateRequest : Tea.TeaModel {
    public class CheckingConfig : Tea.TeaModel {
        public var referencedSamplesFilter: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.referencedSamplesFilter != nil {
                map["ReferencedSamplesFilter"] = self.referencedSamplesFilter!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReferencedSamplesFilter") {
                self.referencedSamplesFilter = dict["ReferencedSamplesFilter"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class SamplingConfig : Tea.TeaModel {
        public var metric: String?

        public var metricParameters: String?

        public var settingConfig: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metric != nil {
                map["Metric"] = self.metric!
            }
            if self.metricParameters != nil {
                map["MetricParameters"] = self.metricParameters!
            }
            if self.settingConfig != nil {
                map["SettingConfig"] = self.settingConfig!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Metric") {
                self.metric = dict["Metric"] as! String
            }
            if dict.keys.contains("MetricParameters") {
                self.metricParameters = dict["MetricParameters"] as! String
            }
            if dict.keys.contains("SettingConfig") {
                self.settingConfig = dict["SettingConfig"] as! String
            }
        }
    }
    public var checkingConfig: UpdateDataQualityRuleTemplateRequest.CheckingConfig?

    public var code: String?

    public var directoryPath: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfig: UpdateDataQualityRuleTemplateRequest.SamplingConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkingConfig?.validate()
        try self.samplingConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfig != nil {
            map["CheckingConfig"] = self.checkingConfig?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfig != nil {
            map["SamplingConfig"] = self.samplingConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckingConfig") {
            var model = UpdateDataQualityRuleTemplateRequest.CheckingConfig()
            model.fromMap(dict["CheckingConfig"] as! [String: Any])
            self.checkingConfig = model
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DirectoryPath") {
            self.directoryPath = dict["DirectoryPath"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SamplingConfig") {
            var model = UpdateDataQualityRuleTemplateRequest.SamplingConfig()
            model.fromMap(dict["SamplingConfig"] as! [String: Any])
            self.samplingConfig = model
        }
    }
}

public class UpdateDataQualityRuleTemplateShrinkRequest : Tea.TeaModel {
    public var checkingConfigShrink: String?

    public var code: String?

    public var directoryPath: String?

    public var name: String?

    public var projectId: Int64?

    public var samplingConfigShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkingConfigShrink != nil {
            map["CheckingConfig"] = self.checkingConfigShrink!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.directoryPath != nil {
            map["DirectoryPath"] = self.directoryPath!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.samplingConfigShrink != nil {
            map["SamplingConfig"] = self.samplingConfigShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckingConfig") {
            self.checkingConfigShrink = dict["CheckingConfig"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DirectoryPath") {
            self.directoryPath = dict["DirectoryPath"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
        if dict.keys.contains("SamplingConfig") {
            self.samplingConfigShrink = dict["SamplingConfig"] as! String
        }
    }
}

public class UpdateDataQualityRuleTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDataQualityRuleTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataQualityRuleTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataQualityRuleTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDataSourceRequest : Tea.TeaModel {
    public var connectionProperties: String?

    public var connectionPropertiesMode: String?

    public var description_: String?

    public var id: Int64?

    public var projectId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionProperties != nil {
            map["ConnectionProperties"] = self.connectionProperties!
        }
        if self.connectionPropertiesMode != nil {
            map["ConnectionPropertiesMode"] = self.connectionPropertiesMode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionProperties") {
            self.connectionProperties = dict["ConnectionProperties"] as! String
        }
        if dict.keys.contains("ConnectionPropertiesMode") {
            self.connectionPropertiesMode = dict["ConnectionPropertiesMode"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! Int64
        }
    }
}

public class UpdateDataSourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDataSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFunctionRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class UpdateFunctionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateFunctionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFunctionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFunctionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNodeRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class UpdateNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProjectRequest : Tea.TeaModel {
    public var description_: String?

    public var devEnvironmentEnabled: Bool?

    public var devRoleDisabled: Bool?

    public var displayName: String?

    public var id: Int64?

    public var paiTaskEnabled: Bool?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.devEnvironmentEnabled != nil {
            map["DevEnvironmentEnabled"] = self.devEnvironmentEnabled!
        }
        if self.devRoleDisabled != nil {
            map["DevRoleDisabled"] = self.devRoleDisabled!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.paiTaskEnabled != nil {
            map["PaiTaskEnabled"] = self.paiTaskEnabled!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DevEnvironmentEnabled") {
            self.devEnvironmentEnabled = dict["DevEnvironmentEnabled"] as! Bool
        }
        if dict.keys.contains("DevRoleDisabled") {
            self.devRoleDisabled = dict["DevRoleDisabled"] as! Bool
        }
        if dict.keys.contains("DisplayName") {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PaiTaskEnabled") {
            self.paiTaskEnabled = dict["PaiTaskEnabled"] as! Bool
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UpdateProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateResourceRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class UpdateResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateResourceGroupRequest : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class UpdateResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRouteRequest : Tea.TeaModel {
    public var destinationCidr: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidr != nil {
            map["DestinationCidr"] = self.destinationCidr!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationCidr") {
            self.destinationCidr = dict["DestinationCidr"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpdateRouteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTaskInstancesRequest : Tea.TeaModel {
    public class TaskInstances : Tea.TeaModel {
        public class DataSource : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var dataSource: UpdateTaskInstancesRequest.TaskInstances.DataSource?

        public var id: Int64?

        public var priority: Int32?

        public var runtimeResource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dataSource?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.runtimeResource != nil {
                map["RuntimeResource"] = self.runtimeResource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataSource") {
                var model = UpdateTaskInstancesRequest.TaskInstances.DataSource()
                model.fromMap(dict["DataSource"] as! [String: Any])
                self.dataSource = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RuntimeResource") {
                self.runtimeResource = dict["RuntimeResource"] as! String
            }
        }
    }
    public var comment: String?

    public var taskInstances: [UpdateTaskInstancesRequest.TaskInstances]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.taskInstances != nil {
            var tmp : [Any] = []
            for k in self.taskInstances! {
                tmp.append(k.toMap())
            }
            map["TaskInstances"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("TaskInstances") {
            var tmp : [UpdateTaskInstancesRequest.TaskInstances] = []
            for v in dict["TaskInstances"] as! [Any] {
                var model = UpdateTaskInstancesRequest.TaskInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.taskInstances = tmp
        }
    }
}

public class UpdateTaskInstancesShrinkRequest : Tea.TeaModel {
    public var comment: String?

    public var taskInstancesShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.taskInstancesShrink != nil {
            map["TaskInstances"] = self.taskInstancesShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("TaskInstances") {
            self.taskInstancesShrink = dict["TaskInstances"] as! String
        }
    }
}

public class UpdateTaskInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var successInfo: [String: SuccessInfoValue]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successInfo != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.successInfo! {
                tmp[k] = v.toMap()
            }
            map["SuccessInfo"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessInfo") {
            var tmp : [String: SuccessInfoValue] = [:]
            for (k, v) in dict["SuccessInfo"] as! [String: Any] {
                if v != nil {
                    var model = SuccessInfoValue()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.successInfo = tmp
        }
    }
}

public class UpdateTaskInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTaskInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTaskInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkflowDefinitionRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class UpdateWorkflowDefinitionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateWorkflowDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkflowDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWorkflowDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
